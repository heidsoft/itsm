package service

import (
	"context"
	"fmt"
	"itsm-backend/ent"
	"itsm-backend/ent/workflowinstance"
	"itsm-backend/ent/workflowversion"
	"time"

	"go.uber.org/zap"
)

type WorkflowVersionService struct {
	client *ent.Client
	logger *zap.SugaredLogger
}

func NewWorkflowVersionService(client *ent.Client, logger *zap.SugaredLogger) *WorkflowVersionService {
	return &WorkflowVersionService{
		client: client,
		logger: logger,
	}
}

// CreateVersion 创建工作流版本
func (wvs *WorkflowVersionService) CreateVersion(ctx context.Context, workflowID int, version string, bpmnXML string, changeLog string, tenantID int) (*ent.WorkflowVersion, error) {
	wvs.logger.Infow("Creating workflow version", "workflow_id", workflowID, "version", version, "tenant_id", tenantID)

	// 检查版本是否已存在
	existingVersion, err := wvs.client.WorkflowVersion.Query().
		Where(workflowversion.WorkflowID(workflowID)).
		Where(workflowversion.Version(version)).
		Only(ctx)

	if err == nil {
		return nil, fmt.Errorf("version %s already exists", version)
	}

	// 获取当前版本
	currentVersion, err := wvs.client.WorkflowVersion.Query().
		Where(workflowversion.WorkflowID(workflowID)).
		Where(workflowversion.IsCurrent(true)).
		Only(ctx)

	if err != nil && !ent.IsNotFound(err) {
		return nil, fmt.Errorf("failed to get current version: %w", err)
	}

	// 创建新版本
	newVersion, err := wvs.client.WorkflowVersion.Create().
		SetTenantID(tenantID).
		SetWorkflowID(workflowID).
		SetVersion(version).
		SetBPMNXML(bpmnXML).
		SetStatus("draft").
		SetCreatedBy("system"). // TODO: 从上下文获取用户
		SetChangeLog(changeLog).
		SetIsCurrent(false).
		Save(ctx)

	if err != nil {
		wvs.logger.Errorw("Failed to create workflow version", "error", err)
		return nil, fmt.Errorf("failed to create workflow version: %w", err)
	}

	wvs.logAuditEvent(ctx, "workflow_version_created", newVersion.ID, tenantID, map[string]interface{}{
		"workflow_id": workflowID,
		"version":     version,
		"change_log":  changeLog,
	})

	return newVersion, nil
}

// DeployVersion 部署工作流版本
func (wvs *WorkflowVersionService) DeployVersion(ctx context.Context, workflowID int, version string, tenantID int) error {
	wvs.logger.Infow("Deploying workflow version", "workflow_id", workflowID, "version", version, "tenant_id", tenantID)

	// 获取要部署的版本
	versionToDeploy, err := wvs.client.WorkflowVersion.Query().
		Where(workflowversion.WorkflowID(workflowID)).
		Where(workflowversion.Version(version)).
		Only(ctx)

	if err != nil {
		return fmt.Errorf("version not found: %w", err)
	}

	// 检查版本状态
	if versionToDeploy.Status != "draft" {
		return fmt.Errorf("only draft versions can be deployed")
	}

	// 开始事务
	tx, err := wvs.client.Tx(ctx)
	if err != nil {
		return fmt.Errorf("failed to start transaction: %w", err)
	}
	defer func() {
		if v := recover(); v != nil {
			tx.Rollback()
			panic(v)
		}
	}()

	// 取消当前版本的当前状态
	_, err = tx.WorkflowVersion.Update().
		Where(workflowversion.WorkflowID(workflowID)).
		Where(workflowversion.IsCurrent(true)).
		SetIsCurrent(false).
		Save(ctx)

	if err != nil && !ent.IsNotFound(err) {
		tx.Rollback()
		return fmt.Errorf("failed to update current version: %w", err)
	}

	// 设置新版本为当前版本
	_, err = tx.WorkflowVersion.UpdateOne(versionToDeploy).
		SetIsCurrent(true).
		SetStatus("active").
		Save(ctx)

	if err != nil {
		tx.Rollback()
		return fmt.Errorf("failed to deploy version: %w", err)
	}

	// 更新工作流的BPMN XML
	_, err = tx.Workflow.UpdateOneID(workflowID).
		SetBPMNXML(versionToDeploy.BPMNXML).
		SetStatus("active").
		Save(ctx)

	if err != nil {
		tx.Rollback()
		return fmt.Errorf("failed to update workflow: %w", err)
	}

	// 提交事务
	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	wvs.logAuditEvent(ctx, "workflow_version_deployed", versionToDeploy.ID, tenantID, map[string]interface{}{
		"workflow_id": workflowID,
		"version":     version,
	})

	return nil
}

// ListVersions 获取工作流版本列表
func (wvs *WorkflowVersionService) ListVersions(ctx context.Context, workflowID int, tenantID int) ([]*ent.WorkflowVersion, error) {
	versions, err := wvs.client.WorkflowVersion.Query().
		Where(workflowversion.WorkflowID(workflowID)).
		Where(workflowversion.TenantID(tenantID)).
		Order(ent.Desc(workflowversion.FieldCreatedAt)).
		All(ctx)

	if err != nil {
		return nil, fmt.Errorf("failed to list versions: %w", err)
	}

	return versions, nil
}

// GetVersion 获取特定版本
func (wvs *WorkflowVersionService) GetVersion(ctx context.Context, workflowID int, version string, tenantID int) (*ent.WorkflowVersion, error) {
	versionObj, err := wvs.client.WorkflowVersion.Query().
		Where(workflowversion.WorkflowID(workflowID)).
		Where(workflowversion.Version(version)).
		Where(workflowversion.TenantID(tenantID)).
		Only(ctx)

	if err != nil {
		return nil, fmt.Errorf("version not found: %w", err)
	}

	return versionObj, nil
}

// CompareVersions 比较两个版本
func (wvs *WorkflowVersionService) CompareVersions(ctx context.Context, workflowID int, version1, version2 string, tenantID int) (map[string]interface{}, error) {
	v1, err := wvs.GetVersion(ctx, workflowID, version1, tenantID)
	if err != nil {
		return nil, fmt.Errorf("failed to get version %s: %w", version1, err)
	}

	v2, err := wvs.GetVersion(ctx, workflowID, version2, tenantID)
	if err != nil {
		return nil, fmt.Errorf("failed to get version %s: %w", version2, err)
	}

	// 解析BPMN XML并比较
	comparison := wvs.compareBPMNXML(v1.BPMNXML, v2.BPMNXML)

	result := map[string]interface{}{
		"version1": map[string]interface{}{
			"version":    v1.Version,
			"created_at": v1.CreatedAt,
			"created_by": v1.CreatedBy,
			"change_log": v1.ChangeLog,
		},
		"version2": map[string]interface{}{
			"version":    v2.Version,
			"created_at": v2.CreatedAt,
			"created_by": v2.CreatedBy,
			"change_log": v2.ChangeLog,
		},
		"comparison": comparison,
	}

	return result, nil
}

// RollbackVersion 回滚到指定版本
func (wvs *WorkflowVersionService) RollbackVersion(ctx context.Context, workflowID int, targetVersion string, tenantID int) error {
	wvs.logger.Infow("Rolling back workflow", "workflow_id", workflowID, "target_version", targetVersion, "tenant_id", tenantID)

	// 获取目标版本
	targetVersionObj, err := wvs.GetVersion(ctx, workflowID, targetVersion, tenantID)
	if err != nil {
		return fmt.Errorf("target version not found: %w", err)
	}

	// 检查是否有运行中的实例
	runningInstances, err := wvs.client.WorkflowInstance.Query().
		Where(workflowinstance.WorkflowID(workflowID)).
		Where(workflowinstance.Status("running")).
		Count(ctx)

	if err != nil {
		return fmt.Errorf("failed to check running instances: %w", err)
	}

	if runningInstances > 0 {
		return fmt.Errorf("cannot rollback: %d running instances", runningInstances)
	}

	// 开始事务
	tx, err := wvs.client.Tx(ctx)
	if err != nil {
		return fmt.Errorf("failed to start transaction: %w", err)
	}
	defer func() {
		if v := recover(); v != nil {
			tx.Rollback()
			panic(v)
		}
	}()

	// 取消当前版本的当前状态
	_, err = tx.WorkflowVersion.Update().
		Where(workflowversion.WorkflowID(workflowID)).
		Where(workflowversion.IsCurrent(true)).
		SetIsCurrent(false).
		Save(ctx)

	if err != nil && !ent.IsNotFound(err) {
		tx.Rollback()
		return fmt.Errorf("failed to update current version: %w", err)
	}

	// 设置目标版本为当前版本
	_, err = tx.WorkflowVersion.UpdateOne(targetVersionObj).
		SetIsCurrent(true).
		SetStatus("active").
		Save(ctx)

	if err != nil {
		tx.Rollback()
		return fmt.Errorf("failed to set target version as current: %w", err)
	}

	// 更新工作流的BPMN XML
	_, err = tx.Workflow.UpdateOneID(workflowID).
		SetBPMNXML(targetVersionObj.BPMNXML).
		SetStatus("active").
		Save(ctx)

	if err != nil {
		tx.Rollback()
		return fmt.Errorf("failed to update workflow: %w", err)
	}

	// 提交事务
	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	wvs.logAuditEvent(ctx, "workflow_version_rolled_back", targetVersionObj.ID, tenantID, map[string]interface{}{
		"workflow_id":    workflowID,
		"target_version": targetVersion,
	})

	return nil
}

// DeleteVersion 删除版本
func (wvs *WorkflowVersionService) DeleteVersion(ctx context.Context, workflowID int, version string, tenantID int) error {
	wvs.logger.Infow("Deleting workflow version", "workflow_id", workflowID, "version", version, "tenant_id", tenantID)

	versionObj, err := wvs.GetVersion(ctx, workflowID, version, tenantID)
	if err != nil {
		return fmt.Errorf("version not found: %w", err)
	}

	// 检查是否为当前版本
	if versionObj.IsCurrent {
		return fmt.Errorf("cannot delete current version")
	}

	// 删除版本
	err = wvs.client.WorkflowVersion.DeleteOne(versionObj).Exec(ctx)
	if err != nil {
		return fmt.Errorf("failed to delete version: %w", err)
	}

	wvs.logAuditEvent(ctx, "workflow_version_deleted", versionObj.ID, tenantID, map[string]interface{}{
		"workflow_id": workflowID,
		"version":     version,
	})

	return nil
}

// GetVersionHistory 获取版本历史
func (wvs *WorkflowVersionService) GetVersionHistory(ctx context.Context, workflowID int, tenantID int) ([]map[string]interface{}, error) {
	versions, err := wvs.ListVersions(ctx, workflowID, tenantID)
	if err != nil {
		return nil, err
	}

	history := make([]map[string]interface{}, 0, len(versions))
	for _, version := range versions {
		historyItem := map[string]interface{}{
			"id":         version.ID,
			"version":    version.Version,
			"status":     version.Status,
			"is_current": version.IsCurrent,
			"created_at": version.CreatedAt,
			"created_by": version.CreatedBy,
			"change_log": version.ChangeLog,
			"bpmn_size":  len(version.BPMNXML),
		}
		history = append(history, historyItem)
	}

	return history, nil
}

// 比较BPMN XML
func (wvs *WorkflowVersionService) compareBPMNXML(xml1, xml2 string) map[string]interface{} {
	// 这里应该实现真正的BPMN XML比较逻辑
	// 暂时返回简单的比较结果
	comparison := map[string]interface{}{
		"elements_added":      []string{},
		"elements_removed":    []string{},
		"elements_modified":   []string{},
		"connections_added":   []string{},
		"connections_removed": []string{},
		"variables_changed":   []string{},
		"is_identical":        xml1 == xml2,
	}

	return comparison
}

// 记录审计事件
func (wvs *WorkflowVersionService) logAuditEvent(ctx context.Context, event string, resourceID int, tenantID int, metadata map[string]interface{}) {
	wvs.logger.Infow("Audit event",
		"event", event,
		"resource_id", resourceID,
		"tenant_id", tenantID,
		"metadata", metadata,
		"timestamp", time.Now(),
	)
}
