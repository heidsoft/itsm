package service

import (
	"context"
	"fmt"
	"time"

	"itsm-backend/dto"
	"itsm-backend/ent"
	"itsm-backend/ent/sladefinition"
	"itsm-backend/ent/slaviolation"
	"itsm-backend/ent/ticket"

	"go.uber.org/zap"
)

type SLAService struct {
	client *ent.Client
	logger *zap.SugaredLogger
	ticketService *TicketService
}

func NewSLAService(client *ent.Client, logger *zap.SugaredLogger) *SLAService {
	return &SLAService{
		client: client,
		logger: logger,
		ticketService: NewTicketService(client, logger),
	}
}

// CreateSLADefinition 创建SLA定义
func (s *SLAService) CreateSLADefinition(ctx context.Context, req *dto.SLADefinitionRequest, tenantID int, createdBy string) (*dto.SLADefinitionResponse, error) {
	s.logger.Infow("Creating SLA definition", "tenant_id", tenantID, "name", req.Name)

	sla, err := s.client.SLADefinition.Create().
		SetName(req.Name).
		SetDescription(req.Description).
		SetServiceType(req.ServiceType).
		SetPriority(req.Priority).
		SetResponseTimeMinutes(req.ResponseTimeMinutes).
		SetResolutionTimeMinutes(req.ResolutionTimeMinutes).
		SetAvailabilityTarget(req.AvailabilityTarget).
		SetIsActive(true).
		SetTenantID(tenantID).
		Save(ctx)

	if err != nil {
		s.logger.Errorw("Failed to create SLA definition", "error", err)
		return nil, fmt.Errorf("failed to create SLA definition: %w", err)
	}

	return &dto.SLADefinitionResponse{
		ID:                     sla.ID,
		Name:                   sla.Name,
		Description:            sla.Description,
		ServiceType:            sla.ServiceType,
		Priority:               sla.Priority,
		ResponseTimeMinutes:    sla.ResponseTimeMinutes,
		ResolutionTimeMinutes:  sla.ResolutionTimeMinutes,
		AvailabilityTarget:     sla.AvailabilityTarget,
		IsActive:               sla.IsActive,
		TenantID:              sla.TenantID,
		CreatedAt:             sla.CreatedAt,
		UpdatedAt:             sla.UpdatedAt,
	}, nil
}

// GetSLADefinitionByID 获取SLA定义详情
func (s *SLAService) GetSLADefinitionByID(ctx context.Context, id int, tenantID int) (*dto.SLADefinitionResponse, error) {
	s.logger.Infow("Getting SLA definition", "id", id, "tenant_id", tenantID)

	sla, err := s.client.SLADefinition.Query().
		Where(sladefinition.ID(id), sladefinition.TenantID(tenantID)).
		First(ctx)

	if err != nil {
		if ent.IsNotFound(err) {
			return nil, fmt.Errorf("SLA definition not found")
		}
		s.logger.Errorw("Failed to get SLA definition", "error", err)
		return nil, fmt.Errorf("failed to get SLA definition: %w", err)
	}

	return &dto.SLADefinitionResponse{
		ID:                     sla.ID,
		Name:                   sla.Name,
		Description:            sla.Description,
		ServiceType:            sla.ServiceType,
		Priority:               sla.Priority,
		ResponseTimeMinutes:    sla.ResponseTimeMinutes,
		ResolutionTimeMinutes:  sla.ResolutionTimeMinutes,
		AvailabilityTarget:     sla.AvailabilityTarget,
		IsActive:               sla.IsActive,
		TenantID:              sla.TenantID,
		CreatedAt:             sla.CreatedAt,
		UpdatedAt:             sla.UpdatedAt,
	}, nil
}

// ListSLADefinitions 获取SLA定义列表
func (s *SLAService) ListSLADefinitions(ctx context.Context, tenantID, page, pageSize int) (*dto.SLADefinitionListResponse, error) {
	s.logger.Infow("Listing SLA definitions", "tenant_id", tenantID)

	query := s.client.SLADefinition.Query().Where(sladefinition.TenantID(tenantID))

	// 获取总数
	total, err := query.Count(ctx)
	if err != nil {
		s.logger.Errorw("Failed to count SLA definitions", "error", err)
		return nil, fmt.Errorf("failed to count SLA definitions: %w", err)
	}

	// 分页查询
	slas, err := query.
		Offset((page - 1) * pageSize).
		Limit(pageSize).
		Order(ent.Desc(sladefinition.FieldCreatedAt)).
		All(ctx)

	if err != nil {
		s.logger.Errorw("Failed to list SLA definitions", "error", err)
		return nil, fmt.Errorf("failed to list SLA definitions: %w", err)
	}

	// 转换为响应格式
	var responses []*dto.SLADefinitionResponse
	for _, sla := range slas {
		responses = append(responses, &dto.SLADefinitionResponse{
			ID:                     sla.ID,
			Name:                   sla.Name,
			Description:            sla.Description,
			ServiceType:            sla.ServiceType,
			Priority:               sla.Priority,
			ResponseTimeMinutes:    sla.ResponseTimeMinutes,
			ResolutionTimeMinutes:  sla.ResolutionTimeMinutes,
			AvailabilityTarget:     sla.AvailabilityTarget,
			IsActive:               sla.IsActive,
			TenantID:              sla.TenantID,
			CreatedAt:             sla.CreatedAt,
			UpdatedAt:             sla.UpdatedAt,
		})
	}

	return &dto.SLADefinitionListResponse{
		Items:    responses,
		Total:    total,
		Page:     page,
		PageSize: pageSize,
	}, nil
}

// UpdateSLADefinition 更新SLA定义
func (s *SLAService) UpdateSLADefinition(ctx context.Context, id int, req *dto.SLADefinitionRequest, tenantID int, updatedBy string) (*dto.SLADefinitionResponse, error) {
	s.logger.Infow("Updating SLA definition", "id", id, "tenant_id", tenantID)

	sla, err := s.client.SLADefinition.UpdateOneID(id).
		Where(sladefinition.TenantID(tenantID)).
		SetName(req.Name).
		SetDescription(req.Description).
		SetServiceType(req.ServiceType).
		SetPriority(req.Priority).
		SetResponseTimeMinutes(req.ResponseTimeMinutes).
		SetResolutionTimeMinutes(req.ResolutionTimeMinutes).
		SetAvailabilityTarget(req.AvailabilityTarget).
		Save(ctx)

	if err != nil {
		s.logger.Errorw("Failed to update SLA definition", "error", err)
		return nil, fmt.Errorf("failed to update SLA definition: %w", err)
	}

	return &dto.SLADefinitionResponse{
		ID:                     sla.ID,
		Name:                   sla.Name,
		Description:            sla.Description,
		ServiceType:            sla.ServiceType,
		Priority:               sla.Priority,
		ResponseTimeMinutes:    sla.ResponseTimeMinutes,
		ResolutionTimeMinutes:  sla.ResolutionTimeMinutes,
		AvailabilityTarget:     sla.AvailabilityTarget,
		IsActive:               sla.IsActive,
		TenantID:              sla.TenantID,
		CreatedAt:             sla.CreatedAt,
		UpdatedAt:             sla.UpdatedAt,
	}, nil
}

// DeleteSLADefinition 删除SLA定义
func (s *SLAService) DeleteSLADefinition(ctx context.Context, id int, tenantID int) error {
	s.logger.Infow("Deleting SLA definition", "id", id, "tenant_id", tenantID)

	err := s.client.SLADefinition.DeleteOneID(id).
		Where(sladefinition.TenantID(tenantID)).
		Exec(ctx)

	if err != nil {
		s.logger.Errorw("Failed to delete SLA definition", "error", err)
		return fmt.Errorf("failed to delete SLA definition: %w", err)
	}

	return nil
}

// GetSLAViolations 获取SLA违例列表
func (s *SLAService) GetSLAViolations(ctx context.Context, tenantID, page, pageSize int) (*dto.SLAViolationListResponse, error) {
	s.logger.Infow("Getting SLA violations", "tenant_id", tenantID)

	query := s.client.SLAViolation.Query().Where(slaviolation.TenantID(tenantID))

	// 获取总数
	total, err := query.Count(ctx)
	if err != nil {
		s.logger.Errorw("Failed to count SLA violations", "error", err)
		return nil, fmt.Errorf("failed to count SLA violations: %w", err)
	}

	// 分页查询
	violations, err := query.
		Offset((page - 1) * pageSize).
		Limit(pageSize).
		Order(ent.Desc(slaviolation.FieldCreatedAt)).
		All(ctx)

	if err != nil {
		s.logger.Errorw("Failed to list SLA violations", "error", err)
		return nil, fmt.Errorf("failed to list SLA violations: %w", err)
	}

	// 转换为响应格式
	var responses []*dto.SLAViolationResponse
	for _, violation := range violations {
		responses = append(responses, &dto.SLAViolationResponse{
			ID:         violation.ID,
			TicketID:   violation.TicketID,
			SLADefID:   violation.SlaDefinitionID,
			ViolationType: violation.ViolationType,
			ExpectedTime:  violation.ExpectedTime,
			ActualTime:    violation.ActualTime,
			DelayMinutes:  violation.DelayMinutes,
			Status:        violation.Status,
			TenantID:      violation.TenantID,
			CreatedAt:     violation.CreatedAt,
			UpdatedAt:     violation.UpdatedAt,
		})
	}

	return &dto.SLAViolationListResponse{
		Items:    responses,
		Total:    total,
		Page:     page,
		PageSize: pageSize,
	}, nil
}

// UpdateSLAViolationStatus 更新SLA违例状态
func (s *SLAService) UpdateSLAViolationStatus(ctx context.Context, id int, status string, tenantID int) error {
	s.logger.Infow("Updating SLA violation status", "id", id, "status", status, "tenant_id", tenantID)

	_, err := s.client.SLAViolation.UpdateOneID(id).
		Where(slaviolation.TenantID(tenantID)).
		SetStatus(status).
		Save(ctx)

	if err != nil {
		s.logger.Errorw("Failed to update SLA violation status", "error", err)
		return fmt.Errorf("failed to update SLA violation status: %w", err)
	}

	return nil
}

// GetSLAComplianceReport 获取SLA合规报告
func (s *SLAService) GetSLAComplianceReport(ctx context.Context, tenantID int, startDate, endDate time.Time) (*dto.SLAComplianceReportResponse, error) {
	s.logger.Infow("Getting SLA compliance report", "tenant_id", tenantID, "start_date", startDate, "end_date", endDate)

	// 获取时间段内的所有工单
	tickets, err := s.client.Ticket.Query().
		Where(
			ticket.TenantID(tenantID),
			ticket.CreatedAtGTE(startDate),
			ticket.CreatedAtLTE(endDate),
		).
		All(ctx)

	if err != nil {
		s.logger.Errorw("Failed to get tickets for SLA report", "error", err)
		return nil, fmt.Errorf("failed to get tickets for SLA report: %w", err)
	}

	// 计算SLA合规性
	totalTickets := len(tickets)
	var metSLA, violatedSLA int
	var totalResponseTime, totalResolutionTime float64

	for _, t := range tickets {
		// 简化的SLA计算逻辑
		responseTime := s.calculateResponseTime(t)
		resolutionTime := s.calculateResolutionTime(t)
		
		totalResponseTime += responseTime
		if t.Status == "closed" || t.Status == "resolved" {
			totalResolutionTime += resolutionTime
		}

		// 检查是否违反SLA
		if s.isSLAViolated(t, responseTime, resolutionTime) {
			violatedSLA++
		} else {
			metSLA++
		}
	}

	// 计算平均时间
	avgResponseTime := float64(0)
	avgResolutionTime := float64(0)
	if totalTickets > 0 {
		avgResponseTime = totalResponseTime / float64(totalTickets)
	}
	closedTickets := s.countClosedTickets(tickets)
	if closedTickets > 0 {
		avgResolutionTime = totalResolutionTime / float64(closedTickets)
	}

	// 计算合规率
	complianceRate := float64(0)
	if totalTickets > 0 {
		complianceRate = float64(metSLA) / float64(totalTickets) * 100
	}

	return &dto.SLAComplianceReportResponse{
		TotalTickets:         totalTickets,
		MetSLA:              metSLA,
		ViolatedSLA:         violatedSLA,
		ComplianceRate:      complianceRate,
		AvgResponseTime:     avgResponseTime,
		AvgResolutionTime:   avgResolutionTime,
		ReportPeriod: dto.ReportPeriod{
			StartDate: startDate,
			EndDate:   endDate,
		},
	}, nil
}

// CheckSLAViolation 检查SLA违规
func (s *SLAService) CheckSLAViolation(ctx context.Context, ticketID int, tenantID int) error {
	s.logger.Infow("Checking SLA violation", "ticket_id", ticketID, "tenant_id", tenantID)

	// 获取工单信息
	t, err := s.ticketService.GetTicket(ctx, ticketID, tenantID)
	if err != nil {
		return err
	}

	// 获取适用的SLA定义
	slaDefinition, err := s.getSLADefinitionForTicket(ctx, t)
	if err != nil {
		return err
	}

	if slaDefinition == nil {
		// 没有适用的SLA定义
		return nil
	}

	// 检查响应时间违规
	responseTime := s.calculateResponseTime(t)
	if responseTime > float64(slaDefinition.ResponseTimeMinutes) {
		err = s.createSLAViolation(ctx, ticketID, slaDefinition.ID, "response_time", 
			time.Now().Add(time.Duration(slaDefinition.ResponseTimeMinutes)*time.Minute), 
			time.Now(), responseTime-float64(slaDefinition.ResponseTimeMinutes), tenantID)
		if err != nil {
			s.logger.Errorw("Failed to create response time violation", "error", err)
		}
	}

	// 检查解决时间违规（如果工单已解决）
	if t.Status == "resolved" || t.Status == "closed" {
		resolutionTime := s.calculateResolutionTime(t)
		if resolutionTime > float64(slaDefinition.ResolutionTimeMinutes) {
			err = s.createSLAViolation(ctx, ticketID, slaDefinition.ID, "resolution_time",
				time.Now().Add(time.Duration(slaDefinition.ResolutionTimeMinutes)*time.Minute),
				time.Now(), resolutionTime-float64(slaDefinition.ResolutionTimeMinutes), tenantID)
			if err != nil {
				s.logger.Errorw("Failed to create resolution time violation", "error", err)
			}
		}
	}

	return nil
}

// MonitorSLAViolations 监控SLA违规（定时任务）
func (s *SLAService) MonitorSLAViolations(ctx context.Context, tenantID int) error {
	s.logger.Infow("Monitoring SLA violations", "tenant_id", tenantID)

	// 获取所有未关闭的工单
	openTickets, err := s.client.Ticket.Query().
		Where(
			ticket.TenantID(tenantID),
			ticket.StatusNotIn("closed", "resolved"),
		).
		All(ctx)

	if err != nil {
		s.logger.Errorw("Failed to get open tickets for SLA monitoring", "error", err)
		return fmt.Errorf("failed to get open tickets: %w", err)
	}

	// 检查每个工单的SLA状态
	for _, t := range openTickets {
		err = s.CheckSLAViolation(ctx, t.ID, tenantID)
		if err != nil {
			s.logger.Errorw("Failed to check SLA violation", "ticket_id", t.ID, "error", err)
			// 继续检查其他工单，不中断处理
		}
	}

	return nil
}

// getSLADefinitionForTicket 获取工单适用的SLA定义
func (s *SLAService) getSLADefinitionForTicket(ctx context.Context, t *ent.Ticket) (*ent.SLADefinition, error) {
	// 根据工单的服务类型和优先级查找匹配的SLA定义
	slaDefinition, err := s.client.SLADefinition.Query().
		Where(
			sladefinition.TenantID(t.TenantID),
			sladefinition.IsActive(true),
			sladefinition.Priority(t.Priority),
		).
		First(ctx)

	if err != nil && !ent.IsNotFound(err) {
		return nil, err
	}

	return slaDefinition, nil
}

// calculateResponseTime 计算响应时间（分钟）
func (s *SLAService) calculateResponseTime(t *ent.Ticket) float64 {
	// 简化计算：从创建到现在的时间（如果未分配）或从创建到分配的时间
	now := time.Now()
	if t.Status == "submitted" {
		return now.Sub(t.CreatedAt).Minutes()
	}
	// 如果已分配，假设分配时间是更新时间
	return t.UpdatedAt.Sub(t.CreatedAt).Minutes()
}

// calculateResolutionTime 计算解决时间（分钟）
func (s *SLAService) calculateResolutionTime(t *ent.Ticket) float64 {
	// 简化计算：从创建到更新的时间
	return t.UpdatedAt.Sub(t.CreatedAt).Minutes()
}

// isSLAViolated 检查是否违反SLA
func (s *SLAService) isSLAViolated(t *ent.Ticket, responseTime, resolutionTime float64) bool {
	// 简化的SLA违规判断逻辑
	// 实际应该根据SLA定义来判断
	maxResponseTime := map[string]float64{
		"critical": 30,  // 30分钟
		"high":     60,  // 1小时
		"medium":   240, // 4小时
		"low":      480, // 8小时
	}

	maxResolution := map[string]float64{
		"critical": 120, // 2小时
		"high":     480, // 8小时
		"medium":   1440, // 24小时
		"low":      2880, // 48小时
	}

	responseLimit, exists := maxResponseTime[t.Priority]
	if !exists {
		responseLimit = 240 // 默认4小时
	}

	resolutionLimit, exists := maxResolution[t.Priority]
	if !exists {
		resolutionLimit = 1440 // 默认24小时
	}

	return responseTime > responseLimit || (t.Status == "closed" && resolutionTime > resolutionLimit)
}

// countClosedTickets 统计已关闭工单数
func (s *SLAService) countClosedTickets(tickets []*ent.Ticket) int {
	count := 0
	for _, t := range tickets {
		if t.Status == "closed" || t.Status == "resolved" {
			count++
		}
	}
	return count
}

// createSLAViolation 创建SLA违规记录
func (s *SLAService) createSLAViolation(ctx context.Context, ticketID, slaDefID int, violationType string, expectedTime, actualTime time.Time, delayMinutes float64, tenantID int) error {
	_, err := s.client.SLAViolation.Create().
		SetTicketID(ticketID).
		SetSlaDefinitionID(slaDefID).
		SetViolationType(violationType).
		SetExpectedTime(expectedTime).
		SetActualTime(actualTime).
		SetDelayMinutes(int(delayMinutes)).
		SetStatus("open").
		SetTenantID(tenantID).
		Save(ctx)

	return err
}
