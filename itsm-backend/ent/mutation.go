// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"itsm-backend/ent/auditlog"
	"itsm-backend/ent/ciattributedefinition"
	"itsm-backend/ent/cirelationship"
	"itsm-backend/ent/citype"
	"itsm-backend/ent/configurationitem"
	"itsm-backend/ent/conversation"
	"itsm-backend/ent/incident"
	"itsm-backend/ent/knowledgearticle"
	"itsm-backend/ent/message"
	"itsm-backend/ent/notification"
	"itsm-backend/ent/predicate"
	"itsm-backend/ent/prompttemplate"
	"itsm-backend/ent/servicecatalog"
	"itsm-backend/ent/servicerequest"
	"itsm-backend/ent/sladefinition"
	"itsm-backend/ent/slaviolation"
	"itsm-backend/ent/tenant"
	"itsm-backend/ent/ticket"
	"itsm-backend/ent/toolinvocation"
	"itsm-backend/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuditLog              = "AuditLog"
	TypeCIAttributeDefinition = "CIAttributeDefinition"
	TypeCIRelationship        = "CIRelationship"
	TypeCIType                = "CIType"
	TypeConfigurationItem     = "ConfigurationItem"
	TypeConversation          = "Conversation"
	TypeIncident              = "Incident"
	TypeKnowledgeArticle      = "KnowledgeArticle"
	TypeMessage               = "Message"
	TypeNotification          = "Notification"
	TypePromptTemplate        = "PromptTemplate"
	TypeSLADefinition         = "SLADefinition"
	TypeSLAViolation          = "SLAViolation"
	TypeServiceCatalog        = "ServiceCatalog"
	TypeServiceRequest        = "ServiceRequest"
	TypeTenant                = "Tenant"
	TypeTicket                = "Ticket"
	TypeToolInvocation        = "ToolInvocation"
	TypeUser                  = "User"
)

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	tenant_id      *int
	addtenant_id   *int
	user_id        *int
	adduser_id     *int
	request_id     *string
	ip             *string
	resource       *string
	action         *string
	_path          *string
	method         *string
	status_code    *int
	addstatus_code *int
	request_body   *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AuditLog, error)
	predicates     []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id int) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *AuditLogMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AuditLogMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *AuditLogMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *AuditLogMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AuditLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[auditlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AuditLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, auditlog.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *AuditLogMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuditLogMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *AuditLogMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AuditLogMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *AuditLogMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[auditlog.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AuditLogMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuditLogMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, auditlog.FieldUserID)
}

// SetRequestID sets the "request_id" field.
func (m *AuditLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *AuditLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *AuditLogMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[auditlog.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *AuditLogMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *AuditLogMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, auditlog.FieldRequestID)
}

// SetIP sets the "ip" field.
func (m *AuditLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AuditLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AuditLogMutation) ResetIP() {
	m.ip = nil
}

// SetResource sets the "resource" field.
func (m *AuditLogMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the value of the "resource" field in the mutation.
func (m *AuditLogMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old "resource" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ResetResource resets all changes to the "resource" field.
func (m *AuditLogMutation) ResetResource() {
	m.resource = nil
}

// SetAction sets the "action" field.
func (m *AuditLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *AuditLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *AuditLogMutation) ResetAction() {
	m.action = nil
}

// SetPath sets the "path" field.
func (m *AuditLogMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *AuditLogMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *AuditLogMutation) ResetPath() {
	m._path = nil
}

// SetMethod sets the "method" field.
func (m *AuditLogMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *AuditLogMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *AuditLogMutation) ResetMethod() {
	m.method = nil
}

// SetStatusCode sets the "status_code" field.
func (m *AuditLogMutation) SetStatusCode(i int) {
	m.status_code = &i
	m.addstatus_code = nil
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *AuditLogMutation) StatusCode() (r int, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldStatusCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// AddStatusCode adds i to the "status_code" field.
func (m *AuditLogMutation) AddStatusCode(i int) {
	if m.addstatus_code != nil {
		*m.addstatus_code += i
	} else {
		m.addstatus_code = &i
	}
}

// AddedStatusCode returns the value that was added to the "status_code" field in this mutation.
func (m *AuditLogMutation) AddedStatusCode() (r int, exists bool) {
	v := m.addstatus_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *AuditLogMutation) ResetStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
}

// SetRequestBody sets the "request_body" field.
func (m *AuditLogMutation) SetRequestBody(s string) {
	m.request_body = &s
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *AuditLogMutation) RequestBody() (r string, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestBody(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// ClearRequestBody clears the value of the "request_body" field.
func (m *AuditLogMutation) ClearRequestBody() {
	m.request_body = nil
	m.clearedFields[auditlog.FieldRequestBody] = struct{}{}
}

// RequestBodyCleared returns if the "request_body" field was cleared in this mutation.
func (m *AuditLogMutation) RequestBodyCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRequestBody]
	return ok
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *AuditLogMutation) ResetRequestBody() {
	m.request_body = nil
	delete(m.clearedFields, auditlog.FieldRequestBody)
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, auditlog.FieldCreatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.request_id != nil {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.ip != nil {
		fields = append(fields, auditlog.FieldIP)
	}
	if m.resource != nil {
		fields = append(fields, auditlog.FieldResource)
	}
	if m.action != nil {
		fields = append(fields, auditlog.FieldAction)
	}
	if m._path != nil {
		fields = append(fields, auditlog.FieldPath)
	}
	if m.method != nil {
		fields = append(fields, auditlog.FieldMethod)
	}
	if m.status_code != nil {
		fields = append(fields, auditlog.FieldStatusCode)
	}
	if m.request_body != nil {
		fields = append(fields, auditlog.FieldRequestBody)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldCreatedAt:
		return m.CreatedAt()
	case auditlog.FieldTenantID:
		return m.TenantID()
	case auditlog.FieldUserID:
		return m.UserID()
	case auditlog.FieldRequestID:
		return m.RequestID()
	case auditlog.FieldIP:
		return m.IP()
	case auditlog.FieldResource:
		return m.Resource()
	case auditlog.FieldAction:
		return m.Action()
	case auditlog.FieldPath:
		return m.Path()
	case auditlog.FieldMethod:
		return m.Method()
	case auditlog.FieldStatusCode:
		return m.StatusCode()
	case auditlog.FieldRequestBody:
		return m.RequestBody()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case auditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case auditlog.FieldUserID:
		return m.OldUserID(ctx)
	case auditlog.FieldRequestID:
		return m.OldRequestID(ctx)
	case auditlog.FieldIP:
		return m.OldIP(ctx)
	case auditlog.FieldResource:
		return m.OldResource(ctx)
	case auditlog.FieldAction:
		return m.OldAction(ctx)
	case auditlog.FieldPath:
		return m.OldPath(ctx)
	case auditlog.FieldMethod:
		return m.OldMethod(ctx)
	case auditlog.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case auditlog.FieldRequestBody:
		return m.OldRequestBody(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case auditlog.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case auditlog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case auditlog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case auditlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case auditlog.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case auditlog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case auditlog.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case auditlog.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case auditlog.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case auditlog.FieldRequestBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.addstatus_code != nil {
		fields = append(fields, auditlog.FieldStatusCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldTenantID:
		return m.AddedTenantID()
	case auditlog.FieldUserID:
		return m.AddedUserID()
	case auditlog.FieldStatusCode:
		return m.AddedStatusCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case auditlog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case auditlog.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusCode(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldTenantID) {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.FieldCleared(auditlog.FieldUserID) {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.FieldCleared(auditlog.FieldRequestID) {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.FieldCleared(auditlog.FieldRequestBody) {
		fields = append(fields, auditlog.FieldRequestBody)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case auditlog.FieldUserID:
		m.ClearUserID()
		return nil
	case auditlog.FieldRequestID:
		m.ClearRequestID()
		return nil
	case auditlog.FieldRequestBody:
		m.ClearRequestBody()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case auditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case auditlog.FieldUserID:
		m.ResetUserID()
		return nil
	case auditlog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case auditlog.FieldIP:
		m.ResetIP()
		return nil
	case auditlog.FieldResource:
		m.ResetResource()
		return nil
	case auditlog.FieldAction:
		m.ResetAction()
		return nil
	case auditlog.FieldPath:
		m.ResetPath()
		return nil
	case auditlog.FieldMethod:
		m.ResetMethod()
		return nil
	case auditlog.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case auditlog.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// CIAttributeDefinitionMutation represents an operation that mutates the CIAttributeDefinition nodes in the graph.
type CIAttributeDefinitionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	display_name     *string
	_type            *string
	required         *bool
	_unique          *bool
	default_value    *string
	validation_rules *string
	ci_type_id       *int
	addci_type_id    *int
	tenant_id        *int
	addtenant_id     *int
	is_active        *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*CIAttributeDefinition, error)
	predicates       []predicate.CIAttributeDefinition
}

var _ ent.Mutation = (*CIAttributeDefinitionMutation)(nil)

// ciattributedefinitionOption allows management of the mutation configuration using functional options.
type ciattributedefinitionOption func(*CIAttributeDefinitionMutation)

// newCIAttributeDefinitionMutation creates new mutation for the CIAttributeDefinition entity.
func newCIAttributeDefinitionMutation(c config, op Op, opts ...ciattributedefinitionOption) *CIAttributeDefinitionMutation {
	m := &CIAttributeDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeCIAttributeDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCIAttributeDefinitionID sets the ID field of the mutation.
func withCIAttributeDefinitionID(id int) ciattributedefinitionOption {
	return func(m *CIAttributeDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *CIAttributeDefinition
		)
		m.oldValue = func(ctx context.Context) (*CIAttributeDefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CIAttributeDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCIAttributeDefinition sets the old CIAttributeDefinition of the mutation.
func withCIAttributeDefinition(node *CIAttributeDefinition) ciattributedefinitionOption {
	return func(m *CIAttributeDefinitionMutation) {
		m.oldValue = func(context.Context) (*CIAttributeDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CIAttributeDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CIAttributeDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CIAttributeDefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CIAttributeDefinitionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CIAttributeDefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CIAttributeDefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CIAttributeDefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CIAttributeDefinitionMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *CIAttributeDefinitionMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *CIAttributeDefinitionMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *CIAttributeDefinitionMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetType sets the "type" field.
func (m *CIAttributeDefinitionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CIAttributeDefinitionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CIAttributeDefinitionMutation) ResetType() {
	m._type = nil
}

// SetRequired sets the "required" field.
func (m *CIAttributeDefinitionMutation) SetRequired(b bool) {
	m.required = &b
}

// Required returns the value of the "required" field in the mutation.
func (m *CIAttributeDefinitionMutation) Required() (r bool, exists bool) {
	v := m.required
	if v == nil {
		return
	}
	return *v, true
}

// OldRequired returns the old "required" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequired: %w", err)
	}
	return oldValue.Required, nil
}

// ResetRequired resets all changes to the "required" field.
func (m *CIAttributeDefinitionMutation) ResetRequired() {
	m.required = nil
}

// SetUnique sets the "unique" field.
func (m *CIAttributeDefinitionMutation) SetUnique(b bool) {
	m._unique = &b
}

// Unique returns the value of the "unique" field in the mutation.
func (m *CIAttributeDefinitionMutation) Unique() (r bool, exists bool) {
	v := m._unique
	if v == nil {
		return
	}
	return *v, true
}

// OldUnique returns the old "unique" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldUnique(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnique is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnique requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnique: %w", err)
	}
	return oldValue.Unique, nil
}

// ResetUnique resets all changes to the "unique" field.
func (m *CIAttributeDefinitionMutation) ResetUnique() {
	m._unique = nil
}

// SetDefaultValue sets the "default_value" field.
func (m *CIAttributeDefinitionMutation) SetDefaultValue(s string) {
	m.default_value = &s
}

// DefaultValue returns the value of the "default_value" field in the mutation.
func (m *CIAttributeDefinitionMutation) DefaultValue() (r string, exists bool) {
	v := m.default_value
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultValue returns the old "default_value" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldDefaultValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultValue: %w", err)
	}
	return oldValue.DefaultValue, nil
}

// ClearDefaultValue clears the value of the "default_value" field.
func (m *CIAttributeDefinitionMutation) ClearDefaultValue() {
	m.default_value = nil
	m.clearedFields[ciattributedefinition.FieldDefaultValue] = struct{}{}
}

// DefaultValueCleared returns if the "default_value" field was cleared in this mutation.
func (m *CIAttributeDefinitionMutation) DefaultValueCleared() bool {
	_, ok := m.clearedFields[ciattributedefinition.FieldDefaultValue]
	return ok
}

// ResetDefaultValue resets all changes to the "default_value" field.
func (m *CIAttributeDefinitionMutation) ResetDefaultValue() {
	m.default_value = nil
	delete(m.clearedFields, ciattributedefinition.FieldDefaultValue)
}

// SetValidationRules sets the "validation_rules" field.
func (m *CIAttributeDefinitionMutation) SetValidationRules(s string) {
	m.validation_rules = &s
}

// ValidationRules returns the value of the "validation_rules" field in the mutation.
func (m *CIAttributeDefinitionMutation) ValidationRules() (r string, exists bool) {
	v := m.validation_rules
	if v == nil {
		return
	}
	return *v, true
}

// OldValidationRules returns the old "validation_rules" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldValidationRules(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidationRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidationRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidationRules: %w", err)
	}
	return oldValue.ValidationRules, nil
}

// ClearValidationRules clears the value of the "validation_rules" field.
func (m *CIAttributeDefinitionMutation) ClearValidationRules() {
	m.validation_rules = nil
	m.clearedFields[ciattributedefinition.FieldValidationRules] = struct{}{}
}

// ValidationRulesCleared returns if the "validation_rules" field was cleared in this mutation.
func (m *CIAttributeDefinitionMutation) ValidationRulesCleared() bool {
	_, ok := m.clearedFields[ciattributedefinition.FieldValidationRules]
	return ok
}

// ResetValidationRules resets all changes to the "validation_rules" field.
func (m *CIAttributeDefinitionMutation) ResetValidationRules() {
	m.validation_rules = nil
	delete(m.clearedFields, ciattributedefinition.FieldValidationRules)
}

// SetCiTypeID sets the "ci_type_id" field.
func (m *CIAttributeDefinitionMutation) SetCiTypeID(i int) {
	m.ci_type_id = &i
	m.addci_type_id = nil
}

// CiTypeID returns the value of the "ci_type_id" field in the mutation.
func (m *CIAttributeDefinitionMutation) CiTypeID() (r int, exists bool) {
	v := m.ci_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCiTypeID returns the old "ci_type_id" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldCiTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCiTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCiTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCiTypeID: %w", err)
	}
	return oldValue.CiTypeID, nil
}

// AddCiTypeID adds i to the "ci_type_id" field.
func (m *CIAttributeDefinitionMutation) AddCiTypeID(i int) {
	if m.addci_type_id != nil {
		*m.addci_type_id += i
	} else {
		m.addci_type_id = &i
	}
}

// AddedCiTypeID returns the value that was added to the "ci_type_id" field in this mutation.
func (m *CIAttributeDefinitionMutation) AddedCiTypeID() (r int, exists bool) {
	v := m.addci_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCiTypeID resets all changes to the "ci_type_id" field.
func (m *CIAttributeDefinitionMutation) ResetCiTypeID() {
	m.ci_type_id = nil
	m.addci_type_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *CIAttributeDefinitionMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CIAttributeDefinitionMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *CIAttributeDefinitionMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *CIAttributeDefinitionMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CIAttributeDefinitionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetIsActive sets the "is_active" field.
func (m *CIAttributeDefinitionMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *CIAttributeDefinitionMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *CIAttributeDefinitionMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CIAttributeDefinitionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CIAttributeDefinitionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CIAttributeDefinitionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CIAttributeDefinitionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CIAttributeDefinitionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CIAttributeDefinitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the CIAttributeDefinitionMutation builder.
func (m *CIAttributeDefinitionMutation) Where(ps ...predicate.CIAttributeDefinition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CIAttributeDefinitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CIAttributeDefinitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CIAttributeDefinition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CIAttributeDefinitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CIAttributeDefinitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CIAttributeDefinition).
func (m *CIAttributeDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CIAttributeDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, ciattributedefinition.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, ciattributedefinition.FieldDisplayName)
	}
	if m._type != nil {
		fields = append(fields, ciattributedefinition.FieldType)
	}
	if m.required != nil {
		fields = append(fields, ciattributedefinition.FieldRequired)
	}
	if m._unique != nil {
		fields = append(fields, ciattributedefinition.FieldUnique)
	}
	if m.default_value != nil {
		fields = append(fields, ciattributedefinition.FieldDefaultValue)
	}
	if m.validation_rules != nil {
		fields = append(fields, ciattributedefinition.FieldValidationRules)
	}
	if m.ci_type_id != nil {
		fields = append(fields, ciattributedefinition.FieldCiTypeID)
	}
	if m.tenant_id != nil {
		fields = append(fields, ciattributedefinition.FieldTenantID)
	}
	if m.is_active != nil {
		fields = append(fields, ciattributedefinition.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, ciattributedefinition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ciattributedefinition.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CIAttributeDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ciattributedefinition.FieldName:
		return m.Name()
	case ciattributedefinition.FieldDisplayName:
		return m.DisplayName()
	case ciattributedefinition.FieldType:
		return m.GetType()
	case ciattributedefinition.FieldRequired:
		return m.Required()
	case ciattributedefinition.FieldUnique:
		return m.Unique()
	case ciattributedefinition.FieldDefaultValue:
		return m.DefaultValue()
	case ciattributedefinition.FieldValidationRules:
		return m.ValidationRules()
	case ciattributedefinition.FieldCiTypeID:
		return m.CiTypeID()
	case ciattributedefinition.FieldTenantID:
		return m.TenantID()
	case ciattributedefinition.FieldIsActive:
		return m.IsActive()
	case ciattributedefinition.FieldCreatedAt:
		return m.CreatedAt()
	case ciattributedefinition.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CIAttributeDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ciattributedefinition.FieldName:
		return m.OldName(ctx)
	case ciattributedefinition.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case ciattributedefinition.FieldType:
		return m.OldType(ctx)
	case ciattributedefinition.FieldRequired:
		return m.OldRequired(ctx)
	case ciattributedefinition.FieldUnique:
		return m.OldUnique(ctx)
	case ciattributedefinition.FieldDefaultValue:
		return m.OldDefaultValue(ctx)
	case ciattributedefinition.FieldValidationRules:
		return m.OldValidationRules(ctx)
	case ciattributedefinition.FieldCiTypeID:
		return m.OldCiTypeID(ctx)
	case ciattributedefinition.FieldTenantID:
		return m.OldTenantID(ctx)
	case ciattributedefinition.FieldIsActive:
		return m.OldIsActive(ctx)
	case ciattributedefinition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ciattributedefinition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CIAttributeDefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CIAttributeDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ciattributedefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ciattributedefinition.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case ciattributedefinition.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case ciattributedefinition.FieldRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequired(v)
		return nil
	case ciattributedefinition.FieldUnique:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnique(v)
		return nil
	case ciattributedefinition.FieldDefaultValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultValue(v)
		return nil
	case ciattributedefinition.FieldValidationRules:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidationRules(v)
		return nil
	case ciattributedefinition.FieldCiTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCiTypeID(v)
		return nil
	case ciattributedefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ciattributedefinition.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case ciattributedefinition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ciattributedefinition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CIAttributeDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CIAttributeDefinitionMutation) AddedFields() []string {
	var fields []string
	if m.addci_type_id != nil {
		fields = append(fields, ciattributedefinition.FieldCiTypeID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, ciattributedefinition.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CIAttributeDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ciattributedefinition.FieldCiTypeID:
		return m.AddedCiTypeID()
	case ciattributedefinition.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CIAttributeDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ciattributedefinition.FieldCiTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCiTypeID(v)
		return nil
	case ciattributedefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown CIAttributeDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CIAttributeDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ciattributedefinition.FieldDefaultValue) {
		fields = append(fields, ciattributedefinition.FieldDefaultValue)
	}
	if m.FieldCleared(ciattributedefinition.FieldValidationRules) {
		fields = append(fields, ciattributedefinition.FieldValidationRules)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CIAttributeDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CIAttributeDefinitionMutation) ClearField(name string) error {
	switch name {
	case ciattributedefinition.FieldDefaultValue:
		m.ClearDefaultValue()
		return nil
	case ciattributedefinition.FieldValidationRules:
		m.ClearValidationRules()
		return nil
	}
	return fmt.Errorf("unknown CIAttributeDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CIAttributeDefinitionMutation) ResetField(name string) error {
	switch name {
	case ciattributedefinition.FieldName:
		m.ResetName()
		return nil
	case ciattributedefinition.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case ciattributedefinition.FieldType:
		m.ResetType()
		return nil
	case ciattributedefinition.FieldRequired:
		m.ResetRequired()
		return nil
	case ciattributedefinition.FieldUnique:
		m.ResetUnique()
		return nil
	case ciattributedefinition.FieldDefaultValue:
		m.ResetDefaultValue()
		return nil
	case ciattributedefinition.FieldValidationRules:
		m.ResetValidationRules()
		return nil
	case ciattributedefinition.FieldCiTypeID:
		m.ResetCiTypeID()
		return nil
	case ciattributedefinition.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ciattributedefinition.FieldIsActive:
		m.ResetIsActive()
		return nil
	case ciattributedefinition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ciattributedefinition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CIAttributeDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CIAttributeDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CIAttributeDefinitionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CIAttributeDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CIAttributeDefinitionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CIAttributeDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CIAttributeDefinitionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CIAttributeDefinitionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CIAttributeDefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CIAttributeDefinitionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CIAttributeDefinition edge %s", name)
}

// CIRelationshipMutation represents an operation that mutates the CIRelationship nodes in the graph.
type CIRelationshipMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	source_ci_id            *int
	addsource_ci_id         *int
	target_ci_id            *int
	addtarget_ci_id         *int
	relationship_type_id    *int
	addrelationship_type_id *int
	description             *string
	tenant_id               *int
	addtenant_id            *int
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*CIRelationship, error)
	predicates              []predicate.CIRelationship
}

var _ ent.Mutation = (*CIRelationshipMutation)(nil)

// cirelationshipOption allows management of the mutation configuration using functional options.
type cirelationshipOption func(*CIRelationshipMutation)

// newCIRelationshipMutation creates new mutation for the CIRelationship entity.
func newCIRelationshipMutation(c config, op Op, opts ...cirelationshipOption) *CIRelationshipMutation {
	m := &CIRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeCIRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCIRelationshipID sets the ID field of the mutation.
func withCIRelationshipID(id int) cirelationshipOption {
	return func(m *CIRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *CIRelationship
		)
		m.oldValue = func(ctx context.Context) (*CIRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CIRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCIRelationship sets the old CIRelationship of the mutation.
func withCIRelationship(node *CIRelationship) cirelationshipOption {
	return func(m *CIRelationshipMutation) {
		m.oldValue = func(context.Context) (*CIRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CIRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CIRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CIRelationshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CIRelationshipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CIRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceCiID sets the "source_ci_id" field.
func (m *CIRelationshipMutation) SetSourceCiID(i int) {
	m.source_ci_id = &i
	m.addsource_ci_id = nil
}

// SourceCiID returns the value of the "source_ci_id" field in the mutation.
func (m *CIRelationshipMutation) SourceCiID() (r int, exists bool) {
	v := m.source_ci_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceCiID returns the old "source_ci_id" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldSourceCiID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceCiID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceCiID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceCiID: %w", err)
	}
	return oldValue.SourceCiID, nil
}

// AddSourceCiID adds i to the "source_ci_id" field.
func (m *CIRelationshipMutation) AddSourceCiID(i int) {
	if m.addsource_ci_id != nil {
		*m.addsource_ci_id += i
	} else {
		m.addsource_ci_id = &i
	}
}

// AddedSourceCiID returns the value that was added to the "source_ci_id" field in this mutation.
func (m *CIRelationshipMutation) AddedSourceCiID() (r int, exists bool) {
	v := m.addsource_ci_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSourceCiID resets all changes to the "source_ci_id" field.
func (m *CIRelationshipMutation) ResetSourceCiID() {
	m.source_ci_id = nil
	m.addsource_ci_id = nil
}

// SetTargetCiID sets the "target_ci_id" field.
func (m *CIRelationshipMutation) SetTargetCiID(i int) {
	m.target_ci_id = &i
	m.addtarget_ci_id = nil
}

// TargetCiID returns the value of the "target_ci_id" field in the mutation.
func (m *CIRelationshipMutation) TargetCiID() (r int, exists bool) {
	v := m.target_ci_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetCiID returns the old "target_ci_id" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldTargetCiID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetCiID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetCiID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetCiID: %w", err)
	}
	return oldValue.TargetCiID, nil
}

// AddTargetCiID adds i to the "target_ci_id" field.
func (m *CIRelationshipMutation) AddTargetCiID(i int) {
	if m.addtarget_ci_id != nil {
		*m.addtarget_ci_id += i
	} else {
		m.addtarget_ci_id = &i
	}
}

// AddedTargetCiID returns the value that was added to the "target_ci_id" field in this mutation.
func (m *CIRelationshipMutation) AddedTargetCiID() (r int, exists bool) {
	v := m.addtarget_ci_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTargetCiID resets all changes to the "target_ci_id" field.
func (m *CIRelationshipMutation) ResetTargetCiID() {
	m.target_ci_id = nil
	m.addtarget_ci_id = nil
}

// SetRelationshipTypeID sets the "relationship_type_id" field.
func (m *CIRelationshipMutation) SetRelationshipTypeID(i int) {
	m.relationship_type_id = &i
	m.addrelationship_type_id = nil
}

// RelationshipTypeID returns the value of the "relationship_type_id" field in the mutation.
func (m *CIRelationshipMutation) RelationshipTypeID() (r int, exists bool) {
	v := m.relationship_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationshipTypeID returns the old "relationship_type_id" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldRelationshipTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationshipTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationshipTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationshipTypeID: %w", err)
	}
	return oldValue.RelationshipTypeID, nil
}

// AddRelationshipTypeID adds i to the "relationship_type_id" field.
func (m *CIRelationshipMutation) AddRelationshipTypeID(i int) {
	if m.addrelationship_type_id != nil {
		*m.addrelationship_type_id += i
	} else {
		m.addrelationship_type_id = &i
	}
}

// AddedRelationshipTypeID returns the value that was added to the "relationship_type_id" field in this mutation.
func (m *CIRelationshipMutation) AddedRelationshipTypeID() (r int, exists bool) {
	v := m.addrelationship_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRelationshipTypeID resets all changes to the "relationship_type_id" field.
func (m *CIRelationshipMutation) ResetRelationshipTypeID() {
	m.relationship_type_id = nil
	m.addrelationship_type_id = nil
}

// SetDescription sets the "description" field.
func (m *CIRelationshipMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CIRelationshipMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CIRelationshipMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[cirelationship.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CIRelationshipMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[cirelationship.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CIRelationshipMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, cirelationship.FieldDescription)
}

// SetTenantID sets the "tenant_id" field.
func (m *CIRelationshipMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CIRelationshipMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *CIRelationshipMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *CIRelationshipMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CIRelationshipMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CIRelationshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CIRelationshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CIRelationshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CIRelationshipMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CIRelationshipMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CIRelationshipMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the CIRelationshipMutation builder.
func (m *CIRelationshipMutation) Where(ps ...predicate.CIRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CIRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CIRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CIRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CIRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CIRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CIRelationship).
func (m *CIRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CIRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.source_ci_id != nil {
		fields = append(fields, cirelationship.FieldSourceCiID)
	}
	if m.target_ci_id != nil {
		fields = append(fields, cirelationship.FieldTargetCiID)
	}
	if m.relationship_type_id != nil {
		fields = append(fields, cirelationship.FieldRelationshipTypeID)
	}
	if m.description != nil {
		fields = append(fields, cirelationship.FieldDescription)
	}
	if m.tenant_id != nil {
		fields = append(fields, cirelationship.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, cirelationship.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cirelationship.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CIRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cirelationship.FieldSourceCiID:
		return m.SourceCiID()
	case cirelationship.FieldTargetCiID:
		return m.TargetCiID()
	case cirelationship.FieldRelationshipTypeID:
		return m.RelationshipTypeID()
	case cirelationship.FieldDescription:
		return m.Description()
	case cirelationship.FieldTenantID:
		return m.TenantID()
	case cirelationship.FieldCreatedAt:
		return m.CreatedAt()
	case cirelationship.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CIRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cirelationship.FieldSourceCiID:
		return m.OldSourceCiID(ctx)
	case cirelationship.FieldTargetCiID:
		return m.OldTargetCiID(ctx)
	case cirelationship.FieldRelationshipTypeID:
		return m.OldRelationshipTypeID(ctx)
	case cirelationship.FieldDescription:
		return m.OldDescription(ctx)
	case cirelationship.FieldTenantID:
		return m.OldTenantID(ctx)
	case cirelationship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cirelationship.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CIRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CIRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cirelationship.FieldSourceCiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceCiID(v)
		return nil
	case cirelationship.FieldTargetCiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetCiID(v)
		return nil
	case cirelationship.FieldRelationshipTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationshipTypeID(v)
		return nil
	case cirelationship.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case cirelationship.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case cirelationship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cirelationship.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CIRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CIRelationshipMutation) AddedFields() []string {
	var fields []string
	if m.addsource_ci_id != nil {
		fields = append(fields, cirelationship.FieldSourceCiID)
	}
	if m.addtarget_ci_id != nil {
		fields = append(fields, cirelationship.FieldTargetCiID)
	}
	if m.addrelationship_type_id != nil {
		fields = append(fields, cirelationship.FieldRelationshipTypeID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, cirelationship.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CIRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cirelationship.FieldSourceCiID:
		return m.AddedSourceCiID()
	case cirelationship.FieldTargetCiID:
		return m.AddedTargetCiID()
	case cirelationship.FieldRelationshipTypeID:
		return m.AddedRelationshipTypeID()
	case cirelationship.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CIRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cirelationship.FieldSourceCiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSourceCiID(v)
		return nil
	case cirelationship.FieldTargetCiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetCiID(v)
		return nil
	case cirelationship.FieldRelationshipTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelationshipTypeID(v)
		return nil
	case cirelationship.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown CIRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CIRelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cirelationship.FieldDescription) {
		fields = append(fields, cirelationship.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CIRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CIRelationshipMutation) ClearField(name string) error {
	switch name {
	case cirelationship.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CIRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CIRelationshipMutation) ResetField(name string) error {
	switch name {
	case cirelationship.FieldSourceCiID:
		m.ResetSourceCiID()
		return nil
	case cirelationship.FieldTargetCiID:
		m.ResetTargetCiID()
		return nil
	case cirelationship.FieldRelationshipTypeID:
		m.ResetRelationshipTypeID()
		return nil
	case cirelationship.FieldDescription:
		m.ResetDescription()
		return nil
	case cirelationship.FieldTenantID:
		m.ResetTenantID()
		return nil
	case cirelationship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cirelationship.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CIRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CIRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CIRelationshipMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CIRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CIRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CIRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CIRelationshipMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CIRelationshipMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CIRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CIRelationshipMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CIRelationship edge %s", name)
}

// CITypeMutation represents an operation that mutates the CIType nodes in the graph.
type CITypeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	description      *string
	icon             *string
	color            *string
	attribute_schema *string
	tenant_id        *int
	addtenant_id     *int
	is_active        *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*CIType, error)
	predicates       []predicate.CIType
}

var _ ent.Mutation = (*CITypeMutation)(nil)

// citypeOption allows management of the mutation configuration using functional options.
type citypeOption func(*CITypeMutation)

// newCITypeMutation creates new mutation for the CIType entity.
func newCITypeMutation(c config, op Op, opts ...citypeOption) *CITypeMutation {
	m := &CITypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCIType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCITypeID sets the ID field of the mutation.
func withCITypeID(id int) citypeOption {
	return func(m *CITypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CIType
		)
		m.oldValue = func(ctx context.Context) (*CIType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CIType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCIType sets the old CIType of the mutation.
func withCIType(node *CIType) citypeOption {
	return func(m *CITypeMutation) {
		m.oldValue = func(context.Context) (*CIType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CITypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CITypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CITypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CITypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CIType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CITypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CITypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CITypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CITypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CITypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CITypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[citype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CITypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[citype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CITypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, citype.FieldDescription)
}

// SetIcon sets the "icon" field.
func (m *CITypeMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *CITypeMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *CITypeMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[citype.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *CITypeMutation) IconCleared() bool {
	_, ok := m.clearedFields[citype.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *CITypeMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, citype.FieldIcon)
}

// SetColor sets the "color" field.
func (m *CITypeMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *CITypeMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *CITypeMutation) ClearColor() {
	m.color = nil
	m.clearedFields[citype.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *CITypeMutation) ColorCleared() bool {
	_, ok := m.clearedFields[citype.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *CITypeMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, citype.FieldColor)
}

// SetAttributeSchema sets the "attribute_schema" field.
func (m *CITypeMutation) SetAttributeSchema(s string) {
	m.attribute_schema = &s
}

// AttributeSchema returns the value of the "attribute_schema" field in the mutation.
func (m *CITypeMutation) AttributeSchema() (r string, exists bool) {
	v := m.attribute_schema
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributeSchema returns the old "attribute_schema" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldAttributeSchema(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributeSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributeSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributeSchema: %w", err)
	}
	return oldValue.AttributeSchema, nil
}

// ClearAttributeSchema clears the value of the "attribute_schema" field.
func (m *CITypeMutation) ClearAttributeSchema() {
	m.attribute_schema = nil
	m.clearedFields[citype.FieldAttributeSchema] = struct{}{}
}

// AttributeSchemaCleared returns if the "attribute_schema" field was cleared in this mutation.
func (m *CITypeMutation) AttributeSchemaCleared() bool {
	_, ok := m.clearedFields[citype.FieldAttributeSchema]
	return ok
}

// ResetAttributeSchema resets all changes to the "attribute_schema" field.
func (m *CITypeMutation) ResetAttributeSchema() {
	m.attribute_schema = nil
	delete(m.clearedFields, citype.FieldAttributeSchema)
}

// SetTenantID sets the "tenant_id" field.
func (m *CITypeMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CITypeMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *CITypeMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *CITypeMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CITypeMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetIsActive sets the "is_active" field.
func (m *CITypeMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *CITypeMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *CITypeMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CITypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CITypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CITypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CITypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CITypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CITypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the CITypeMutation builder.
func (m *CITypeMutation) Where(ps ...predicate.CIType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CITypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CITypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CIType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CITypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CITypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CIType).
func (m *CITypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CITypeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, citype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, citype.FieldDescription)
	}
	if m.icon != nil {
		fields = append(fields, citype.FieldIcon)
	}
	if m.color != nil {
		fields = append(fields, citype.FieldColor)
	}
	if m.attribute_schema != nil {
		fields = append(fields, citype.FieldAttributeSchema)
	}
	if m.tenant_id != nil {
		fields = append(fields, citype.FieldTenantID)
	}
	if m.is_active != nil {
		fields = append(fields, citype.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, citype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, citype.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CITypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case citype.FieldName:
		return m.Name()
	case citype.FieldDescription:
		return m.Description()
	case citype.FieldIcon:
		return m.Icon()
	case citype.FieldColor:
		return m.Color()
	case citype.FieldAttributeSchema:
		return m.AttributeSchema()
	case citype.FieldTenantID:
		return m.TenantID()
	case citype.FieldIsActive:
		return m.IsActive()
	case citype.FieldCreatedAt:
		return m.CreatedAt()
	case citype.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CITypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case citype.FieldName:
		return m.OldName(ctx)
	case citype.FieldDescription:
		return m.OldDescription(ctx)
	case citype.FieldIcon:
		return m.OldIcon(ctx)
	case citype.FieldColor:
		return m.OldColor(ctx)
	case citype.FieldAttributeSchema:
		return m.OldAttributeSchema(ctx)
	case citype.FieldTenantID:
		return m.OldTenantID(ctx)
	case citype.FieldIsActive:
		return m.OldIsActive(ctx)
	case citype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case citype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CIType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CITypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case citype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case citype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case citype.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case citype.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case citype.FieldAttributeSchema:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributeSchema(v)
		return nil
	case citype.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case citype.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case citype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case citype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CIType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CITypeMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, citype.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CITypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case citype.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CITypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case citype.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown CIType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CITypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(citype.FieldDescription) {
		fields = append(fields, citype.FieldDescription)
	}
	if m.FieldCleared(citype.FieldIcon) {
		fields = append(fields, citype.FieldIcon)
	}
	if m.FieldCleared(citype.FieldColor) {
		fields = append(fields, citype.FieldColor)
	}
	if m.FieldCleared(citype.FieldAttributeSchema) {
		fields = append(fields, citype.FieldAttributeSchema)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CITypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CITypeMutation) ClearField(name string) error {
	switch name {
	case citype.FieldDescription:
		m.ClearDescription()
		return nil
	case citype.FieldIcon:
		m.ClearIcon()
		return nil
	case citype.FieldColor:
		m.ClearColor()
		return nil
	case citype.FieldAttributeSchema:
		m.ClearAttributeSchema()
		return nil
	}
	return fmt.Errorf("unknown CIType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CITypeMutation) ResetField(name string) error {
	switch name {
	case citype.FieldName:
		m.ResetName()
		return nil
	case citype.FieldDescription:
		m.ResetDescription()
		return nil
	case citype.FieldIcon:
		m.ResetIcon()
		return nil
	case citype.FieldColor:
		m.ResetColor()
		return nil
	case citype.FieldAttributeSchema:
		m.ResetAttributeSchema()
		return nil
	case citype.FieldTenantID:
		m.ResetTenantID()
		return nil
	case citype.FieldIsActive:
		m.ResetIsActive()
		return nil
	case citype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case citype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CIType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CITypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CITypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CITypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CITypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CITypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CITypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CITypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CIType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CITypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CIType edge %s", name)
}

// ConfigurationItemMutation represents an operation that mutates the ConfigurationItem nodes in the graph.
type ConfigurationItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	_type         *string
	status        *string
	location      *string
	serial_number *string
	model         *string
	vendor        *string
	ci_type_id    *int
	addci_type_id *int
	tenant_id     *int
	addtenant_id  *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ConfigurationItem, error)
	predicates    []predicate.ConfigurationItem
}

var _ ent.Mutation = (*ConfigurationItemMutation)(nil)

// configurationitemOption allows management of the mutation configuration using functional options.
type configurationitemOption func(*ConfigurationItemMutation)

// newConfigurationItemMutation creates new mutation for the ConfigurationItem entity.
func newConfigurationItemMutation(c config, op Op, opts ...configurationitemOption) *ConfigurationItemMutation {
	m := &ConfigurationItemMutation{
		config:        c,
		op:            op,
		typ:           TypeConfigurationItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigurationItemID sets the ID field of the mutation.
func withConfigurationItemID(id int) configurationitemOption {
	return func(m *ConfigurationItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ConfigurationItem
		)
		m.oldValue = func(ctx context.Context) (*ConfigurationItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConfigurationItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfigurationItem sets the old ConfigurationItem of the mutation.
func withConfigurationItem(node *ConfigurationItem) configurationitemOption {
	return func(m *ConfigurationItemMutation) {
		m.oldValue = func(context.Context) (*ConfigurationItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigurationItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigurationItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConfigurationItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConfigurationItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConfigurationItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ConfigurationItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConfigurationItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConfigurationItemMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ConfigurationItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ConfigurationItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ConfigurationItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[configurationitem.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ConfigurationItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ConfigurationItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, configurationitem.FieldDescription)
}

// SetType sets the "type" field.
func (m *ConfigurationItemMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ConfigurationItemMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ConfigurationItemMutation) ClearType() {
	m._type = nil
	m.clearedFields[configurationitem.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ConfigurationItemMutation) TypeCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ConfigurationItemMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, configurationitem.FieldType)
}

// SetStatus sets the "status" field.
func (m *ConfigurationItemMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ConfigurationItemMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ConfigurationItemMutation) ResetStatus() {
	m.status = nil
}

// SetLocation sets the "location" field.
func (m *ConfigurationItemMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *ConfigurationItemMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *ConfigurationItemMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[configurationitem.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *ConfigurationItemMutation) LocationCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *ConfigurationItemMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, configurationitem.FieldLocation)
}

// SetSerialNumber sets the "serial_number" field.
func (m *ConfigurationItemMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *ConfigurationItemMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ClearSerialNumber clears the value of the "serial_number" field.
func (m *ConfigurationItemMutation) ClearSerialNumber() {
	m.serial_number = nil
	m.clearedFields[configurationitem.FieldSerialNumber] = struct{}{}
}

// SerialNumberCleared returns if the "serial_number" field was cleared in this mutation.
func (m *ConfigurationItemMutation) SerialNumberCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldSerialNumber]
	return ok
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *ConfigurationItemMutation) ResetSerialNumber() {
	m.serial_number = nil
	delete(m.clearedFields, configurationitem.FieldSerialNumber)
}

// SetModel sets the "model" field.
func (m *ConfigurationItemMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ConfigurationItemMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *ConfigurationItemMutation) ClearModel() {
	m.model = nil
	m.clearedFields[configurationitem.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *ConfigurationItemMutation) ModelCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *ConfigurationItemMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, configurationitem.FieldModel)
}

// SetVendor sets the "vendor" field.
func (m *ConfigurationItemMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ConfigurationItemMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ClearVendor clears the value of the "vendor" field.
func (m *ConfigurationItemMutation) ClearVendor() {
	m.vendor = nil
	m.clearedFields[configurationitem.FieldVendor] = struct{}{}
}

// VendorCleared returns if the "vendor" field was cleared in this mutation.
func (m *ConfigurationItemMutation) VendorCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldVendor]
	return ok
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ConfigurationItemMutation) ResetVendor() {
	m.vendor = nil
	delete(m.clearedFields, configurationitem.FieldVendor)
}

// SetCiTypeID sets the "ci_type_id" field.
func (m *ConfigurationItemMutation) SetCiTypeID(i int) {
	m.ci_type_id = &i
	m.addci_type_id = nil
}

// CiTypeID returns the value of the "ci_type_id" field in the mutation.
func (m *ConfigurationItemMutation) CiTypeID() (r int, exists bool) {
	v := m.ci_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCiTypeID returns the old "ci_type_id" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldCiTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCiTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCiTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCiTypeID: %w", err)
	}
	return oldValue.CiTypeID, nil
}

// AddCiTypeID adds i to the "ci_type_id" field.
func (m *ConfigurationItemMutation) AddCiTypeID(i int) {
	if m.addci_type_id != nil {
		*m.addci_type_id += i
	} else {
		m.addci_type_id = &i
	}
}

// AddedCiTypeID returns the value that was added to the "ci_type_id" field in this mutation.
func (m *ConfigurationItemMutation) AddedCiTypeID() (r int, exists bool) {
	v := m.addci_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCiTypeID resets all changes to the "ci_type_id" field.
func (m *ConfigurationItemMutation) ResetCiTypeID() {
	m.ci_type_id = nil
	m.addci_type_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ConfigurationItemMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ConfigurationItemMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ConfigurationItemMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ConfigurationItemMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ConfigurationItemMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConfigurationItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConfigurationItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConfigurationItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConfigurationItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConfigurationItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConfigurationItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ConfigurationItemMutation builder.
func (m *ConfigurationItemMutation) Where(ps ...predicate.ConfigurationItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConfigurationItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConfigurationItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConfigurationItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConfigurationItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConfigurationItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConfigurationItem).
func (m *ConfigurationItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigurationItemMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, configurationitem.FieldName)
	}
	if m.description != nil {
		fields = append(fields, configurationitem.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, configurationitem.FieldType)
	}
	if m.status != nil {
		fields = append(fields, configurationitem.FieldStatus)
	}
	if m.location != nil {
		fields = append(fields, configurationitem.FieldLocation)
	}
	if m.serial_number != nil {
		fields = append(fields, configurationitem.FieldSerialNumber)
	}
	if m.model != nil {
		fields = append(fields, configurationitem.FieldModel)
	}
	if m.vendor != nil {
		fields = append(fields, configurationitem.FieldVendor)
	}
	if m.ci_type_id != nil {
		fields = append(fields, configurationitem.FieldCiTypeID)
	}
	if m.tenant_id != nil {
		fields = append(fields, configurationitem.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, configurationitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, configurationitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigurationItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configurationitem.FieldName:
		return m.Name()
	case configurationitem.FieldDescription:
		return m.Description()
	case configurationitem.FieldType:
		return m.GetType()
	case configurationitem.FieldStatus:
		return m.Status()
	case configurationitem.FieldLocation:
		return m.Location()
	case configurationitem.FieldSerialNumber:
		return m.SerialNumber()
	case configurationitem.FieldModel:
		return m.Model()
	case configurationitem.FieldVendor:
		return m.Vendor()
	case configurationitem.FieldCiTypeID:
		return m.CiTypeID()
	case configurationitem.FieldTenantID:
		return m.TenantID()
	case configurationitem.FieldCreatedAt:
		return m.CreatedAt()
	case configurationitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigurationItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configurationitem.FieldName:
		return m.OldName(ctx)
	case configurationitem.FieldDescription:
		return m.OldDescription(ctx)
	case configurationitem.FieldType:
		return m.OldType(ctx)
	case configurationitem.FieldStatus:
		return m.OldStatus(ctx)
	case configurationitem.FieldLocation:
		return m.OldLocation(ctx)
	case configurationitem.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case configurationitem.FieldModel:
		return m.OldModel(ctx)
	case configurationitem.FieldVendor:
		return m.OldVendor(ctx)
	case configurationitem.FieldCiTypeID:
		return m.OldCiTypeID(ctx)
	case configurationitem.FieldTenantID:
		return m.OldTenantID(ctx)
	case configurationitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case configurationitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ConfigurationItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configurationitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case configurationitem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case configurationitem.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case configurationitem.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case configurationitem.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case configurationitem.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case configurationitem.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case configurationitem.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case configurationitem.FieldCiTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCiTypeID(v)
		return nil
	case configurationitem.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case configurationitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case configurationitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigurationItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigurationItemMutation) AddedFields() []string {
	var fields []string
	if m.addci_type_id != nil {
		fields = append(fields, configurationitem.FieldCiTypeID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, configurationitem.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigurationItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case configurationitem.FieldCiTypeID:
		return m.AddedCiTypeID()
	case configurationitem.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case configurationitem.FieldCiTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCiTypeID(v)
		return nil
	case configurationitem.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigurationItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigurationItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configurationitem.FieldDescription) {
		fields = append(fields, configurationitem.FieldDescription)
	}
	if m.FieldCleared(configurationitem.FieldType) {
		fields = append(fields, configurationitem.FieldType)
	}
	if m.FieldCleared(configurationitem.FieldLocation) {
		fields = append(fields, configurationitem.FieldLocation)
	}
	if m.FieldCleared(configurationitem.FieldSerialNumber) {
		fields = append(fields, configurationitem.FieldSerialNumber)
	}
	if m.FieldCleared(configurationitem.FieldModel) {
		fields = append(fields, configurationitem.FieldModel)
	}
	if m.FieldCleared(configurationitem.FieldVendor) {
		fields = append(fields, configurationitem.FieldVendor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigurationItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigurationItemMutation) ClearField(name string) error {
	switch name {
	case configurationitem.FieldDescription:
		m.ClearDescription()
		return nil
	case configurationitem.FieldType:
		m.ClearType()
		return nil
	case configurationitem.FieldLocation:
		m.ClearLocation()
		return nil
	case configurationitem.FieldSerialNumber:
		m.ClearSerialNumber()
		return nil
	case configurationitem.FieldModel:
		m.ClearModel()
		return nil
	case configurationitem.FieldVendor:
		m.ClearVendor()
		return nil
	}
	return fmt.Errorf("unknown ConfigurationItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigurationItemMutation) ResetField(name string) error {
	switch name {
	case configurationitem.FieldName:
		m.ResetName()
		return nil
	case configurationitem.FieldDescription:
		m.ResetDescription()
		return nil
	case configurationitem.FieldType:
		m.ResetType()
		return nil
	case configurationitem.FieldStatus:
		m.ResetStatus()
		return nil
	case configurationitem.FieldLocation:
		m.ResetLocation()
		return nil
	case configurationitem.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case configurationitem.FieldModel:
		m.ResetModel()
		return nil
	case configurationitem.FieldVendor:
		m.ResetVendor()
		return nil
	case configurationitem.FieldCiTypeID:
		m.ResetCiTypeID()
		return nil
	case configurationitem.FieldTenantID:
		m.ResetTenantID()
		return nil
	case configurationitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case configurationitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ConfigurationItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigurationItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigurationItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigurationItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigurationItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigurationItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigurationItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigurationItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ConfigurationItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigurationItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ConfigurationItem edge %s", name)
}

// ConversationMutation represents an operation that mutates the Conversation nodes in the graph.
type ConversationMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	tenant_id               *int
	addtenant_id            *int
	user_id                 *int
	adduser_id              *int
	title                   *string
	clearedFields           map[string]struct{}
	messages                map[int]struct{}
	removedmessages         map[int]struct{}
	clearedmessages         bool
	tool_invocations        map[int]struct{}
	removedtool_invocations map[int]struct{}
	clearedtool_invocations bool
	done                    bool
	oldValue                func(context.Context) (*Conversation, error)
	predicates              []predicate.Conversation
}

var _ ent.Mutation = (*ConversationMutation)(nil)

// conversationOption allows management of the mutation configuration using functional options.
type conversationOption func(*ConversationMutation)

// newConversationMutation creates new mutation for the Conversation entity.
func newConversationMutation(c config, op Op, opts ...conversationOption) *ConversationMutation {
	m := &ConversationMutation{
		config:        c,
		op:            op,
		typ:           TypeConversation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConversationID sets the ID field of the mutation.
func withConversationID(id int) conversationOption {
	return func(m *ConversationMutation) {
		var (
			err   error
			once  sync.Once
			value *Conversation
		)
		m.oldValue = func(ctx context.Context) (*Conversation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Conversation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConversation sets the old Conversation of the mutation.
func withConversation(node *Conversation) conversationOption {
	return func(m *ConversationMutation) {
		m.oldValue = func(context.Context) (*Conversation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConversationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConversationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConversationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConversationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Conversation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ConversationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConversationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConversationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ConversationMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ConversationMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ConversationMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ConversationMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *ConversationMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[conversation.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *ConversationMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[conversation.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ConversationMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, conversation.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *ConversationMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ConversationMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *ConversationMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ConversationMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *ConversationMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[conversation.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ConversationMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[conversation.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ConversationMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, conversation.FieldUserID)
}

// SetTitle sets the "title" field.
func (m *ConversationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ConversationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ConversationMutation) ResetTitle() {
	m.title = nil
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *ConversationMutation) AddMessageIDs(ids ...int) {
	if m.messages == nil {
		m.messages = make(map[int]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *ConversationMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *ConversationMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *ConversationMutation) RemoveMessageIDs(ids ...int) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *ConversationMutation) RemovedMessagesIDs() (ids []int) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *ConversationMutation) MessagesIDs() (ids []int) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *ConversationMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddToolInvocationIDs adds the "tool_invocations" edge to the ToolInvocation entity by ids.
func (m *ConversationMutation) AddToolInvocationIDs(ids ...int) {
	if m.tool_invocations == nil {
		m.tool_invocations = make(map[int]struct{})
	}
	for i := range ids {
		m.tool_invocations[ids[i]] = struct{}{}
	}
}

// ClearToolInvocations clears the "tool_invocations" edge to the ToolInvocation entity.
func (m *ConversationMutation) ClearToolInvocations() {
	m.clearedtool_invocations = true
}

// ToolInvocationsCleared reports if the "tool_invocations" edge to the ToolInvocation entity was cleared.
func (m *ConversationMutation) ToolInvocationsCleared() bool {
	return m.clearedtool_invocations
}

// RemoveToolInvocationIDs removes the "tool_invocations" edge to the ToolInvocation entity by IDs.
func (m *ConversationMutation) RemoveToolInvocationIDs(ids ...int) {
	if m.removedtool_invocations == nil {
		m.removedtool_invocations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tool_invocations, ids[i])
		m.removedtool_invocations[ids[i]] = struct{}{}
	}
}

// RemovedToolInvocations returns the removed IDs of the "tool_invocations" edge to the ToolInvocation entity.
func (m *ConversationMutation) RemovedToolInvocationsIDs() (ids []int) {
	for id := range m.removedtool_invocations {
		ids = append(ids, id)
	}
	return
}

// ToolInvocationsIDs returns the "tool_invocations" edge IDs in the mutation.
func (m *ConversationMutation) ToolInvocationsIDs() (ids []int) {
	for id := range m.tool_invocations {
		ids = append(ids, id)
	}
	return
}

// ResetToolInvocations resets all changes to the "tool_invocations" edge.
func (m *ConversationMutation) ResetToolInvocations() {
	m.tool_invocations = nil
	m.clearedtool_invocations = false
	m.removedtool_invocations = nil
}

// Where appends a list predicates to the ConversationMutation builder.
func (m *ConversationMutation) Where(ps ...predicate.Conversation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConversationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConversationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Conversation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConversationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConversationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Conversation).
func (m *ConversationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConversationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, conversation.FieldCreatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, conversation.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, conversation.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, conversation.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConversationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case conversation.FieldCreatedAt:
		return m.CreatedAt()
	case conversation.FieldTenantID:
		return m.TenantID()
	case conversation.FieldUserID:
		return m.UserID()
	case conversation.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConversationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case conversation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case conversation.FieldTenantID:
		return m.OldTenantID(ctx)
	case conversation.FieldUserID:
		return m.OldUserID(ctx)
	case conversation.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown Conversation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case conversation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case conversation.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case conversation.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case conversation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConversationMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, conversation.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, conversation.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConversationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case conversation.FieldTenantID:
		return m.AddedTenantID()
	case conversation.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case conversation.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case conversation.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Conversation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConversationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(conversation.FieldTenantID) {
		fields = append(fields, conversation.FieldTenantID)
	}
	if m.FieldCleared(conversation.FieldUserID) {
		fields = append(fields, conversation.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConversationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConversationMutation) ClearField(name string) error {
	switch name {
	case conversation.FieldTenantID:
		m.ClearTenantID()
		return nil
	case conversation.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Conversation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConversationMutation) ResetField(name string) error {
	switch name {
	case conversation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case conversation.FieldTenantID:
		m.ResetTenantID()
		return nil
	case conversation.FieldUserID:
		m.ResetUserID()
		return nil
	case conversation.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConversationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.messages != nil {
		edges = append(edges, conversation.EdgeMessages)
	}
	if m.tool_invocations != nil {
		edges = append(edges, conversation.EdgeToolInvocations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConversationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case conversation.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case conversation.EdgeToolInvocations:
		ids := make([]ent.Value, 0, len(m.tool_invocations))
		for id := range m.tool_invocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConversationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmessages != nil {
		edges = append(edges, conversation.EdgeMessages)
	}
	if m.removedtool_invocations != nil {
		edges = append(edges, conversation.EdgeToolInvocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConversationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case conversation.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case conversation.EdgeToolInvocations:
		ids := make([]ent.Value, 0, len(m.removedtool_invocations))
		for id := range m.removedtool_invocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConversationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmessages {
		edges = append(edges, conversation.EdgeMessages)
	}
	if m.clearedtool_invocations {
		edges = append(edges, conversation.EdgeToolInvocations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConversationMutation) EdgeCleared(name string) bool {
	switch name {
	case conversation.EdgeMessages:
		return m.clearedmessages
	case conversation.EdgeToolInvocations:
		return m.clearedtool_invocations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConversationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Conversation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConversationMutation) ResetEdge(name string) error {
	switch name {
	case conversation.EdgeMessages:
		m.ResetMessages()
		return nil
	case conversation.EdgeToolInvocations:
		m.ResetToolInvocations()
		return nil
	}
	return fmt.Errorf("unknown Conversation edge %s", name)
}

// IncidentMutation represents an operation that mutates the Incident nodes in the graph.
type IncidentMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	title                    *string
	description              *string
	status                   *string
	priority                 *string
	incident_number          *string
	reporter_id              *int
	addreporter_id           *int
	assignee_id              *int
	addassignee_id           *int
	configuration_item_id    *int
	addconfiguration_item_id *int
	resolved_at              *time.Time
	closed_at                *time.Time
	tenant_id                *int
	addtenant_id             *int
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Incident, error)
	predicates               []predicate.Incident
}

var _ ent.Mutation = (*IncidentMutation)(nil)

// incidentOption allows management of the mutation configuration using functional options.
type incidentOption func(*IncidentMutation)

// newIncidentMutation creates new mutation for the Incident entity.
func newIncidentMutation(c config, op Op, opts ...incidentOption) *IncidentMutation {
	m := &IncidentMutation{
		config:        c,
		op:            op,
		typ:           TypeIncident,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentID sets the ID field of the mutation.
func withIncidentID(id int) incidentOption {
	return func(m *IncidentMutation) {
		var (
			err   error
			once  sync.Once
			value *Incident
		)
		m.oldValue = func(ctx context.Context) (*Incident, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Incident.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncident sets the old Incident of the mutation.
func withIncident(node *Incident) incidentOption {
	return func(m *IncidentMutation) {
		m.oldValue = func(context.Context) (*Incident, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Incident.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *IncidentMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IncidentMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IncidentMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *IncidentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incident.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incident.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incident.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *IncidentMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *IncidentMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *IncidentMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *IncidentMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *IncidentMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *IncidentMutation) ResetPriority() {
	m.priority = nil
}

// SetIncidentNumber sets the "incident_number" field.
func (m *IncidentMutation) SetIncidentNumber(s string) {
	m.incident_number = &s
}

// IncidentNumber returns the value of the "incident_number" field in the mutation.
func (m *IncidentMutation) IncidentNumber() (r string, exists bool) {
	v := m.incident_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentNumber returns the old "incident_number" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldIncidentNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentNumber: %w", err)
	}
	return oldValue.IncidentNumber, nil
}

// ResetIncidentNumber resets all changes to the "incident_number" field.
func (m *IncidentMutation) ResetIncidentNumber() {
	m.incident_number = nil
}

// SetReporterID sets the "reporter_id" field.
func (m *IncidentMutation) SetReporterID(i int) {
	m.reporter_id = &i
	m.addreporter_id = nil
}

// ReporterID returns the value of the "reporter_id" field in the mutation.
func (m *IncidentMutation) ReporterID() (r int, exists bool) {
	v := m.reporter_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReporterID returns the old "reporter_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldReporterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReporterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReporterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReporterID: %w", err)
	}
	return oldValue.ReporterID, nil
}

// AddReporterID adds i to the "reporter_id" field.
func (m *IncidentMutation) AddReporterID(i int) {
	if m.addreporter_id != nil {
		*m.addreporter_id += i
	} else {
		m.addreporter_id = &i
	}
}

// AddedReporterID returns the value that was added to the "reporter_id" field in this mutation.
func (m *IncidentMutation) AddedReporterID() (r int, exists bool) {
	v := m.addreporter_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetReporterID resets all changes to the "reporter_id" field.
func (m *IncidentMutation) ResetReporterID() {
	m.reporter_id = nil
	m.addreporter_id = nil
}

// SetAssigneeID sets the "assignee_id" field.
func (m *IncidentMutation) SetAssigneeID(i int) {
	m.assignee_id = &i
	m.addassignee_id = nil
}

// AssigneeID returns the value of the "assignee_id" field in the mutation.
func (m *IncidentMutation) AssigneeID() (r int, exists bool) {
	v := m.assignee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeID returns the old "assignee_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldAssigneeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeID: %w", err)
	}
	return oldValue.AssigneeID, nil
}

// AddAssigneeID adds i to the "assignee_id" field.
func (m *IncidentMutation) AddAssigneeID(i int) {
	if m.addassignee_id != nil {
		*m.addassignee_id += i
	} else {
		m.addassignee_id = &i
	}
}

// AddedAssigneeID returns the value that was added to the "assignee_id" field in this mutation.
func (m *IncidentMutation) AddedAssigneeID() (r int, exists bool) {
	v := m.addassignee_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssigneeID clears the value of the "assignee_id" field.
func (m *IncidentMutation) ClearAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	m.clearedFields[incident.FieldAssigneeID] = struct{}{}
}

// AssigneeIDCleared returns if the "assignee_id" field was cleared in this mutation.
func (m *IncidentMutation) AssigneeIDCleared() bool {
	_, ok := m.clearedFields[incident.FieldAssigneeID]
	return ok
}

// ResetAssigneeID resets all changes to the "assignee_id" field.
func (m *IncidentMutation) ResetAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	delete(m.clearedFields, incident.FieldAssigneeID)
}

// SetConfigurationItemID sets the "configuration_item_id" field.
func (m *IncidentMutation) SetConfigurationItemID(i int) {
	m.configuration_item_id = &i
	m.addconfiguration_item_id = nil
}

// ConfigurationItemID returns the value of the "configuration_item_id" field in the mutation.
func (m *IncidentMutation) ConfigurationItemID() (r int, exists bool) {
	v := m.configuration_item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigurationItemID returns the old "configuration_item_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldConfigurationItemID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigurationItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigurationItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigurationItemID: %w", err)
	}
	return oldValue.ConfigurationItemID, nil
}

// AddConfigurationItemID adds i to the "configuration_item_id" field.
func (m *IncidentMutation) AddConfigurationItemID(i int) {
	if m.addconfiguration_item_id != nil {
		*m.addconfiguration_item_id += i
	} else {
		m.addconfiguration_item_id = &i
	}
}

// AddedConfigurationItemID returns the value that was added to the "configuration_item_id" field in this mutation.
func (m *IncidentMutation) AddedConfigurationItemID() (r int, exists bool) {
	v := m.addconfiguration_item_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearConfigurationItemID clears the value of the "configuration_item_id" field.
func (m *IncidentMutation) ClearConfigurationItemID() {
	m.configuration_item_id = nil
	m.addconfiguration_item_id = nil
	m.clearedFields[incident.FieldConfigurationItemID] = struct{}{}
}

// ConfigurationItemIDCleared returns if the "configuration_item_id" field was cleared in this mutation.
func (m *IncidentMutation) ConfigurationItemIDCleared() bool {
	_, ok := m.clearedFields[incident.FieldConfigurationItemID]
	return ok
}

// ResetConfigurationItemID resets all changes to the "configuration_item_id" field.
func (m *IncidentMutation) ResetConfigurationItemID() {
	m.configuration_item_id = nil
	m.addconfiguration_item_id = nil
	delete(m.clearedFields, incident.FieldConfigurationItemID)
}

// SetResolvedAt sets the "resolved_at" field.
func (m *IncidentMutation) SetResolvedAt(t time.Time) {
	m.resolved_at = &t
}

// ResolvedAt returns the value of the "resolved_at" field in the mutation.
func (m *IncidentMutation) ResolvedAt() (r time.Time, exists bool) {
	v := m.resolved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedAt returns the old "resolved_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldResolvedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedAt: %w", err)
	}
	return oldValue.ResolvedAt, nil
}

// ClearResolvedAt clears the value of the "resolved_at" field.
func (m *IncidentMutation) ClearResolvedAt() {
	m.resolved_at = nil
	m.clearedFields[incident.FieldResolvedAt] = struct{}{}
}

// ResolvedAtCleared returns if the "resolved_at" field was cleared in this mutation.
func (m *IncidentMutation) ResolvedAtCleared() bool {
	_, ok := m.clearedFields[incident.FieldResolvedAt]
	return ok
}

// ResetResolvedAt resets all changes to the "resolved_at" field.
func (m *IncidentMutation) ResetResolvedAt() {
	m.resolved_at = nil
	delete(m.clearedFields, incident.FieldResolvedAt)
}

// SetClosedAt sets the "closed_at" field.
func (m *IncidentMutation) SetClosedAt(t time.Time) {
	m.closed_at = &t
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *IncidentMutation) ClosedAt() (r time.Time, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldClosedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ClearClosedAt clears the value of the "closed_at" field.
func (m *IncidentMutation) ClearClosedAt() {
	m.closed_at = nil
	m.clearedFields[incident.FieldClosedAt] = struct{}{}
}

// ClosedAtCleared returns if the "closed_at" field was cleared in this mutation.
func (m *IncidentMutation) ClosedAtCleared() bool {
	_, ok := m.clearedFields[incident.FieldClosedAt]
	return ok
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *IncidentMutation) ResetClosedAt() {
	m.closed_at = nil
	delete(m.clearedFields, incident.FieldClosedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *IncidentMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *IncidentMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IncidentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IncidentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IncidentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the IncidentMutation builder.
func (m *IncidentMutation) Where(ps ...predicate.Incident) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Incident, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Incident).
func (m *IncidentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.title != nil {
		fields = append(fields, incident.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, incident.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, incident.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, incident.FieldPriority)
	}
	if m.incident_number != nil {
		fields = append(fields, incident.FieldIncidentNumber)
	}
	if m.reporter_id != nil {
		fields = append(fields, incident.FieldReporterID)
	}
	if m.assignee_id != nil {
		fields = append(fields, incident.FieldAssigneeID)
	}
	if m.configuration_item_id != nil {
		fields = append(fields, incident.FieldConfigurationItemID)
	}
	if m.resolved_at != nil {
		fields = append(fields, incident.FieldResolvedAt)
	}
	if m.closed_at != nil {
		fields = append(fields, incident.FieldClosedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, incident.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, incident.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, incident.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incident.FieldTitle:
		return m.Title()
	case incident.FieldDescription:
		return m.Description()
	case incident.FieldStatus:
		return m.Status()
	case incident.FieldPriority:
		return m.Priority()
	case incident.FieldIncidentNumber:
		return m.IncidentNumber()
	case incident.FieldReporterID:
		return m.ReporterID()
	case incident.FieldAssigneeID:
		return m.AssigneeID()
	case incident.FieldConfigurationItemID:
		return m.ConfigurationItemID()
	case incident.FieldResolvedAt:
		return m.ResolvedAt()
	case incident.FieldClosedAt:
		return m.ClosedAt()
	case incident.FieldTenantID:
		return m.TenantID()
	case incident.FieldCreatedAt:
		return m.CreatedAt()
	case incident.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incident.FieldTitle:
		return m.OldTitle(ctx)
	case incident.FieldDescription:
		return m.OldDescription(ctx)
	case incident.FieldStatus:
		return m.OldStatus(ctx)
	case incident.FieldPriority:
		return m.OldPriority(ctx)
	case incident.FieldIncidentNumber:
		return m.OldIncidentNumber(ctx)
	case incident.FieldReporterID:
		return m.OldReporterID(ctx)
	case incident.FieldAssigneeID:
		return m.OldAssigneeID(ctx)
	case incident.FieldConfigurationItemID:
		return m.OldConfigurationItemID(ctx)
	case incident.FieldResolvedAt:
		return m.OldResolvedAt(ctx)
	case incident.FieldClosedAt:
		return m.OldClosedAt(ctx)
	case incident.FieldTenantID:
		return m.OldTenantID(ctx)
	case incident.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incident.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Incident field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incident.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case incident.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incident.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case incident.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case incident.FieldIncidentNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentNumber(v)
		return nil
	case incident.FieldReporterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReporterID(v)
		return nil
	case incident.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeID(v)
		return nil
	case incident.FieldConfigurationItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigurationItemID(v)
		return nil
	case incident.FieldResolvedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedAt(v)
		return nil
	case incident.FieldClosedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	case incident.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incident.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incident.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Incident field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentMutation) AddedFields() []string {
	var fields []string
	if m.addreporter_id != nil {
		fields = append(fields, incident.FieldReporterID)
	}
	if m.addassignee_id != nil {
		fields = append(fields, incident.FieldAssigneeID)
	}
	if m.addconfiguration_item_id != nil {
		fields = append(fields, incident.FieldConfigurationItemID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, incident.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case incident.FieldReporterID:
		return m.AddedReporterID()
	case incident.FieldAssigneeID:
		return m.AddedAssigneeID()
	case incident.FieldConfigurationItemID:
		return m.AddedConfigurationItemID()
	case incident.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case incident.FieldReporterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReporterID(v)
		return nil
	case incident.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssigneeID(v)
		return nil
	case incident.FieldConfigurationItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfigurationItemID(v)
		return nil
	case incident.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Incident numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incident.FieldDescription) {
		fields = append(fields, incident.FieldDescription)
	}
	if m.FieldCleared(incident.FieldAssigneeID) {
		fields = append(fields, incident.FieldAssigneeID)
	}
	if m.FieldCleared(incident.FieldConfigurationItemID) {
		fields = append(fields, incident.FieldConfigurationItemID)
	}
	if m.FieldCleared(incident.FieldResolvedAt) {
		fields = append(fields, incident.FieldResolvedAt)
	}
	if m.FieldCleared(incident.FieldClosedAt) {
		fields = append(fields, incident.FieldClosedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentMutation) ClearField(name string) error {
	switch name {
	case incident.FieldDescription:
		m.ClearDescription()
		return nil
	case incident.FieldAssigneeID:
		m.ClearAssigneeID()
		return nil
	case incident.FieldConfigurationItemID:
		m.ClearConfigurationItemID()
		return nil
	case incident.FieldResolvedAt:
		m.ClearResolvedAt()
		return nil
	case incident.FieldClosedAt:
		m.ClearClosedAt()
		return nil
	}
	return fmt.Errorf("unknown Incident nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentMutation) ResetField(name string) error {
	switch name {
	case incident.FieldTitle:
		m.ResetTitle()
		return nil
	case incident.FieldDescription:
		m.ResetDescription()
		return nil
	case incident.FieldStatus:
		m.ResetStatus()
		return nil
	case incident.FieldPriority:
		m.ResetPriority()
		return nil
	case incident.FieldIncidentNumber:
		m.ResetIncidentNumber()
		return nil
	case incident.FieldReporterID:
		m.ResetReporterID()
		return nil
	case incident.FieldAssigneeID:
		m.ResetAssigneeID()
		return nil
	case incident.FieldConfigurationItemID:
		m.ResetConfigurationItemID()
		return nil
	case incident.FieldResolvedAt:
		m.ResetResolvedAt()
		return nil
	case incident.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	case incident.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incident.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incident.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Incident field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Incident unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Incident edge %s", name)
}

// KnowledgeArticleMutation represents an operation that mutates the KnowledgeArticle nodes in the graph.
type KnowledgeArticleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	content       *string
	category      *string
	tags          *string
	author_id     *int
	addauthor_id  *int
	tenant_id     *int
	addtenant_id  *int
	is_published  *bool
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*KnowledgeArticle, error)
	predicates    []predicate.KnowledgeArticle
}

var _ ent.Mutation = (*KnowledgeArticleMutation)(nil)

// knowledgearticleOption allows management of the mutation configuration using functional options.
type knowledgearticleOption func(*KnowledgeArticleMutation)

// newKnowledgeArticleMutation creates new mutation for the KnowledgeArticle entity.
func newKnowledgeArticleMutation(c config, op Op, opts ...knowledgearticleOption) *KnowledgeArticleMutation {
	m := &KnowledgeArticleMutation{
		config:        c,
		op:            op,
		typ:           TypeKnowledgeArticle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKnowledgeArticleID sets the ID field of the mutation.
func withKnowledgeArticleID(id int) knowledgearticleOption {
	return func(m *KnowledgeArticleMutation) {
		var (
			err   error
			once  sync.Once
			value *KnowledgeArticle
		)
		m.oldValue = func(ctx context.Context) (*KnowledgeArticle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KnowledgeArticle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKnowledgeArticle sets the old KnowledgeArticle of the mutation.
func withKnowledgeArticle(node *KnowledgeArticle) knowledgearticleOption {
	return func(m *KnowledgeArticleMutation) {
		m.oldValue = func(context.Context) (*KnowledgeArticle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KnowledgeArticleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KnowledgeArticleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KnowledgeArticleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KnowledgeArticleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KnowledgeArticle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *KnowledgeArticleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *KnowledgeArticleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *KnowledgeArticleMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *KnowledgeArticleMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *KnowledgeArticleMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *KnowledgeArticleMutation) ClearContent() {
	m.content = nil
	m.clearedFields[knowledgearticle.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *KnowledgeArticleMutation) ContentCleared() bool {
	_, ok := m.clearedFields[knowledgearticle.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *KnowledgeArticleMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, knowledgearticle.FieldContent)
}

// SetCategory sets the "category" field.
func (m *KnowledgeArticleMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *KnowledgeArticleMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *KnowledgeArticleMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[knowledgearticle.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *KnowledgeArticleMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[knowledgearticle.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *KnowledgeArticleMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, knowledgearticle.FieldCategory)
}

// SetTags sets the "tags" field.
func (m *KnowledgeArticleMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *KnowledgeArticleMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *KnowledgeArticleMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[knowledgearticle.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *KnowledgeArticleMutation) TagsCleared() bool {
	_, ok := m.clearedFields[knowledgearticle.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *KnowledgeArticleMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, knowledgearticle.FieldTags)
}

// SetAuthorID sets the "author_id" field.
func (m *KnowledgeArticleMutation) SetAuthorID(i int) {
	m.author_id = &i
	m.addauthor_id = nil
}

// AuthorID returns the value of the "author_id" field in the mutation.
func (m *KnowledgeArticleMutation) AuthorID() (r int, exists bool) {
	v := m.author_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorID returns the old "author_id" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldAuthorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorID: %w", err)
	}
	return oldValue.AuthorID, nil
}

// AddAuthorID adds i to the "author_id" field.
func (m *KnowledgeArticleMutation) AddAuthorID(i int) {
	if m.addauthor_id != nil {
		*m.addauthor_id += i
	} else {
		m.addauthor_id = &i
	}
}

// AddedAuthorID returns the value that was added to the "author_id" field in this mutation.
func (m *KnowledgeArticleMutation) AddedAuthorID() (r int, exists bool) {
	v := m.addauthor_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthorID resets all changes to the "author_id" field.
func (m *KnowledgeArticleMutation) ResetAuthorID() {
	m.author_id = nil
	m.addauthor_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *KnowledgeArticleMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *KnowledgeArticleMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *KnowledgeArticleMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *KnowledgeArticleMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *KnowledgeArticleMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetIsPublished sets the "is_published" field.
func (m *KnowledgeArticleMutation) SetIsPublished(b bool) {
	m.is_published = &b
}

// IsPublished returns the value of the "is_published" field in the mutation.
func (m *KnowledgeArticleMutation) IsPublished() (r bool, exists bool) {
	v := m.is_published
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublished returns the old "is_published" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldIsPublished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublished: %w", err)
	}
	return oldValue.IsPublished, nil
}

// ResetIsPublished resets all changes to the "is_published" field.
func (m *KnowledgeArticleMutation) ResetIsPublished() {
	m.is_published = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *KnowledgeArticleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KnowledgeArticleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KnowledgeArticleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KnowledgeArticleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KnowledgeArticleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KnowledgeArticleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the KnowledgeArticleMutation builder.
func (m *KnowledgeArticleMutation) Where(ps ...predicate.KnowledgeArticle) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KnowledgeArticleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KnowledgeArticleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.KnowledgeArticle, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KnowledgeArticleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KnowledgeArticleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (KnowledgeArticle).
func (m *KnowledgeArticleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KnowledgeArticleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.title != nil {
		fields = append(fields, knowledgearticle.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, knowledgearticle.FieldContent)
	}
	if m.category != nil {
		fields = append(fields, knowledgearticle.FieldCategory)
	}
	if m.tags != nil {
		fields = append(fields, knowledgearticle.FieldTags)
	}
	if m.author_id != nil {
		fields = append(fields, knowledgearticle.FieldAuthorID)
	}
	if m.tenant_id != nil {
		fields = append(fields, knowledgearticle.FieldTenantID)
	}
	if m.is_published != nil {
		fields = append(fields, knowledgearticle.FieldIsPublished)
	}
	if m.created_at != nil {
		fields = append(fields, knowledgearticle.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, knowledgearticle.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KnowledgeArticleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case knowledgearticle.FieldTitle:
		return m.Title()
	case knowledgearticle.FieldContent:
		return m.Content()
	case knowledgearticle.FieldCategory:
		return m.Category()
	case knowledgearticle.FieldTags:
		return m.Tags()
	case knowledgearticle.FieldAuthorID:
		return m.AuthorID()
	case knowledgearticle.FieldTenantID:
		return m.TenantID()
	case knowledgearticle.FieldIsPublished:
		return m.IsPublished()
	case knowledgearticle.FieldCreatedAt:
		return m.CreatedAt()
	case knowledgearticle.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KnowledgeArticleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case knowledgearticle.FieldTitle:
		return m.OldTitle(ctx)
	case knowledgearticle.FieldContent:
		return m.OldContent(ctx)
	case knowledgearticle.FieldCategory:
		return m.OldCategory(ctx)
	case knowledgearticle.FieldTags:
		return m.OldTags(ctx)
	case knowledgearticle.FieldAuthorID:
		return m.OldAuthorID(ctx)
	case knowledgearticle.FieldTenantID:
		return m.OldTenantID(ctx)
	case knowledgearticle.FieldIsPublished:
		return m.OldIsPublished(ctx)
	case knowledgearticle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case knowledgearticle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown KnowledgeArticle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KnowledgeArticleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case knowledgearticle.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case knowledgearticle.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case knowledgearticle.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case knowledgearticle.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case knowledgearticle.FieldAuthorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorID(v)
		return nil
	case knowledgearticle.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case knowledgearticle.FieldIsPublished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublished(v)
		return nil
	case knowledgearticle.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case knowledgearticle.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown KnowledgeArticle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KnowledgeArticleMutation) AddedFields() []string {
	var fields []string
	if m.addauthor_id != nil {
		fields = append(fields, knowledgearticle.FieldAuthorID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, knowledgearticle.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KnowledgeArticleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case knowledgearticle.FieldAuthorID:
		return m.AddedAuthorID()
	case knowledgearticle.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KnowledgeArticleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case knowledgearticle.FieldAuthorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthorID(v)
		return nil
	case knowledgearticle.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown KnowledgeArticle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KnowledgeArticleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(knowledgearticle.FieldContent) {
		fields = append(fields, knowledgearticle.FieldContent)
	}
	if m.FieldCleared(knowledgearticle.FieldCategory) {
		fields = append(fields, knowledgearticle.FieldCategory)
	}
	if m.FieldCleared(knowledgearticle.FieldTags) {
		fields = append(fields, knowledgearticle.FieldTags)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KnowledgeArticleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KnowledgeArticleMutation) ClearField(name string) error {
	switch name {
	case knowledgearticle.FieldContent:
		m.ClearContent()
		return nil
	case knowledgearticle.FieldCategory:
		m.ClearCategory()
		return nil
	case knowledgearticle.FieldTags:
		m.ClearTags()
		return nil
	}
	return fmt.Errorf("unknown KnowledgeArticle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KnowledgeArticleMutation) ResetField(name string) error {
	switch name {
	case knowledgearticle.FieldTitle:
		m.ResetTitle()
		return nil
	case knowledgearticle.FieldContent:
		m.ResetContent()
		return nil
	case knowledgearticle.FieldCategory:
		m.ResetCategory()
		return nil
	case knowledgearticle.FieldTags:
		m.ResetTags()
		return nil
	case knowledgearticle.FieldAuthorID:
		m.ResetAuthorID()
		return nil
	case knowledgearticle.FieldTenantID:
		m.ResetTenantID()
		return nil
	case knowledgearticle.FieldIsPublished:
		m.ResetIsPublished()
		return nil
	case knowledgearticle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case knowledgearticle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown KnowledgeArticle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KnowledgeArticleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KnowledgeArticleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KnowledgeArticleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KnowledgeArticleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KnowledgeArticleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KnowledgeArticleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KnowledgeArticleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown KnowledgeArticle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KnowledgeArticleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown KnowledgeArticle edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	role                *string
	content             *string
	request_id          *string
	clearedFields       map[string]struct{}
	conversation        *int
	clearedconversation bool
	done                bool
	oldValue            func(context.Context) (*Message, error)
	predicates          []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id int) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetConversationID sets the "conversation_id" field.
func (m *MessageMutation) SetConversationID(i int) {
	m.conversation = &i
}

// ConversationID returns the value of the "conversation_id" field in the mutation.
func (m *MessageMutation) ConversationID() (r int, exists bool) {
	v := m.conversation
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationID returns the old "conversation_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldConversationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationID: %w", err)
	}
	return oldValue.ConversationID, nil
}

// ResetConversationID resets all changes to the "conversation_id" field.
func (m *MessageMutation) ResetConversationID() {
	m.conversation = nil
}

// SetRole sets the "role" field.
func (m *MessageMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *MessageMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *MessageMutation) ResetRole() {
	m.role = nil
}

// SetContent sets the "content" field.
func (m *MessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MessageMutation) ResetContent() {
	m.content = nil
}

// SetRequestID sets the "request_id" field.
func (m *MessageMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *MessageMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *MessageMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[message.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *MessageMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[message.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *MessageMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, message.FieldRequestID)
}

// ClearConversation clears the "conversation" edge to the Conversation entity.
func (m *MessageMutation) ClearConversation() {
	m.clearedconversation = true
	m.clearedFields[message.FieldConversationID] = struct{}{}
}

// ConversationCleared reports if the "conversation" edge to the Conversation entity was cleared.
func (m *MessageMutation) ConversationCleared() bool {
	return m.clearedconversation
}

// ConversationIDs returns the "conversation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConversationID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) ConversationIDs() (ids []int) {
	if id := m.conversation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConversation resets all changes to the "conversation" edge.
func (m *MessageMutation) ResetConversation() {
	m.conversation = nil
	m.clearedconversation = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.conversation != nil {
		fields = append(fields, message.FieldConversationID)
	}
	if m.role != nil {
		fields = append(fields, message.FieldRole)
	}
	if m.content != nil {
		fields = append(fields, message.FieldContent)
	}
	if m.request_id != nil {
		fields = append(fields, message.FieldRequestID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldCreatedAt:
		return m.CreatedAt()
	case message.FieldConversationID:
		return m.ConversationID()
	case message.FieldRole:
		return m.Role()
	case message.FieldContent:
		return m.Content()
	case message.FieldRequestID:
		return m.RequestID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case message.FieldConversationID:
		return m.OldConversationID(ctx)
	case message.FieldRole:
		return m.OldRole(ctx)
	case message.FieldContent:
		return m.OldContent(ctx)
	case message.FieldRequestID:
		return m.OldRequestID(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case message.FieldConversationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationID(v)
		return nil
	case message.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case message.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case message.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldRequestID) {
		fields = append(fields, message.FieldRequestID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldRequestID:
		m.ClearRequestID()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case message.FieldConversationID:
		m.ResetConversationID()
		return nil
	case message.FieldRole:
		m.ResetRole()
		return nil
	case message.FieldContent:
		m.ResetContent()
		return nil
	case message.FieldRequestID:
		m.ResetRequestID()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.conversation != nil {
		edges = append(edges, message.EdgeConversation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeConversation:
		if id := m.conversation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconversation {
		edges = append(edges, message.EdgeConversation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeConversation:
		return m.clearedconversation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ClearConversation()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ResetConversation()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	message       *string
	_type         *string
	read          *bool
	action_url    *string
	action_text   *string
	user_id       *int
	adduser_id    *int
	tenant_id     *int
	addtenant_id  *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Notification, error)
	predicates    []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id int) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *NotificationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *NotificationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *NotificationMutation) ResetTitle() {
	m.title = nil
}

// SetMessage sets the "message" field.
func (m *NotificationMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *NotificationMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *NotificationMutation) ResetMessage() {
	m.message = nil
}

// SetType sets the "type" field.
func (m *NotificationMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationMutation) ResetType() {
	m._type = nil
}

// SetRead sets the "read" field.
func (m *NotificationMutation) SetRead(b bool) {
	m.read = &b
}

// Read returns the value of the "read" field in the mutation.
func (m *NotificationMutation) Read() (r bool, exists bool) {
	v := m.read
	if v == nil {
		return
	}
	return *v, true
}

// OldRead returns the old "read" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRead: %w", err)
	}
	return oldValue.Read, nil
}

// ResetRead resets all changes to the "read" field.
func (m *NotificationMutation) ResetRead() {
	m.read = nil
}

// SetActionURL sets the "action_url" field.
func (m *NotificationMutation) SetActionURL(s string) {
	m.action_url = &s
}

// ActionURL returns the value of the "action_url" field in the mutation.
func (m *NotificationMutation) ActionURL() (r string, exists bool) {
	v := m.action_url
	if v == nil {
		return
	}
	return *v, true
}

// OldActionURL returns the old "action_url" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldActionURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionURL: %w", err)
	}
	return oldValue.ActionURL, nil
}

// ClearActionURL clears the value of the "action_url" field.
func (m *NotificationMutation) ClearActionURL() {
	m.action_url = nil
	m.clearedFields[notification.FieldActionURL] = struct{}{}
}

// ActionURLCleared returns if the "action_url" field was cleared in this mutation.
func (m *NotificationMutation) ActionURLCleared() bool {
	_, ok := m.clearedFields[notification.FieldActionURL]
	return ok
}

// ResetActionURL resets all changes to the "action_url" field.
func (m *NotificationMutation) ResetActionURL() {
	m.action_url = nil
	delete(m.clearedFields, notification.FieldActionURL)
}

// SetActionText sets the "action_text" field.
func (m *NotificationMutation) SetActionText(s string) {
	m.action_text = &s
}

// ActionText returns the value of the "action_text" field in the mutation.
func (m *NotificationMutation) ActionText() (r string, exists bool) {
	v := m.action_text
	if v == nil {
		return
	}
	return *v, true
}

// OldActionText returns the old "action_text" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldActionText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionText: %w", err)
	}
	return oldValue.ActionText, nil
}

// ClearActionText clears the value of the "action_text" field.
func (m *NotificationMutation) ClearActionText() {
	m.action_text = nil
	m.clearedFields[notification.FieldActionText] = struct{}{}
}

// ActionTextCleared returns if the "action_text" field was cleared in this mutation.
func (m *NotificationMutation) ActionTextCleared() bool {
	_, ok := m.clearedFields[notification.FieldActionText]
	return ok
}

// ResetActionText resets all changes to the "action_text" field.
func (m *NotificationMutation) ResetActionText() {
	m.action_text = nil
	delete(m.clearedFields, notification.FieldActionText)
}

// SetUserID sets the "user_id" field.
func (m *NotificationMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *NotificationMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *NotificationMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *NotificationMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *NotificationMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *NotificationMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *NotificationMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *NotificationMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *NotificationMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *NotificationMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.title != nil {
		fields = append(fields, notification.FieldTitle)
	}
	if m.message != nil {
		fields = append(fields, notification.FieldMessage)
	}
	if m._type != nil {
		fields = append(fields, notification.FieldType)
	}
	if m.read != nil {
		fields = append(fields, notification.FieldRead)
	}
	if m.action_url != nil {
		fields = append(fields, notification.FieldActionURL)
	}
	if m.action_text != nil {
		fields = append(fields, notification.FieldActionText)
	}
	if m.user_id != nil {
		fields = append(fields, notification.FieldUserID)
	}
	if m.tenant_id != nil {
		fields = append(fields, notification.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notification.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldTitle:
		return m.Title()
	case notification.FieldMessage:
		return m.Message()
	case notification.FieldType:
		return m.GetType()
	case notification.FieldRead:
		return m.Read()
	case notification.FieldActionURL:
		return m.ActionURL()
	case notification.FieldActionText:
		return m.ActionText()
	case notification.FieldUserID:
		return m.UserID()
	case notification.FieldTenantID:
		return m.TenantID()
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	case notification.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldTitle:
		return m.OldTitle(ctx)
	case notification.FieldMessage:
		return m.OldMessage(ctx)
	case notification.FieldType:
		return m.OldType(ctx)
	case notification.FieldRead:
		return m.OldRead(ctx)
	case notification.FieldActionURL:
		return m.OldActionURL(ctx)
	case notification.FieldActionText:
		return m.OldActionText(ctx)
	case notification.FieldUserID:
		return m.OldUserID(ctx)
	case notification.FieldTenantID:
		return m.OldTenantID(ctx)
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case notification.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case notification.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notification.FieldRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRead(v)
		return nil
	case notification.FieldActionURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionURL(v)
		return nil
	case notification.FieldActionText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionText(v)
		return nil
	case notification.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case notification.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, notification.FieldUserID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, notification.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldUserID:
		return m.AddedUserID()
	case notification.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notification.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case notification.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldActionURL) {
		fields = append(fields, notification.FieldActionURL)
	}
	if m.FieldCleared(notification.FieldActionText) {
		fields = append(fields, notification.FieldActionText)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldActionURL:
		m.ClearActionURL()
		return nil
	case notification.FieldActionText:
		m.ClearActionText()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldTitle:
		m.ResetTitle()
		return nil
	case notification.FieldMessage:
		m.ResetMessage()
		return nil
	case notification.FieldType:
		m.ResetType()
		return nil
	case notification.FieldRead:
		m.ResetRead()
		return nil
	case notification.FieldActionURL:
		m.ResetActionURL()
		return nil
	case notification.FieldActionText:
		m.ResetActionText()
		return nil
	case notification.FieldUserID:
		m.ResetUserID()
		return nil
	case notification.FieldTenantID:
		m.ResetTenantID()
		return nil
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Notification edge %s", name)
}

// PromptTemplateMutation represents an operation that mutates the PromptTemplate nodes in the graph.
type PromptTemplateMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	version       *string
	template      *string
	description   *string
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PromptTemplate, error)
	predicates    []predicate.PromptTemplate
}

var _ ent.Mutation = (*PromptTemplateMutation)(nil)

// prompttemplateOption allows management of the mutation configuration using functional options.
type prompttemplateOption func(*PromptTemplateMutation)

// newPromptTemplateMutation creates new mutation for the PromptTemplate entity.
func newPromptTemplateMutation(c config, op Op, opts ...prompttemplateOption) *PromptTemplateMutation {
	m := &PromptTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypePromptTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromptTemplateID sets the ID field of the mutation.
func withPromptTemplateID(id int) prompttemplateOption {
	return func(m *PromptTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *PromptTemplate
		)
		m.oldValue = func(ctx context.Context) (*PromptTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromptTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromptTemplate sets the old PromptTemplate of the mutation.
func withPromptTemplate(node *PromptTemplate) prompttemplateOption {
	return func(m *PromptTemplateMutation) {
		m.oldValue = func(context.Context) (*PromptTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromptTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromptTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromptTemplateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromptTemplateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromptTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromptTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromptTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromptTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromptTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromptTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromptTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PromptTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PromptTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PromptTemplateMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *PromptTemplateMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PromptTemplateMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PromptTemplateMutation) ResetVersion() {
	m.version = nil
}

// SetTemplate sets the "template" field.
func (m *PromptTemplateMutation) SetTemplate(s string) {
	m.template = &s
}

// Template returns the value of the "template" field in the mutation.
func (m *PromptTemplateMutation) Template() (r string, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old "template" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ResetTemplate resets all changes to the "template" field.
func (m *PromptTemplateMutation) ResetTemplate() {
	m.template = nil
}

// SetDescription sets the "description" field.
func (m *PromptTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PromptTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PromptTemplateMutation) ResetDescription() {
	m.description = nil
}

// SetMetadata sets the "metadata" field.
func (m *PromptTemplateMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PromptTemplateMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PromptTemplateMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[prompttemplate.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PromptTemplateMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[prompttemplate.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PromptTemplateMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, prompttemplate.FieldMetadata)
}

// Where appends a list predicates to the PromptTemplateMutation builder.
func (m *PromptTemplateMutation) Where(ps ...predicate.PromptTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromptTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromptTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromptTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromptTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromptTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromptTemplate).
func (m *PromptTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromptTemplateMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, prompttemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, prompttemplate.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, prompttemplate.FieldName)
	}
	if m.version != nil {
		fields = append(fields, prompttemplate.FieldVersion)
	}
	if m.template != nil {
		fields = append(fields, prompttemplate.FieldTemplate)
	}
	if m.description != nil {
		fields = append(fields, prompttemplate.FieldDescription)
	}
	if m.metadata != nil {
		fields = append(fields, prompttemplate.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromptTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prompttemplate.FieldCreatedAt:
		return m.CreatedAt()
	case prompttemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	case prompttemplate.FieldName:
		return m.Name()
	case prompttemplate.FieldVersion:
		return m.Version()
	case prompttemplate.FieldTemplate:
		return m.Template()
	case prompttemplate.FieldDescription:
		return m.Description()
	case prompttemplate.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromptTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prompttemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case prompttemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case prompttemplate.FieldName:
		return m.OldName(ctx)
	case prompttemplate.FieldVersion:
		return m.OldVersion(ctx)
	case prompttemplate.FieldTemplate:
		return m.OldTemplate(ctx)
	case prompttemplate.FieldDescription:
		return m.OldDescription(ctx)
	case prompttemplate.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown PromptTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prompttemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case prompttemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case prompttemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case prompttemplate.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case prompttemplate.FieldTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	case prompttemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case prompttemplate.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown PromptTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromptTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromptTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PromptTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromptTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(prompttemplate.FieldMetadata) {
		fields = append(fields, prompttemplate.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromptTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromptTemplateMutation) ClearField(name string) error {
	switch name {
	case prompttemplate.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown PromptTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromptTemplateMutation) ResetField(name string) error {
	switch name {
	case prompttemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case prompttemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case prompttemplate.FieldName:
		m.ResetName()
		return nil
	case prompttemplate.FieldVersion:
		m.ResetVersion()
		return nil
	case prompttemplate.FieldTemplate:
		m.ResetTemplate()
		return nil
	case prompttemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case prompttemplate.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown PromptTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromptTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromptTemplateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromptTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromptTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromptTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromptTemplateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromptTemplateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PromptTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromptTemplateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PromptTemplate edge %s", name)
}

// SLADefinitionMutation represents an operation that mutates the SLADefinition nodes in the graph.
type SLADefinitionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	tenant_id     *int
	addtenant_id  *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SLADefinition, error)
	predicates    []predicate.SLADefinition
}

var _ ent.Mutation = (*SLADefinitionMutation)(nil)

// sladefinitionOption allows management of the mutation configuration using functional options.
type sladefinitionOption func(*SLADefinitionMutation)

// newSLADefinitionMutation creates new mutation for the SLADefinition entity.
func newSLADefinitionMutation(c config, op Op, opts ...sladefinitionOption) *SLADefinitionMutation {
	m := &SLADefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeSLADefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSLADefinitionID sets the ID field of the mutation.
func withSLADefinitionID(id int) sladefinitionOption {
	return func(m *SLADefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *SLADefinition
		)
		m.oldValue = func(ctx context.Context) (*SLADefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SLADefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSLADefinition sets the old SLADefinition of the mutation.
func withSLADefinition(node *SLADefinition) sladefinitionOption {
	return func(m *SLADefinitionMutation) {
		m.oldValue = func(context.Context) (*SLADefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SLADefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SLADefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SLADefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SLADefinitionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SLADefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SLADefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SLADefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SLADefinitionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SLADefinitionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SLADefinitionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SLADefinitionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[sladefinition.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SLADefinitionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[sladefinition.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SLADefinitionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, sladefinition.FieldDescription)
}

// SetTenantID sets the "tenant_id" field.
func (m *SLADefinitionMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SLADefinitionMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *SLADefinitionMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *SLADefinitionMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SLADefinitionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SLADefinitionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SLADefinitionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SLADefinitionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SLADefinitionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SLADefinitionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SLADefinitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the SLADefinitionMutation builder.
func (m *SLADefinitionMutation) Where(ps ...predicate.SLADefinition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SLADefinitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SLADefinitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SLADefinition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SLADefinitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SLADefinitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SLADefinition).
func (m *SLADefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SLADefinitionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, sladefinition.FieldName)
	}
	if m.description != nil {
		fields = append(fields, sladefinition.FieldDescription)
	}
	if m.tenant_id != nil {
		fields = append(fields, sladefinition.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, sladefinition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sladefinition.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SLADefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sladefinition.FieldName:
		return m.Name()
	case sladefinition.FieldDescription:
		return m.Description()
	case sladefinition.FieldTenantID:
		return m.TenantID()
	case sladefinition.FieldCreatedAt:
		return m.CreatedAt()
	case sladefinition.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SLADefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sladefinition.FieldName:
		return m.OldName(ctx)
	case sladefinition.FieldDescription:
		return m.OldDescription(ctx)
	case sladefinition.FieldTenantID:
		return m.OldTenantID(ctx)
	case sladefinition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sladefinition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SLADefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLADefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sladefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sladefinition.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case sladefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case sladefinition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sladefinition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SLADefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SLADefinitionMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, sladefinition.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SLADefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sladefinition.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLADefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sladefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown SLADefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SLADefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sladefinition.FieldDescription) {
		fields = append(fields, sladefinition.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SLADefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SLADefinitionMutation) ClearField(name string) error {
	switch name {
	case sladefinition.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SLADefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SLADefinitionMutation) ResetField(name string) error {
	switch name {
	case sladefinition.FieldName:
		m.ResetName()
		return nil
	case sladefinition.FieldDescription:
		m.ResetDescription()
		return nil
	case sladefinition.FieldTenantID:
		m.ResetTenantID()
		return nil
	case sladefinition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sladefinition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SLADefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SLADefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SLADefinitionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SLADefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SLADefinitionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SLADefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SLADefinitionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SLADefinitionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SLADefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SLADefinitionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SLADefinition edge %s", name)
}

// SLAViolationMutation represents an operation that mutates the SLAViolation nodes in the graph.
type SLAViolationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	sla_definition_id    *int
	addsla_definition_id *int
	ticket_id            *int
	addticket_id         *int
	violation_type       *string
	violation_time       *time.Time
	description          *string
	tenant_id            *int
	addtenant_id         *int
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*SLAViolation, error)
	predicates           []predicate.SLAViolation
}

var _ ent.Mutation = (*SLAViolationMutation)(nil)

// slaviolationOption allows management of the mutation configuration using functional options.
type slaviolationOption func(*SLAViolationMutation)

// newSLAViolationMutation creates new mutation for the SLAViolation entity.
func newSLAViolationMutation(c config, op Op, opts ...slaviolationOption) *SLAViolationMutation {
	m := &SLAViolationMutation{
		config:        c,
		op:            op,
		typ:           TypeSLAViolation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSLAViolationID sets the ID field of the mutation.
func withSLAViolationID(id int) slaviolationOption {
	return func(m *SLAViolationMutation) {
		var (
			err   error
			once  sync.Once
			value *SLAViolation
		)
		m.oldValue = func(ctx context.Context) (*SLAViolation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SLAViolation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSLAViolation sets the old SLAViolation of the mutation.
func withSLAViolation(node *SLAViolation) slaviolationOption {
	return func(m *SLAViolationMutation) {
		m.oldValue = func(context.Context) (*SLAViolation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SLAViolationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SLAViolationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SLAViolationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SLAViolationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SLAViolation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSLADefinitionID sets the "sla_definition_id" field.
func (m *SLAViolationMutation) SetSLADefinitionID(i int) {
	m.sla_definition_id = &i
	m.addsla_definition_id = nil
}

// SLADefinitionID returns the value of the "sla_definition_id" field in the mutation.
func (m *SLAViolationMutation) SLADefinitionID() (r int, exists bool) {
	v := m.sla_definition_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSLADefinitionID returns the old "sla_definition_id" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldSLADefinitionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSLADefinitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSLADefinitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSLADefinitionID: %w", err)
	}
	return oldValue.SLADefinitionID, nil
}

// AddSLADefinitionID adds i to the "sla_definition_id" field.
func (m *SLAViolationMutation) AddSLADefinitionID(i int) {
	if m.addsla_definition_id != nil {
		*m.addsla_definition_id += i
	} else {
		m.addsla_definition_id = &i
	}
}

// AddedSLADefinitionID returns the value that was added to the "sla_definition_id" field in this mutation.
func (m *SLAViolationMutation) AddedSLADefinitionID() (r int, exists bool) {
	v := m.addsla_definition_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSLADefinitionID resets all changes to the "sla_definition_id" field.
func (m *SLAViolationMutation) ResetSLADefinitionID() {
	m.sla_definition_id = nil
	m.addsla_definition_id = nil
}

// SetTicketID sets the "ticket_id" field.
func (m *SLAViolationMutation) SetTicketID(i int) {
	m.ticket_id = &i
	m.addticket_id = nil
}

// TicketID returns the value of the "ticket_id" field in the mutation.
func (m *SLAViolationMutation) TicketID() (r int, exists bool) {
	v := m.ticket_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketID returns the old "ticket_id" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldTicketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketID: %w", err)
	}
	return oldValue.TicketID, nil
}

// AddTicketID adds i to the "ticket_id" field.
func (m *SLAViolationMutation) AddTicketID(i int) {
	if m.addticket_id != nil {
		*m.addticket_id += i
	} else {
		m.addticket_id = &i
	}
}

// AddedTicketID returns the value that was added to the "ticket_id" field in this mutation.
func (m *SLAViolationMutation) AddedTicketID() (r int, exists bool) {
	v := m.addticket_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTicketID resets all changes to the "ticket_id" field.
func (m *SLAViolationMutation) ResetTicketID() {
	m.ticket_id = nil
	m.addticket_id = nil
}

// SetViolationType sets the "violation_type" field.
func (m *SLAViolationMutation) SetViolationType(s string) {
	m.violation_type = &s
}

// ViolationType returns the value of the "violation_type" field in the mutation.
func (m *SLAViolationMutation) ViolationType() (r string, exists bool) {
	v := m.violation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldViolationType returns the old "violation_type" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldViolationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViolationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViolationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViolationType: %w", err)
	}
	return oldValue.ViolationType, nil
}

// ResetViolationType resets all changes to the "violation_type" field.
func (m *SLAViolationMutation) ResetViolationType() {
	m.violation_type = nil
}

// SetViolationTime sets the "violation_time" field.
func (m *SLAViolationMutation) SetViolationTime(t time.Time) {
	m.violation_time = &t
}

// ViolationTime returns the value of the "violation_time" field in the mutation.
func (m *SLAViolationMutation) ViolationTime() (r time.Time, exists bool) {
	v := m.violation_time
	if v == nil {
		return
	}
	return *v, true
}

// OldViolationTime returns the old "violation_time" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldViolationTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViolationTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViolationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViolationTime: %w", err)
	}
	return oldValue.ViolationTime, nil
}

// ResetViolationTime resets all changes to the "violation_time" field.
func (m *SLAViolationMutation) ResetViolationTime() {
	m.violation_time = nil
}

// SetDescription sets the "description" field.
func (m *SLAViolationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SLAViolationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SLAViolationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[slaviolation.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SLAViolationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[slaviolation.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SLAViolationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, slaviolation.FieldDescription)
}

// SetTenantID sets the "tenant_id" field.
func (m *SLAViolationMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SLAViolationMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *SLAViolationMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *SLAViolationMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SLAViolationMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SLAViolationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SLAViolationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SLAViolationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SLAViolationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SLAViolationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SLAViolationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the SLAViolationMutation builder.
func (m *SLAViolationMutation) Where(ps ...predicate.SLAViolation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SLAViolationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SLAViolationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SLAViolation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SLAViolationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SLAViolationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SLAViolation).
func (m *SLAViolationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SLAViolationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.sla_definition_id != nil {
		fields = append(fields, slaviolation.FieldSLADefinitionID)
	}
	if m.ticket_id != nil {
		fields = append(fields, slaviolation.FieldTicketID)
	}
	if m.violation_type != nil {
		fields = append(fields, slaviolation.FieldViolationType)
	}
	if m.violation_time != nil {
		fields = append(fields, slaviolation.FieldViolationTime)
	}
	if m.description != nil {
		fields = append(fields, slaviolation.FieldDescription)
	}
	if m.tenant_id != nil {
		fields = append(fields, slaviolation.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, slaviolation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, slaviolation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SLAViolationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		return m.SLADefinitionID()
	case slaviolation.FieldTicketID:
		return m.TicketID()
	case slaviolation.FieldViolationType:
		return m.ViolationType()
	case slaviolation.FieldViolationTime:
		return m.ViolationTime()
	case slaviolation.FieldDescription:
		return m.Description()
	case slaviolation.FieldTenantID:
		return m.TenantID()
	case slaviolation.FieldCreatedAt:
		return m.CreatedAt()
	case slaviolation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SLAViolationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		return m.OldSLADefinitionID(ctx)
	case slaviolation.FieldTicketID:
		return m.OldTicketID(ctx)
	case slaviolation.FieldViolationType:
		return m.OldViolationType(ctx)
	case slaviolation.FieldViolationTime:
		return m.OldViolationTime(ctx)
	case slaviolation.FieldDescription:
		return m.OldDescription(ctx)
	case slaviolation.FieldTenantID:
		return m.OldTenantID(ctx)
	case slaviolation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case slaviolation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SLAViolation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLAViolationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSLADefinitionID(v)
		return nil
	case slaviolation.FieldTicketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketID(v)
		return nil
	case slaviolation.FieldViolationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViolationType(v)
		return nil
	case slaviolation.FieldViolationTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViolationTime(v)
		return nil
	case slaviolation.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case slaviolation.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case slaviolation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case slaviolation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SLAViolation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SLAViolationMutation) AddedFields() []string {
	var fields []string
	if m.addsla_definition_id != nil {
		fields = append(fields, slaviolation.FieldSLADefinitionID)
	}
	if m.addticket_id != nil {
		fields = append(fields, slaviolation.FieldTicketID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, slaviolation.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SLAViolationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		return m.AddedSLADefinitionID()
	case slaviolation.FieldTicketID:
		return m.AddedTicketID()
	case slaviolation.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLAViolationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSLADefinitionID(v)
		return nil
	case slaviolation.FieldTicketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTicketID(v)
		return nil
	case slaviolation.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown SLAViolation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SLAViolationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(slaviolation.FieldDescription) {
		fields = append(fields, slaviolation.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SLAViolationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SLAViolationMutation) ClearField(name string) error {
	switch name {
	case slaviolation.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SLAViolation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SLAViolationMutation) ResetField(name string) error {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		m.ResetSLADefinitionID()
		return nil
	case slaviolation.FieldTicketID:
		m.ResetTicketID()
		return nil
	case slaviolation.FieldViolationType:
		m.ResetViolationType()
		return nil
	case slaviolation.FieldViolationTime:
		m.ResetViolationTime()
		return nil
	case slaviolation.FieldDescription:
		m.ResetDescription()
		return nil
	case slaviolation.FieldTenantID:
		m.ResetTenantID()
		return nil
	case slaviolation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case slaviolation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SLAViolation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SLAViolationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SLAViolationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SLAViolationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SLAViolationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SLAViolationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SLAViolationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SLAViolationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SLAViolation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SLAViolationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SLAViolation edge %s", name)
}

// ServiceCatalogMutation represents an operation that mutates the ServiceCatalog nodes in the graph.
type ServiceCatalogMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	description      *string
	category         *string
	price            *float64
	addprice         *float64
	delivery_time    *int
	adddelivery_time *int
	status           *string
	tenant_id        *int
	addtenant_id     *int
	is_active        *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*ServiceCatalog, error)
	predicates       []predicate.ServiceCatalog
}

var _ ent.Mutation = (*ServiceCatalogMutation)(nil)

// servicecatalogOption allows management of the mutation configuration using functional options.
type servicecatalogOption func(*ServiceCatalogMutation)

// newServiceCatalogMutation creates new mutation for the ServiceCatalog entity.
func newServiceCatalogMutation(c config, op Op, opts ...servicecatalogOption) *ServiceCatalogMutation {
	m := &ServiceCatalogMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceCatalog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceCatalogID sets the ID field of the mutation.
func withServiceCatalogID(id int) servicecatalogOption {
	return func(m *ServiceCatalogMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceCatalog
		)
		m.oldValue = func(ctx context.Context) (*ServiceCatalog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceCatalog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceCatalog sets the old ServiceCatalog of the mutation.
func withServiceCatalog(node *ServiceCatalog) servicecatalogOption {
	return func(m *ServiceCatalogMutation) {
		m.oldValue = func(context.Context) (*ServiceCatalog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceCatalogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceCatalogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceCatalogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceCatalogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceCatalog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ServiceCatalogMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceCatalogMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceCatalogMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ServiceCatalogMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServiceCatalogMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ServiceCatalogMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[servicecatalog.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ServiceCatalogMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[servicecatalog.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ServiceCatalogMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, servicecatalog.FieldDescription)
}

// SetCategory sets the "category" field.
func (m *ServiceCatalogMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ServiceCatalogMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ServiceCatalogMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[servicecatalog.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ServiceCatalogMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[servicecatalog.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ServiceCatalogMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, servicecatalog.FieldCategory)
}

// SetPrice sets the "price" field.
func (m *ServiceCatalogMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ServiceCatalogMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ServiceCatalogMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ServiceCatalogMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *ServiceCatalogMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[servicecatalog.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *ServiceCatalogMutation) PriceCleared() bool {
	_, ok := m.clearedFields[servicecatalog.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *ServiceCatalogMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, servicecatalog.FieldPrice)
}

// SetDeliveryTime sets the "delivery_time" field.
func (m *ServiceCatalogMutation) SetDeliveryTime(i int) {
	m.delivery_time = &i
	m.adddelivery_time = nil
}

// DeliveryTime returns the value of the "delivery_time" field in the mutation.
func (m *ServiceCatalogMutation) DeliveryTime() (r int, exists bool) {
	v := m.delivery_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryTime returns the old "delivery_time" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldDeliveryTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryTime: %w", err)
	}
	return oldValue.DeliveryTime, nil
}

// AddDeliveryTime adds i to the "delivery_time" field.
func (m *ServiceCatalogMutation) AddDeliveryTime(i int) {
	if m.adddelivery_time != nil {
		*m.adddelivery_time += i
	} else {
		m.adddelivery_time = &i
	}
}

// AddedDeliveryTime returns the value that was added to the "delivery_time" field in this mutation.
func (m *ServiceCatalogMutation) AddedDeliveryTime() (r int, exists bool) {
	v := m.adddelivery_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeliveryTime clears the value of the "delivery_time" field.
func (m *ServiceCatalogMutation) ClearDeliveryTime() {
	m.delivery_time = nil
	m.adddelivery_time = nil
	m.clearedFields[servicecatalog.FieldDeliveryTime] = struct{}{}
}

// DeliveryTimeCleared returns if the "delivery_time" field was cleared in this mutation.
func (m *ServiceCatalogMutation) DeliveryTimeCleared() bool {
	_, ok := m.clearedFields[servicecatalog.FieldDeliveryTime]
	return ok
}

// ResetDeliveryTime resets all changes to the "delivery_time" field.
func (m *ServiceCatalogMutation) ResetDeliveryTime() {
	m.delivery_time = nil
	m.adddelivery_time = nil
	delete(m.clearedFields, servicecatalog.FieldDeliveryTime)
}

// SetStatus sets the "status" field.
func (m *ServiceCatalogMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceCatalogMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceCatalogMutation) ResetStatus() {
	m.status = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ServiceCatalogMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ServiceCatalogMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ServiceCatalogMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ServiceCatalogMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ServiceCatalogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetIsActive sets the "is_active" field.
func (m *ServiceCatalogMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ServiceCatalogMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ServiceCatalogMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceCatalogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceCatalogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceCatalogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServiceCatalogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServiceCatalogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServiceCatalogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ServiceCatalogMutation builder.
func (m *ServiceCatalogMutation) Where(ps ...predicate.ServiceCatalog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceCatalogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceCatalogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceCatalog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceCatalogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceCatalogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceCatalog).
func (m *ServiceCatalogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceCatalogMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, servicecatalog.FieldName)
	}
	if m.description != nil {
		fields = append(fields, servicecatalog.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, servicecatalog.FieldCategory)
	}
	if m.price != nil {
		fields = append(fields, servicecatalog.FieldPrice)
	}
	if m.delivery_time != nil {
		fields = append(fields, servicecatalog.FieldDeliveryTime)
	}
	if m.status != nil {
		fields = append(fields, servicecatalog.FieldStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, servicecatalog.FieldTenantID)
	}
	if m.is_active != nil {
		fields = append(fields, servicecatalog.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, servicecatalog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servicecatalog.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceCatalogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicecatalog.FieldName:
		return m.Name()
	case servicecatalog.FieldDescription:
		return m.Description()
	case servicecatalog.FieldCategory:
		return m.Category()
	case servicecatalog.FieldPrice:
		return m.Price()
	case servicecatalog.FieldDeliveryTime:
		return m.DeliveryTime()
	case servicecatalog.FieldStatus:
		return m.Status()
	case servicecatalog.FieldTenantID:
		return m.TenantID()
	case servicecatalog.FieldIsActive:
		return m.IsActive()
	case servicecatalog.FieldCreatedAt:
		return m.CreatedAt()
	case servicecatalog.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceCatalogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicecatalog.FieldName:
		return m.OldName(ctx)
	case servicecatalog.FieldDescription:
		return m.OldDescription(ctx)
	case servicecatalog.FieldCategory:
		return m.OldCategory(ctx)
	case servicecatalog.FieldPrice:
		return m.OldPrice(ctx)
	case servicecatalog.FieldDeliveryTime:
		return m.OldDeliveryTime(ctx)
	case servicecatalog.FieldStatus:
		return m.OldStatus(ctx)
	case servicecatalog.FieldTenantID:
		return m.OldTenantID(ctx)
	case servicecatalog.FieldIsActive:
		return m.OldIsActive(ctx)
	case servicecatalog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servicecatalog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceCatalog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceCatalogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicecatalog.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case servicecatalog.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case servicecatalog.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case servicecatalog.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case servicecatalog.FieldDeliveryTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryTime(v)
		return nil
	case servicecatalog.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case servicecatalog.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case servicecatalog.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case servicecatalog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servicecatalog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceCatalog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceCatalogMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, servicecatalog.FieldPrice)
	}
	if m.adddelivery_time != nil {
		fields = append(fields, servicecatalog.FieldDeliveryTime)
	}
	if m.addtenant_id != nil {
		fields = append(fields, servicecatalog.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceCatalogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servicecatalog.FieldPrice:
		return m.AddedPrice()
	case servicecatalog.FieldDeliveryTime:
		return m.AddedDeliveryTime()
	case servicecatalog.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceCatalogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servicecatalog.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case servicecatalog.FieldDeliveryTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveryTime(v)
		return nil
	case servicecatalog.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceCatalog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceCatalogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicecatalog.FieldDescription) {
		fields = append(fields, servicecatalog.FieldDescription)
	}
	if m.FieldCleared(servicecatalog.FieldCategory) {
		fields = append(fields, servicecatalog.FieldCategory)
	}
	if m.FieldCleared(servicecatalog.FieldPrice) {
		fields = append(fields, servicecatalog.FieldPrice)
	}
	if m.FieldCleared(servicecatalog.FieldDeliveryTime) {
		fields = append(fields, servicecatalog.FieldDeliveryTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceCatalogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceCatalogMutation) ClearField(name string) error {
	switch name {
	case servicecatalog.FieldDescription:
		m.ClearDescription()
		return nil
	case servicecatalog.FieldCategory:
		m.ClearCategory()
		return nil
	case servicecatalog.FieldPrice:
		m.ClearPrice()
		return nil
	case servicecatalog.FieldDeliveryTime:
		m.ClearDeliveryTime()
		return nil
	}
	return fmt.Errorf("unknown ServiceCatalog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceCatalogMutation) ResetField(name string) error {
	switch name {
	case servicecatalog.FieldName:
		m.ResetName()
		return nil
	case servicecatalog.FieldDescription:
		m.ResetDescription()
		return nil
	case servicecatalog.FieldCategory:
		m.ResetCategory()
		return nil
	case servicecatalog.FieldPrice:
		m.ResetPrice()
		return nil
	case servicecatalog.FieldDeliveryTime:
		m.ResetDeliveryTime()
		return nil
	case servicecatalog.FieldStatus:
		m.ResetStatus()
		return nil
	case servicecatalog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case servicecatalog.FieldIsActive:
		m.ResetIsActive()
		return nil
	case servicecatalog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servicecatalog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ServiceCatalog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceCatalogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceCatalogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceCatalogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceCatalogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceCatalogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceCatalogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceCatalogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ServiceCatalog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceCatalogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ServiceCatalog edge %s", name)
}

// ServiceRequestMutation represents an operation that mutates the ServiceRequest nodes in the graph.
type ServiceRequestMutation struct {
	config
	op              Op
	typ             string
	id              *int
	catalog_id      *int
	addcatalog_id   *int
	requester_id    *int
	addrequester_id *int
	status          *string
	reason          *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*ServiceRequest, error)
	predicates      []predicate.ServiceRequest
}

var _ ent.Mutation = (*ServiceRequestMutation)(nil)

// servicerequestOption allows management of the mutation configuration using functional options.
type servicerequestOption func(*ServiceRequestMutation)

// newServiceRequestMutation creates new mutation for the ServiceRequest entity.
func newServiceRequestMutation(c config, op Op, opts ...servicerequestOption) *ServiceRequestMutation {
	m := &ServiceRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceRequestID sets the ID field of the mutation.
func withServiceRequestID(id int) servicerequestOption {
	return func(m *ServiceRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceRequest
		)
		m.oldValue = func(ctx context.Context) (*ServiceRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceRequest sets the old ServiceRequest of the mutation.
func withServiceRequest(node *ServiceRequest) servicerequestOption {
	return func(m *ServiceRequestMutation) {
		m.oldValue = func(context.Context) (*ServiceRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceRequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceRequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCatalogID sets the "catalog_id" field.
func (m *ServiceRequestMutation) SetCatalogID(i int) {
	m.catalog_id = &i
	m.addcatalog_id = nil
}

// CatalogID returns the value of the "catalog_id" field in the mutation.
func (m *ServiceRequestMutation) CatalogID() (r int, exists bool) {
	v := m.catalog_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCatalogID returns the old "catalog_id" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldCatalogID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCatalogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCatalogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCatalogID: %w", err)
	}
	return oldValue.CatalogID, nil
}

// AddCatalogID adds i to the "catalog_id" field.
func (m *ServiceRequestMutation) AddCatalogID(i int) {
	if m.addcatalog_id != nil {
		*m.addcatalog_id += i
	} else {
		m.addcatalog_id = &i
	}
}

// AddedCatalogID returns the value that was added to the "catalog_id" field in this mutation.
func (m *ServiceRequestMutation) AddedCatalogID() (r int, exists bool) {
	v := m.addcatalog_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCatalogID resets all changes to the "catalog_id" field.
func (m *ServiceRequestMutation) ResetCatalogID() {
	m.catalog_id = nil
	m.addcatalog_id = nil
}

// SetRequesterID sets the "requester_id" field.
func (m *ServiceRequestMutation) SetRequesterID(i int) {
	m.requester_id = &i
	m.addrequester_id = nil
}

// RequesterID returns the value of the "requester_id" field in the mutation.
func (m *ServiceRequestMutation) RequesterID() (r int, exists bool) {
	v := m.requester_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequesterID returns the old "requester_id" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldRequesterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequesterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequesterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequesterID: %w", err)
	}
	return oldValue.RequesterID, nil
}

// AddRequesterID adds i to the "requester_id" field.
func (m *ServiceRequestMutation) AddRequesterID(i int) {
	if m.addrequester_id != nil {
		*m.addrequester_id += i
	} else {
		m.addrequester_id = &i
	}
}

// AddedRequesterID returns the value that was added to the "requester_id" field in this mutation.
func (m *ServiceRequestMutation) AddedRequesterID() (r int, exists bool) {
	v := m.addrequester_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequesterID resets all changes to the "requester_id" field.
func (m *ServiceRequestMutation) ResetRequesterID() {
	m.requester_id = nil
	m.addrequester_id = nil
}

// SetStatus sets the "status" field.
func (m *ServiceRequestMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceRequestMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceRequestMutation) ResetStatus() {
	m.status = nil
}

// SetReason sets the "reason" field.
func (m *ServiceRequestMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *ServiceRequestMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *ServiceRequestMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[servicerequest.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *ServiceRequestMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[servicerequest.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *ServiceRequestMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, servicerequest.FieldReason)
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServiceRequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServiceRequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServiceRequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ServiceRequestMutation builder.
func (m *ServiceRequestMutation) Where(ps ...predicate.ServiceRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceRequest).
func (m *ServiceRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceRequestMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.catalog_id != nil {
		fields = append(fields, servicerequest.FieldCatalogID)
	}
	if m.requester_id != nil {
		fields = append(fields, servicerequest.FieldRequesterID)
	}
	if m.status != nil {
		fields = append(fields, servicerequest.FieldStatus)
	}
	if m.reason != nil {
		fields = append(fields, servicerequest.FieldReason)
	}
	if m.created_at != nil {
		fields = append(fields, servicerequest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servicerequest.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicerequest.FieldCatalogID:
		return m.CatalogID()
	case servicerequest.FieldRequesterID:
		return m.RequesterID()
	case servicerequest.FieldStatus:
		return m.Status()
	case servicerequest.FieldReason:
		return m.Reason()
	case servicerequest.FieldCreatedAt:
		return m.CreatedAt()
	case servicerequest.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicerequest.FieldCatalogID:
		return m.OldCatalogID(ctx)
	case servicerequest.FieldRequesterID:
		return m.OldRequesterID(ctx)
	case servicerequest.FieldStatus:
		return m.OldStatus(ctx)
	case servicerequest.FieldReason:
		return m.OldReason(ctx)
	case servicerequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servicerequest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicerequest.FieldCatalogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCatalogID(v)
		return nil
	case servicerequest.FieldRequesterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequesterID(v)
		return nil
	case servicerequest.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case servicerequest.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case servicerequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servicerequest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceRequestMutation) AddedFields() []string {
	var fields []string
	if m.addcatalog_id != nil {
		fields = append(fields, servicerequest.FieldCatalogID)
	}
	if m.addrequester_id != nil {
		fields = append(fields, servicerequest.FieldRequesterID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceRequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servicerequest.FieldCatalogID:
		return m.AddedCatalogID()
	case servicerequest.FieldRequesterID:
		return m.AddedRequesterID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servicerequest.FieldCatalogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCatalogID(v)
		return nil
	case servicerequest.FieldRequesterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequesterID(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicerequest.FieldReason) {
		fields = append(fields, servicerequest.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceRequestMutation) ClearField(name string) error {
	switch name {
	case servicerequest.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown ServiceRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceRequestMutation) ResetField(name string) error {
	switch name {
	case servicerequest.FieldCatalogID:
		m.ResetCatalogID()
		return nil
	case servicerequest.FieldRequesterID:
		m.ResetRequesterID()
		return nil
	case servicerequest.FieldStatus:
		m.ResetStatus()
		return nil
	case servicerequest.FieldReason:
		m.ResetReason()
		return nil
	case servicerequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servicerequest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ServiceRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceRequestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceRequestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceRequestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ServiceRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceRequestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ServiceRequest edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	code          *string
	domain        *string
	_type         *string
	status        *string
	expires_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tenant, error)
	predicates    []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id int) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *TenantMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TenantMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TenantMutation) ResetCode() {
	m.code = nil
}

// SetDomain sets the "domain" field.
func (m *TenantMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *TenantMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *TenantMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[tenant.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *TenantMutation) DomainCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *TenantMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, tenant.FieldDomain)
}

// SetType sets the "type" field.
func (m *TenantMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TenantMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TenantMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *TenantMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TenantMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TenantMutation) ResetStatus() {
	m.status = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *TenantMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *TenantMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *TenantMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[tenant.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *TenantMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *TenantMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, tenant.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	if m.code != nil {
		fields = append(fields, tenant.FieldCode)
	}
	if m.domain != nil {
		fields = append(fields, tenant.FieldDomain)
	}
	if m._type != nil {
		fields = append(fields, tenant.FieldType)
	}
	if m.status != nil {
		fields = append(fields, tenant.FieldStatus)
	}
	if m.expires_at != nil {
		fields = append(fields, tenant.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenant.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldName:
		return m.Name()
	case tenant.FieldCode:
		return m.Code()
	case tenant.FieldDomain:
		return m.Domain()
	case tenant.FieldType:
		return m.GetType()
	case tenant.FieldStatus:
		return m.Status()
	case tenant.FieldExpiresAt:
		return m.ExpiresAt()
	case tenant.FieldCreatedAt:
		return m.CreatedAt()
	case tenant.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldName:
		return m.OldName(ctx)
	case tenant.FieldCode:
		return m.OldCode(ctx)
	case tenant.FieldDomain:
		return m.OldDomain(ctx)
	case tenant.FieldType:
		return m.OldType(ctx)
	case tenant.FieldStatus:
		return m.OldStatus(ctx)
	case tenant.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case tenant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tenant.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case tenant.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case tenant.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case tenant.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tenant.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case tenant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenant.FieldDomain) {
		fields = append(fields, tenant.FieldDomain)
	}
	if m.FieldCleared(tenant.FieldExpiresAt) {
		fields = append(fields, tenant.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	switch name {
	case tenant.FieldDomain:
		m.ClearDomain()
		return nil
	case tenant.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldName:
		m.ResetName()
		return nil
	case tenant.FieldCode:
		m.ResetCode()
		return nil
	case tenant.FieldDomain:
		m.ResetDomain()
		return nil
	case tenant.FieldType:
		m.ResetType()
		return nil
	case tenant.FieldStatus:
		m.ResetStatus()
		return nil
	case tenant.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case tenant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// TicketMutation represents an operation that mutates the Ticket nodes in the graph.
type TicketMutation struct {
	config
	op              Op
	typ             string
	id              *int
	title           *string
	description     *string
	status          *string
	priority        *string
	ticket_number   *string
	requester_id    *int
	addrequester_id *int
	assignee_id     *int
	addassignee_id  *int
	tenant_id       *int
	addtenant_id    *int
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Ticket, error)
	predicates      []predicate.Ticket
}

var _ ent.Mutation = (*TicketMutation)(nil)

// ticketOption allows management of the mutation configuration using functional options.
type ticketOption func(*TicketMutation)

// newTicketMutation creates new mutation for the Ticket entity.
func newTicketMutation(c config, op Op, opts ...ticketOption) *TicketMutation {
	m := &TicketMutation{
		config:        c,
		op:            op,
		typ:           TypeTicket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketID sets the ID field of the mutation.
func withTicketID(id int) ticketOption {
	return func(m *TicketMutation) {
		var (
			err   error
			once  sync.Once
			value *Ticket
		)
		m.oldValue = func(ctx context.Context) (*Ticket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ticket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicket sets the old Ticket of the mutation.
func withTicket(node *Ticket) ticketOption {
	return func(m *TicketMutation) {
		m.oldValue = func(context.Context) (*Ticket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ticket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *TicketMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TicketMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TicketMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TicketMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TicketMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TicketMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ticket.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TicketMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ticket.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TicketMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ticket.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *TicketMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TicketMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TicketMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *TicketMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TicketMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *TicketMutation) ResetPriority() {
	m.priority = nil
}

// SetTicketNumber sets the "ticket_number" field.
func (m *TicketMutation) SetTicketNumber(s string) {
	m.ticket_number = &s
}

// TicketNumber returns the value of the "ticket_number" field in the mutation.
func (m *TicketMutation) TicketNumber() (r string, exists bool) {
	v := m.ticket_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketNumber returns the old "ticket_number" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldTicketNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketNumber: %w", err)
	}
	return oldValue.TicketNumber, nil
}

// ResetTicketNumber resets all changes to the "ticket_number" field.
func (m *TicketMutation) ResetTicketNumber() {
	m.ticket_number = nil
}

// SetRequesterID sets the "requester_id" field.
func (m *TicketMutation) SetRequesterID(i int) {
	m.requester_id = &i
	m.addrequester_id = nil
}

// RequesterID returns the value of the "requester_id" field in the mutation.
func (m *TicketMutation) RequesterID() (r int, exists bool) {
	v := m.requester_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequesterID returns the old "requester_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldRequesterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequesterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequesterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequesterID: %w", err)
	}
	return oldValue.RequesterID, nil
}

// AddRequesterID adds i to the "requester_id" field.
func (m *TicketMutation) AddRequesterID(i int) {
	if m.addrequester_id != nil {
		*m.addrequester_id += i
	} else {
		m.addrequester_id = &i
	}
}

// AddedRequesterID returns the value that was added to the "requester_id" field in this mutation.
func (m *TicketMutation) AddedRequesterID() (r int, exists bool) {
	v := m.addrequester_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequesterID resets all changes to the "requester_id" field.
func (m *TicketMutation) ResetRequesterID() {
	m.requester_id = nil
	m.addrequester_id = nil
}

// SetAssigneeID sets the "assignee_id" field.
func (m *TicketMutation) SetAssigneeID(i int) {
	m.assignee_id = &i
	m.addassignee_id = nil
}

// AssigneeID returns the value of the "assignee_id" field in the mutation.
func (m *TicketMutation) AssigneeID() (r int, exists bool) {
	v := m.assignee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeID returns the old "assignee_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldAssigneeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeID: %w", err)
	}
	return oldValue.AssigneeID, nil
}

// AddAssigneeID adds i to the "assignee_id" field.
func (m *TicketMutation) AddAssigneeID(i int) {
	if m.addassignee_id != nil {
		*m.addassignee_id += i
	} else {
		m.addassignee_id = &i
	}
}

// AddedAssigneeID returns the value that was added to the "assignee_id" field in this mutation.
func (m *TicketMutation) AddedAssigneeID() (r int, exists bool) {
	v := m.addassignee_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssigneeID clears the value of the "assignee_id" field.
func (m *TicketMutation) ClearAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	m.clearedFields[ticket.FieldAssigneeID] = struct{}{}
}

// AssigneeIDCleared returns if the "assignee_id" field was cleared in this mutation.
func (m *TicketMutation) AssigneeIDCleared() bool {
	_, ok := m.clearedFields[ticket.FieldAssigneeID]
	return ok
}

// ResetAssigneeID resets all changes to the "assignee_id" field.
func (m *TicketMutation) ResetAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	delete(m.clearedFields, ticket.FieldAssigneeID)
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TicketMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TicketMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the TicketMutation builder.
func (m *TicketMutation) Where(ps ...predicate.Ticket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ticket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ticket).
func (m *TicketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.title != nil {
		fields = append(fields, ticket.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, ticket.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, ticket.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, ticket.FieldPriority)
	}
	if m.ticket_number != nil {
		fields = append(fields, ticket.FieldTicketNumber)
	}
	if m.requester_id != nil {
		fields = append(fields, ticket.FieldRequesterID)
	}
	if m.assignee_id != nil {
		fields = append(fields, ticket.FieldAssigneeID)
	}
	if m.tenant_id != nil {
		fields = append(fields, ticket.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, ticket.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ticket.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldTitle:
		return m.Title()
	case ticket.FieldDescription:
		return m.Description()
	case ticket.FieldStatus:
		return m.Status()
	case ticket.FieldPriority:
		return m.Priority()
	case ticket.FieldTicketNumber:
		return m.TicketNumber()
	case ticket.FieldRequesterID:
		return m.RequesterID()
	case ticket.FieldAssigneeID:
		return m.AssigneeID()
	case ticket.FieldTenantID:
		return m.TenantID()
	case ticket.FieldCreatedAt:
		return m.CreatedAt()
	case ticket.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticket.FieldTitle:
		return m.OldTitle(ctx)
	case ticket.FieldDescription:
		return m.OldDescription(ctx)
	case ticket.FieldStatus:
		return m.OldStatus(ctx)
	case ticket.FieldPriority:
		return m.OldPriority(ctx)
	case ticket.FieldTicketNumber:
		return m.OldTicketNumber(ctx)
	case ticket.FieldRequesterID:
		return m.OldRequesterID(ctx)
	case ticket.FieldAssigneeID:
		return m.OldAssigneeID(ctx)
	case ticket.FieldTenantID:
		return m.OldTenantID(ctx)
	case ticket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ticket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case ticket.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ticket.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ticket.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case ticket.FieldTicketNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketNumber(v)
		return nil
	case ticket.FieldRequesterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequesterID(v)
		return nil
	case ticket.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeID(v)
		return nil
	case ticket.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ticket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketMutation) AddedFields() []string {
	var fields []string
	if m.addrequester_id != nil {
		fields = append(fields, ticket.FieldRequesterID)
	}
	if m.addassignee_id != nil {
		fields = append(fields, ticket.FieldAssigneeID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, ticket.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldRequesterID:
		return m.AddedRequesterID()
	case ticket.FieldAssigneeID:
		return m.AddedAssigneeID()
	case ticket.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldRequesterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequesterID(v)
		return nil
	case ticket.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssigneeID(v)
		return nil
	case ticket.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticket.FieldDescription) {
		fields = append(fields, ticket.FieldDescription)
	}
	if m.FieldCleared(ticket.FieldAssigneeID) {
		fields = append(fields, ticket.FieldAssigneeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketMutation) ClearField(name string) error {
	switch name {
	case ticket.FieldDescription:
		m.ClearDescription()
		return nil
	case ticket.FieldAssigneeID:
		m.ClearAssigneeID()
		return nil
	}
	return fmt.Errorf("unknown Ticket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketMutation) ResetField(name string) error {
	switch name {
	case ticket.FieldTitle:
		m.ResetTitle()
		return nil
	case ticket.FieldDescription:
		m.ResetDescription()
		return nil
	case ticket.FieldStatus:
		m.ResetStatus()
		return nil
	case ticket.FieldPriority:
		m.ResetPriority()
		return nil
	case ticket.FieldTicketNumber:
		m.ResetTicketNumber()
		return nil
	case ticket.FieldRequesterID:
		m.ResetRequesterID()
		return nil
	case ticket.FieldAssigneeID:
		m.ResetAssigneeID()
		return nil
	case ticket.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ticket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Ticket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Ticket edge %s", name)
}

// ToolInvocationMutation represents an operation that mutates the ToolInvocation nodes in the graph.
type ToolInvocationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	tool_name           *string
	arguments           *string
	result              *string
	status              *string
	request_id          *string
	needs_approval      *bool
	approval_state      *string
	approval_reason     *string
	approved_by         *int
	addapproved_by      *int
	approved_at         *time.Time
	dry_run             *bool
	error               *string
	clearedFields       map[string]struct{}
	conversation        *int
	clearedconversation bool
	done                bool
	oldValue            func(context.Context) (*ToolInvocation, error)
	predicates          []predicate.ToolInvocation
}

var _ ent.Mutation = (*ToolInvocationMutation)(nil)

// toolinvocationOption allows management of the mutation configuration using functional options.
type toolinvocationOption func(*ToolInvocationMutation)

// newToolInvocationMutation creates new mutation for the ToolInvocation entity.
func newToolInvocationMutation(c config, op Op, opts ...toolinvocationOption) *ToolInvocationMutation {
	m := &ToolInvocationMutation{
		config:        c,
		op:            op,
		typ:           TypeToolInvocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolInvocationID sets the ID field of the mutation.
func withToolInvocationID(id int) toolinvocationOption {
	return func(m *ToolInvocationMutation) {
		var (
			err   error
			once  sync.Once
			value *ToolInvocation
		)
		m.oldValue = func(ctx context.Context) (*ToolInvocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ToolInvocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToolInvocation sets the old ToolInvocation of the mutation.
func withToolInvocation(node *ToolInvocation) toolinvocationOption {
	return func(m *ToolInvocationMutation) {
		m.oldValue = func(context.Context) (*ToolInvocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolInvocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolInvocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToolInvocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToolInvocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ToolInvocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ToolInvocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ToolInvocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ToolInvocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetConversationID sets the "conversation_id" field.
func (m *ToolInvocationMutation) SetConversationID(i int) {
	m.conversation = &i
}

// ConversationID returns the value of the "conversation_id" field in the mutation.
func (m *ToolInvocationMutation) ConversationID() (r int, exists bool) {
	v := m.conversation
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationID returns the old "conversation_id" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldConversationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationID: %w", err)
	}
	return oldValue.ConversationID, nil
}

// ResetConversationID resets all changes to the "conversation_id" field.
func (m *ToolInvocationMutation) ResetConversationID() {
	m.conversation = nil
}

// SetToolName sets the "tool_name" field.
func (m *ToolInvocationMutation) SetToolName(s string) {
	m.tool_name = &s
}

// ToolName returns the value of the "tool_name" field in the mutation.
func (m *ToolInvocationMutation) ToolName() (r string, exists bool) {
	v := m.tool_name
	if v == nil {
		return
	}
	return *v, true
}

// OldToolName returns the old "tool_name" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldToolName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToolName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToolName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolName: %w", err)
	}
	return oldValue.ToolName, nil
}

// ResetToolName resets all changes to the "tool_name" field.
func (m *ToolInvocationMutation) ResetToolName() {
	m.tool_name = nil
}

// SetArguments sets the "arguments" field.
func (m *ToolInvocationMutation) SetArguments(s string) {
	m.arguments = &s
}

// Arguments returns the value of the "arguments" field in the mutation.
func (m *ToolInvocationMutation) Arguments() (r string, exists bool) {
	v := m.arguments
	if v == nil {
		return
	}
	return *v, true
}

// OldArguments returns the old "arguments" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldArguments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArguments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArguments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArguments: %w", err)
	}
	return oldValue.Arguments, nil
}

// ResetArguments resets all changes to the "arguments" field.
func (m *ToolInvocationMutation) ResetArguments() {
	m.arguments = nil
}

// SetResult sets the "result" field.
func (m *ToolInvocationMutation) SetResult(s string) {
	m.result = &s
}

// Result returns the value of the "result" field in the mutation.
func (m *ToolInvocationMutation) Result() (r string, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldResult(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ClearResult clears the value of the "result" field.
func (m *ToolInvocationMutation) ClearResult() {
	m.result = nil
	m.clearedFields[toolinvocation.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *ToolInvocationMutation) ResultCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *ToolInvocationMutation) ResetResult() {
	m.result = nil
	delete(m.clearedFields, toolinvocation.FieldResult)
}

// SetStatus sets the "status" field.
func (m *ToolInvocationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ToolInvocationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ToolInvocationMutation) ResetStatus() {
	m.status = nil
}

// SetRequestID sets the "request_id" field.
func (m *ToolInvocationMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *ToolInvocationMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *ToolInvocationMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[toolinvocation.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *ToolInvocationMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *ToolInvocationMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, toolinvocation.FieldRequestID)
}

// SetNeedsApproval sets the "needs_approval" field.
func (m *ToolInvocationMutation) SetNeedsApproval(b bool) {
	m.needs_approval = &b
}

// NeedsApproval returns the value of the "needs_approval" field in the mutation.
func (m *ToolInvocationMutation) NeedsApproval() (r bool, exists bool) {
	v := m.needs_approval
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedsApproval returns the old "needs_approval" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldNeedsApproval(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNeedsApproval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNeedsApproval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedsApproval: %w", err)
	}
	return oldValue.NeedsApproval, nil
}

// ResetNeedsApproval resets all changes to the "needs_approval" field.
func (m *ToolInvocationMutation) ResetNeedsApproval() {
	m.needs_approval = nil
}

// SetApprovalState sets the "approval_state" field.
func (m *ToolInvocationMutation) SetApprovalState(s string) {
	m.approval_state = &s
}

// ApprovalState returns the value of the "approval_state" field in the mutation.
func (m *ToolInvocationMutation) ApprovalState() (r string, exists bool) {
	v := m.approval_state
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalState returns the old "approval_state" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldApprovalState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalState: %w", err)
	}
	return oldValue.ApprovalState, nil
}

// ResetApprovalState resets all changes to the "approval_state" field.
func (m *ToolInvocationMutation) ResetApprovalState() {
	m.approval_state = nil
}

// SetApprovalReason sets the "approval_reason" field.
func (m *ToolInvocationMutation) SetApprovalReason(s string) {
	m.approval_reason = &s
}

// ApprovalReason returns the value of the "approval_reason" field in the mutation.
func (m *ToolInvocationMutation) ApprovalReason() (r string, exists bool) {
	v := m.approval_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalReason returns the old "approval_reason" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldApprovalReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalReason: %w", err)
	}
	return oldValue.ApprovalReason, nil
}

// ResetApprovalReason resets all changes to the "approval_reason" field.
func (m *ToolInvocationMutation) ResetApprovalReason() {
	m.approval_reason = nil
}

// SetApprovedBy sets the "approved_by" field.
func (m *ToolInvocationMutation) SetApprovedBy(i int) {
	m.approved_by = &i
	m.addapproved_by = nil
}

// ApprovedBy returns the value of the "approved_by" field in the mutation.
func (m *ToolInvocationMutation) ApprovedBy() (r int, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedBy returns the old "approved_by" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldApprovedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedBy: %w", err)
	}
	return oldValue.ApprovedBy, nil
}

// AddApprovedBy adds i to the "approved_by" field.
func (m *ToolInvocationMutation) AddApprovedBy(i int) {
	if m.addapproved_by != nil {
		*m.addapproved_by += i
	} else {
		m.addapproved_by = &i
	}
}

// AddedApprovedBy returns the value that was added to the "approved_by" field in this mutation.
func (m *ToolInvocationMutation) AddedApprovedBy() (r int, exists bool) {
	v := m.addapproved_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearApprovedBy clears the value of the "approved_by" field.
func (m *ToolInvocationMutation) ClearApprovedBy() {
	m.approved_by = nil
	m.addapproved_by = nil
	m.clearedFields[toolinvocation.FieldApprovedBy] = struct{}{}
}

// ApprovedByCleared returns if the "approved_by" field was cleared in this mutation.
func (m *ToolInvocationMutation) ApprovedByCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldApprovedBy]
	return ok
}

// ResetApprovedBy resets all changes to the "approved_by" field.
func (m *ToolInvocationMutation) ResetApprovedBy() {
	m.approved_by = nil
	m.addapproved_by = nil
	delete(m.clearedFields, toolinvocation.FieldApprovedBy)
}

// SetApprovedAt sets the "approved_at" field.
func (m *ToolInvocationMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *ToolInvocationMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldApprovedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *ToolInvocationMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[toolinvocation.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *ToolInvocationMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *ToolInvocationMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, toolinvocation.FieldApprovedAt)
}

// SetDryRun sets the "dry_run" field.
func (m *ToolInvocationMutation) SetDryRun(b bool) {
	m.dry_run = &b
}

// DryRun returns the value of the "dry_run" field in the mutation.
func (m *ToolInvocationMutation) DryRun() (r bool, exists bool) {
	v := m.dry_run
	if v == nil {
		return
	}
	return *v, true
}

// OldDryRun returns the old "dry_run" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldDryRun(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDryRun is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDryRun requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDryRun: %w", err)
	}
	return oldValue.DryRun, nil
}

// ResetDryRun resets all changes to the "dry_run" field.
func (m *ToolInvocationMutation) ResetDryRun() {
	m.dry_run = nil
}

// SetError sets the "error" field.
func (m *ToolInvocationMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *ToolInvocationMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldError(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *ToolInvocationMutation) ClearError() {
	m.error = nil
	m.clearedFields[toolinvocation.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *ToolInvocationMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *ToolInvocationMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, toolinvocation.FieldError)
}

// ClearConversation clears the "conversation" edge to the Conversation entity.
func (m *ToolInvocationMutation) ClearConversation() {
	m.clearedconversation = true
	m.clearedFields[toolinvocation.FieldConversationID] = struct{}{}
}

// ConversationCleared reports if the "conversation" edge to the Conversation entity was cleared.
func (m *ToolInvocationMutation) ConversationCleared() bool {
	return m.clearedconversation
}

// ConversationIDs returns the "conversation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConversationID instead. It exists only for internal usage by the builders.
func (m *ToolInvocationMutation) ConversationIDs() (ids []int) {
	if id := m.conversation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConversation resets all changes to the "conversation" edge.
func (m *ToolInvocationMutation) ResetConversation() {
	m.conversation = nil
	m.clearedconversation = false
}

// Where appends a list predicates to the ToolInvocationMutation builder.
func (m *ToolInvocationMutation) Where(ps ...predicate.ToolInvocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToolInvocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToolInvocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ToolInvocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToolInvocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToolInvocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ToolInvocation).
func (m *ToolInvocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToolInvocationMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, toolinvocation.FieldCreatedAt)
	}
	if m.conversation != nil {
		fields = append(fields, toolinvocation.FieldConversationID)
	}
	if m.tool_name != nil {
		fields = append(fields, toolinvocation.FieldToolName)
	}
	if m.arguments != nil {
		fields = append(fields, toolinvocation.FieldArguments)
	}
	if m.result != nil {
		fields = append(fields, toolinvocation.FieldResult)
	}
	if m.status != nil {
		fields = append(fields, toolinvocation.FieldStatus)
	}
	if m.request_id != nil {
		fields = append(fields, toolinvocation.FieldRequestID)
	}
	if m.needs_approval != nil {
		fields = append(fields, toolinvocation.FieldNeedsApproval)
	}
	if m.approval_state != nil {
		fields = append(fields, toolinvocation.FieldApprovalState)
	}
	if m.approval_reason != nil {
		fields = append(fields, toolinvocation.FieldApprovalReason)
	}
	if m.approved_by != nil {
		fields = append(fields, toolinvocation.FieldApprovedBy)
	}
	if m.approved_at != nil {
		fields = append(fields, toolinvocation.FieldApprovedAt)
	}
	if m.dry_run != nil {
		fields = append(fields, toolinvocation.FieldDryRun)
	}
	if m.error != nil {
		fields = append(fields, toolinvocation.FieldError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToolInvocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case toolinvocation.FieldCreatedAt:
		return m.CreatedAt()
	case toolinvocation.FieldConversationID:
		return m.ConversationID()
	case toolinvocation.FieldToolName:
		return m.ToolName()
	case toolinvocation.FieldArguments:
		return m.Arguments()
	case toolinvocation.FieldResult:
		return m.Result()
	case toolinvocation.FieldStatus:
		return m.Status()
	case toolinvocation.FieldRequestID:
		return m.RequestID()
	case toolinvocation.FieldNeedsApproval:
		return m.NeedsApproval()
	case toolinvocation.FieldApprovalState:
		return m.ApprovalState()
	case toolinvocation.FieldApprovalReason:
		return m.ApprovalReason()
	case toolinvocation.FieldApprovedBy:
		return m.ApprovedBy()
	case toolinvocation.FieldApprovedAt:
		return m.ApprovedAt()
	case toolinvocation.FieldDryRun:
		return m.DryRun()
	case toolinvocation.FieldError:
		return m.Error()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToolInvocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case toolinvocation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case toolinvocation.FieldConversationID:
		return m.OldConversationID(ctx)
	case toolinvocation.FieldToolName:
		return m.OldToolName(ctx)
	case toolinvocation.FieldArguments:
		return m.OldArguments(ctx)
	case toolinvocation.FieldResult:
		return m.OldResult(ctx)
	case toolinvocation.FieldStatus:
		return m.OldStatus(ctx)
	case toolinvocation.FieldRequestID:
		return m.OldRequestID(ctx)
	case toolinvocation.FieldNeedsApproval:
		return m.OldNeedsApproval(ctx)
	case toolinvocation.FieldApprovalState:
		return m.OldApprovalState(ctx)
	case toolinvocation.FieldApprovalReason:
		return m.OldApprovalReason(ctx)
	case toolinvocation.FieldApprovedBy:
		return m.OldApprovedBy(ctx)
	case toolinvocation.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case toolinvocation.FieldDryRun:
		return m.OldDryRun(ctx)
	case toolinvocation.FieldError:
		return m.OldError(ctx)
	}
	return nil, fmt.Errorf("unknown ToolInvocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolInvocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case toolinvocation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case toolinvocation.FieldConversationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationID(v)
		return nil
	case toolinvocation.FieldToolName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolName(v)
		return nil
	case toolinvocation.FieldArguments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArguments(v)
		return nil
	case toolinvocation.FieldResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case toolinvocation.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case toolinvocation.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case toolinvocation.FieldNeedsApproval:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedsApproval(v)
		return nil
	case toolinvocation.FieldApprovalState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalState(v)
		return nil
	case toolinvocation.FieldApprovalReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalReason(v)
		return nil
	case toolinvocation.FieldApprovedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedBy(v)
		return nil
	case toolinvocation.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case toolinvocation.FieldDryRun:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDryRun(v)
		return nil
	case toolinvocation.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToolInvocationMutation) AddedFields() []string {
	var fields []string
	if m.addapproved_by != nil {
		fields = append(fields, toolinvocation.FieldApprovedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToolInvocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case toolinvocation.FieldApprovedBy:
		return m.AddedApprovedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolInvocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case toolinvocation.FieldApprovedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApprovedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToolInvocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(toolinvocation.FieldResult) {
		fields = append(fields, toolinvocation.FieldResult)
	}
	if m.FieldCleared(toolinvocation.FieldRequestID) {
		fields = append(fields, toolinvocation.FieldRequestID)
	}
	if m.FieldCleared(toolinvocation.FieldApprovedBy) {
		fields = append(fields, toolinvocation.FieldApprovedBy)
	}
	if m.FieldCleared(toolinvocation.FieldApprovedAt) {
		fields = append(fields, toolinvocation.FieldApprovedAt)
	}
	if m.FieldCleared(toolinvocation.FieldError) {
		fields = append(fields, toolinvocation.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToolInvocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolInvocationMutation) ClearField(name string) error {
	switch name {
	case toolinvocation.FieldResult:
		m.ClearResult()
		return nil
	case toolinvocation.FieldRequestID:
		m.ClearRequestID()
		return nil
	case toolinvocation.FieldApprovedBy:
		m.ClearApprovedBy()
		return nil
	case toolinvocation.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case toolinvocation.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToolInvocationMutation) ResetField(name string) error {
	switch name {
	case toolinvocation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case toolinvocation.FieldConversationID:
		m.ResetConversationID()
		return nil
	case toolinvocation.FieldToolName:
		m.ResetToolName()
		return nil
	case toolinvocation.FieldArguments:
		m.ResetArguments()
		return nil
	case toolinvocation.FieldResult:
		m.ResetResult()
		return nil
	case toolinvocation.FieldStatus:
		m.ResetStatus()
		return nil
	case toolinvocation.FieldRequestID:
		m.ResetRequestID()
		return nil
	case toolinvocation.FieldNeedsApproval:
		m.ResetNeedsApproval()
		return nil
	case toolinvocation.FieldApprovalState:
		m.ResetApprovalState()
		return nil
	case toolinvocation.FieldApprovalReason:
		m.ResetApprovalReason()
		return nil
	case toolinvocation.FieldApprovedBy:
		m.ResetApprovedBy()
		return nil
	case toolinvocation.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case toolinvocation.FieldDryRun:
		m.ResetDryRun()
		return nil
	case toolinvocation.FieldError:
		m.ResetError()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToolInvocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.conversation != nil {
		edges = append(edges, toolinvocation.EdgeConversation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToolInvocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case toolinvocation.EdgeConversation:
		if id := m.conversation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToolInvocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToolInvocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToolInvocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconversation {
		edges = append(edges, toolinvocation.EdgeConversation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToolInvocationMutation) EdgeCleared(name string) bool {
	switch name {
	case toolinvocation.EdgeConversation:
		return m.clearedconversation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToolInvocationMutation) ClearEdge(name string) error {
	switch name {
	case toolinvocation.EdgeConversation:
		m.ClearConversation()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToolInvocationMutation) ResetEdge(name string) error {
	switch name {
	case toolinvocation.EdgeConversation:
		m.ResetConversation()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	username      *string
	email         *string
	name          *string
	department    *string
	phone         *string
	password_hash *string
	active        *bool
	tenant_id     *int
	addtenant_id  *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetDepartment sets the "department" field.
func (m *UserMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the value of the "department" field in the mutation.
func (m *UserMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old "department" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ClearDepartment clears the value of the "department" field.
func (m *UserMutation) ClearDepartment() {
	m.department = nil
	m.clearedFields[user.FieldDepartment] = struct{}{}
}

// DepartmentCleared returns if the "department" field was cleared in this mutation.
func (m *UserMutation) DepartmentCleared() bool {
	_, ok := m.clearedFields[user.FieldDepartment]
	return ok
}

// ResetDepartment resets all changes to the "department" field.
func (m *UserMutation) ResetDepartment() {
	m.department = nil
	delete(m.clearedFields, user.FieldDepartment)
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *UserMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *UserMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *UserMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.department != nil {
		fields = append(fields, user.FieldDepartment)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	if m.tenant_id != nil {
		fields = append(fields, user.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldDepartment:
		return m.Department()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldActive:
		return m.Active()
	case user.FieldTenantID:
		return m.TenantID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldDepartment:
		return m.OldDepartment(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	case user.FieldTenantID:
		return m.OldTenantID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case user.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, user.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDepartment) {
		fields = append(fields, user.FieldDepartment)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDepartment:
		m.ClearDepartment()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldDepartment:
		m.ResetDepartment()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	case user.FieldTenantID:
		m.ResetTenantID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
