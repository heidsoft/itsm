// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"itsm-backend/ent/application"
	"itsm-backend/ent/approvalrecord"
	"itsm-backend/ent/approvalworkflow"
	"itsm-backend/ent/auditlog"
	"itsm-backend/ent/change"
	"itsm-backend/ent/ciattributedefinition"
	"itsm-backend/ent/cirelationship"
	"itsm-backend/ent/citype"
	"itsm-backend/ent/configurationitem"
	"itsm-backend/ent/conversation"
	"itsm-backend/ent/department"
	"itsm-backend/ent/incident"
	"itsm-backend/ent/incidentalert"
	"itsm-backend/ent/incidentevent"
	"itsm-backend/ent/incidentmetric"
	"itsm-backend/ent/incidentrule"
	"itsm-backend/ent/incidentruleexecution"
	"itsm-backend/ent/knowledgearticle"
	"itsm-backend/ent/message"
	"itsm-backend/ent/microservice"
	"itsm-backend/ent/notification"
	"itsm-backend/ent/predicate"
	"itsm-backend/ent/problem"
	"itsm-backend/ent/processdefinition"
	"itsm-backend/ent/processdeployment"
	"itsm-backend/ent/processexecutionhistory"
	"itsm-backend/ent/processinstance"
	"itsm-backend/ent/processtask"
	"itsm-backend/ent/processvariable"
	"itsm-backend/ent/project"
	"itsm-backend/ent/prompttemplate"
	"itsm-backend/ent/rootcauseanalysis"
	"itsm-backend/ent/servicecatalog"
	"itsm-backend/ent/servicerequest"
	"itsm-backend/ent/slaalerthistory"
	"itsm-backend/ent/slaalertrule"
	"itsm-backend/ent/sladefinition"
	"itsm-backend/ent/slametric"
	"itsm-backend/ent/slaviolation"
	"itsm-backend/ent/tag"
	"itsm-backend/ent/team"
	"itsm-backend/ent/tenant"
	"itsm-backend/ent/ticket"
	"itsm-backend/ent/ticketassignmentrule"
	"itsm-backend/ent/ticketattachment"
	"itsm-backend/ent/ticketautomationrule"
	"itsm-backend/ent/ticketcategory"
	"itsm-backend/ent/ticketcomment"
	"itsm-backend/ent/ticketnotification"
	"itsm-backend/ent/tickettag"
	"itsm-backend/ent/tickettemplate"
	"itsm-backend/ent/ticketview"
	"itsm-backend/ent/toolinvocation"
	"itsm-backend/ent/user"
	"itsm-backend/ent/workflow"
	"itsm-backend/ent/workflowinstance"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApplication             = "Application"
	TypeApprovalRecord          = "ApprovalRecord"
	TypeApprovalWorkflow        = "ApprovalWorkflow"
	TypeAuditLog                = "AuditLog"
	TypeCIAttributeDefinition   = "CIAttributeDefinition"
	TypeCIRelationship          = "CIRelationship"
	TypeCIType                  = "CIType"
	TypeChange                  = "Change"
	TypeConfigurationItem       = "ConfigurationItem"
	TypeConversation            = "Conversation"
	TypeDepartment              = "Department"
	TypeIncident                = "Incident"
	TypeIncidentAlert           = "IncidentAlert"
	TypeIncidentEvent           = "IncidentEvent"
	TypeIncidentMetric          = "IncidentMetric"
	TypeIncidentRule            = "IncidentRule"
	TypeIncidentRuleExecution   = "IncidentRuleExecution"
	TypeKnowledgeArticle        = "KnowledgeArticle"
	TypeMessage                 = "Message"
	TypeMicroservice            = "Microservice"
	TypeNotification            = "Notification"
	TypeProblem                 = "Problem"
	TypeProcessDefinition       = "ProcessDefinition"
	TypeProcessDeployment       = "ProcessDeployment"
	TypeProcessExecutionHistory = "ProcessExecutionHistory"
	TypeProcessInstance         = "ProcessInstance"
	TypeProcessTask             = "ProcessTask"
	TypeProcessVariable         = "ProcessVariable"
	TypeProject                 = "Project"
	TypePromptTemplate          = "PromptTemplate"
	TypeRootCauseAnalysis       = "RootCauseAnalysis"
	TypeSLAAlertHistory         = "SLAAlertHistory"
	TypeSLAAlertRule            = "SLAAlertRule"
	TypeSLADefinition           = "SLADefinition"
	TypeSLAMetric               = "SLAMetric"
	TypeSLAViolation            = "SLAViolation"
	TypeServiceCatalog          = "ServiceCatalog"
	TypeServiceRequest          = "ServiceRequest"
	TypeTag                     = "Tag"
	TypeTeam                    = "Team"
	TypeTenant                  = "Tenant"
	TypeTicket                  = "Ticket"
	TypeTicketAssignmentRule    = "TicketAssignmentRule"
	TypeTicketAttachment        = "TicketAttachment"
	TypeTicketAutomationRule    = "TicketAutomationRule"
	TypeTicketCategory          = "TicketCategory"
	TypeTicketComment           = "TicketComment"
	TypeTicketNotification      = "TicketNotification"
	TypeTicketTag               = "TicketTag"
	TypeTicketTemplate          = "TicketTemplate"
	TypeTicketView              = "TicketView"
	TypeToolInvocation          = "ToolInvocation"
	TypeUser                    = "User"
	TypeWorkflow                = "Workflow"
	TypeWorkflowInstance        = "WorkflowInstance"
)

// ApplicationMutation represents an operation that mutates the Application nodes in the graph.
type ApplicationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	code                 *string
	description          *string
	_type                *string
	status               *string
	owner_id             *int
	addowner_id          *int
	tenant_id            *int
	addtenant_id         *int
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	project              *int
	clearedproject       bool
	microservices        map[int]struct{}
	removedmicroservices map[int]struct{}
	clearedmicroservices bool
	tags                 map[int]struct{}
	removedtags          map[int]struct{}
	clearedtags          bool
	done                 bool
	oldValue             func(context.Context) (*Application, error)
	predicates           []predicate.Application
}

var _ ent.Mutation = (*ApplicationMutation)(nil)

// applicationOption allows management of the mutation configuration using functional options.
type applicationOption func(*ApplicationMutation)

// newApplicationMutation creates new mutation for the Application entity.
func newApplicationMutation(c config, op Op, opts ...applicationOption) *ApplicationMutation {
	m := &ApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationID sets the ID field of the mutation.
func withApplicationID(id int) applicationOption {
	return func(m *ApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Application
		)
		m.oldValue = func(ctx context.Context) (*Application, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Application.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplication sets the old Application of the mutation.
func withApplication(node *Application) applicationOption {
	return func(m *ApplicationMutation) {
		m.oldValue = func(context.Context) (*Application, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Application.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ApplicationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApplicationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApplicationMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *ApplicationMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ApplicationMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ApplicationMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *ApplicationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ApplicationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ApplicationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[application.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ApplicationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[application.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ApplicationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, application.FieldDescription)
}

// SetType sets the "type" field.
func (m *ApplicationMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ApplicationMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ApplicationMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *ApplicationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ApplicationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ApplicationMutation) ResetStatus() {
	m.status = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *ApplicationMutation) SetOwnerID(i int) {
	m.owner_id = &i
	m.addowner_id = nil
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ApplicationMutation) OwnerID() (r int, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldOwnerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// AddOwnerID adds i to the "owner_id" field.
func (m *ApplicationMutation) AddOwnerID(i int) {
	if m.addowner_id != nil {
		*m.addowner_id += i
	} else {
		m.addowner_id = &i
	}
}

// AddedOwnerID returns the value that was added to the "owner_id" field in this mutation.
func (m *ApplicationMutation) AddedOwnerID() (r int, exists bool) {
	v := m.addowner_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *ApplicationMutation) ClearOwnerID() {
	m.owner_id = nil
	m.addowner_id = nil
	m.clearedFields[application.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *ApplicationMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[application.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ApplicationMutation) ResetOwnerID() {
	m.owner_id = nil
	m.addowner_id = nil
	delete(m.clearedFields, application.FieldOwnerID)
}

// SetProjectID sets the "project_id" field.
func (m *ApplicationMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ApplicationMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *ApplicationMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[application.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *ApplicationMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[application.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ApplicationMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, application.FieldProjectID)
}

// SetTenantID sets the "tenant_id" field.
func (m *ApplicationMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ApplicationMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ApplicationMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ApplicationMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ApplicationMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ApplicationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApplicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApplicationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApplicationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApplicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApplicationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ApplicationMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[application.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ApplicationMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ApplicationMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddMicroserviceIDs adds the "microservices" edge to the Microservice entity by ids.
func (m *ApplicationMutation) AddMicroserviceIDs(ids ...int) {
	if m.microservices == nil {
		m.microservices = make(map[int]struct{})
	}
	for i := range ids {
		m.microservices[ids[i]] = struct{}{}
	}
}

// ClearMicroservices clears the "microservices" edge to the Microservice entity.
func (m *ApplicationMutation) ClearMicroservices() {
	m.clearedmicroservices = true
}

// MicroservicesCleared reports if the "microservices" edge to the Microservice entity was cleared.
func (m *ApplicationMutation) MicroservicesCleared() bool {
	return m.clearedmicroservices
}

// RemoveMicroserviceIDs removes the "microservices" edge to the Microservice entity by IDs.
func (m *ApplicationMutation) RemoveMicroserviceIDs(ids ...int) {
	if m.removedmicroservices == nil {
		m.removedmicroservices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.microservices, ids[i])
		m.removedmicroservices[ids[i]] = struct{}{}
	}
}

// RemovedMicroservices returns the removed IDs of the "microservices" edge to the Microservice entity.
func (m *ApplicationMutation) RemovedMicroservicesIDs() (ids []int) {
	for id := range m.removedmicroservices {
		ids = append(ids, id)
	}
	return
}

// MicroservicesIDs returns the "microservices" edge IDs in the mutation.
func (m *ApplicationMutation) MicroservicesIDs() (ids []int) {
	for id := range m.microservices {
		ids = append(ids, id)
	}
	return
}

// ResetMicroservices resets all changes to the "microservices" edge.
func (m *ApplicationMutation) ResetMicroservices() {
	m.microservices = nil
	m.clearedmicroservices = false
	m.removedmicroservices = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *ApplicationMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ApplicationMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ApplicationMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *ApplicationMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *ApplicationMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ApplicationMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ApplicationMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the ApplicationMutation builder.
func (m *ApplicationMutation) Where(ps ...predicate.Application) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Application, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Application).
func (m *ApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, application.FieldName)
	}
	if m.code != nil {
		fields = append(fields, application.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, application.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, application.FieldType)
	}
	if m.status != nil {
		fields = append(fields, application.FieldStatus)
	}
	if m.owner_id != nil {
		fields = append(fields, application.FieldOwnerID)
	}
	if m.project != nil {
		fields = append(fields, application.FieldProjectID)
	}
	if m.tenant_id != nil {
		fields = append(fields, application.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, application.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, application.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case application.FieldName:
		return m.Name()
	case application.FieldCode:
		return m.Code()
	case application.FieldDescription:
		return m.Description()
	case application.FieldType:
		return m.GetType()
	case application.FieldStatus:
		return m.Status()
	case application.FieldOwnerID:
		return m.OwnerID()
	case application.FieldProjectID:
		return m.ProjectID()
	case application.FieldTenantID:
		return m.TenantID()
	case application.FieldCreatedAt:
		return m.CreatedAt()
	case application.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case application.FieldName:
		return m.OldName(ctx)
	case application.FieldCode:
		return m.OldCode(ctx)
	case application.FieldDescription:
		return m.OldDescription(ctx)
	case application.FieldType:
		return m.OldType(ctx)
	case application.FieldStatus:
		return m.OldStatus(ctx)
	case application.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case application.FieldProjectID:
		return m.OldProjectID(ctx)
	case application.FieldTenantID:
		return m.OldTenantID(ctx)
	case application.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case application.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Application field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case application.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case application.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case application.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case application.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case application.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case application.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case application.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case application.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case application.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case application.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicationMutation) AddedFields() []string {
	var fields []string
	if m.addowner_id != nil {
		fields = append(fields, application.FieldOwnerID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, application.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case application.FieldOwnerID:
		return m.AddedOwnerID()
	case application.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case application.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerID(v)
		return nil
	case application.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Application numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(application.FieldDescription) {
		fields = append(fields, application.FieldDescription)
	}
	if m.FieldCleared(application.FieldOwnerID) {
		fields = append(fields, application.FieldOwnerID)
	}
	if m.FieldCleared(application.FieldProjectID) {
		fields = append(fields, application.FieldProjectID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationMutation) ClearField(name string) error {
	switch name {
	case application.FieldDescription:
		m.ClearDescription()
		return nil
	case application.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case application.FieldProjectID:
		m.ClearProjectID()
		return nil
	}
	return fmt.Errorf("unknown Application nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicationMutation) ResetField(name string) error {
	switch name {
	case application.FieldName:
		m.ResetName()
		return nil
	case application.FieldCode:
		m.ResetCode()
		return nil
	case application.FieldDescription:
		m.ResetDescription()
		return nil
	case application.FieldType:
		m.ResetType()
		return nil
	case application.FieldStatus:
		m.ResetStatus()
		return nil
	case application.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case application.FieldProjectID:
		m.ResetProjectID()
		return nil
	case application.FieldTenantID:
		m.ResetTenantID()
		return nil
	case application.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case application.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, application.EdgeProject)
	}
	if m.microservices != nil {
		edges = append(edges, application.EdgeMicroservices)
	}
	if m.tags != nil {
		edges = append(edges, application.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeMicroservices:
		ids := make([]ent.Value, 0, len(m.microservices))
		for id := range m.microservices {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmicroservices != nil {
		edges = append(edges, application.EdgeMicroservices)
	}
	if m.removedtags != nil {
		edges = append(edges, application.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeMicroservices:
		ids := make([]ent.Value, 0, len(m.removedmicroservices))
		for id := range m.removedmicroservices {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, application.EdgeProject)
	}
	if m.clearedmicroservices {
		edges = append(edges, application.EdgeMicroservices)
	}
	if m.clearedtags {
		edges = append(edges, application.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case application.EdgeProject:
		return m.clearedproject
	case application.EdgeMicroservices:
		return m.clearedmicroservices
	case application.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicationMutation) ClearEdge(name string) error {
	switch name {
	case application.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Application unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicationMutation) ResetEdge(name string) error {
	switch name {
	case application.EdgeProject:
		m.ResetProject()
		return nil
	case application.EdgeMicroservices:
		m.ResetMicroservices()
		return nil
	case application.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Application edge %s", name)
}

// ApprovalRecordMutation represents an operation that mutates the ApprovalRecord nodes in the graph.
type ApprovalRecordMutation struct {
	config
	op               Op
	typ              string
	id               *int
	ticket_number    *string
	ticket_title     *string
	workflow_name    *string
	current_level    *int
	addcurrent_level *int
	total_levels     *int
	addtotal_levels  *int
	approver_id      *int
	addapprover_id   *int
	approver_name    *string
	status           *string
	action           *string
	comment          *string
	tenant_id        *int
	addtenant_id     *int
	created_at       *time.Time
	processed_at     *time.Time
	clearedFields    map[string]struct{}
	ticket           *int
	clearedticket    bool
	workflow         *int
	clearedworkflow  bool
	done             bool
	oldValue         func(context.Context) (*ApprovalRecord, error)
	predicates       []predicate.ApprovalRecord
}

var _ ent.Mutation = (*ApprovalRecordMutation)(nil)

// approvalrecordOption allows management of the mutation configuration using functional options.
type approvalrecordOption func(*ApprovalRecordMutation)

// newApprovalRecordMutation creates new mutation for the ApprovalRecord entity.
func newApprovalRecordMutation(c config, op Op, opts ...approvalrecordOption) *ApprovalRecordMutation {
	m := &ApprovalRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeApprovalRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApprovalRecordID sets the ID field of the mutation.
func withApprovalRecordID(id int) approvalrecordOption {
	return func(m *ApprovalRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *ApprovalRecord
		)
		m.oldValue = func(ctx context.Context) (*ApprovalRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApprovalRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApprovalRecord sets the old ApprovalRecord of the mutation.
func withApprovalRecord(node *ApprovalRecord) approvalrecordOption {
	return func(m *ApprovalRecordMutation) {
		m.oldValue = func(context.Context) (*ApprovalRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApprovalRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApprovalRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApprovalRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApprovalRecordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApprovalRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTicketID sets the "ticket_id" field.
func (m *ApprovalRecordMutation) SetTicketID(i int) {
	m.ticket = &i
}

// TicketID returns the value of the "ticket_id" field in the mutation.
func (m *ApprovalRecordMutation) TicketID() (r int, exists bool) {
	v := m.ticket
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketID returns the old "ticket_id" field's value of the ApprovalRecord entity.
// If the ApprovalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalRecordMutation) OldTicketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketID: %w", err)
	}
	return oldValue.TicketID, nil
}

// ResetTicketID resets all changes to the "ticket_id" field.
func (m *ApprovalRecordMutation) ResetTicketID() {
	m.ticket = nil
}

// SetTicketNumber sets the "ticket_number" field.
func (m *ApprovalRecordMutation) SetTicketNumber(s string) {
	m.ticket_number = &s
}

// TicketNumber returns the value of the "ticket_number" field in the mutation.
func (m *ApprovalRecordMutation) TicketNumber() (r string, exists bool) {
	v := m.ticket_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketNumber returns the old "ticket_number" field's value of the ApprovalRecord entity.
// If the ApprovalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalRecordMutation) OldTicketNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketNumber: %w", err)
	}
	return oldValue.TicketNumber, nil
}

// ResetTicketNumber resets all changes to the "ticket_number" field.
func (m *ApprovalRecordMutation) ResetTicketNumber() {
	m.ticket_number = nil
}

// SetTicketTitle sets the "ticket_title" field.
func (m *ApprovalRecordMutation) SetTicketTitle(s string) {
	m.ticket_title = &s
}

// TicketTitle returns the value of the "ticket_title" field in the mutation.
func (m *ApprovalRecordMutation) TicketTitle() (r string, exists bool) {
	v := m.ticket_title
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketTitle returns the old "ticket_title" field's value of the ApprovalRecord entity.
// If the ApprovalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalRecordMutation) OldTicketTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketTitle: %w", err)
	}
	return oldValue.TicketTitle, nil
}

// ResetTicketTitle resets all changes to the "ticket_title" field.
func (m *ApprovalRecordMutation) ResetTicketTitle() {
	m.ticket_title = nil
}

// SetWorkflowID sets the "workflow_id" field.
func (m *ApprovalRecordMutation) SetWorkflowID(i int) {
	m.workflow = &i
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *ApprovalRecordMutation) WorkflowID() (r int, exists bool) {
	v := m.workflow
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the ApprovalRecord entity.
// If the ApprovalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalRecordMutation) OldWorkflowID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *ApprovalRecordMutation) ResetWorkflowID() {
	m.workflow = nil
}

// SetWorkflowName sets the "workflow_name" field.
func (m *ApprovalRecordMutation) SetWorkflowName(s string) {
	m.workflow_name = &s
}

// WorkflowName returns the value of the "workflow_name" field in the mutation.
func (m *ApprovalRecordMutation) WorkflowName() (r string, exists bool) {
	v := m.workflow_name
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowName returns the old "workflow_name" field's value of the ApprovalRecord entity.
// If the ApprovalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalRecordMutation) OldWorkflowName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowName: %w", err)
	}
	return oldValue.WorkflowName, nil
}

// ResetWorkflowName resets all changes to the "workflow_name" field.
func (m *ApprovalRecordMutation) ResetWorkflowName() {
	m.workflow_name = nil
}

// SetCurrentLevel sets the "current_level" field.
func (m *ApprovalRecordMutation) SetCurrentLevel(i int) {
	m.current_level = &i
	m.addcurrent_level = nil
}

// CurrentLevel returns the value of the "current_level" field in the mutation.
func (m *ApprovalRecordMutation) CurrentLevel() (r int, exists bool) {
	v := m.current_level
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentLevel returns the old "current_level" field's value of the ApprovalRecord entity.
// If the ApprovalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalRecordMutation) OldCurrentLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentLevel: %w", err)
	}
	return oldValue.CurrentLevel, nil
}

// AddCurrentLevel adds i to the "current_level" field.
func (m *ApprovalRecordMutation) AddCurrentLevel(i int) {
	if m.addcurrent_level != nil {
		*m.addcurrent_level += i
	} else {
		m.addcurrent_level = &i
	}
}

// AddedCurrentLevel returns the value that was added to the "current_level" field in this mutation.
func (m *ApprovalRecordMutation) AddedCurrentLevel() (r int, exists bool) {
	v := m.addcurrent_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentLevel resets all changes to the "current_level" field.
func (m *ApprovalRecordMutation) ResetCurrentLevel() {
	m.current_level = nil
	m.addcurrent_level = nil
}

// SetTotalLevels sets the "total_levels" field.
func (m *ApprovalRecordMutation) SetTotalLevels(i int) {
	m.total_levels = &i
	m.addtotal_levels = nil
}

// TotalLevels returns the value of the "total_levels" field in the mutation.
func (m *ApprovalRecordMutation) TotalLevels() (r int, exists bool) {
	v := m.total_levels
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalLevels returns the old "total_levels" field's value of the ApprovalRecord entity.
// If the ApprovalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalRecordMutation) OldTotalLevels(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalLevels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalLevels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalLevels: %w", err)
	}
	return oldValue.TotalLevels, nil
}

// AddTotalLevels adds i to the "total_levels" field.
func (m *ApprovalRecordMutation) AddTotalLevels(i int) {
	if m.addtotal_levels != nil {
		*m.addtotal_levels += i
	} else {
		m.addtotal_levels = &i
	}
}

// AddedTotalLevels returns the value that was added to the "total_levels" field in this mutation.
func (m *ApprovalRecordMutation) AddedTotalLevels() (r int, exists bool) {
	v := m.addtotal_levels
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalLevels resets all changes to the "total_levels" field.
func (m *ApprovalRecordMutation) ResetTotalLevels() {
	m.total_levels = nil
	m.addtotal_levels = nil
}

// SetApproverID sets the "approver_id" field.
func (m *ApprovalRecordMutation) SetApproverID(i int) {
	m.approver_id = &i
	m.addapprover_id = nil
}

// ApproverID returns the value of the "approver_id" field in the mutation.
func (m *ApprovalRecordMutation) ApproverID() (r int, exists bool) {
	v := m.approver_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApproverID returns the old "approver_id" field's value of the ApprovalRecord entity.
// If the ApprovalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalRecordMutation) OldApproverID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproverID: %w", err)
	}
	return oldValue.ApproverID, nil
}

// AddApproverID adds i to the "approver_id" field.
func (m *ApprovalRecordMutation) AddApproverID(i int) {
	if m.addapprover_id != nil {
		*m.addapprover_id += i
	} else {
		m.addapprover_id = &i
	}
}

// AddedApproverID returns the value that was added to the "approver_id" field in this mutation.
func (m *ApprovalRecordMutation) AddedApproverID() (r int, exists bool) {
	v := m.addapprover_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetApproverID resets all changes to the "approver_id" field.
func (m *ApprovalRecordMutation) ResetApproverID() {
	m.approver_id = nil
	m.addapprover_id = nil
}

// SetApproverName sets the "approver_name" field.
func (m *ApprovalRecordMutation) SetApproverName(s string) {
	m.approver_name = &s
}

// ApproverName returns the value of the "approver_name" field in the mutation.
func (m *ApprovalRecordMutation) ApproverName() (r string, exists bool) {
	v := m.approver_name
	if v == nil {
		return
	}
	return *v, true
}

// OldApproverName returns the old "approver_name" field's value of the ApprovalRecord entity.
// If the ApprovalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalRecordMutation) OldApproverName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproverName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproverName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproverName: %w", err)
	}
	return oldValue.ApproverName, nil
}

// ResetApproverName resets all changes to the "approver_name" field.
func (m *ApprovalRecordMutation) ResetApproverName() {
	m.approver_name = nil
}

// SetStatus sets the "status" field.
func (m *ApprovalRecordMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ApprovalRecordMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ApprovalRecord entity.
// If the ApprovalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalRecordMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ApprovalRecordMutation) ResetStatus() {
	m.status = nil
}

// SetAction sets the "action" field.
func (m *ApprovalRecordMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *ApprovalRecordMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the ApprovalRecord entity.
// If the ApprovalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalRecordMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ClearAction clears the value of the "action" field.
func (m *ApprovalRecordMutation) ClearAction() {
	m.action = nil
	m.clearedFields[approvalrecord.FieldAction] = struct{}{}
}

// ActionCleared returns if the "action" field was cleared in this mutation.
func (m *ApprovalRecordMutation) ActionCleared() bool {
	_, ok := m.clearedFields[approvalrecord.FieldAction]
	return ok
}

// ResetAction resets all changes to the "action" field.
func (m *ApprovalRecordMutation) ResetAction() {
	m.action = nil
	delete(m.clearedFields, approvalrecord.FieldAction)
}

// SetComment sets the "comment" field.
func (m *ApprovalRecordMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *ApprovalRecordMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the ApprovalRecord entity.
// If the ApprovalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalRecordMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *ApprovalRecordMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[approvalrecord.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *ApprovalRecordMutation) CommentCleared() bool {
	_, ok := m.clearedFields[approvalrecord.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *ApprovalRecordMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, approvalrecord.FieldComment)
}

// SetTenantID sets the "tenant_id" field.
func (m *ApprovalRecordMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ApprovalRecordMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ApprovalRecord entity.
// If the ApprovalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalRecordMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ApprovalRecordMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ApprovalRecordMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ApprovalRecordMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ApprovalRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApprovalRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApprovalRecord entity.
// If the ApprovalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApprovalRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetProcessedAt sets the "processed_at" field.
func (m *ApprovalRecordMutation) SetProcessedAt(t time.Time) {
	m.processed_at = &t
}

// ProcessedAt returns the value of the "processed_at" field in the mutation.
func (m *ApprovalRecordMutation) ProcessedAt() (r time.Time, exists bool) {
	v := m.processed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedAt returns the old "processed_at" field's value of the ApprovalRecord entity.
// If the ApprovalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalRecordMutation) OldProcessedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedAt: %w", err)
	}
	return oldValue.ProcessedAt, nil
}

// ClearProcessedAt clears the value of the "processed_at" field.
func (m *ApprovalRecordMutation) ClearProcessedAt() {
	m.processed_at = nil
	m.clearedFields[approvalrecord.FieldProcessedAt] = struct{}{}
}

// ProcessedAtCleared returns if the "processed_at" field was cleared in this mutation.
func (m *ApprovalRecordMutation) ProcessedAtCleared() bool {
	_, ok := m.clearedFields[approvalrecord.FieldProcessedAt]
	return ok
}

// ResetProcessedAt resets all changes to the "processed_at" field.
func (m *ApprovalRecordMutation) ResetProcessedAt() {
	m.processed_at = nil
	delete(m.clearedFields, approvalrecord.FieldProcessedAt)
}

// ClearTicket clears the "ticket" edge to the Ticket entity.
func (m *ApprovalRecordMutation) ClearTicket() {
	m.clearedticket = true
	m.clearedFields[approvalrecord.FieldTicketID] = struct{}{}
}

// TicketCleared reports if the "ticket" edge to the Ticket entity was cleared.
func (m *ApprovalRecordMutation) TicketCleared() bool {
	return m.clearedticket
}

// TicketIDs returns the "ticket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TicketID instead. It exists only for internal usage by the builders.
func (m *ApprovalRecordMutation) TicketIDs() (ids []int) {
	if id := m.ticket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicket resets all changes to the "ticket" edge.
func (m *ApprovalRecordMutation) ResetTicket() {
	m.ticket = nil
	m.clearedticket = false
}

// ClearWorkflow clears the "workflow" edge to the ApprovalWorkflow entity.
func (m *ApprovalRecordMutation) ClearWorkflow() {
	m.clearedworkflow = true
	m.clearedFields[approvalrecord.FieldWorkflowID] = struct{}{}
}

// WorkflowCleared reports if the "workflow" edge to the ApprovalWorkflow entity was cleared.
func (m *ApprovalRecordMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *ApprovalRecordMutation) WorkflowIDs() (ids []int) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *ApprovalRecordMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// Where appends a list predicates to the ApprovalRecordMutation builder.
func (m *ApprovalRecordMutation) Where(ps ...predicate.ApprovalRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApprovalRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApprovalRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApprovalRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApprovalRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApprovalRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApprovalRecord).
func (m *ApprovalRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApprovalRecordMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.ticket != nil {
		fields = append(fields, approvalrecord.FieldTicketID)
	}
	if m.ticket_number != nil {
		fields = append(fields, approvalrecord.FieldTicketNumber)
	}
	if m.ticket_title != nil {
		fields = append(fields, approvalrecord.FieldTicketTitle)
	}
	if m.workflow != nil {
		fields = append(fields, approvalrecord.FieldWorkflowID)
	}
	if m.workflow_name != nil {
		fields = append(fields, approvalrecord.FieldWorkflowName)
	}
	if m.current_level != nil {
		fields = append(fields, approvalrecord.FieldCurrentLevel)
	}
	if m.total_levels != nil {
		fields = append(fields, approvalrecord.FieldTotalLevels)
	}
	if m.approver_id != nil {
		fields = append(fields, approvalrecord.FieldApproverID)
	}
	if m.approver_name != nil {
		fields = append(fields, approvalrecord.FieldApproverName)
	}
	if m.status != nil {
		fields = append(fields, approvalrecord.FieldStatus)
	}
	if m.action != nil {
		fields = append(fields, approvalrecord.FieldAction)
	}
	if m.comment != nil {
		fields = append(fields, approvalrecord.FieldComment)
	}
	if m.tenant_id != nil {
		fields = append(fields, approvalrecord.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, approvalrecord.FieldCreatedAt)
	}
	if m.processed_at != nil {
		fields = append(fields, approvalrecord.FieldProcessedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApprovalRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approvalrecord.FieldTicketID:
		return m.TicketID()
	case approvalrecord.FieldTicketNumber:
		return m.TicketNumber()
	case approvalrecord.FieldTicketTitle:
		return m.TicketTitle()
	case approvalrecord.FieldWorkflowID:
		return m.WorkflowID()
	case approvalrecord.FieldWorkflowName:
		return m.WorkflowName()
	case approvalrecord.FieldCurrentLevel:
		return m.CurrentLevel()
	case approvalrecord.FieldTotalLevels:
		return m.TotalLevels()
	case approvalrecord.FieldApproverID:
		return m.ApproverID()
	case approvalrecord.FieldApproverName:
		return m.ApproverName()
	case approvalrecord.FieldStatus:
		return m.Status()
	case approvalrecord.FieldAction:
		return m.Action()
	case approvalrecord.FieldComment:
		return m.Comment()
	case approvalrecord.FieldTenantID:
		return m.TenantID()
	case approvalrecord.FieldCreatedAt:
		return m.CreatedAt()
	case approvalrecord.FieldProcessedAt:
		return m.ProcessedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApprovalRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approvalrecord.FieldTicketID:
		return m.OldTicketID(ctx)
	case approvalrecord.FieldTicketNumber:
		return m.OldTicketNumber(ctx)
	case approvalrecord.FieldTicketTitle:
		return m.OldTicketTitle(ctx)
	case approvalrecord.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case approvalrecord.FieldWorkflowName:
		return m.OldWorkflowName(ctx)
	case approvalrecord.FieldCurrentLevel:
		return m.OldCurrentLevel(ctx)
	case approvalrecord.FieldTotalLevels:
		return m.OldTotalLevels(ctx)
	case approvalrecord.FieldApproverID:
		return m.OldApproverID(ctx)
	case approvalrecord.FieldApproverName:
		return m.OldApproverName(ctx)
	case approvalrecord.FieldStatus:
		return m.OldStatus(ctx)
	case approvalrecord.FieldAction:
		return m.OldAction(ctx)
	case approvalrecord.FieldComment:
		return m.OldComment(ctx)
	case approvalrecord.FieldTenantID:
		return m.OldTenantID(ctx)
	case approvalrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case approvalrecord.FieldProcessedAt:
		return m.OldProcessedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ApprovalRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApprovalRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approvalrecord.FieldTicketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketID(v)
		return nil
	case approvalrecord.FieldTicketNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketNumber(v)
		return nil
	case approvalrecord.FieldTicketTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketTitle(v)
		return nil
	case approvalrecord.FieldWorkflowID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case approvalrecord.FieldWorkflowName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowName(v)
		return nil
	case approvalrecord.FieldCurrentLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentLevel(v)
		return nil
	case approvalrecord.FieldTotalLevels:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalLevels(v)
		return nil
	case approvalrecord.FieldApproverID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproverID(v)
		return nil
	case approvalrecord.FieldApproverName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproverName(v)
		return nil
	case approvalrecord.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case approvalrecord.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case approvalrecord.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case approvalrecord.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case approvalrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approvalrecord.FieldProcessedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ApprovalRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApprovalRecordMutation) AddedFields() []string {
	var fields []string
	if m.addcurrent_level != nil {
		fields = append(fields, approvalrecord.FieldCurrentLevel)
	}
	if m.addtotal_levels != nil {
		fields = append(fields, approvalrecord.FieldTotalLevels)
	}
	if m.addapprover_id != nil {
		fields = append(fields, approvalrecord.FieldApproverID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, approvalrecord.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApprovalRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case approvalrecord.FieldCurrentLevel:
		return m.AddedCurrentLevel()
	case approvalrecord.FieldTotalLevels:
		return m.AddedTotalLevels()
	case approvalrecord.FieldApproverID:
		return m.AddedApproverID()
	case approvalrecord.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApprovalRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case approvalrecord.FieldCurrentLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentLevel(v)
		return nil
	case approvalrecord.FieldTotalLevels:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalLevels(v)
		return nil
	case approvalrecord.FieldApproverID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApproverID(v)
		return nil
	case approvalrecord.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ApprovalRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApprovalRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(approvalrecord.FieldAction) {
		fields = append(fields, approvalrecord.FieldAction)
	}
	if m.FieldCleared(approvalrecord.FieldComment) {
		fields = append(fields, approvalrecord.FieldComment)
	}
	if m.FieldCleared(approvalrecord.FieldProcessedAt) {
		fields = append(fields, approvalrecord.FieldProcessedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApprovalRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApprovalRecordMutation) ClearField(name string) error {
	switch name {
	case approvalrecord.FieldAction:
		m.ClearAction()
		return nil
	case approvalrecord.FieldComment:
		m.ClearComment()
		return nil
	case approvalrecord.FieldProcessedAt:
		m.ClearProcessedAt()
		return nil
	}
	return fmt.Errorf("unknown ApprovalRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApprovalRecordMutation) ResetField(name string) error {
	switch name {
	case approvalrecord.FieldTicketID:
		m.ResetTicketID()
		return nil
	case approvalrecord.FieldTicketNumber:
		m.ResetTicketNumber()
		return nil
	case approvalrecord.FieldTicketTitle:
		m.ResetTicketTitle()
		return nil
	case approvalrecord.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case approvalrecord.FieldWorkflowName:
		m.ResetWorkflowName()
		return nil
	case approvalrecord.FieldCurrentLevel:
		m.ResetCurrentLevel()
		return nil
	case approvalrecord.FieldTotalLevels:
		m.ResetTotalLevels()
		return nil
	case approvalrecord.FieldApproverID:
		m.ResetApproverID()
		return nil
	case approvalrecord.FieldApproverName:
		m.ResetApproverName()
		return nil
	case approvalrecord.FieldStatus:
		m.ResetStatus()
		return nil
	case approvalrecord.FieldAction:
		m.ResetAction()
		return nil
	case approvalrecord.FieldComment:
		m.ResetComment()
		return nil
	case approvalrecord.FieldTenantID:
		m.ResetTenantID()
		return nil
	case approvalrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approvalrecord.FieldProcessedAt:
		m.ResetProcessedAt()
		return nil
	}
	return fmt.Errorf("unknown ApprovalRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApprovalRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.ticket != nil {
		edges = append(edges, approvalrecord.EdgeTicket)
	}
	if m.workflow != nil {
		edges = append(edges, approvalrecord.EdgeWorkflow)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApprovalRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case approvalrecord.EdgeTicket:
		if id := m.ticket; id != nil {
			return []ent.Value{*id}
		}
	case approvalrecord.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApprovalRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApprovalRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApprovalRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedticket {
		edges = append(edges, approvalrecord.EdgeTicket)
	}
	if m.clearedworkflow {
		edges = append(edges, approvalrecord.EdgeWorkflow)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApprovalRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case approvalrecord.EdgeTicket:
		return m.clearedticket
	case approvalrecord.EdgeWorkflow:
		return m.clearedworkflow
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApprovalRecordMutation) ClearEdge(name string) error {
	switch name {
	case approvalrecord.EdgeTicket:
		m.ClearTicket()
		return nil
	case approvalrecord.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown ApprovalRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApprovalRecordMutation) ResetEdge(name string) error {
	switch name {
	case approvalrecord.EdgeTicket:
		m.ResetTicket()
		return nil
	case approvalrecord.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	}
	return fmt.Errorf("unknown ApprovalRecord edge %s", name)
}

// ApprovalWorkflowMutation represents an operation that mutates the ApprovalWorkflow nodes in the graph.
type ApprovalWorkflowMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	name                    *string
	description             *string
	ticket_type             *string
	priority                *string
	nodes                   *[]map[string]interface{}
	appendnodes             []map[string]interface{}
	is_active               *bool
	tenant_id               *int
	addtenant_id            *int
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	approval_records        map[int]struct{}
	removedapproval_records map[int]struct{}
	clearedapproval_records bool
	done                    bool
	oldValue                func(context.Context) (*ApprovalWorkflow, error)
	predicates              []predicate.ApprovalWorkflow
}

var _ ent.Mutation = (*ApprovalWorkflowMutation)(nil)

// approvalworkflowOption allows management of the mutation configuration using functional options.
type approvalworkflowOption func(*ApprovalWorkflowMutation)

// newApprovalWorkflowMutation creates new mutation for the ApprovalWorkflow entity.
func newApprovalWorkflowMutation(c config, op Op, opts ...approvalworkflowOption) *ApprovalWorkflowMutation {
	m := &ApprovalWorkflowMutation{
		config:        c,
		op:            op,
		typ:           TypeApprovalWorkflow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApprovalWorkflowID sets the ID field of the mutation.
func withApprovalWorkflowID(id int) approvalworkflowOption {
	return func(m *ApprovalWorkflowMutation) {
		var (
			err   error
			once  sync.Once
			value *ApprovalWorkflow
		)
		m.oldValue = func(ctx context.Context) (*ApprovalWorkflow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApprovalWorkflow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApprovalWorkflow sets the old ApprovalWorkflow of the mutation.
func withApprovalWorkflow(node *ApprovalWorkflow) approvalworkflowOption {
	return func(m *ApprovalWorkflowMutation) {
		m.oldValue = func(context.Context) (*ApprovalWorkflow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApprovalWorkflowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApprovalWorkflowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApprovalWorkflowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApprovalWorkflowMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApprovalWorkflow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ApprovalWorkflowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApprovalWorkflowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ApprovalWorkflow entity.
// If the ApprovalWorkflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalWorkflowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApprovalWorkflowMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ApprovalWorkflowMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ApprovalWorkflowMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ApprovalWorkflow entity.
// If the ApprovalWorkflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalWorkflowMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ApprovalWorkflowMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[approvalworkflow.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ApprovalWorkflowMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[approvalworkflow.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ApprovalWorkflowMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, approvalworkflow.FieldDescription)
}

// SetTicketType sets the "ticket_type" field.
func (m *ApprovalWorkflowMutation) SetTicketType(s string) {
	m.ticket_type = &s
}

// TicketType returns the value of the "ticket_type" field in the mutation.
func (m *ApprovalWorkflowMutation) TicketType() (r string, exists bool) {
	v := m.ticket_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketType returns the old "ticket_type" field's value of the ApprovalWorkflow entity.
// If the ApprovalWorkflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalWorkflowMutation) OldTicketType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketType: %w", err)
	}
	return oldValue.TicketType, nil
}

// ClearTicketType clears the value of the "ticket_type" field.
func (m *ApprovalWorkflowMutation) ClearTicketType() {
	m.ticket_type = nil
	m.clearedFields[approvalworkflow.FieldTicketType] = struct{}{}
}

// TicketTypeCleared returns if the "ticket_type" field was cleared in this mutation.
func (m *ApprovalWorkflowMutation) TicketTypeCleared() bool {
	_, ok := m.clearedFields[approvalworkflow.FieldTicketType]
	return ok
}

// ResetTicketType resets all changes to the "ticket_type" field.
func (m *ApprovalWorkflowMutation) ResetTicketType() {
	m.ticket_type = nil
	delete(m.clearedFields, approvalworkflow.FieldTicketType)
}

// SetPriority sets the "priority" field.
func (m *ApprovalWorkflowMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ApprovalWorkflowMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the ApprovalWorkflow entity.
// If the ApprovalWorkflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalWorkflowMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ClearPriority clears the value of the "priority" field.
func (m *ApprovalWorkflowMutation) ClearPriority() {
	m.priority = nil
	m.clearedFields[approvalworkflow.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *ApprovalWorkflowMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[approvalworkflow.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *ApprovalWorkflowMutation) ResetPriority() {
	m.priority = nil
	delete(m.clearedFields, approvalworkflow.FieldPriority)
}

// SetNodes sets the "nodes" field.
func (m *ApprovalWorkflowMutation) SetNodes(value []map[string]interface{}) {
	m.nodes = &value
	m.appendnodes = nil
}

// Nodes returns the value of the "nodes" field in the mutation.
func (m *ApprovalWorkflowMutation) Nodes() (r []map[string]interface{}, exists bool) {
	v := m.nodes
	if v == nil {
		return
	}
	return *v, true
}

// OldNodes returns the old "nodes" field's value of the ApprovalWorkflow entity.
// If the ApprovalWorkflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalWorkflowMutation) OldNodes(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodes: %w", err)
	}
	return oldValue.Nodes, nil
}

// AppendNodes adds value to the "nodes" field.
func (m *ApprovalWorkflowMutation) AppendNodes(value []map[string]interface{}) {
	m.appendnodes = append(m.appendnodes, value...)
}

// AppendedNodes returns the list of values that were appended to the "nodes" field in this mutation.
func (m *ApprovalWorkflowMutation) AppendedNodes() ([]map[string]interface{}, bool) {
	if len(m.appendnodes) == 0 {
		return nil, false
	}
	return m.appendnodes, true
}

// ResetNodes resets all changes to the "nodes" field.
func (m *ApprovalWorkflowMutation) ResetNodes() {
	m.nodes = nil
	m.appendnodes = nil
}

// SetIsActive sets the "is_active" field.
func (m *ApprovalWorkflowMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ApprovalWorkflowMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the ApprovalWorkflow entity.
// If the ApprovalWorkflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalWorkflowMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ApprovalWorkflowMutation) ResetIsActive() {
	m.is_active = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ApprovalWorkflowMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ApprovalWorkflowMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ApprovalWorkflow entity.
// If the ApprovalWorkflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalWorkflowMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ApprovalWorkflowMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ApprovalWorkflowMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ApprovalWorkflowMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ApprovalWorkflowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApprovalWorkflowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApprovalWorkflow entity.
// If the ApprovalWorkflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalWorkflowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApprovalWorkflowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApprovalWorkflowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApprovalWorkflowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApprovalWorkflow entity.
// If the ApprovalWorkflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalWorkflowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApprovalWorkflowMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddApprovalRecordIDs adds the "approval_records" edge to the ApprovalRecord entity by ids.
func (m *ApprovalWorkflowMutation) AddApprovalRecordIDs(ids ...int) {
	if m.approval_records == nil {
		m.approval_records = make(map[int]struct{})
	}
	for i := range ids {
		m.approval_records[ids[i]] = struct{}{}
	}
}

// ClearApprovalRecords clears the "approval_records" edge to the ApprovalRecord entity.
func (m *ApprovalWorkflowMutation) ClearApprovalRecords() {
	m.clearedapproval_records = true
}

// ApprovalRecordsCleared reports if the "approval_records" edge to the ApprovalRecord entity was cleared.
func (m *ApprovalWorkflowMutation) ApprovalRecordsCleared() bool {
	return m.clearedapproval_records
}

// RemoveApprovalRecordIDs removes the "approval_records" edge to the ApprovalRecord entity by IDs.
func (m *ApprovalWorkflowMutation) RemoveApprovalRecordIDs(ids ...int) {
	if m.removedapproval_records == nil {
		m.removedapproval_records = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.approval_records, ids[i])
		m.removedapproval_records[ids[i]] = struct{}{}
	}
}

// RemovedApprovalRecords returns the removed IDs of the "approval_records" edge to the ApprovalRecord entity.
func (m *ApprovalWorkflowMutation) RemovedApprovalRecordsIDs() (ids []int) {
	for id := range m.removedapproval_records {
		ids = append(ids, id)
	}
	return
}

// ApprovalRecordsIDs returns the "approval_records" edge IDs in the mutation.
func (m *ApprovalWorkflowMutation) ApprovalRecordsIDs() (ids []int) {
	for id := range m.approval_records {
		ids = append(ids, id)
	}
	return
}

// ResetApprovalRecords resets all changes to the "approval_records" edge.
func (m *ApprovalWorkflowMutation) ResetApprovalRecords() {
	m.approval_records = nil
	m.clearedapproval_records = false
	m.removedapproval_records = nil
}

// Where appends a list predicates to the ApprovalWorkflowMutation builder.
func (m *ApprovalWorkflowMutation) Where(ps ...predicate.ApprovalWorkflow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApprovalWorkflowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApprovalWorkflowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApprovalWorkflow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApprovalWorkflowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApprovalWorkflowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApprovalWorkflow).
func (m *ApprovalWorkflowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApprovalWorkflowMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, approvalworkflow.FieldName)
	}
	if m.description != nil {
		fields = append(fields, approvalworkflow.FieldDescription)
	}
	if m.ticket_type != nil {
		fields = append(fields, approvalworkflow.FieldTicketType)
	}
	if m.priority != nil {
		fields = append(fields, approvalworkflow.FieldPriority)
	}
	if m.nodes != nil {
		fields = append(fields, approvalworkflow.FieldNodes)
	}
	if m.is_active != nil {
		fields = append(fields, approvalworkflow.FieldIsActive)
	}
	if m.tenant_id != nil {
		fields = append(fields, approvalworkflow.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, approvalworkflow.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, approvalworkflow.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApprovalWorkflowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approvalworkflow.FieldName:
		return m.Name()
	case approvalworkflow.FieldDescription:
		return m.Description()
	case approvalworkflow.FieldTicketType:
		return m.TicketType()
	case approvalworkflow.FieldPriority:
		return m.Priority()
	case approvalworkflow.FieldNodes:
		return m.Nodes()
	case approvalworkflow.FieldIsActive:
		return m.IsActive()
	case approvalworkflow.FieldTenantID:
		return m.TenantID()
	case approvalworkflow.FieldCreatedAt:
		return m.CreatedAt()
	case approvalworkflow.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApprovalWorkflowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approvalworkflow.FieldName:
		return m.OldName(ctx)
	case approvalworkflow.FieldDescription:
		return m.OldDescription(ctx)
	case approvalworkflow.FieldTicketType:
		return m.OldTicketType(ctx)
	case approvalworkflow.FieldPriority:
		return m.OldPriority(ctx)
	case approvalworkflow.FieldNodes:
		return m.OldNodes(ctx)
	case approvalworkflow.FieldIsActive:
		return m.OldIsActive(ctx)
	case approvalworkflow.FieldTenantID:
		return m.OldTenantID(ctx)
	case approvalworkflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case approvalworkflow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ApprovalWorkflow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApprovalWorkflowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approvalworkflow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case approvalworkflow.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case approvalworkflow.FieldTicketType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketType(v)
		return nil
	case approvalworkflow.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case approvalworkflow.FieldNodes:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodes(v)
		return nil
	case approvalworkflow.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case approvalworkflow.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case approvalworkflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approvalworkflow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ApprovalWorkflow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApprovalWorkflowMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, approvalworkflow.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApprovalWorkflowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case approvalworkflow.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApprovalWorkflowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case approvalworkflow.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ApprovalWorkflow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApprovalWorkflowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(approvalworkflow.FieldDescription) {
		fields = append(fields, approvalworkflow.FieldDescription)
	}
	if m.FieldCleared(approvalworkflow.FieldTicketType) {
		fields = append(fields, approvalworkflow.FieldTicketType)
	}
	if m.FieldCleared(approvalworkflow.FieldPriority) {
		fields = append(fields, approvalworkflow.FieldPriority)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApprovalWorkflowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApprovalWorkflowMutation) ClearField(name string) error {
	switch name {
	case approvalworkflow.FieldDescription:
		m.ClearDescription()
		return nil
	case approvalworkflow.FieldTicketType:
		m.ClearTicketType()
		return nil
	case approvalworkflow.FieldPriority:
		m.ClearPriority()
		return nil
	}
	return fmt.Errorf("unknown ApprovalWorkflow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApprovalWorkflowMutation) ResetField(name string) error {
	switch name {
	case approvalworkflow.FieldName:
		m.ResetName()
		return nil
	case approvalworkflow.FieldDescription:
		m.ResetDescription()
		return nil
	case approvalworkflow.FieldTicketType:
		m.ResetTicketType()
		return nil
	case approvalworkflow.FieldPriority:
		m.ResetPriority()
		return nil
	case approvalworkflow.FieldNodes:
		m.ResetNodes()
		return nil
	case approvalworkflow.FieldIsActive:
		m.ResetIsActive()
		return nil
	case approvalworkflow.FieldTenantID:
		m.ResetTenantID()
		return nil
	case approvalworkflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approvalworkflow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ApprovalWorkflow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApprovalWorkflowMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.approval_records != nil {
		edges = append(edges, approvalworkflow.EdgeApprovalRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApprovalWorkflowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case approvalworkflow.EdgeApprovalRecords:
		ids := make([]ent.Value, 0, len(m.approval_records))
		for id := range m.approval_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApprovalWorkflowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedapproval_records != nil {
		edges = append(edges, approvalworkflow.EdgeApprovalRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApprovalWorkflowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case approvalworkflow.EdgeApprovalRecords:
		ids := make([]ent.Value, 0, len(m.removedapproval_records))
		for id := range m.removedapproval_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApprovalWorkflowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapproval_records {
		edges = append(edges, approvalworkflow.EdgeApprovalRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApprovalWorkflowMutation) EdgeCleared(name string) bool {
	switch name {
	case approvalworkflow.EdgeApprovalRecords:
		return m.clearedapproval_records
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApprovalWorkflowMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ApprovalWorkflow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApprovalWorkflowMutation) ResetEdge(name string) error {
	switch name {
	case approvalworkflow.EdgeApprovalRecords:
		m.ResetApprovalRecords()
		return nil
	}
	return fmt.Errorf("unknown ApprovalWorkflow edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	tenant_id      *int
	addtenant_id   *int
	user_id        *int
	adduser_id     *int
	request_id     *string
	ip             *string
	resource       *string
	action         *string
	_path          *string
	method         *string
	status_code    *int
	addstatus_code *int
	request_body   *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AuditLog, error)
	predicates     []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id int) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *AuditLogMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AuditLogMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *AuditLogMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *AuditLogMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AuditLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[auditlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AuditLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, auditlog.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *AuditLogMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuditLogMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *AuditLogMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AuditLogMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *AuditLogMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[auditlog.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AuditLogMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuditLogMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, auditlog.FieldUserID)
}

// SetRequestID sets the "request_id" field.
func (m *AuditLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *AuditLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *AuditLogMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[auditlog.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *AuditLogMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *AuditLogMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, auditlog.FieldRequestID)
}

// SetIP sets the "ip" field.
func (m *AuditLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AuditLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AuditLogMutation) ResetIP() {
	m.ip = nil
}

// SetResource sets the "resource" field.
func (m *AuditLogMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the value of the "resource" field in the mutation.
func (m *AuditLogMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old "resource" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ResetResource resets all changes to the "resource" field.
func (m *AuditLogMutation) ResetResource() {
	m.resource = nil
}

// SetAction sets the "action" field.
func (m *AuditLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *AuditLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *AuditLogMutation) ResetAction() {
	m.action = nil
}

// SetPath sets the "path" field.
func (m *AuditLogMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *AuditLogMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *AuditLogMutation) ResetPath() {
	m._path = nil
}

// SetMethod sets the "method" field.
func (m *AuditLogMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *AuditLogMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *AuditLogMutation) ResetMethod() {
	m.method = nil
}

// SetStatusCode sets the "status_code" field.
func (m *AuditLogMutation) SetStatusCode(i int) {
	m.status_code = &i
	m.addstatus_code = nil
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *AuditLogMutation) StatusCode() (r int, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldStatusCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// AddStatusCode adds i to the "status_code" field.
func (m *AuditLogMutation) AddStatusCode(i int) {
	if m.addstatus_code != nil {
		*m.addstatus_code += i
	} else {
		m.addstatus_code = &i
	}
}

// AddedStatusCode returns the value that was added to the "status_code" field in this mutation.
func (m *AuditLogMutation) AddedStatusCode() (r int, exists bool) {
	v := m.addstatus_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *AuditLogMutation) ResetStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
}

// SetRequestBody sets the "request_body" field.
func (m *AuditLogMutation) SetRequestBody(s string) {
	m.request_body = &s
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *AuditLogMutation) RequestBody() (r string, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestBody(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// ClearRequestBody clears the value of the "request_body" field.
func (m *AuditLogMutation) ClearRequestBody() {
	m.request_body = nil
	m.clearedFields[auditlog.FieldRequestBody] = struct{}{}
}

// RequestBodyCleared returns if the "request_body" field was cleared in this mutation.
func (m *AuditLogMutation) RequestBodyCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRequestBody]
	return ok
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *AuditLogMutation) ResetRequestBody() {
	m.request_body = nil
	delete(m.clearedFields, auditlog.FieldRequestBody)
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, auditlog.FieldCreatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.request_id != nil {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.ip != nil {
		fields = append(fields, auditlog.FieldIP)
	}
	if m.resource != nil {
		fields = append(fields, auditlog.FieldResource)
	}
	if m.action != nil {
		fields = append(fields, auditlog.FieldAction)
	}
	if m._path != nil {
		fields = append(fields, auditlog.FieldPath)
	}
	if m.method != nil {
		fields = append(fields, auditlog.FieldMethod)
	}
	if m.status_code != nil {
		fields = append(fields, auditlog.FieldStatusCode)
	}
	if m.request_body != nil {
		fields = append(fields, auditlog.FieldRequestBody)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldCreatedAt:
		return m.CreatedAt()
	case auditlog.FieldTenantID:
		return m.TenantID()
	case auditlog.FieldUserID:
		return m.UserID()
	case auditlog.FieldRequestID:
		return m.RequestID()
	case auditlog.FieldIP:
		return m.IP()
	case auditlog.FieldResource:
		return m.Resource()
	case auditlog.FieldAction:
		return m.Action()
	case auditlog.FieldPath:
		return m.Path()
	case auditlog.FieldMethod:
		return m.Method()
	case auditlog.FieldStatusCode:
		return m.StatusCode()
	case auditlog.FieldRequestBody:
		return m.RequestBody()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case auditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case auditlog.FieldUserID:
		return m.OldUserID(ctx)
	case auditlog.FieldRequestID:
		return m.OldRequestID(ctx)
	case auditlog.FieldIP:
		return m.OldIP(ctx)
	case auditlog.FieldResource:
		return m.OldResource(ctx)
	case auditlog.FieldAction:
		return m.OldAction(ctx)
	case auditlog.FieldPath:
		return m.OldPath(ctx)
	case auditlog.FieldMethod:
		return m.OldMethod(ctx)
	case auditlog.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case auditlog.FieldRequestBody:
		return m.OldRequestBody(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case auditlog.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case auditlog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case auditlog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case auditlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case auditlog.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case auditlog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case auditlog.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case auditlog.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case auditlog.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case auditlog.FieldRequestBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.addstatus_code != nil {
		fields = append(fields, auditlog.FieldStatusCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldTenantID:
		return m.AddedTenantID()
	case auditlog.FieldUserID:
		return m.AddedUserID()
	case auditlog.FieldStatusCode:
		return m.AddedStatusCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case auditlog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case auditlog.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusCode(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldTenantID) {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.FieldCleared(auditlog.FieldUserID) {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.FieldCleared(auditlog.FieldRequestID) {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.FieldCleared(auditlog.FieldRequestBody) {
		fields = append(fields, auditlog.FieldRequestBody)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case auditlog.FieldUserID:
		m.ClearUserID()
		return nil
	case auditlog.FieldRequestID:
		m.ClearRequestID()
		return nil
	case auditlog.FieldRequestBody:
		m.ClearRequestBody()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case auditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case auditlog.FieldUserID:
		m.ResetUserID()
		return nil
	case auditlog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case auditlog.FieldIP:
		m.ResetIP()
		return nil
	case auditlog.FieldResource:
		m.ResetResource()
		return nil
	case auditlog.FieldAction:
		m.ResetAction()
		return nil
	case auditlog.FieldPath:
		m.ResetPath()
		return nil
	case auditlog.FieldMethod:
		m.ResetMethod()
		return nil
	case auditlog.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case auditlog.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// CIAttributeDefinitionMutation represents an operation that mutates the CIAttributeDefinition nodes in the graph.
type CIAttributeDefinitionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	display_name     *string
	_type            *string
	required         *bool
	_unique          *bool
	default_value    *string
	validation_rules *string
	ci_type_id       *int
	addci_type_id    *int
	tenant_id        *int
	addtenant_id     *int
	is_active        *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*CIAttributeDefinition, error)
	predicates       []predicate.CIAttributeDefinition
}

var _ ent.Mutation = (*CIAttributeDefinitionMutation)(nil)

// ciattributedefinitionOption allows management of the mutation configuration using functional options.
type ciattributedefinitionOption func(*CIAttributeDefinitionMutation)

// newCIAttributeDefinitionMutation creates new mutation for the CIAttributeDefinition entity.
func newCIAttributeDefinitionMutation(c config, op Op, opts ...ciattributedefinitionOption) *CIAttributeDefinitionMutation {
	m := &CIAttributeDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeCIAttributeDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCIAttributeDefinitionID sets the ID field of the mutation.
func withCIAttributeDefinitionID(id int) ciattributedefinitionOption {
	return func(m *CIAttributeDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *CIAttributeDefinition
		)
		m.oldValue = func(ctx context.Context) (*CIAttributeDefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CIAttributeDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCIAttributeDefinition sets the old CIAttributeDefinition of the mutation.
func withCIAttributeDefinition(node *CIAttributeDefinition) ciattributedefinitionOption {
	return func(m *CIAttributeDefinitionMutation) {
		m.oldValue = func(context.Context) (*CIAttributeDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CIAttributeDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CIAttributeDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CIAttributeDefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CIAttributeDefinitionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CIAttributeDefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CIAttributeDefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CIAttributeDefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CIAttributeDefinitionMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *CIAttributeDefinitionMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *CIAttributeDefinitionMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *CIAttributeDefinitionMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetType sets the "type" field.
func (m *CIAttributeDefinitionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CIAttributeDefinitionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CIAttributeDefinitionMutation) ResetType() {
	m._type = nil
}

// SetRequired sets the "required" field.
func (m *CIAttributeDefinitionMutation) SetRequired(b bool) {
	m.required = &b
}

// Required returns the value of the "required" field in the mutation.
func (m *CIAttributeDefinitionMutation) Required() (r bool, exists bool) {
	v := m.required
	if v == nil {
		return
	}
	return *v, true
}

// OldRequired returns the old "required" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequired: %w", err)
	}
	return oldValue.Required, nil
}

// ResetRequired resets all changes to the "required" field.
func (m *CIAttributeDefinitionMutation) ResetRequired() {
	m.required = nil
}

// SetUnique sets the "unique" field.
func (m *CIAttributeDefinitionMutation) SetUnique(b bool) {
	m._unique = &b
}

// Unique returns the value of the "unique" field in the mutation.
func (m *CIAttributeDefinitionMutation) Unique() (r bool, exists bool) {
	v := m._unique
	if v == nil {
		return
	}
	return *v, true
}

// OldUnique returns the old "unique" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldUnique(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnique is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnique requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnique: %w", err)
	}
	return oldValue.Unique, nil
}

// ResetUnique resets all changes to the "unique" field.
func (m *CIAttributeDefinitionMutation) ResetUnique() {
	m._unique = nil
}

// SetDefaultValue sets the "default_value" field.
func (m *CIAttributeDefinitionMutation) SetDefaultValue(s string) {
	m.default_value = &s
}

// DefaultValue returns the value of the "default_value" field in the mutation.
func (m *CIAttributeDefinitionMutation) DefaultValue() (r string, exists bool) {
	v := m.default_value
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultValue returns the old "default_value" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldDefaultValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultValue: %w", err)
	}
	return oldValue.DefaultValue, nil
}

// ClearDefaultValue clears the value of the "default_value" field.
func (m *CIAttributeDefinitionMutation) ClearDefaultValue() {
	m.default_value = nil
	m.clearedFields[ciattributedefinition.FieldDefaultValue] = struct{}{}
}

// DefaultValueCleared returns if the "default_value" field was cleared in this mutation.
func (m *CIAttributeDefinitionMutation) DefaultValueCleared() bool {
	_, ok := m.clearedFields[ciattributedefinition.FieldDefaultValue]
	return ok
}

// ResetDefaultValue resets all changes to the "default_value" field.
func (m *CIAttributeDefinitionMutation) ResetDefaultValue() {
	m.default_value = nil
	delete(m.clearedFields, ciattributedefinition.FieldDefaultValue)
}

// SetValidationRules sets the "validation_rules" field.
func (m *CIAttributeDefinitionMutation) SetValidationRules(s string) {
	m.validation_rules = &s
}

// ValidationRules returns the value of the "validation_rules" field in the mutation.
func (m *CIAttributeDefinitionMutation) ValidationRules() (r string, exists bool) {
	v := m.validation_rules
	if v == nil {
		return
	}
	return *v, true
}

// OldValidationRules returns the old "validation_rules" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldValidationRules(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidationRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidationRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidationRules: %w", err)
	}
	return oldValue.ValidationRules, nil
}

// ClearValidationRules clears the value of the "validation_rules" field.
func (m *CIAttributeDefinitionMutation) ClearValidationRules() {
	m.validation_rules = nil
	m.clearedFields[ciattributedefinition.FieldValidationRules] = struct{}{}
}

// ValidationRulesCleared returns if the "validation_rules" field was cleared in this mutation.
func (m *CIAttributeDefinitionMutation) ValidationRulesCleared() bool {
	_, ok := m.clearedFields[ciattributedefinition.FieldValidationRules]
	return ok
}

// ResetValidationRules resets all changes to the "validation_rules" field.
func (m *CIAttributeDefinitionMutation) ResetValidationRules() {
	m.validation_rules = nil
	delete(m.clearedFields, ciattributedefinition.FieldValidationRules)
}

// SetCiTypeID sets the "ci_type_id" field.
func (m *CIAttributeDefinitionMutation) SetCiTypeID(i int) {
	m.ci_type_id = &i
	m.addci_type_id = nil
}

// CiTypeID returns the value of the "ci_type_id" field in the mutation.
func (m *CIAttributeDefinitionMutation) CiTypeID() (r int, exists bool) {
	v := m.ci_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCiTypeID returns the old "ci_type_id" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldCiTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCiTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCiTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCiTypeID: %w", err)
	}
	return oldValue.CiTypeID, nil
}

// AddCiTypeID adds i to the "ci_type_id" field.
func (m *CIAttributeDefinitionMutation) AddCiTypeID(i int) {
	if m.addci_type_id != nil {
		*m.addci_type_id += i
	} else {
		m.addci_type_id = &i
	}
}

// AddedCiTypeID returns the value that was added to the "ci_type_id" field in this mutation.
func (m *CIAttributeDefinitionMutation) AddedCiTypeID() (r int, exists bool) {
	v := m.addci_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCiTypeID resets all changes to the "ci_type_id" field.
func (m *CIAttributeDefinitionMutation) ResetCiTypeID() {
	m.ci_type_id = nil
	m.addci_type_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *CIAttributeDefinitionMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CIAttributeDefinitionMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *CIAttributeDefinitionMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *CIAttributeDefinitionMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CIAttributeDefinitionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetIsActive sets the "is_active" field.
func (m *CIAttributeDefinitionMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *CIAttributeDefinitionMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *CIAttributeDefinitionMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CIAttributeDefinitionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CIAttributeDefinitionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CIAttributeDefinitionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CIAttributeDefinitionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CIAttributeDefinitionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CIAttributeDefinitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the CIAttributeDefinitionMutation builder.
func (m *CIAttributeDefinitionMutation) Where(ps ...predicate.CIAttributeDefinition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CIAttributeDefinitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CIAttributeDefinitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CIAttributeDefinition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CIAttributeDefinitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CIAttributeDefinitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CIAttributeDefinition).
func (m *CIAttributeDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CIAttributeDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, ciattributedefinition.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, ciattributedefinition.FieldDisplayName)
	}
	if m._type != nil {
		fields = append(fields, ciattributedefinition.FieldType)
	}
	if m.required != nil {
		fields = append(fields, ciattributedefinition.FieldRequired)
	}
	if m._unique != nil {
		fields = append(fields, ciattributedefinition.FieldUnique)
	}
	if m.default_value != nil {
		fields = append(fields, ciattributedefinition.FieldDefaultValue)
	}
	if m.validation_rules != nil {
		fields = append(fields, ciattributedefinition.FieldValidationRules)
	}
	if m.ci_type_id != nil {
		fields = append(fields, ciattributedefinition.FieldCiTypeID)
	}
	if m.tenant_id != nil {
		fields = append(fields, ciattributedefinition.FieldTenantID)
	}
	if m.is_active != nil {
		fields = append(fields, ciattributedefinition.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, ciattributedefinition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ciattributedefinition.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CIAttributeDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ciattributedefinition.FieldName:
		return m.Name()
	case ciattributedefinition.FieldDisplayName:
		return m.DisplayName()
	case ciattributedefinition.FieldType:
		return m.GetType()
	case ciattributedefinition.FieldRequired:
		return m.Required()
	case ciattributedefinition.FieldUnique:
		return m.Unique()
	case ciattributedefinition.FieldDefaultValue:
		return m.DefaultValue()
	case ciattributedefinition.FieldValidationRules:
		return m.ValidationRules()
	case ciattributedefinition.FieldCiTypeID:
		return m.CiTypeID()
	case ciattributedefinition.FieldTenantID:
		return m.TenantID()
	case ciattributedefinition.FieldIsActive:
		return m.IsActive()
	case ciattributedefinition.FieldCreatedAt:
		return m.CreatedAt()
	case ciattributedefinition.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CIAttributeDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ciattributedefinition.FieldName:
		return m.OldName(ctx)
	case ciattributedefinition.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case ciattributedefinition.FieldType:
		return m.OldType(ctx)
	case ciattributedefinition.FieldRequired:
		return m.OldRequired(ctx)
	case ciattributedefinition.FieldUnique:
		return m.OldUnique(ctx)
	case ciattributedefinition.FieldDefaultValue:
		return m.OldDefaultValue(ctx)
	case ciattributedefinition.FieldValidationRules:
		return m.OldValidationRules(ctx)
	case ciattributedefinition.FieldCiTypeID:
		return m.OldCiTypeID(ctx)
	case ciattributedefinition.FieldTenantID:
		return m.OldTenantID(ctx)
	case ciattributedefinition.FieldIsActive:
		return m.OldIsActive(ctx)
	case ciattributedefinition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ciattributedefinition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CIAttributeDefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CIAttributeDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ciattributedefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ciattributedefinition.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case ciattributedefinition.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case ciattributedefinition.FieldRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequired(v)
		return nil
	case ciattributedefinition.FieldUnique:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnique(v)
		return nil
	case ciattributedefinition.FieldDefaultValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultValue(v)
		return nil
	case ciattributedefinition.FieldValidationRules:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidationRules(v)
		return nil
	case ciattributedefinition.FieldCiTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCiTypeID(v)
		return nil
	case ciattributedefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ciattributedefinition.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case ciattributedefinition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ciattributedefinition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CIAttributeDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CIAttributeDefinitionMutation) AddedFields() []string {
	var fields []string
	if m.addci_type_id != nil {
		fields = append(fields, ciattributedefinition.FieldCiTypeID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, ciattributedefinition.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CIAttributeDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ciattributedefinition.FieldCiTypeID:
		return m.AddedCiTypeID()
	case ciattributedefinition.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CIAttributeDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ciattributedefinition.FieldCiTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCiTypeID(v)
		return nil
	case ciattributedefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown CIAttributeDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CIAttributeDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ciattributedefinition.FieldDefaultValue) {
		fields = append(fields, ciattributedefinition.FieldDefaultValue)
	}
	if m.FieldCleared(ciattributedefinition.FieldValidationRules) {
		fields = append(fields, ciattributedefinition.FieldValidationRules)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CIAttributeDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CIAttributeDefinitionMutation) ClearField(name string) error {
	switch name {
	case ciattributedefinition.FieldDefaultValue:
		m.ClearDefaultValue()
		return nil
	case ciattributedefinition.FieldValidationRules:
		m.ClearValidationRules()
		return nil
	}
	return fmt.Errorf("unknown CIAttributeDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CIAttributeDefinitionMutation) ResetField(name string) error {
	switch name {
	case ciattributedefinition.FieldName:
		m.ResetName()
		return nil
	case ciattributedefinition.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case ciattributedefinition.FieldType:
		m.ResetType()
		return nil
	case ciattributedefinition.FieldRequired:
		m.ResetRequired()
		return nil
	case ciattributedefinition.FieldUnique:
		m.ResetUnique()
		return nil
	case ciattributedefinition.FieldDefaultValue:
		m.ResetDefaultValue()
		return nil
	case ciattributedefinition.FieldValidationRules:
		m.ResetValidationRules()
		return nil
	case ciattributedefinition.FieldCiTypeID:
		m.ResetCiTypeID()
		return nil
	case ciattributedefinition.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ciattributedefinition.FieldIsActive:
		m.ResetIsActive()
		return nil
	case ciattributedefinition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ciattributedefinition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CIAttributeDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CIAttributeDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CIAttributeDefinitionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CIAttributeDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CIAttributeDefinitionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CIAttributeDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CIAttributeDefinitionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CIAttributeDefinitionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CIAttributeDefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CIAttributeDefinitionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CIAttributeDefinition edge %s", name)
}

// CIRelationshipMutation represents an operation that mutates the CIRelationship nodes in the graph.
type CIRelationshipMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	source_ci_id            *int
	addsource_ci_id         *int
	target_ci_id            *int
	addtarget_ci_id         *int
	relationship_type_id    *int
	addrelationship_type_id *int
	description             *string
	tenant_id               *int
	addtenant_id            *int
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*CIRelationship, error)
	predicates              []predicate.CIRelationship
}

var _ ent.Mutation = (*CIRelationshipMutation)(nil)

// cirelationshipOption allows management of the mutation configuration using functional options.
type cirelationshipOption func(*CIRelationshipMutation)

// newCIRelationshipMutation creates new mutation for the CIRelationship entity.
func newCIRelationshipMutation(c config, op Op, opts ...cirelationshipOption) *CIRelationshipMutation {
	m := &CIRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeCIRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCIRelationshipID sets the ID field of the mutation.
func withCIRelationshipID(id int) cirelationshipOption {
	return func(m *CIRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *CIRelationship
		)
		m.oldValue = func(ctx context.Context) (*CIRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CIRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCIRelationship sets the old CIRelationship of the mutation.
func withCIRelationship(node *CIRelationship) cirelationshipOption {
	return func(m *CIRelationshipMutation) {
		m.oldValue = func(context.Context) (*CIRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CIRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CIRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CIRelationshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CIRelationshipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CIRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceCiID sets the "source_ci_id" field.
func (m *CIRelationshipMutation) SetSourceCiID(i int) {
	m.source_ci_id = &i
	m.addsource_ci_id = nil
}

// SourceCiID returns the value of the "source_ci_id" field in the mutation.
func (m *CIRelationshipMutation) SourceCiID() (r int, exists bool) {
	v := m.source_ci_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceCiID returns the old "source_ci_id" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldSourceCiID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceCiID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceCiID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceCiID: %w", err)
	}
	return oldValue.SourceCiID, nil
}

// AddSourceCiID adds i to the "source_ci_id" field.
func (m *CIRelationshipMutation) AddSourceCiID(i int) {
	if m.addsource_ci_id != nil {
		*m.addsource_ci_id += i
	} else {
		m.addsource_ci_id = &i
	}
}

// AddedSourceCiID returns the value that was added to the "source_ci_id" field in this mutation.
func (m *CIRelationshipMutation) AddedSourceCiID() (r int, exists bool) {
	v := m.addsource_ci_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSourceCiID resets all changes to the "source_ci_id" field.
func (m *CIRelationshipMutation) ResetSourceCiID() {
	m.source_ci_id = nil
	m.addsource_ci_id = nil
}

// SetTargetCiID sets the "target_ci_id" field.
func (m *CIRelationshipMutation) SetTargetCiID(i int) {
	m.target_ci_id = &i
	m.addtarget_ci_id = nil
}

// TargetCiID returns the value of the "target_ci_id" field in the mutation.
func (m *CIRelationshipMutation) TargetCiID() (r int, exists bool) {
	v := m.target_ci_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetCiID returns the old "target_ci_id" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldTargetCiID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetCiID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetCiID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetCiID: %w", err)
	}
	return oldValue.TargetCiID, nil
}

// AddTargetCiID adds i to the "target_ci_id" field.
func (m *CIRelationshipMutation) AddTargetCiID(i int) {
	if m.addtarget_ci_id != nil {
		*m.addtarget_ci_id += i
	} else {
		m.addtarget_ci_id = &i
	}
}

// AddedTargetCiID returns the value that was added to the "target_ci_id" field in this mutation.
func (m *CIRelationshipMutation) AddedTargetCiID() (r int, exists bool) {
	v := m.addtarget_ci_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTargetCiID resets all changes to the "target_ci_id" field.
func (m *CIRelationshipMutation) ResetTargetCiID() {
	m.target_ci_id = nil
	m.addtarget_ci_id = nil
}

// SetRelationshipTypeID sets the "relationship_type_id" field.
func (m *CIRelationshipMutation) SetRelationshipTypeID(i int) {
	m.relationship_type_id = &i
	m.addrelationship_type_id = nil
}

// RelationshipTypeID returns the value of the "relationship_type_id" field in the mutation.
func (m *CIRelationshipMutation) RelationshipTypeID() (r int, exists bool) {
	v := m.relationship_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationshipTypeID returns the old "relationship_type_id" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldRelationshipTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationshipTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationshipTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationshipTypeID: %w", err)
	}
	return oldValue.RelationshipTypeID, nil
}

// AddRelationshipTypeID adds i to the "relationship_type_id" field.
func (m *CIRelationshipMutation) AddRelationshipTypeID(i int) {
	if m.addrelationship_type_id != nil {
		*m.addrelationship_type_id += i
	} else {
		m.addrelationship_type_id = &i
	}
}

// AddedRelationshipTypeID returns the value that was added to the "relationship_type_id" field in this mutation.
func (m *CIRelationshipMutation) AddedRelationshipTypeID() (r int, exists bool) {
	v := m.addrelationship_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRelationshipTypeID resets all changes to the "relationship_type_id" field.
func (m *CIRelationshipMutation) ResetRelationshipTypeID() {
	m.relationship_type_id = nil
	m.addrelationship_type_id = nil
}

// SetDescription sets the "description" field.
func (m *CIRelationshipMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CIRelationshipMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CIRelationshipMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[cirelationship.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CIRelationshipMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[cirelationship.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CIRelationshipMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, cirelationship.FieldDescription)
}

// SetTenantID sets the "tenant_id" field.
func (m *CIRelationshipMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CIRelationshipMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *CIRelationshipMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *CIRelationshipMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CIRelationshipMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CIRelationshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CIRelationshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CIRelationshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CIRelationshipMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CIRelationshipMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CIRelationshipMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the CIRelationshipMutation builder.
func (m *CIRelationshipMutation) Where(ps ...predicate.CIRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CIRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CIRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CIRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CIRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CIRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CIRelationship).
func (m *CIRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CIRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.source_ci_id != nil {
		fields = append(fields, cirelationship.FieldSourceCiID)
	}
	if m.target_ci_id != nil {
		fields = append(fields, cirelationship.FieldTargetCiID)
	}
	if m.relationship_type_id != nil {
		fields = append(fields, cirelationship.FieldRelationshipTypeID)
	}
	if m.description != nil {
		fields = append(fields, cirelationship.FieldDescription)
	}
	if m.tenant_id != nil {
		fields = append(fields, cirelationship.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, cirelationship.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cirelationship.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CIRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cirelationship.FieldSourceCiID:
		return m.SourceCiID()
	case cirelationship.FieldTargetCiID:
		return m.TargetCiID()
	case cirelationship.FieldRelationshipTypeID:
		return m.RelationshipTypeID()
	case cirelationship.FieldDescription:
		return m.Description()
	case cirelationship.FieldTenantID:
		return m.TenantID()
	case cirelationship.FieldCreatedAt:
		return m.CreatedAt()
	case cirelationship.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CIRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cirelationship.FieldSourceCiID:
		return m.OldSourceCiID(ctx)
	case cirelationship.FieldTargetCiID:
		return m.OldTargetCiID(ctx)
	case cirelationship.FieldRelationshipTypeID:
		return m.OldRelationshipTypeID(ctx)
	case cirelationship.FieldDescription:
		return m.OldDescription(ctx)
	case cirelationship.FieldTenantID:
		return m.OldTenantID(ctx)
	case cirelationship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cirelationship.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CIRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CIRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cirelationship.FieldSourceCiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceCiID(v)
		return nil
	case cirelationship.FieldTargetCiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetCiID(v)
		return nil
	case cirelationship.FieldRelationshipTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationshipTypeID(v)
		return nil
	case cirelationship.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case cirelationship.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case cirelationship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cirelationship.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CIRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CIRelationshipMutation) AddedFields() []string {
	var fields []string
	if m.addsource_ci_id != nil {
		fields = append(fields, cirelationship.FieldSourceCiID)
	}
	if m.addtarget_ci_id != nil {
		fields = append(fields, cirelationship.FieldTargetCiID)
	}
	if m.addrelationship_type_id != nil {
		fields = append(fields, cirelationship.FieldRelationshipTypeID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, cirelationship.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CIRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cirelationship.FieldSourceCiID:
		return m.AddedSourceCiID()
	case cirelationship.FieldTargetCiID:
		return m.AddedTargetCiID()
	case cirelationship.FieldRelationshipTypeID:
		return m.AddedRelationshipTypeID()
	case cirelationship.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CIRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cirelationship.FieldSourceCiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSourceCiID(v)
		return nil
	case cirelationship.FieldTargetCiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetCiID(v)
		return nil
	case cirelationship.FieldRelationshipTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelationshipTypeID(v)
		return nil
	case cirelationship.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown CIRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CIRelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cirelationship.FieldDescription) {
		fields = append(fields, cirelationship.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CIRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CIRelationshipMutation) ClearField(name string) error {
	switch name {
	case cirelationship.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CIRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CIRelationshipMutation) ResetField(name string) error {
	switch name {
	case cirelationship.FieldSourceCiID:
		m.ResetSourceCiID()
		return nil
	case cirelationship.FieldTargetCiID:
		m.ResetTargetCiID()
		return nil
	case cirelationship.FieldRelationshipTypeID:
		m.ResetRelationshipTypeID()
		return nil
	case cirelationship.FieldDescription:
		m.ResetDescription()
		return nil
	case cirelationship.FieldTenantID:
		m.ResetTenantID()
		return nil
	case cirelationship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cirelationship.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CIRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CIRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CIRelationshipMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CIRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CIRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CIRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CIRelationshipMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CIRelationshipMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CIRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CIRelationshipMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CIRelationship edge %s", name)
}

// CITypeMutation represents an operation that mutates the CIType nodes in the graph.
type CITypeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	description      *string
	icon             *string
	color            *string
	attribute_schema *string
	tenant_id        *int
	addtenant_id     *int
	is_active        *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*CIType, error)
	predicates       []predicate.CIType
}

var _ ent.Mutation = (*CITypeMutation)(nil)

// citypeOption allows management of the mutation configuration using functional options.
type citypeOption func(*CITypeMutation)

// newCITypeMutation creates new mutation for the CIType entity.
func newCITypeMutation(c config, op Op, opts ...citypeOption) *CITypeMutation {
	m := &CITypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCIType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCITypeID sets the ID field of the mutation.
func withCITypeID(id int) citypeOption {
	return func(m *CITypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CIType
		)
		m.oldValue = func(ctx context.Context) (*CIType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CIType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCIType sets the old CIType of the mutation.
func withCIType(node *CIType) citypeOption {
	return func(m *CITypeMutation) {
		m.oldValue = func(context.Context) (*CIType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CITypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CITypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CITypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CITypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CIType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CITypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CITypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CITypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CITypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CITypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CITypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[citype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CITypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[citype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CITypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, citype.FieldDescription)
}

// SetIcon sets the "icon" field.
func (m *CITypeMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *CITypeMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *CITypeMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[citype.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *CITypeMutation) IconCleared() bool {
	_, ok := m.clearedFields[citype.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *CITypeMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, citype.FieldIcon)
}

// SetColor sets the "color" field.
func (m *CITypeMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *CITypeMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *CITypeMutation) ClearColor() {
	m.color = nil
	m.clearedFields[citype.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *CITypeMutation) ColorCleared() bool {
	_, ok := m.clearedFields[citype.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *CITypeMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, citype.FieldColor)
}

// SetAttributeSchema sets the "attribute_schema" field.
func (m *CITypeMutation) SetAttributeSchema(s string) {
	m.attribute_schema = &s
}

// AttributeSchema returns the value of the "attribute_schema" field in the mutation.
func (m *CITypeMutation) AttributeSchema() (r string, exists bool) {
	v := m.attribute_schema
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributeSchema returns the old "attribute_schema" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldAttributeSchema(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributeSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributeSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributeSchema: %w", err)
	}
	return oldValue.AttributeSchema, nil
}

// ClearAttributeSchema clears the value of the "attribute_schema" field.
func (m *CITypeMutation) ClearAttributeSchema() {
	m.attribute_schema = nil
	m.clearedFields[citype.FieldAttributeSchema] = struct{}{}
}

// AttributeSchemaCleared returns if the "attribute_schema" field was cleared in this mutation.
func (m *CITypeMutation) AttributeSchemaCleared() bool {
	_, ok := m.clearedFields[citype.FieldAttributeSchema]
	return ok
}

// ResetAttributeSchema resets all changes to the "attribute_schema" field.
func (m *CITypeMutation) ResetAttributeSchema() {
	m.attribute_schema = nil
	delete(m.clearedFields, citype.FieldAttributeSchema)
}

// SetTenantID sets the "tenant_id" field.
func (m *CITypeMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CITypeMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *CITypeMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *CITypeMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CITypeMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetIsActive sets the "is_active" field.
func (m *CITypeMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *CITypeMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *CITypeMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CITypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CITypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CITypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CITypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CITypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CITypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the CITypeMutation builder.
func (m *CITypeMutation) Where(ps ...predicate.CIType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CITypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CITypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CIType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CITypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CITypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CIType).
func (m *CITypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CITypeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, citype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, citype.FieldDescription)
	}
	if m.icon != nil {
		fields = append(fields, citype.FieldIcon)
	}
	if m.color != nil {
		fields = append(fields, citype.FieldColor)
	}
	if m.attribute_schema != nil {
		fields = append(fields, citype.FieldAttributeSchema)
	}
	if m.tenant_id != nil {
		fields = append(fields, citype.FieldTenantID)
	}
	if m.is_active != nil {
		fields = append(fields, citype.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, citype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, citype.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CITypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case citype.FieldName:
		return m.Name()
	case citype.FieldDescription:
		return m.Description()
	case citype.FieldIcon:
		return m.Icon()
	case citype.FieldColor:
		return m.Color()
	case citype.FieldAttributeSchema:
		return m.AttributeSchema()
	case citype.FieldTenantID:
		return m.TenantID()
	case citype.FieldIsActive:
		return m.IsActive()
	case citype.FieldCreatedAt:
		return m.CreatedAt()
	case citype.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CITypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case citype.FieldName:
		return m.OldName(ctx)
	case citype.FieldDescription:
		return m.OldDescription(ctx)
	case citype.FieldIcon:
		return m.OldIcon(ctx)
	case citype.FieldColor:
		return m.OldColor(ctx)
	case citype.FieldAttributeSchema:
		return m.OldAttributeSchema(ctx)
	case citype.FieldTenantID:
		return m.OldTenantID(ctx)
	case citype.FieldIsActive:
		return m.OldIsActive(ctx)
	case citype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case citype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CIType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CITypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case citype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case citype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case citype.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case citype.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case citype.FieldAttributeSchema:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributeSchema(v)
		return nil
	case citype.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case citype.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case citype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case citype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CIType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CITypeMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, citype.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CITypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case citype.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CITypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case citype.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown CIType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CITypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(citype.FieldDescription) {
		fields = append(fields, citype.FieldDescription)
	}
	if m.FieldCleared(citype.FieldIcon) {
		fields = append(fields, citype.FieldIcon)
	}
	if m.FieldCleared(citype.FieldColor) {
		fields = append(fields, citype.FieldColor)
	}
	if m.FieldCleared(citype.FieldAttributeSchema) {
		fields = append(fields, citype.FieldAttributeSchema)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CITypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CITypeMutation) ClearField(name string) error {
	switch name {
	case citype.FieldDescription:
		m.ClearDescription()
		return nil
	case citype.FieldIcon:
		m.ClearIcon()
		return nil
	case citype.FieldColor:
		m.ClearColor()
		return nil
	case citype.FieldAttributeSchema:
		m.ClearAttributeSchema()
		return nil
	}
	return fmt.Errorf("unknown CIType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CITypeMutation) ResetField(name string) error {
	switch name {
	case citype.FieldName:
		m.ResetName()
		return nil
	case citype.FieldDescription:
		m.ResetDescription()
		return nil
	case citype.FieldIcon:
		m.ResetIcon()
		return nil
	case citype.FieldColor:
		m.ResetColor()
		return nil
	case citype.FieldAttributeSchema:
		m.ResetAttributeSchema()
		return nil
	case citype.FieldTenantID:
		m.ResetTenantID()
		return nil
	case citype.FieldIsActive:
		m.ResetIsActive()
		return nil
	case citype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case citype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CIType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CITypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CITypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CITypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CITypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CITypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CITypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CITypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CIType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CITypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CIType edge %s", name)
}

// ChangeMutation represents an operation that mutates the Change nodes in the graph.
type ChangeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	title                 *string
	description           *string
	justification         *string
	_type                 *string
	status                *string
	priority              *string
	impact_scope          *string
	risk_level            *string
	assignee_id           *int
	addassignee_id        *int
	created_by            *int
	addcreated_by         *int
	tenant_id             *int
	addtenant_id          *int
	planned_start_date    *time.Time
	planned_end_date      *time.Time
	actual_start_date     *time.Time
	actual_end_date       *time.Time
	implementation_plan   *string
	rollback_plan         *string
	affected_cis          *[]string
	appendaffected_cis    []string
	related_tickets       *[]string
	appendrelated_tickets []string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*Change, error)
	predicates            []predicate.Change
}

var _ ent.Mutation = (*ChangeMutation)(nil)

// changeOption allows management of the mutation configuration using functional options.
type changeOption func(*ChangeMutation)

// newChangeMutation creates new mutation for the Change entity.
func newChangeMutation(c config, op Op, opts ...changeOption) *ChangeMutation {
	m := &ChangeMutation{
		config:        c,
		op:            op,
		typ:           TypeChange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChangeID sets the ID field of the mutation.
func withChangeID(id int) changeOption {
	return func(m *ChangeMutation) {
		var (
			err   error
			once  sync.Once
			value *Change
		)
		m.oldValue = func(ctx context.Context) (*Change, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Change.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChange sets the old Change of the mutation.
func withChange(node *Change) changeOption {
	return func(m *ChangeMutation) {
		m.oldValue = func(context.Context) (*Change, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChangeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChangeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Change.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ChangeMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ChangeMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ChangeMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ChangeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ChangeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ChangeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[change.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ChangeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[change.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ChangeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, change.FieldDescription)
}

// SetJustification sets the "justification" field.
func (m *ChangeMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *ChangeMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ClearJustification clears the value of the "justification" field.
func (m *ChangeMutation) ClearJustification() {
	m.justification = nil
	m.clearedFields[change.FieldJustification] = struct{}{}
}

// JustificationCleared returns if the "justification" field was cleared in this mutation.
func (m *ChangeMutation) JustificationCleared() bool {
	_, ok := m.clearedFields[change.FieldJustification]
	return ok
}

// ResetJustification resets all changes to the "justification" field.
func (m *ChangeMutation) ResetJustification() {
	m.justification = nil
	delete(m.clearedFields, change.FieldJustification)
}

// SetType sets the "type" field.
func (m *ChangeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ChangeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ChangeMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *ChangeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ChangeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ChangeMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *ChangeMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ChangeMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *ChangeMutation) ResetPriority() {
	m.priority = nil
}

// SetImpactScope sets the "impact_scope" field.
func (m *ChangeMutation) SetImpactScope(s string) {
	m.impact_scope = &s
}

// ImpactScope returns the value of the "impact_scope" field in the mutation.
func (m *ChangeMutation) ImpactScope() (r string, exists bool) {
	v := m.impact_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldImpactScope returns the old "impact_scope" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldImpactScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpactScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpactScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpactScope: %w", err)
	}
	return oldValue.ImpactScope, nil
}

// ResetImpactScope resets all changes to the "impact_scope" field.
func (m *ChangeMutation) ResetImpactScope() {
	m.impact_scope = nil
}

// SetRiskLevel sets the "risk_level" field.
func (m *ChangeMutation) SetRiskLevel(s string) {
	m.risk_level = &s
}

// RiskLevel returns the value of the "risk_level" field in the mutation.
func (m *ChangeMutation) RiskLevel() (r string, exists bool) {
	v := m.risk_level
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskLevel returns the old "risk_level" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldRiskLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskLevel: %w", err)
	}
	return oldValue.RiskLevel, nil
}

// ResetRiskLevel resets all changes to the "risk_level" field.
func (m *ChangeMutation) ResetRiskLevel() {
	m.risk_level = nil
}

// SetAssigneeID sets the "assignee_id" field.
func (m *ChangeMutation) SetAssigneeID(i int) {
	m.assignee_id = &i
	m.addassignee_id = nil
}

// AssigneeID returns the value of the "assignee_id" field in the mutation.
func (m *ChangeMutation) AssigneeID() (r int, exists bool) {
	v := m.assignee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeID returns the old "assignee_id" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldAssigneeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeID: %w", err)
	}
	return oldValue.AssigneeID, nil
}

// AddAssigneeID adds i to the "assignee_id" field.
func (m *ChangeMutation) AddAssigneeID(i int) {
	if m.addassignee_id != nil {
		*m.addassignee_id += i
	} else {
		m.addassignee_id = &i
	}
}

// AddedAssigneeID returns the value that was added to the "assignee_id" field in this mutation.
func (m *ChangeMutation) AddedAssigneeID() (r int, exists bool) {
	v := m.addassignee_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssigneeID clears the value of the "assignee_id" field.
func (m *ChangeMutation) ClearAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	m.clearedFields[change.FieldAssigneeID] = struct{}{}
}

// AssigneeIDCleared returns if the "assignee_id" field was cleared in this mutation.
func (m *ChangeMutation) AssigneeIDCleared() bool {
	_, ok := m.clearedFields[change.FieldAssigneeID]
	return ok
}

// ResetAssigneeID resets all changes to the "assignee_id" field.
func (m *ChangeMutation) ResetAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	delete(m.clearedFields, change.FieldAssigneeID)
}

// SetCreatedBy sets the "created_by" field.
func (m *ChangeMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ChangeMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ChangeMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ChangeMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ChangeMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ChangeMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ChangeMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ChangeMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ChangeMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ChangeMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetPlannedStartDate sets the "planned_start_date" field.
func (m *ChangeMutation) SetPlannedStartDate(t time.Time) {
	m.planned_start_date = &t
}

// PlannedStartDate returns the value of the "planned_start_date" field in the mutation.
func (m *ChangeMutation) PlannedStartDate() (r time.Time, exists bool) {
	v := m.planned_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPlannedStartDate returns the old "planned_start_date" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldPlannedStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlannedStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlannedStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlannedStartDate: %w", err)
	}
	return oldValue.PlannedStartDate, nil
}

// ClearPlannedStartDate clears the value of the "planned_start_date" field.
func (m *ChangeMutation) ClearPlannedStartDate() {
	m.planned_start_date = nil
	m.clearedFields[change.FieldPlannedStartDate] = struct{}{}
}

// PlannedStartDateCleared returns if the "planned_start_date" field was cleared in this mutation.
func (m *ChangeMutation) PlannedStartDateCleared() bool {
	_, ok := m.clearedFields[change.FieldPlannedStartDate]
	return ok
}

// ResetPlannedStartDate resets all changes to the "planned_start_date" field.
func (m *ChangeMutation) ResetPlannedStartDate() {
	m.planned_start_date = nil
	delete(m.clearedFields, change.FieldPlannedStartDate)
}

// SetPlannedEndDate sets the "planned_end_date" field.
func (m *ChangeMutation) SetPlannedEndDate(t time.Time) {
	m.planned_end_date = &t
}

// PlannedEndDate returns the value of the "planned_end_date" field in the mutation.
func (m *ChangeMutation) PlannedEndDate() (r time.Time, exists bool) {
	v := m.planned_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPlannedEndDate returns the old "planned_end_date" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldPlannedEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlannedEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlannedEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlannedEndDate: %w", err)
	}
	return oldValue.PlannedEndDate, nil
}

// ClearPlannedEndDate clears the value of the "planned_end_date" field.
func (m *ChangeMutation) ClearPlannedEndDate() {
	m.planned_end_date = nil
	m.clearedFields[change.FieldPlannedEndDate] = struct{}{}
}

// PlannedEndDateCleared returns if the "planned_end_date" field was cleared in this mutation.
func (m *ChangeMutation) PlannedEndDateCleared() bool {
	_, ok := m.clearedFields[change.FieldPlannedEndDate]
	return ok
}

// ResetPlannedEndDate resets all changes to the "planned_end_date" field.
func (m *ChangeMutation) ResetPlannedEndDate() {
	m.planned_end_date = nil
	delete(m.clearedFields, change.FieldPlannedEndDate)
}

// SetActualStartDate sets the "actual_start_date" field.
func (m *ChangeMutation) SetActualStartDate(t time.Time) {
	m.actual_start_date = &t
}

// ActualStartDate returns the value of the "actual_start_date" field in the mutation.
func (m *ChangeMutation) ActualStartDate() (r time.Time, exists bool) {
	v := m.actual_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldActualStartDate returns the old "actual_start_date" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldActualStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualStartDate: %w", err)
	}
	return oldValue.ActualStartDate, nil
}

// ClearActualStartDate clears the value of the "actual_start_date" field.
func (m *ChangeMutation) ClearActualStartDate() {
	m.actual_start_date = nil
	m.clearedFields[change.FieldActualStartDate] = struct{}{}
}

// ActualStartDateCleared returns if the "actual_start_date" field was cleared in this mutation.
func (m *ChangeMutation) ActualStartDateCleared() bool {
	_, ok := m.clearedFields[change.FieldActualStartDate]
	return ok
}

// ResetActualStartDate resets all changes to the "actual_start_date" field.
func (m *ChangeMutation) ResetActualStartDate() {
	m.actual_start_date = nil
	delete(m.clearedFields, change.FieldActualStartDate)
}

// SetActualEndDate sets the "actual_end_date" field.
func (m *ChangeMutation) SetActualEndDate(t time.Time) {
	m.actual_end_date = &t
}

// ActualEndDate returns the value of the "actual_end_date" field in the mutation.
func (m *ChangeMutation) ActualEndDate() (r time.Time, exists bool) {
	v := m.actual_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldActualEndDate returns the old "actual_end_date" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldActualEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualEndDate: %w", err)
	}
	return oldValue.ActualEndDate, nil
}

// ClearActualEndDate clears the value of the "actual_end_date" field.
func (m *ChangeMutation) ClearActualEndDate() {
	m.actual_end_date = nil
	m.clearedFields[change.FieldActualEndDate] = struct{}{}
}

// ActualEndDateCleared returns if the "actual_end_date" field was cleared in this mutation.
func (m *ChangeMutation) ActualEndDateCleared() bool {
	_, ok := m.clearedFields[change.FieldActualEndDate]
	return ok
}

// ResetActualEndDate resets all changes to the "actual_end_date" field.
func (m *ChangeMutation) ResetActualEndDate() {
	m.actual_end_date = nil
	delete(m.clearedFields, change.FieldActualEndDate)
}

// SetImplementationPlan sets the "implementation_plan" field.
func (m *ChangeMutation) SetImplementationPlan(s string) {
	m.implementation_plan = &s
}

// ImplementationPlan returns the value of the "implementation_plan" field in the mutation.
func (m *ChangeMutation) ImplementationPlan() (r string, exists bool) {
	v := m.implementation_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementationPlan returns the old "implementation_plan" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldImplementationPlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementationPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementationPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementationPlan: %w", err)
	}
	return oldValue.ImplementationPlan, nil
}

// ClearImplementationPlan clears the value of the "implementation_plan" field.
func (m *ChangeMutation) ClearImplementationPlan() {
	m.implementation_plan = nil
	m.clearedFields[change.FieldImplementationPlan] = struct{}{}
}

// ImplementationPlanCleared returns if the "implementation_plan" field was cleared in this mutation.
func (m *ChangeMutation) ImplementationPlanCleared() bool {
	_, ok := m.clearedFields[change.FieldImplementationPlan]
	return ok
}

// ResetImplementationPlan resets all changes to the "implementation_plan" field.
func (m *ChangeMutation) ResetImplementationPlan() {
	m.implementation_plan = nil
	delete(m.clearedFields, change.FieldImplementationPlan)
}

// SetRollbackPlan sets the "rollback_plan" field.
func (m *ChangeMutation) SetRollbackPlan(s string) {
	m.rollback_plan = &s
}

// RollbackPlan returns the value of the "rollback_plan" field in the mutation.
func (m *ChangeMutation) RollbackPlan() (r string, exists bool) {
	v := m.rollback_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldRollbackPlan returns the old "rollback_plan" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldRollbackPlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRollbackPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRollbackPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRollbackPlan: %w", err)
	}
	return oldValue.RollbackPlan, nil
}

// ClearRollbackPlan clears the value of the "rollback_plan" field.
func (m *ChangeMutation) ClearRollbackPlan() {
	m.rollback_plan = nil
	m.clearedFields[change.FieldRollbackPlan] = struct{}{}
}

// RollbackPlanCleared returns if the "rollback_plan" field was cleared in this mutation.
func (m *ChangeMutation) RollbackPlanCleared() bool {
	_, ok := m.clearedFields[change.FieldRollbackPlan]
	return ok
}

// ResetRollbackPlan resets all changes to the "rollback_plan" field.
func (m *ChangeMutation) ResetRollbackPlan() {
	m.rollback_plan = nil
	delete(m.clearedFields, change.FieldRollbackPlan)
}

// SetAffectedCis sets the "affected_cis" field.
func (m *ChangeMutation) SetAffectedCis(s []string) {
	m.affected_cis = &s
	m.appendaffected_cis = nil
}

// AffectedCis returns the value of the "affected_cis" field in the mutation.
func (m *ChangeMutation) AffectedCis() (r []string, exists bool) {
	v := m.affected_cis
	if v == nil {
		return
	}
	return *v, true
}

// OldAffectedCis returns the old "affected_cis" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldAffectedCis(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffectedCis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffectedCis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffectedCis: %w", err)
	}
	return oldValue.AffectedCis, nil
}

// AppendAffectedCis adds s to the "affected_cis" field.
func (m *ChangeMutation) AppendAffectedCis(s []string) {
	m.appendaffected_cis = append(m.appendaffected_cis, s...)
}

// AppendedAffectedCis returns the list of values that were appended to the "affected_cis" field in this mutation.
func (m *ChangeMutation) AppendedAffectedCis() ([]string, bool) {
	if len(m.appendaffected_cis) == 0 {
		return nil, false
	}
	return m.appendaffected_cis, true
}

// ClearAffectedCis clears the value of the "affected_cis" field.
func (m *ChangeMutation) ClearAffectedCis() {
	m.affected_cis = nil
	m.appendaffected_cis = nil
	m.clearedFields[change.FieldAffectedCis] = struct{}{}
}

// AffectedCisCleared returns if the "affected_cis" field was cleared in this mutation.
func (m *ChangeMutation) AffectedCisCleared() bool {
	_, ok := m.clearedFields[change.FieldAffectedCis]
	return ok
}

// ResetAffectedCis resets all changes to the "affected_cis" field.
func (m *ChangeMutation) ResetAffectedCis() {
	m.affected_cis = nil
	m.appendaffected_cis = nil
	delete(m.clearedFields, change.FieldAffectedCis)
}

// SetRelatedTickets sets the "related_tickets" field.
func (m *ChangeMutation) SetRelatedTickets(s []string) {
	m.related_tickets = &s
	m.appendrelated_tickets = nil
}

// RelatedTickets returns the value of the "related_tickets" field in the mutation.
func (m *ChangeMutation) RelatedTickets() (r []string, exists bool) {
	v := m.related_tickets
	if v == nil {
		return
	}
	return *v, true
}

// OldRelatedTickets returns the old "related_tickets" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldRelatedTickets(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelatedTickets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelatedTickets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelatedTickets: %w", err)
	}
	return oldValue.RelatedTickets, nil
}

// AppendRelatedTickets adds s to the "related_tickets" field.
func (m *ChangeMutation) AppendRelatedTickets(s []string) {
	m.appendrelated_tickets = append(m.appendrelated_tickets, s...)
}

// AppendedRelatedTickets returns the list of values that were appended to the "related_tickets" field in this mutation.
func (m *ChangeMutation) AppendedRelatedTickets() ([]string, bool) {
	if len(m.appendrelated_tickets) == 0 {
		return nil, false
	}
	return m.appendrelated_tickets, true
}

// ClearRelatedTickets clears the value of the "related_tickets" field.
func (m *ChangeMutation) ClearRelatedTickets() {
	m.related_tickets = nil
	m.appendrelated_tickets = nil
	m.clearedFields[change.FieldRelatedTickets] = struct{}{}
}

// RelatedTicketsCleared returns if the "related_tickets" field was cleared in this mutation.
func (m *ChangeMutation) RelatedTicketsCleared() bool {
	_, ok := m.clearedFields[change.FieldRelatedTickets]
	return ok
}

// ResetRelatedTickets resets all changes to the "related_tickets" field.
func (m *ChangeMutation) ResetRelatedTickets() {
	m.related_tickets = nil
	m.appendrelated_tickets = nil
	delete(m.clearedFields, change.FieldRelatedTickets)
}

// SetCreatedAt sets the "created_at" field.
func (m *ChangeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChangeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChangeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChangeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChangeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChangeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ChangeMutation builder.
func (m *ChangeMutation) Where(ps ...predicate.Change) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChangeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChangeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Change, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChangeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChangeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Change).
func (m *ChangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChangeMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.title != nil {
		fields = append(fields, change.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, change.FieldDescription)
	}
	if m.justification != nil {
		fields = append(fields, change.FieldJustification)
	}
	if m._type != nil {
		fields = append(fields, change.FieldType)
	}
	if m.status != nil {
		fields = append(fields, change.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, change.FieldPriority)
	}
	if m.impact_scope != nil {
		fields = append(fields, change.FieldImpactScope)
	}
	if m.risk_level != nil {
		fields = append(fields, change.FieldRiskLevel)
	}
	if m.assignee_id != nil {
		fields = append(fields, change.FieldAssigneeID)
	}
	if m.created_by != nil {
		fields = append(fields, change.FieldCreatedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, change.FieldTenantID)
	}
	if m.planned_start_date != nil {
		fields = append(fields, change.FieldPlannedStartDate)
	}
	if m.planned_end_date != nil {
		fields = append(fields, change.FieldPlannedEndDate)
	}
	if m.actual_start_date != nil {
		fields = append(fields, change.FieldActualStartDate)
	}
	if m.actual_end_date != nil {
		fields = append(fields, change.FieldActualEndDate)
	}
	if m.implementation_plan != nil {
		fields = append(fields, change.FieldImplementationPlan)
	}
	if m.rollback_plan != nil {
		fields = append(fields, change.FieldRollbackPlan)
	}
	if m.affected_cis != nil {
		fields = append(fields, change.FieldAffectedCis)
	}
	if m.related_tickets != nil {
		fields = append(fields, change.FieldRelatedTickets)
	}
	if m.created_at != nil {
		fields = append(fields, change.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, change.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case change.FieldTitle:
		return m.Title()
	case change.FieldDescription:
		return m.Description()
	case change.FieldJustification:
		return m.Justification()
	case change.FieldType:
		return m.GetType()
	case change.FieldStatus:
		return m.Status()
	case change.FieldPriority:
		return m.Priority()
	case change.FieldImpactScope:
		return m.ImpactScope()
	case change.FieldRiskLevel:
		return m.RiskLevel()
	case change.FieldAssigneeID:
		return m.AssigneeID()
	case change.FieldCreatedBy:
		return m.CreatedBy()
	case change.FieldTenantID:
		return m.TenantID()
	case change.FieldPlannedStartDate:
		return m.PlannedStartDate()
	case change.FieldPlannedEndDate:
		return m.PlannedEndDate()
	case change.FieldActualStartDate:
		return m.ActualStartDate()
	case change.FieldActualEndDate:
		return m.ActualEndDate()
	case change.FieldImplementationPlan:
		return m.ImplementationPlan()
	case change.FieldRollbackPlan:
		return m.RollbackPlan()
	case change.FieldAffectedCis:
		return m.AffectedCis()
	case change.FieldRelatedTickets:
		return m.RelatedTickets()
	case change.FieldCreatedAt:
		return m.CreatedAt()
	case change.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case change.FieldTitle:
		return m.OldTitle(ctx)
	case change.FieldDescription:
		return m.OldDescription(ctx)
	case change.FieldJustification:
		return m.OldJustification(ctx)
	case change.FieldType:
		return m.OldType(ctx)
	case change.FieldStatus:
		return m.OldStatus(ctx)
	case change.FieldPriority:
		return m.OldPriority(ctx)
	case change.FieldImpactScope:
		return m.OldImpactScope(ctx)
	case change.FieldRiskLevel:
		return m.OldRiskLevel(ctx)
	case change.FieldAssigneeID:
		return m.OldAssigneeID(ctx)
	case change.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case change.FieldTenantID:
		return m.OldTenantID(ctx)
	case change.FieldPlannedStartDate:
		return m.OldPlannedStartDate(ctx)
	case change.FieldPlannedEndDate:
		return m.OldPlannedEndDate(ctx)
	case change.FieldActualStartDate:
		return m.OldActualStartDate(ctx)
	case change.FieldActualEndDate:
		return m.OldActualEndDate(ctx)
	case change.FieldImplementationPlan:
		return m.OldImplementationPlan(ctx)
	case change.FieldRollbackPlan:
		return m.OldRollbackPlan(ctx)
	case change.FieldAffectedCis:
		return m.OldAffectedCis(ctx)
	case change.FieldRelatedTickets:
		return m.OldRelatedTickets(ctx)
	case change.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case change.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Change field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case change.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case change.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case change.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case change.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case change.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case change.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case change.FieldImpactScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpactScope(v)
		return nil
	case change.FieldRiskLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskLevel(v)
		return nil
	case change.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeID(v)
		return nil
	case change.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case change.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case change.FieldPlannedStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlannedStartDate(v)
		return nil
	case change.FieldPlannedEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlannedEndDate(v)
		return nil
	case change.FieldActualStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualStartDate(v)
		return nil
	case change.FieldActualEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualEndDate(v)
		return nil
	case change.FieldImplementationPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementationPlan(v)
		return nil
	case change.FieldRollbackPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRollbackPlan(v)
		return nil
	case change.FieldAffectedCis:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffectedCis(v)
		return nil
	case change.FieldRelatedTickets:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelatedTickets(v)
		return nil
	case change.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case change.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Change field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChangeMutation) AddedFields() []string {
	var fields []string
	if m.addassignee_id != nil {
		fields = append(fields, change.FieldAssigneeID)
	}
	if m.addcreated_by != nil {
		fields = append(fields, change.FieldCreatedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, change.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChangeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case change.FieldAssigneeID:
		return m.AddedAssigneeID()
	case change.FieldCreatedBy:
		return m.AddedCreatedBy()
	case change.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case change.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssigneeID(v)
		return nil
	case change.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case change.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Change numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChangeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(change.FieldDescription) {
		fields = append(fields, change.FieldDescription)
	}
	if m.FieldCleared(change.FieldJustification) {
		fields = append(fields, change.FieldJustification)
	}
	if m.FieldCleared(change.FieldAssigneeID) {
		fields = append(fields, change.FieldAssigneeID)
	}
	if m.FieldCleared(change.FieldPlannedStartDate) {
		fields = append(fields, change.FieldPlannedStartDate)
	}
	if m.FieldCleared(change.FieldPlannedEndDate) {
		fields = append(fields, change.FieldPlannedEndDate)
	}
	if m.FieldCleared(change.FieldActualStartDate) {
		fields = append(fields, change.FieldActualStartDate)
	}
	if m.FieldCleared(change.FieldActualEndDate) {
		fields = append(fields, change.FieldActualEndDate)
	}
	if m.FieldCleared(change.FieldImplementationPlan) {
		fields = append(fields, change.FieldImplementationPlan)
	}
	if m.FieldCleared(change.FieldRollbackPlan) {
		fields = append(fields, change.FieldRollbackPlan)
	}
	if m.FieldCleared(change.FieldAffectedCis) {
		fields = append(fields, change.FieldAffectedCis)
	}
	if m.FieldCleared(change.FieldRelatedTickets) {
		fields = append(fields, change.FieldRelatedTickets)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChangeMutation) ClearField(name string) error {
	switch name {
	case change.FieldDescription:
		m.ClearDescription()
		return nil
	case change.FieldJustification:
		m.ClearJustification()
		return nil
	case change.FieldAssigneeID:
		m.ClearAssigneeID()
		return nil
	case change.FieldPlannedStartDate:
		m.ClearPlannedStartDate()
		return nil
	case change.FieldPlannedEndDate:
		m.ClearPlannedEndDate()
		return nil
	case change.FieldActualStartDate:
		m.ClearActualStartDate()
		return nil
	case change.FieldActualEndDate:
		m.ClearActualEndDate()
		return nil
	case change.FieldImplementationPlan:
		m.ClearImplementationPlan()
		return nil
	case change.FieldRollbackPlan:
		m.ClearRollbackPlan()
		return nil
	case change.FieldAffectedCis:
		m.ClearAffectedCis()
		return nil
	case change.FieldRelatedTickets:
		m.ClearRelatedTickets()
		return nil
	}
	return fmt.Errorf("unknown Change nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChangeMutation) ResetField(name string) error {
	switch name {
	case change.FieldTitle:
		m.ResetTitle()
		return nil
	case change.FieldDescription:
		m.ResetDescription()
		return nil
	case change.FieldJustification:
		m.ResetJustification()
		return nil
	case change.FieldType:
		m.ResetType()
		return nil
	case change.FieldStatus:
		m.ResetStatus()
		return nil
	case change.FieldPriority:
		m.ResetPriority()
		return nil
	case change.FieldImpactScope:
		m.ResetImpactScope()
		return nil
	case change.FieldRiskLevel:
		m.ResetRiskLevel()
		return nil
	case change.FieldAssigneeID:
		m.ResetAssigneeID()
		return nil
	case change.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case change.FieldTenantID:
		m.ResetTenantID()
		return nil
	case change.FieldPlannedStartDate:
		m.ResetPlannedStartDate()
		return nil
	case change.FieldPlannedEndDate:
		m.ResetPlannedEndDate()
		return nil
	case change.FieldActualStartDate:
		m.ResetActualStartDate()
		return nil
	case change.FieldActualEndDate:
		m.ResetActualEndDate()
		return nil
	case change.FieldImplementationPlan:
		m.ResetImplementationPlan()
		return nil
	case change.FieldRollbackPlan:
		m.ResetRollbackPlan()
		return nil
	case change.FieldAffectedCis:
		m.ResetAffectedCis()
		return nil
	case change.FieldRelatedTickets:
		m.ResetRelatedTickets()
		return nil
	case change.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case change.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Change field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChangeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChangeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChangeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChangeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Change unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChangeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Change edge %s", name)
}

// ConfigurationItemMutation represents an operation that mutates the ConfigurationItem nodes in the graph.
type ConfigurationItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	_type         *string
	status        *string
	location      *string
	serial_number *string
	model         *string
	vendor        *string
	ci_type_id    *int
	addci_type_id *int
	tenant_id     *int
	addtenant_id  *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ConfigurationItem, error)
	predicates    []predicate.ConfigurationItem
}

var _ ent.Mutation = (*ConfigurationItemMutation)(nil)

// configurationitemOption allows management of the mutation configuration using functional options.
type configurationitemOption func(*ConfigurationItemMutation)

// newConfigurationItemMutation creates new mutation for the ConfigurationItem entity.
func newConfigurationItemMutation(c config, op Op, opts ...configurationitemOption) *ConfigurationItemMutation {
	m := &ConfigurationItemMutation{
		config:        c,
		op:            op,
		typ:           TypeConfigurationItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigurationItemID sets the ID field of the mutation.
func withConfigurationItemID(id int) configurationitemOption {
	return func(m *ConfigurationItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ConfigurationItem
		)
		m.oldValue = func(ctx context.Context) (*ConfigurationItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConfigurationItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfigurationItem sets the old ConfigurationItem of the mutation.
func withConfigurationItem(node *ConfigurationItem) configurationitemOption {
	return func(m *ConfigurationItemMutation) {
		m.oldValue = func(context.Context) (*ConfigurationItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigurationItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigurationItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConfigurationItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConfigurationItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConfigurationItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ConfigurationItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConfigurationItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConfigurationItemMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ConfigurationItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ConfigurationItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ConfigurationItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[configurationitem.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ConfigurationItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ConfigurationItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, configurationitem.FieldDescription)
}

// SetType sets the "type" field.
func (m *ConfigurationItemMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ConfigurationItemMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ConfigurationItemMutation) ClearType() {
	m._type = nil
	m.clearedFields[configurationitem.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ConfigurationItemMutation) TypeCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ConfigurationItemMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, configurationitem.FieldType)
}

// SetStatus sets the "status" field.
func (m *ConfigurationItemMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ConfigurationItemMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ConfigurationItemMutation) ResetStatus() {
	m.status = nil
}

// SetLocation sets the "location" field.
func (m *ConfigurationItemMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *ConfigurationItemMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *ConfigurationItemMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[configurationitem.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *ConfigurationItemMutation) LocationCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *ConfigurationItemMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, configurationitem.FieldLocation)
}

// SetSerialNumber sets the "serial_number" field.
func (m *ConfigurationItemMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *ConfigurationItemMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ClearSerialNumber clears the value of the "serial_number" field.
func (m *ConfigurationItemMutation) ClearSerialNumber() {
	m.serial_number = nil
	m.clearedFields[configurationitem.FieldSerialNumber] = struct{}{}
}

// SerialNumberCleared returns if the "serial_number" field was cleared in this mutation.
func (m *ConfigurationItemMutation) SerialNumberCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldSerialNumber]
	return ok
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *ConfigurationItemMutation) ResetSerialNumber() {
	m.serial_number = nil
	delete(m.clearedFields, configurationitem.FieldSerialNumber)
}

// SetModel sets the "model" field.
func (m *ConfigurationItemMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ConfigurationItemMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *ConfigurationItemMutation) ClearModel() {
	m.model = nil
	m.clearedFields[configurationitem.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *ConfigurationItemMutation) ModelCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *ConfigurationItemMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, configurationitem.FieldModel)
}

// SetVendor sets the "vendor" field.
func (m *ConfigurationItemMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ConfigurationItemMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ClearVendor clears the value of the "vendor" field.
func (m *ConfigurationItemMutation) ClearVendor() {
	m.vendor = nil
	m.clearedFields[configurationitem.FieldVendor] = struct{}{}
}

// VendorCleared returns if the "vendor" field was cleared in this mutation.
func (m *ConfigurationItemMutation) VendorCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldVendor]
	return ok
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ConfigurationItemMutation) ResetVendor() {
	m.vendor = nil
	delete(m.clearedFields, configurationitem.FieldVendor)
}

// SetCiTypeID sets the "ci_type_id" field.
func (m *ConfigurationItemMutation) SetCiTypeID(i int) {
	m.ci_type_id = &i
	m.addci_type_id = nil
}

// CiTypeID returns the value of the "ci_type_id" field in the mutation.
func (m *ConfigurationItemMutation) CiTypeID() (r int, exists bool) {
	v := m.ci_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCiTypeID returns the old "ci_type_id" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldCiTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCiTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCiTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCiTypeID: %w", err)
	}
	return oldValue.CiTypeID, nil
}

// AddCiTypeID adds i to the "ci_type_id" field.
func (m *ConfigurationItemMutation) AddCiTypeID(i int) {
	if m.addci_type_id != nil {
		*m.addci_type_id += i
	} else {
		m.addci_type_id = &i
	}
}

// AddedCiTypeID returns the value that was added to the "ci_type_id" field in this mutation.
func (m *ConfigurationItemMutation) AddedCiTypeID() (r int, exists bool) {
	v := m.addci_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCiTypeID resets all changes to the "ci_type_id" field.
func (m *ConfigurationItemMutation) ResetCiTypeID() {
	m.ci_type_id = nil
	m.addci_type_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ConfigurationItemMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ConfigurationItemMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ConfigurationItemMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ConfigurationItemMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ConfigurationItemMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConfigurationItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConfigurationItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConfigurationItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConfigurationItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConfigurationItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConfigurationItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ConfigurationItemMutation builder.
func (m *ConfigurationItemMutation) Where(ps ...predicate.ConfigurationItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConfigurationItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConfigurationItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConfigurationItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConfigurationItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConfigurationItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConfigurationItem).
func (m *ConfigurationItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigurationItemMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, configurationitem.FieldName)
	}
	if m.description != nil {
		fields = append(fields, configurationitem.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, configurationitem.FieldType)
	}
	if m.status != nil {
		fields = append(fields, configurationitem.FieldStatus)
	}
	if m.location != nil {
		fields = append(fields, configurationitem.FieldLocation)
	}
	if m.serial_number != nil {
		fields = append(fields, configurationitem.FieldSerialNumber)
	}
	if m.model != nil {
		fields = append(fields, configurationitem.FieldModel)
	}
	if m.vendor != nil {
		fields = append(fields, configurationitem.FieldVendor)
	}
	if m.ci_type_id != nil {
		fields = append(fields, configurationitem.FieldCiTypeID)
	}
	if m.tenant_id != nil {
		fields = append(fields, configurationitem.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, configurationitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, configurationitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigurationItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configurationitem.FieldName:
		return m.Name()
	case configurationitem.FieldDescription:
		return m.Description()
	case configurationitem.FieldType:
		return m.GetType()
	case configurationitem.FieldStatus:
		return m.Status()
	case configurationitem.FieldLocation:
		return m.Location()
	case configurationitem.FieldSerialNumber:
		return m.SerialNumber()
	case configurationitem.FieldModel:
		return m.Model()
	case configurationitem.FieldVendor:
		return m.Vendor()
	case configurationitem.FieldCiTypeID:
		return m.CiTypeID()
	case configurationitem.FieldTenantID:
		return m.TenantID()
	case configurationitem.FieldCreatedAt:
		return m.CreatedAt()
	case configurationitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigurationItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configurationitem.FieldName:
		return m.OldName(ctx)
	case configurationitem.FieldDescription:
		return m.OldDescription(ctx)
	case configurationitem.FieldType:
		return m.OldType(ctx)
	case configurationitem.FieldStatus:
		return m.OldStatus(ctx)
	case configurationitem.FieldLocation:
		return m.OldLocation(ctx)
	case configurationitem.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case configurationitem.FieldModel:
		return m.OldModel(ctx)
	case configurationitem.FieldVendor:
		return m.OldVendor(ctx)
	case configurationitem.FieldCiTypeID:
		return m.OldCiTypeID(ctx)
	case configurationitem.FieldTenantID:
		return m.OldTenantID(ctx)
	case configurationitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case configurationitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ConfigurationItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configurationitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case configurationitem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case configurationitem.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case configurationitem.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case configurationitem.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case configurationitem.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case configurationitem.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case configurationitem.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case configurationitem.FieldCiTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCiTypeID(v)
		return nil
	case configurationitem.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case configurationitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case configurationitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigurationItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigurationItemMutation) AddedFields() []string {
	var fields []string
	if m.addci_type_id != nil {
		fields = append(fields, configurationitem.FieldCiTypeID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, configurationitem.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigurationItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case configurationitem.FieldCiTypeID:
		return m.AddedCiTypeID()
	case configurationitem.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case configurationitem.FieldCiTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCiTypeID(v)
		return nil
	case configurationitem.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigurationItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigurationItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configurationitem.FieldDescription) {
		fields = append(fields, configurationitem.FieldDescription)
	}
	if m.FieldCleared(configurationitem.FieldType) {
		fields = append(fields, configurationitem.FieldType)
	}
	if m.FieldCleared(configurationitem.FieldLocation) {
		fields = append(fields, configurationitem.FieldLocation)
	}
	if m.FieldCleared(configurationitem.FieldSerialNumber) {
		fields = append(fields, configurationitem.FieldSerialNumber)
	}
	if m.FieldCleared(configurationitem.FieldModel) {
		fields = append(fields, configurationitem.FieldModel)
	}
	if m.FieldCleared(configurationitem.FieldVendor) {
		fields = append(fields, configurationitem.FieldVendor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigurationItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigurationItemMutation) ClearField(name string) error {
	switch name {
	case configurationitem.FieldDescription:
		m.ClearDescription()
		return nil
	case configurationitem.FieldType:
		m.ClearType()
		return nil
	case configurationitem.FieldLocation:
		m.ClearLocation()
		return nil
	case configurationitem.FieldSerialNumber:
		m.ClearSerialNumber()
		return nil
	case configurationitem.FieldModel:
		m.ClearModel()
		return nil
	case configurationitem.FieldVendor:
		m.ClearVendor()
		return nil
	}
	return fmt.Errorf("unknown ConfigurationItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigurationItemMutation) ResetField(name string) error {
	switch name {
	case configurationitem.FieldName:
		m.ResetName()
		return nil
	case configurationitem.FieldDescription:
		m.ResetDescription()
		return nil
	case configurationitem.FieldType:
		m.ResetType()
		return nil
	case configurationitem.FieldStatus:
		m.ResetStatus()
		return nil
	case configurationitem.FieldLocation:
		m.ResetLocation()
		return nil
	case configurationitem.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case configurationitem.FieldModel:
		m.ResetModel()
		return nil
	case configurationitem.FieldVendor:
		m.ResetVendor()
		return nil
	case configurationitem.FieldCiTypeID:
		m.ResetCiTypeID()
		return nil
	case configurationitem.FieldTenantID:
		m.ResetTenantID()
		return nil
	case configurationitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case configurationitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ConfigurationItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigurationItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigurationItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigurationItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigurationItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigurationItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigurationItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigurationItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ConfigurationItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigurationItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ConfigurationItem edge %s", name)
}

// ConversationMutation represents an operation that mutates the Conversation nodes in the graph.
type ConversationMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	tenant_id               *int
	addtenant_id            *int
	user_id                 *int
	adduser_id              *int
	title                   *string
	clearedFields           map[string]struct{}
	messages                map[int]struct{}
	removedmessages         map[int]struct{}
	clearedmessages         bool
	tool_invocations        map[int]struct{}
	removedtool_invocations map[int]struct{}
	clearedtool_invocations bool
	done                    bool
	oldValue                func(context.Context) (*Conversation, error)
	predicates              []predicate.Conversation
}

var _ ent.Mutation = (*ConversationMutation)(nil)

// conversationOption allows management of the mutation configuration using functional options.
type conversationOption func(*ConversationMutation)

// newConversationMutation creates new mutation for the Conversation entity.
func newConversationMutation(c config, op Op, opts ...conversationOption) *ConversationMutation {
	m := &ConversationMutation{
		config:        c,
		op:            op,
		typ:           TypeConversation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConversationID sets the ID field of the mutation.
func withConversationID(id int) conversationOption {
	return func(m *ConversationMutation) {
		var (
			err   error
			once  sync.Once
			value *Conversation
		)
		m.oldValue = func(ctx context.Context) (*Conversation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Conversation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConversation sets the old Conversation of the mutation.
func withConversation(node *Conversation) conversationOption {
	return func(m *ConversationMutation) {
		m.oldValue = func(context.Context) (*Conversation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConversationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConversationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConversationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConversationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Conversation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ConversationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConversationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConversationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ConversationMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ConversationMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ConversationMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ConversationMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *ConversationMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[conversation.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *ConversationMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[conversation.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ConversationMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, conversation.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *ConversationMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ConversationMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *ConversationMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ConversationMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *ConversationMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[conversation.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ConversationMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[conversation.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ConversationMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, conversation.FieldUserID)
}

// SetTitle sets the "title" field.
func (m *ConversationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ConversationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ConversationMutation) ResetTitle() {
	m.title = nil
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *ConversationMutation) AddMessageIDs(ids ...int) {
	if m.messages == nil {
		m.messages = make(map[int]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *ConversationMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *ConversationMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *ConversationMutation) RemoveMessageIDs(ids ...int) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *ConversationMutation) RemovedMessagesIDs() (ids []int) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *ConversationMutation) MessagesIDs() (ids []int) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *ConversationMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddToolInvocationIDs adds the "tool_invocations" edge to the ToolInvocation entity by ids.
func (m *ConversationMutation) AddToolInvocationIDs(ids ...int) {
	if m.tool_invocations == nil {
		m.tool_invocations = make(map[int]struct{})
	}
	for i := range ids {
		m.tool_invocations[ids[i]] = struct{}{}
	}
}

// ClearToolInvocations clears the "tool_invocations" edge to the ToolInvocation entity.
func (m *ConversationMutation) ClearToolInvocations() {
	m.clearedtool_invocations = true
}

// ToolInvocationsCleared reports if the "tool_invocations" edge to the ToolInvocation entity was cleared.
func (m *ConversationMutation) ToolInvocationsCleared() bool {
	return m.clearedtool_invocations
}

// RemoveToolInvocationIDs removes the "tool_invocations" edge to the ToolInvocation entity by IDs.
func (m *ConversationMutation) RemoveToolInvocationIDs(ids ...int) {
	if m.removedtool_invocations == nil {
		m.removedtool_invocations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tool_invocations, ids[i])
		m.removedtool_invocations[ids[i]] = struct{}{}
	}
}

// RemovedToolInvocations returns the removed IDs of the "tool_invocations" edge to the ToolInvocation entity.
func (m *ConversationMutation) RemovedToolInvocationsIDs() (ids []int) {
	for id := range m.removedtool_invocations {
		ids = append(ids, id)
	}
	return
}

// ToolInvocationsIDs returns the "tool_invocations" edge IDs in the mutation.
func (m *ConversationMutation) ToolInvocationsIDs() (ids []int) {
	for id := range m.tool_invocations {
		ids = append(ids, id)
	}
	return
}

// ResetToolInvocations resets all changes to the "tool_invocations" edge.
func (m *ConversationMutation) ResetToolInvocations() {
	m.tool_invocations = nil
	m.clearedtool_invocations = false
	m.removedtool_invocations = nil
}

// Where appends a list predicates to the ConversationMutation builder.
func (m *ConversationMutation) Where(ps ...predicate.Conversation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConversationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConversationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Conversation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConversationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConversationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Conversation).
func (m *ConversationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConversationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, conversation.FieldCreatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, conversation.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, conversation.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, conversation.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConversationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case conversation.FieldCreatedAt:
		return m.CreatedAt()
	case conversation.FieldTenantID:
		return m.TenantID()
	case conversation.FieldUserID:
		return m.UserID()
	case conversation.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConversationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case conversation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case conversation.FieldTenantID:
		return m.OldTenantID(ctx)
	case conversation.FieldUserID:
		return m.OldUserID(ctx)
	case conversation.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown Conversation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case conversation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case conversation.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case conversation.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case conversation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConversationMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, conversation.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, conversation.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConversationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case conversation.FieldTenantID:
		return m.AddedTenantID()
	case conversation.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case conversation.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case conversation.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Conversation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConversationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(conversation.FieldTenantID) {
		fields = append(fields, conversation.FieldTenantID)
	}
	if m.FieldCleared(conversation.FieldUserID) {
		fields = append(fields, conversation.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConversationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConversationMutation) ClearField(name string) error {
	switch name {
	case conversation.FieldTenantID:
		m.ClearTenantID()
		return nil
	case conversation.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Conversation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConversationMutation) ResetField(name string) error {
	switch name {
	case conversation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case conversation.FieldTenantID:
		m.ResetTenantID()
		return nil
	case conversation.FieldUserID:
		m.ResetUserID()
		return nil
	case conversation.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConversationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.messages != nil {
		edges = append(edges, conversation.EdgeMessages)
	}
	if m.tool_invocations != nil {
		edges = append(edges, conversation.EdgeToolInvocations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConversationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case conversation.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case conversation.EdgeToolInvocations:
		ids := make([]ent.Value, 0, len(m.tool_invocations))
		for id := range m.tool_invocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConversationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmessages != nil {
		edges = append(edges, conversation.EdgeMessages)
	}
	if m.removedtool_invocations != nil {
		edges = append(edges, conversation.EdgeToolInvocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConversationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case conversation.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case conversation.EdgeToolInvocations:
		ids := make([]ent.Value, 0, len(m.removedtool_invocations))
		for id := range m.removedtool_invocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConversationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmessages {
		edges = append(edges, conversation.EdgeMessages)
	}
	if m.clearedtool_invocations {
		edges = append(edges, conversation.EdgeToolInvocations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConversationMutation) EdgeCleared(name string) bool {
	switch name {
	case conversation.EdgeMessages:
		return m.clearedmessages
	case conversation.EdgeToolInvocations:
		return m.clearedtool_invocations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConversationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Conversation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConversationMutation) ResetEdge(name string) error {
	switch name {
	case conversation.EdgeMessages:
		m.ResetMessages()
		return nil
	case conversation.EdgeToolInvocations:
		m.ResetToolInvocations()
		return nil
	}
	return fmt.Errorf("unknown Conversation edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	code              *string
	description       *string
	manager_id        *int
	addmanager_id     *int
	tenant_id         *int
	addtenant_id      *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	parent            *int
	clearedparent     bool
	children          map[int]struct{}
	removedchildren   map[int]struct{}
	clearedchildren   bool
	users             map[int]struct{}
	removedusers      map[int]struct{}
	clearedusers      bool
	tickets           map[int]struct{}
	removedtickets    map[int]struct{}
	clearedtickets    bool
	workflows         map[int]struct{}
	removedworkflows  map[int]struct{}
	clearedworkflows  bool
	categories        map[int]struct{}
	removedcategories map[int]struct{}
	clearedcategories bool
	projects          map[int]struct{}
	removedprojects   map[int]struct{}
	clearedprojects   bool
	tags              map[int]struct{}
	removedtags       map[int]struct{}
	clearedtags       bool
	done              bool
	oldValue          func(context.Context) (*Department, error)
	predicates        []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DepartmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DepartmentMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *DepartmentMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *DepartmentMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *DepartmentMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *DepartmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DepartmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DepartmentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[department.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DepartmentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[department.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DepartmentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, department.FieldDescription)
}

// SetManagerID sets the "manager_id" field.
func (m *DepartmentMutation) SetManagerID(i int) {
	m.manager_id = &i
	m.addmanager_id = nil
}

// ManagerID returns the value of the "manager_id" field in the mutation.
func (m *DepartmentMutation) ManagerID() (r int, exists bool) {
	v := m.manager_id
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerID returns the old "manager_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldManagerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerID: %w", err)
	}
	return oldValue.ManagerID, nil
}

// AddManagerID adds i to the "manager_id" field.
func (m *DepartmentMutation) AddManagerID(i int) {
	if m.addmanager_id != nil {
		*m.addmanager_id += i
	} else {
		m.addmanager_id = &i
	}
}

// AddedManagerID returns the value that was added to the "manager_id" field in this mutation.
func (m *DepartmentMutation) AddedManagerID() (r int, exists bool) {
	v := m.addmanager_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearManagerID clears the value of the "manager_id" field.
func (m *DepartmentMutation) ClearManagerID() {
	m.manager_id = nil
	m.addmanager_id = nil
	m.clearedFields[department.FieldManagerID] = struct{}{}
}

// ManagerIDCleared returns if the "manager_id" field was cleared in this mutation.
func (m *DepartmentMutation) ManagerIDCleared() bool {
	_, ok := m.clearedFields[department.FieldManagerID]
	return ok
}

// ResetManagerID resets all changes to the "manager_id" field.
func (m *DepartmentMutation) ResetManagerID() {
	m.manager_id = nil
	m.addmanager_id = nil
	delete(m.clearedFields, department.FieldManagerID)
}

// SetParentID sets the "parent_id" field.
func (m *DepartmentMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *DepartmentMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *DepartmentMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[department.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *DepartmentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[department.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *DepartmentMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, department.FieldParentID)
}

// SetTenantID sets the "tenant_id" field.
func (m *DepartmentMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DepartmentMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *DepartmentMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DepartmentMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DepartmentMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DepartmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DepartmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DepartmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DepartmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DepartmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DepartmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearParent clears the "parent" edge to the Department entity.
func (m *DepartmentMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[department.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Department entity was cleared.
func (m *DepartmentMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *DepartmentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Department entity by ids.
func (m *DepartmentMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Department entity.
func (m *DepartmentMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Department entity was cleared.
func (m *DepartmentMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Department entity by IDs.
func (m *DepartmentMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Department entity.
func (m *DepartmentMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *DepartmentMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *DepartmentMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *DepartmentMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *DepartmentMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *DepartmentMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *DepartmentMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *DepartmentMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *DepartmentMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *DepartmentMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by ids.
func (m *DepartmentMutation) AddTicketIDs(ids ...int) {
	if m.tickets == nil {
		m.tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.tickets[ids[i]] = struct{}{}
	}
}

// ClearTickets clears the "tickets" edge to the Ticket entity.
func (m *DepartmentMutation) ClearTickets() {
	m.clearedtickets = true
}

// TicketsCleared reports if the "tickets" edge to the Ticket entity was cleared.
func (m *DepartmentMutation) TicketsCleared() bool {
	return m.clearedtickets
}

// RemoveTicketIDs removes the "tickets" edge to the Ticket entity by IDs.
func (m *DepartmentMutation) RemoveTicketIDs(ids ...int) {
	if m.removedtickets == nil {
		m.removedtickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tickets, ids[i])
		m.removedtickets[ids[i]] = struct{}{}
	}
}

// RemovedTickets returns the removed IDs of the "tickets" edge to the Ticket entity.
func (m *DepartmentMutation) RemovedTicketsIDs() (ids []int) {
	for id := range m.removedtickets {
		ids = append(ids, id)
	}
	return
}

// TicketsIDs returns the "tickets" edge IDs in the mutation.
func (m *DepartmentMutation) TicketsIDs() (ids []int) {
	for id := range m.tickets {
		ids = append(ids, id)
	}
	return
}

// ResetTickets resets all changes to the "tickets" edge.
func (m *DepartmentMutation) ResetTickets() {
	m.tickets = nil
	m.clearedtickets = false
	m.removedtickets = nil
}

// AddWorkflowIDs adds the "workflows" edge to the Workflow entity by ids.
func (m *DepartmentMutation) AddWorkflowIDs(ids ...int) {
	if m.workflows == nil {
		m.workflows = make(map[int]struct{})
	}
	for i := range ids {
		m.workflows[ids[i]] = struct{}{}
	}
}

// ClearWorkflows clears the "workflows" edge to the Workflow entity.
func (m *DepartmentMutation) ClearWorkflows() {
	m.clearedworkflows = true
}

// WorkflowsCleared reports if the "workflows" edge to the Workflow entity was cleared.
func (m *DepartmentMutation) WorkflowsCleared() bool {
	return m.clearedworkflows
}

// RemoveWorkflowIDs removes the "workflows" edge to the Workflow entity by IDs.
func (m *DepartmentMutation) RemoveWorkflowIDs(ids ...int) {
	if m.removedworkflows == nil {
		m.removedworkflows = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workflows, ids[i])
		m.removedworkflows[ids[i]] = struct{}{}
	}
}

// RemovedWorkflows returns the removed IDs of the "workflows" edge to the Workflow entity.
func (m *DepartmentMutation) RemovedWorkflowsIDs() (ids []int) {
	for id := range m.removedworkflows {
		ids = append(ids, id)
	}
	return
}

// WorkflowsIDs returns the "workflows" edge IDs in the mutation.
func (m *DepartmentMutation) WorkflowsIDs() (ids []int) {
	for id := range m.workflows {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflows resets all changes to the "workflows" edge.
func (m *DepartmentMutation) ResetWorkflows() {
	m.workflows = nil
	m.clearedworkflows = false
	m.removedworkflows = nil
}

// AddCategoryIDs adds the "categories" edge to the TicketCategory entity by ids.
func (m *DepartmentMutation) AddCategoryIDs(ids ...int) {
	if m.categories == nil {
		m.categories = make(map[int]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the TicketCategory entity.
func (m *DepartmentMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the TicketCategory entity was cleared.
func (m *DepartmentMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the TicketCategory entity by IDs.
func (m *DepartmentMutation) RemoveCategoryIDs(ids ...int) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the TicketCategory entity.
func (m *DepartmentMutation) RemovedCategoriesIDs() (ids []int) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *DepartmentMutation) CategoriesIDs() (ids []int) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *DepartmentMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *DepartmentMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *DepartmentMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *DepartmentMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *DepartmentMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *DepartmentMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *DepartmentMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *DepartmentMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *DepartmentMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *DepartmentMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *DepartmentMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *DepartmentMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *DepartmentMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *DepartmentMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *DepartmentMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, department.FieldName)
	}
	if m.code != nil {
		fields = append(fields, department.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, department.FieldDescription)
	}
	if m.manager_id != nil {
		fields = append(fields, department.FieldManagerID)
	}
	if m.parent != nil {
		fields = append(fields, department.FieldParentID)
	}
	if m.tenant_id != nil {
		fields = append(fields, department.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, department.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, department.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldName:
		return m.Name()
	case department.FieldCode:
		return m.Code()
	case department.FieldDescription:
		return m.Description()
	case department.FieldManagerID:
		return m.ManagerID()
	case department.FieldParentID:
		return m.ParentID()
	case department.FieldTenantID:
		return m.TenantID()
	case department.FieldCreatedAt:
		return m.CreatedAt()
	case department.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldName:
		return m.OldName(ctx)
	case department.FieldCode:
		return m.OldCode(ctx)
	case department.FieldDescription:
		return m.OldDescription(ctx)
	case department.FieldManagerID:
		return m.OldManagerID(ctx)
	case department.FieldParentID:
		return m.OldParentID(ctx)
	case department.FieldTenantID:
		return m.OldTenantID(ctx)
	case department.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case department.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case department.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case department.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case department.FieldManagerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerID(v)
		return nil
	case department.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case department.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case department.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case department.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	var fields []string
	if m.addmanager_id != nil {
		fields = append(fields, department.FieldManagerID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, department.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case department.FieldManagerID:
		return m.AddedManagerID()
	case department.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case department.FieldManagerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddManagerID(v)
		return nil
	case department.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(department.FieldDescription) {
		fields = append(fields, department.FieldDescription)
	}
	if m.FieldCleared(department.FieldManagerID) {
		fields = append(fields, department.FieldManagerID)
	}
	if m.FieldCleared(department.FieldParentID) {
		fields = append(fields, department.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	switch name {
	case department.FieldDescription:
		m.ClearDescription()
		return nil
	case department.FieldManagerID:
		m.ClearManagerID()
		return nil
	case department.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldName:
		m.ResetName()
		return nil
	case department.FieldCode:
		m.ResetCode()
		return nil
	case department.FieldDescription:
		m.ResetDescription()
		return nil
	case department.FieldManagerID:
		m.ResetManagerID()
		return nil
	case department.FieldParentID:
		m.ResetParentID()
		return nil
	case department.FieldTenantID:
		m.ResetTenantID()
		return nil
	case department.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case department.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.parent != nil {
		edges = append(edges, department.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, department.EdgeChildren)
	}
	if m.users != nil {
		edges = append(edges, department.EdgeUsers)
	}
	if m.tickets != nil {
		edges = append(edges, department.EdgeTickets)
	}
	if m.workflows != nil {
		edges = append(edges, department.EdgeWorkflows)
	}
	if m.categories != nil {
		edges = append(edges, department.EdgeCategories)
	}
	if m.projects != nil {
		edges = append(edges, department.EdgeProjects)
	}
	if m.tags != nil {
		edges = append(edges, department.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.tickets))
		for id := range m.tickets {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.workflows))
		for id := range m.workflows {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedchildren != nil {
		edges = append(edges, department.EdgeChildren)
	}
	if m.removedusers != nil {
		edges = append(edges, department.EdgeUsers)
	}
	if m.removedtickets != nil {
		edges = append(edges, department.EdgeTickets)
	}
	if m.removedworkflows != nil {
		edges = append(edges, department.EdgeWorkflows)
	}
	if m.removedcategories != nil {
		edges = append(edges, department.EdgeCategories)
	}
	if m.removedprojects != nil {
		edges = append(edges, department.EdgeProjects)
	}
	if m.removedtags != nil {
		edges = append(edges, department.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.removedtickets))
		for id := range m.removedtickets {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.removedworkflows))
		for id := range m.removedworkflows {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedparent {
		edges = append(edges, department.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, department.EdgeChildren)
	}
	if m.clearedusers {
		edges = append(edges, department.EdgeUsers)
	}
	if m.clearedtickets {
		edges = append(edges, department.EdgeTickets)
	}
	if m.clearedworkflows {
		edges = append(edges, department.EdgeWorkflows)
	}
	if m.clearedcategories {
		edges = append(edges, department.EdgeCategories)
	}
	if m.clearedprojects {
		edges = append(edges, department.EdgeProjects)
	}
	if m.clearedtags {
		edges = append(edges, department.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeParent:
		return m.clearedparent
	case department.EdgeChildren:
		return m.clearedchildren
	case department.EdgeUsers:
		return m.clearedusers
	case department.EdgeTickets:
		return m.clearedtickets
	case department.EdgeWorkflows:
		return m.clearedworkflows
	case department.EdgeCategories:
		return m.clearedcategories
	case department.EdgeProjects:
		return m.clearedprojects
	case department.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	case department.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeParent:
		m.ResetParent()
		return nil
	case department.EdgeChildren:
		m.ResetChildren()
		return nil
	case department.EdgeUsers:
		m.ResetUsers()
		return nil
	case department.EdgeTickets:
		m.ResetTickets()
		return nil
	case department.EdgeWorkflows:
		m.ResetWorkflows()
		return nil
	case department.EdgeCategories:
		m.ResetCategories()
		return nil
	case department.EdgeProjects:
		m.ResetProjects()
		return nil
	case department.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// IncidentMutation represents an operation that mutates the Incident nodes in the graph.
type IncidentMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	title                    *string
	description              *string
	status                   *string
	priority                 *string
	severity                 *string
	incident_number          *string
	reporter_id              *int
	addreporter_id           *int
	assignee_id              *int
	addassignee_id           *int
	configuration_item_id    *int
	addconfiguration_item_id *int
	category                 *string
	subcategory              *string
	impact_analysis          *map[string]interface{}
	root_cause               *map[string]interface{}
	resolution_steps         *[]map[string]interface{}
	appendresolution_steps   []map[string]interface{}
	detected_at              *time.Time
	resolved_at              *time.Time
	closed_at                *time.Time
	escalated_at             *time.Time
	escalation_level         *int
	addescalation_level      *int
	is_automated             *bool
	source                   *string
	metadata                 *map[string]interface{}
	tenant_id                *int
	addtenant_id             *int
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	related_incidents        map[int]struct{}
	removedrelated_incidents map[int]struct{}
	clearedrelated_incidents bool
	incident_events          map[int]struct{}
	removedincident_events   map[int]struct{}
	clearedincident_events   bool
	incident_alerts          map[int]struct{}
	removedincident_alerts   map[int]struct{}
	clearedincident_alerts   bool
	incident_metrics         map[int]struct{}
	removedincident_metrics  map[int]struct{}
	clearedincident_metrics  bool
	parent_incident          map[int]struct{}
	removedparent_incident   map[int]struct{}
	clearedparent_incident   bool
	done                     bool
	oldValue                 func(context.Context) (*Incident, error)
	predicates               []predicate.Incident
}

var _ ent.Mutation = (*IncidentMutation)(nil)

// incidentOption allows management of the mutation configuration using functional options.
type incidentOption func(*IncidentMutation)

// newIncidentMutation creates new mutation for the Incident entity.
func newIncidentMutation(c config, op Op, opts ...incidentOption) *IncidentMutation {
	m := &IncidentMutation{
		config:        c,
		op:            op,
		typ:           TypeIncident,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentID sets the ID field of the mutation.
func withIncidentID(id int) incidentOption {
	return func(m *IncidentMutation) {
		var (
			err   error
			once  sync.Once
			value *Incident
		)
		m.oldValue = func(ctx context.Context) (*Incident, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Incident.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncident sets the old Incident of the mutation.
func withIncident(node *Incident) incidentOption {
	return func(m *IncidentMutation) {
		m.oldValue = func(context.Context) (*Incident, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Incident.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *IncidentMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IncidentMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IncidentMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *IncidentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incident.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incident.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incident.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *IncidentMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *IncidentMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *IncidentMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *IncidentMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *IncidentMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *IncidentMutation) ResetPriority() {
	m.priority = nil
}

// SetSeverity sets the "severity" field.
func (m *IncidentMutation) SetSeverity(s string) {
	m.severity = &s
}

// Severity returns the value of the "severity" field in the mutation.
func (m *IncidentMutation) Severity() (r string, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldSeverity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *IncidentMutation) ResetSeverity() {
	m.severity = nil
}

// SetIncidentNumber sets the "incident_number" field.
func (m *IncidentMutation) SetIncidentNumber(s string) {
	m.incident_number = &s
}

// IncidentNumber returns the value of the "incident_number" field in the mutation.
func (m *IncidentMutation) IncidentNumber() (r string, exists bool) {
	v := m.incident_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentNumber returns the old "incident_number" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldIncidentNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentNumber: %w", err)
	}
	return oldValue.IncidentNumber, nil
}

// ResetIncidentNumber resets all changes to the "incident_number" field.
func (m *IncidentMutation) ResetIncidentNumber() {
	m.incident_number = nil
}

// SetReporterID sets the "reporter_id" field.
func (m *IncidentMutation) SetReporterID(i int) {
	m.reporter_id = &i
	m.addreporter_id = nil
}

// ReporterID returns the value of the "reporter_id" field in the mutation.
func (m *IncidentMutation) ReporterID() (r int, exists bool) {
	v := m.reporter_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReporterID returns the old "reporter_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldReporterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReporterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReporterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReporterID: %w", err)
	}
	return oldValue.ReporterID, nil
}

// AddReporterID adds i to the "reporter_id" field.
func (m *IncidentMutation) AddReporterID(i int) {
	if m.addreporter_id != nil {
		*m.addreporter_id += i
	} else {
		m.addreporter_id = &i
	}
}

// AddedReporterID returns the value that was added to the "reporter_id" field in this mutation.
func (m *IncidentMutation) AddedReporterID() (r int, exists bool) {
	v := m.addreporter_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetReporterID resets all changes to the "reporter_id" field.
func (m *IncidentMutation) ResetReporterID() {
	m.reporter_id = nil
	m.addreporter_id = nil
}

// SetAssigneeID sets the "assignee_id" field.
func (m *IncidentMutation) SetAssigneeID(i int) {
	m.assignee_id = &i
	m.addassignee_id = nil
}

// AssigneeID returns the value of the "assignee_id" field in the mutation.
func (m *IncidentMutation) AssigneeID() (r int, exists bool) {
	v := m.assignee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeID returns the old "assignee_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldAssigneeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeID: %w", err)
	}
	return oldValue.AssigneeID, nil
}

// AddAssigneeID adds i to the "assignee_id" field.
func (m *IncidentMutation) AddAssigneeID(i int) {
	if m.addassignee_id != nil {
		*m.addassignee_id += i
	} else {
		m.addassignee_id = &i
	}
}

// AddedAssigneeID returns the value that was added to the "assignee_id" field in this mutation.
func (m *IncidentMutation) AddedAssigneeID() (r int, exists bool) {
	v := m.addassignee_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssigneeID clears the value of the "assignee_id" field.
func (m *IncidentMutation) ClearAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	m.clearedFields[incident.FieldAssigneeID] = struct{}{}
}

// AssigneeIDCleared returns if the "assignee_id" field was cleared in this mutation.
func (m *IncidentMutation) AssigneeIDCleared() bool {
	_, ok := m.clearedFields[incident.FieldAssigneeID]
	return ok
}

// ResetAssigneeID resets all changes to the "assignee_id" field.
func (m *IncidentMutation) ResetAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	delete(m.clearedFields, incident.FieldAssigneeID)
}

// SetConfigurationItemID sets the "configuration_item_id" field.
func (m *IncidentMutation) SetConfigurationItemID(i int) {
	m.configuration_item_id = &i
	m.addconfiguration_item_id = nil
}

// ConfigurationItemID returns the value of the "configuration_item_id" field in the mutation.
func (m *IncidentMutation) ConfigurationItemID() (r int, exists bool) {
	v := m.configuration_item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigurationItemID returns the old "configuration_item_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldConfigurationItemID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigurationItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigurationItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigurationItemID: %w", err)
	}
	return oldValue.ConfigurationItemID, nil
}

// AddConfigurationItemID adds i to the "configuration_item_id" field.
func (m *IncidentMutation) AddConfigurationItemID(i int) {
	if m.addconfiguration_item_id != nil {
		*m.addconfiguration_item_id += i
	} else {
		m.addconfiguration_item_id = &i
	}
}

// AddedConfigurationItemID returns the value that was added to the "configuration_item_id" field in this mutation.
func (m *IncidentMutation) AddedConfigurationItemID() (r int, exists bool) {
	v := m.addconfiguration_item_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearConfigurationItemID clears the value of the "configuration_item_id" field.
func (m *IncidentMutation) ClearConfigurationItemID() {
	m.configuration_item_id = nil
	m.addconfiguration_item_id = nil
	m.clearedFields[incident.FieldConfigurationItemID] = struct{}{}
}

// ConfigurationItemIDCleared returns if the "configuration_item_id" field was cleared in this mutation.
func (m *IncidentMutation) ConfigurationItemIDCleared() bool {
	_, ok := m.clearedFields[incident.FieldConfigurationItemID]
	return ok
}

// ResetConfigurationItemID resets all changes to the "configuration_item_id" field.
func (m *IncidentMutation) ResetConfigurationItemID() {
	m.configuration_item_id = nil
	m.addconfiguration_item_id = nil
	delete(m.clearedFields, incident.FieldConfigurationItemID)
}

// SetCategory sets the "category" field.
func (m *IncidentMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *IncidentMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *IncidentMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[incident.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *IncidentMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[incident.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *IncidentMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, incident.FieldCategory)
}

// SetSubcategory sets the "subcategory" field.
func (m *IncidentMutation) SetSubcategory(s string) {
	m.subcategory = &s
}

// Subcategory returns the value of the "subcategory" field in the mutation.
func (m *IncidentMutation) Subcategory() (r string, exists bool) {
	v := m.subcategory
	if v == nil {
		return
	}
	return *v, true
}

// OldSubcategory returns the old "subcategory" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldSubcategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubcategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubcategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubcategory: %w", err)
	}
	return oldValue.Subcategory, nil
}

// ClearSubcategory clears the value of the "subcategory" field.
func (m *IncidentMutation) ClearSubcategory() {
	m.subcategory = nil
	m.clearedFields[incident.FieldSubcategory] = struct{}{}
}

// SubcategoryCleared returns if the "subcategory" field was cleared in this mutation.
func (m *IncidentMutation) SubcategoryCleared() bool {
	_, ok := m.clearedFields[incident.FieldSubcategory]
	return ok
}

// ResetSubcategory resets all changes to the "subcategory" field.
func (m *IncidentMutation) ResetSubcategory() {
	m.subcategory = nil
	delete(m.clearedFields, incident.FieldSubcategory)
}

// SetImpactAnalysis sets the "impact_analysis" field.
func (m *IncidentMutation) SetImpactAnalysis(value map[string]interface{}) {
	m.impact_analysis = &value
}

// ImpactAnalysis returns the value of the "impact_analysis" field in the mutation.
func (m *IncidentMutation) ImpactAnalysis() (r map[string]interface{}, exists bool) {
	v := m.impact_analysis
	if v == nil {
		return
	}
	return *v, true
}

// OldImpactAnalysis returns the old "impact_analysis" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldImpactAnalysis(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpactAnalysis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpactAnalysis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpactAnalysis: %w", err)
	}
	return oldValue.ImpactAnalysis, nil
}

// ClearImpactAnalysis clears the value of the "impact_analysis" field.
func (m *IncidentMutation) ClearImpactAnalysis() {
	m.impact_analysis = nil
	m.clearedFields[incident.FieldImpactAnalysis] = struct{}{}
}

// ImpactAnalysisCleared returns if the "impact_analysis" field was cleared in this mutation.
func (m *IncidentMutation) ImpactAnalysisCleared() bool {
	_, ok := m.clearedFields[incident.FieldImpactAnalysis]
	return ok
}

// ResetImpactAnalysis resets all changes to the "impact_analysis" field.
func (m *IncidentMutation) ResetImpactAnalysis() {
	m.impact_analysis = nil
	delete(m.clearedFields, incident.FieldImpactAnalysis)
}

// SetRootCause sets the "root_cause" field.
func (m *IncidentMutation) SetRootCause(value map[string]interface{}) {
	m.root_cause = &value
}

// RootCause returns the value of the "root_cause" field in the mutation.
func (m *IncidentMutation) RootCause() (r map[string]interface{}, exists bool) {
	v := m.root_cause
	if v == nil {
		return
	}
	return *v, true
}

// OldRootCause returns the old "root_cause" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldRootCause(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootCause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootCause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootCause: %w", err)
	}
	return oldValue.RootCause, nil
}

// ClearRootCause clears the value of the "root_cause" field.
func (m *IncidentMutation) ClearRootCause() {
	m.root_cause = nil
	m.clearedFields[incident.FieldRootCause] = struct{}{}
}

// RootCauseCleared returns if the "root_cause" field was cleared in this mutation.
func (m *IncidentMutation) RootCauseCleared() bool {
	_, ok := m.clearedFields[incident.FieldRootCause]
	return ok
}

// ResetRootCause resets all changes to the "root_cause" field.
func (m *IncidentMutation) ResetRootCause() {
	m.root_cause = nil
	delete(m.clearedFields, incident.FieldRootCause)
}

// SetResolutionSteps sets the "resolution_steps" field.
func (m *IncidentMutation) SetResolutionSteps(value []map[string]interface{}) {
	m.resolution_steps = &value
	m.appendresolution_steps = nil
}

// ResolutionSteps returns the value of the "resolution_steps" field in the mutation.
func (m *IncidentMutation) ResolutionSteps() (r []map[string]interface{}, exists bool) {
	v := m.resolution_steps
	if v == nil {
		return
	}
	return *v, true
}

// OldResolutionSteps returns the old "resolution_steps" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldResolutionSteps(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolutionSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolutionSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolutionSteps: %w", err)
	}
	return oldValue.ResolutionSteps, nil
}

// AppendResolutionSteps adds value to the "resolution_steps" field.
func (m *IncidentMutation) AppendResolutionSteps(value []map[string]interface{}) {
	m.appendresolution_steps = append(m.appendresolution_steps, value...)
}

// AppendedResolutionSteps returns the list of values that were appended to the "resolution_steps" field in this mutation.
func (m *IncidentMutation) AppendedResolutionSteps() ([]map[string]interface{}, bool) {
	if len(m.appendresolution_steps) == 0 {
		return nil, false
	}
	return m.appendresolution_steps, true
}

// ClearResolutionSteps clears the value of the "resolution_steps" field.
func (m *IncidentMutation) ClearResolutionSteps() {
	m.resolution_steps = nil
	m.appendresolution_steps = nil
	m.clearedFields[incident.FieldResolutionSteps] = struct{}{}
}

// ResolutionStepsCleared returns if the "resolution_steps" field was cleared in this mutation.
func (m *IncidentMutation) ResolutionStepsCleared() bool {
	_, ok := m.clearedFields[incident.FieldResolutionSteps]
	return ok
}

// ResetResolutionSteps resets all changes to the "resolution_steps" field.
func (m *IncidentMutation) ResetResolutionSteps() {
	m.resolution_steps = nil
	m.appendresolution_steps = nil
	delete(m.clearedFields, incident.FieldResolutionSteps)
}

// SetDetectedAt sets the "detected_at" field.
func (m *IncidentMutation) SetDetectedAt(t time.Time) {
	m.detected_at = &t
}

// DetectedAt returns the value of the "detected_at" field in the mutation.
func (m *IncidentMutation) DetectedAt() (r time.Time, exists bool) {
	v := m.detected_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDetectedAt returns the old "detected_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldDetectedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetectedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetectedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetectedAt: %w", err)
	}
	return oldValue.DetectedAt, nil
}

// ResetDetectedAt resets all changes to the "detected_at" field.
func (m *IncidentMutation) ResetDetectedAt() {
	m.detected_at = nil
}

// SetResolvedAt sets the "resolved_at" field.
func (m *IncidentMutation) SetResolvedAt(t time.Time) {
	m.resolved_at = &t
}

// ResolvedAt returns the value of the "resolved_at" field in the mutation.
func (m *IncidentMutation) ResolvedAt() (r time.Time, exists bool) {
	v := m.resolved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedAt returns the old "resolved_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldResolvedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedAt: %w", err)
	}
	return oldValue.ResolvedAt, nil
}

// ClearResolvedAt clears the value of the "resolved_at" field.
func (m *IncidentMutation) ClearResolvedAt() {
	m.resolved_at = nil
	m.clearedFields[incident.FieldResolvedAt] = struct{}{}
}

// ResolvedAtCleared returns if the "resolved_at" field was cleared in this mutation.
func (m *IncidentMutation) ResolvedAtCleared() bool {
	_, ok := m.clearedFields[incident.FieldResolvedAt]
	return ok
}

// ResetResolvedAt resets all changes to the "resolved_at" field.
func (m *IncidentMutation) ResetResolvedAt() {
	m.resolved_at = nil
	delete(m.clearedFields, incident.FieldResolvedAt)
}

// SetClosedAt sets the "closed_at" field.
func (m *IncidentMutation) SetClosedAt(t time.Time) {
	m.closed_at = &t
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *IncidentMutation) ClosedAt() (r time.Time, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldClosedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ClearClosedAt clears the value of the "closed_at" field.
func (m *IncidentMutation) ClearClosedAt() {
	m.closed_at = nil
	m.clearedFields[incident.FieldClosedAt] = struct{}{}
}

// ClosedAtCleared returns if the "closed_at" field was cleared in this mutation.
func (m *IncidentMutation) ClosedAtCleared() bool {
	_, ok := m.clearedFields[incident.FieldClosedAt]
	return ok
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *IncidentMutation) ResetClosedAt() {
	m.closed_at = nil
	delete(m.clearedFields, incident.FieldClosedAt)
}

// SetEscalatedAt sets the "escalated_at" field.
func (m *IncidentMutation) SetEscalatedAt(t time.Time) {
	m.escalated_at = &t
}

// EscalatedAt returns the value of the "escalated_at" field in the mutation.
func (m *IncidentMutation) EscalatedAt() (r time.Time, exists bool) {
	v := m.escalated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEscalatedAt returns the old "escalated_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldEscalatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEscalatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEscalatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEscalatedAt: %w", err)
	}
	return oldValue.EscalatedAt, nil
}

// ClearEscalatedAt clears the value of the "escalated_at" field.
func (m *IncidentMutation) ClearEscalatedAt() {
	m.escalated_at = nil
	m.clearedFields[incident.FieldEscalatedAt] = struct{}{}
}

// EscalatedAtCleared returns if the "escalated_at" field was cleared in this mutation.
func (m *IncidentMutation) EscalatedAtCleared() bool {
	_, ok := m.clearedFields[incident.FieldEscalatedAt]
	return ok
}

// ResetEscalatedAt resets all changes to the "escalated_at" field.
func (m *IncidentMutation) ResetEscalatedAt() {
	m.escalated_at = nil
	delete(m.clearedFields, incident.FieldEscalatedAt)
}

// SetEscalationLevel sets the "escalation_level" field.
func (m *IncidentMutation) SetEscalationLevel(i int) {
	m.escalation_level = &i
	m.addescalation_level = nil
}

// EscalationLevel returns the value of the "escalation_level" field in the mutation.
func (m *IncidentMutation) EscalationLevel() (r int, exists bool) {
	v := m.escalation_level
	if v == nil {
		return
	}
	return *v, true
}

// OldEscalationLevel returns the old "escalation_level" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldEscalationLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEscalationLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEscalationLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEscalationLevel: %w", err)
	}
	return oldValue.EscalationLevel, nil
}

// AddEscalationLevel adds i to the "escalation_level" field.
func (m *IncidentMutation) AddEscalationLevel(i int) {
	if m.addescalation_level != nil {
		*m.addescalation_level += i
	} else {
		m.addescalation_level = &i
	}
}

// AddedEscalationLevel returns the value that was added to the "escalation_level" field in this mutation.
func (m *IncidentMutation) AddedEscalationLevel() (r int, exists bool) {
	v := m.addescalation_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetEscalationLevel resets all changes to the "escalation_level" field.
func (m *IncidentMutation) ResetEscalationLevel() {
	m.escalation_level = nil
	m.addescalation_level = nil
}

// SetIsAutomated sets the "is_automated" field.
func (m *IncidentMutation) SetIsAutomated(b bool) {
	m.is_automated = &b
}

// IsAutomated returns the value of the "is_automated" field in the mutation.
func (m *IncidentMutation) IsAutomated() (r bool, exists bool) {
	v := m.is_automated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAutomated returns the old "is_automated" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldIsAutomated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAutomated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAutomated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAutomated: %w", err)
	}
	return oldValue.IsAutomated, nil
}

// ResetIsAutomated resets all changes to the "is_automated" field.
func (m *IncidentMutation) ResetIsAutomated() {
	m.is_automated = nil
}

// SetSource sets the "source" field.
func (m *IncidentMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *IncidentMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *IncidentMutation) ResetSource() {
	m.source = nil
}

// SetMetadata sets the "metadata" field.
func (m *IncidentMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *IncidentMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *IncidentMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[incident.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *IncidentMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[incident.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *IncidentMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, incident.FieldMetadata)
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *IncidentMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *IncidentMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IncidentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IncidentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IncidentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddRelatedIncidentIDs adds the "related_incidents" edge to the Incident entity by ids.
func (m *IncidentMutation) AddRelatedIncidentIDs(ids ...int) {
	if m.related_incidents == nil {
		m.related_incidents = make(map[int]struct{})
	}
	for i := range ids {
		m.related_incidents[ids[i]] = struct{}{}
	}
}

// ClearRelatedIncidents clears the "related_incidents" edge to the Incident entity.
func (m *IncidentMutation) ClearRelatedIncidents() {
	m.clearedrelated_incidents = true
}

// RelatedIncidentsCleared reports if the "related_incidents" edge to the Incident entity was cleared.
func (m *IncidentMutation) RelatedIncidentsCleared() bool {
	return m.clearedrelated_incidents
}

// RemoveRelatedIncidentIDs removes the "related_incidents" edge to the Incident entity by IDs.
func (m *IncidentMutation) RemoveRelatedIncidentIDs(ids ...int) {
	if m.removedrelated_incidents == nil {
		m.removedrelated_incidents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.related_incidents, ids[i])
		m.removedrelated_incidents[ids[i]] = struct{}{}
	}
}

// RemovedRelatedIncidents returns the removed IDs of the "related_incidents" edge to the Incident entity.
func (m *IncidentMutation) RemovedRelatedIncidentsIDs() (ids []int) {
	for id := range m.removedrelated_incidents {
		ids = append(ids, id)
	}
	return
}

// RelatedIncidentsIDs returns the "related_incidents" edge IDs in the mutation.
func (m *IncidentMutation) RelatedIncidentsIDs() (ids []int) {
	for id := range m.related_incidents {
		ids = append(ids, id)
	}
	return
}

// ResetRelatedIncidents resets all changes to the "related_incidents" edge.
func (m *IncidentMutation) ResetRelatedIncidents() {
	m.related_incidents = nil
	m.clearedrelated_incidents = false
	m.removedrelated_incidents = nil
}

// AddIncidentEventIDs adds the "incident_events" edge to the IncidentEvent entity by ids.
func (m *IncidentMutation) AddIncidentEventIDs(ids ...int) {
	if m.incident_events == nil {
		m.incident_events = make(map[int]struct{})
	}
	for i := range ids {
		m.incident_events[ids[i]] = struct{}{}
	}
}

// ClearIncidentEvents clears the "incident_events" edge to the IncidentEvent entity.
func (m *IncidentMutation) ClearIncidentEvents() {
	m.clearedincident_events = true
}

// IncidentEventsCleared reports if the "incident_events" edge to the IncidentEvent entity was cleared.
func (m *IncidentMutation) IncidentEventsCleared() bool {
	return m.clearedincident_events
}

// RemoveIncidentEventIDs removes the "incident_events" edge to the IncidentEvent entity by IDs.
func (m *IncidentMutation) RemoveIncidentEventIDs(ids ...int) {
	if m.removedincident_events == nil {
		m.removedincident_events = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.incident_events, ids[i])
		m.removedincident_events[ids[i]] = struct{}{}
	}
}

// RemovedIncidentEvents returns the removed IDs of the "incident_events" edge to the IncidentEvent entity.
func (m *IncidentMutation) RemovedIncidentEventsIDs() (ids []int) {
	for id := range m.removedincident_events {
		ids = append(ids, id)
	}
	return
}

// IncidentEventsIDs returns the "incident_events" edge IDs in the mutation.
func (m *IncidentMutation) IncidentEventsIDs() (ids []int) {
	for id := range m.incident_events {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentEvents resets all changes to the "incident_events" edge.
func (m *IncidentMutation) ResetIncidentEvents() {
	m.incident_events = nil
	m.clearedincident_events = false
	m.removedincident_events = nil
}

// AddIncidentAlertIDs adds the "incident_alerts" edge to the IncidentAlert entity by ids.
func (m *IncidentMutation) AddIncidentAlertIDs(ids ...int) {
	if m.incident_alerts == nil {
		m.incident_alerts = make(map[int]struct{})
	}
	for i := range ids {
		m.incident_alerts[ids[i]] = struct{}{}
	}
}

// ClearIncidentAlerts clears the "incident_alerts" edge to the IncidentAlert entity.
func (m *IncidentMutation) ClearIncidentAlerts() {
	m.clearedincident_alerts = true
}

// IncidentAlertsCleared reports if the "incident_alerts" edge to the IncidentAlert entity was cleared.
func (m *IncidentMutation) IncidentAlertsCleared() bool {
	return m.clearedincident_alerts
}

// RemoveIncidentAlertIDs removes the "incident_alerts" edge to the IncidentAlert entity by IDs.
func (m *IncidentMutation) RemoveIncidentAlertIDs(ids ...int) {
	if m.removedincident_alerts == nil {
		m.removedincident_alerts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.incident_alerts, ids[i])
		m.removedincident_alerts[ids[i]] = struct{}{}
	}
}

// RemovedIncidentAlerts returns the removed IDs of the "incident_alerts" edge to the IncidentAlert entity.
func (m *IncidentMutation) RemovedIncidentAlertsIDs() (ids []int) {
	for id := range m.removedincident_alerts {
		ids = append(ids, id)
	}
	return
}

// IncidentAlertsIDs returns the "incident_alerts" edge IDs in the mutation.
func (m *IncidentMutation) IncidentAlertsIDs() (ids []int) {
	for id := range m.incident_alerts {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentAlerts resets all changes to the "incident_alerts" edge.
func (m *IncidentMutation) ResetIncidentAlerts() {
	m.incident_alerts = nil
	m.clearedincident_alerts = false
	m.removedincident_alerts = nil
}

// AddIncidentMetricIDs adds the "incident_metrics" edge to the IncidentMetric entity by ids.
func (m *IncidentMutation) AddIncidentMetricIDs(ids ...int) {
	if m.incident_metrics == nil {
		m.incident_metrics = make(map[int]struct{})
	}
	for i := range ids {
		m.incident_metrics[ids[i]] = struct{}{}
	}
}

// ClearIncidentMetrics clears the "incident_metrics" edge to the IncidentMetric entity.
func (m *IncidentMutation) ClearIncidentMetrics() {
	m.clearedincident_metrics = true
}

// IncidentMetricsCleared reports if the "incident_metrics" edge to the IncidentMetric entity was cleared.
func (m *IncidentMutation) IncidentMetricsCleared() bool {
	return m.clearedincident_metrics
}

// RemoveIncidentMetricIDs removes the "incident_metrics" edge to the IncidentMetric entity by IDs.
func (m *IncidentMutation) RemoveIncidentMetricIDs(ids ...int) {
	if m.removedincident_metrics == nil {
		m.removedincident_metrics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.incident_metrics, ids[i])
		m.removedincident_metrics[ids[i]] = struct{}{}
	}
}

// RemovedIncidentMetrics returns the removed IDs of the "incident_metrics" edge to the IncidentMetric entity.
func (m *IncidentMutation) RemovedIncidentMetricsIDs() (ids []int) {
	for id := range m.removedincident_metrics {
		ids = append(ids, id)
	}
	return
}

// IncidentMetricsIDs returns the "incident_metrics" edge IDs in the mutation.
func (m *IncidentMutation) IncidentMetricsIDs() (ids []int) {
	for id := range m.incident_metrics {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentMetrics resets all changes to the "incident_metrics" edge.
func (m *IncidentMutation) ResetIncidentMetrics() {
	m.incident_metrics = nil
	m.clearedincident_metrics = false
	m.removedincident_metrics = nil
}

// AddParentIncidentIDs adds the "parent_incident" edge to the Incident entity by ids.
func (m *IncidentMutation) AddParentIncidentIDs(ids ...int) {
	if m.parent_incident == nil {
		m.parent_incident = make(map[int]struct{})
	}
	for i := range ids {
		m.parent_incident[ids[i]] = struct{}{}
	}
}

// ClearParentIncident clears the "parent_incident" edge to the Incident entity.
func (m *IncidentMutation) ClearParentIncident() {
	m.clearedparent_incident = true
}

// ParentIncidentCleared reports if the "parent_incident" edge to the Incident entity was cleared.
func (m *IncidentMutation) ParentIncidentCleared() bool {
	return m.clearedparent_incident
}

// RemoveParentIncidentIDs removes the "parent_incident" edge to the Incident entity by IDs.
func (m *IncidentMutation) RemoveParentIncidentIDs(ids ...int) {
	if m.removedparent_incident == nil {
		m.removedparent_incident = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.parent_incident, ids[i])
		m.removedparent_incident[ids[i]] = struct{}{}
	}
}

// RemovedParentIncident returns the removed IDs of the "parent_incident" edge to the Incident entity.
func (m *IncidentMutation) RemovedParentIncidentIDs() (ids []int) {
	for id := range m.removedparent_incident {
		ids = append(ids, id)
	}
	return
}

// ParentIncidentIDs returns the "parent_incident" edge IDs in the mutation.
func (m *IncidentMutation) ParentIncidentIDs() (ids []int) {
	for id := range m.parent_incident {
		ids = append(ids, id)
	}
	return
}

// ResetParentIncident resets all changes to the "parent_incident" edge.
func (m *IncidentMutation) ResetParentIncident() {
	m.parent_incident = nil
	m.clearedparent_incident = false
	m.removedparent_incident = nil
}

// Where appends a list predicates to the IncidentMutation builder.
func (m *IncidentMutation) Where(ps ...predicate.Incident) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Incident, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Incident).
func (m *IncidentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.title != nil {
		fields = append(fields, incident.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, incident.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, incident.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, incident.FieldPriority)
	}
	if m.severity != nil {
		fields = append(fields, incident.FieldSeverity)
	}
	if m.incident_number != nil {
		fields = append(fields, incident.FieldIncidentNumber)
	}
	if m.reporter_id != nil {
		fields = append(fields, incident.FieldReporterID)
	}
	if m.assignee_id != nil {
		fields = append(fields, incident.FieldAssigneeID)
	}
	if m.configuration_item_id != nil {
		fields = append(fields, incident.FieldConfigurationItemID)
	}
	if m.category != nil {
		fields = append(fields, incident.FieldCategory)
	}
	if m.subcategory != nil {
		fields = append(fields, incident.FieldSubcategory)
	}
	if m.impact_analysis != nil {
		fields = append(fields, incident.FieldImpactAnalysis)
	}
	if m.root_cause != nil {
		fields = append(fields, incident.FieldRootCause)
	}
	if m.resolution_steps != nil {
		fields = append(fields, incident.FieldResolutionSteps)
	}
	if m.detected_at != nil {
		fields = append(fields, incident.FieldDetectedAt)
	}
	if m.resolved_at != nil {
		fields = append(fields, incident.FieldResolvedAt)
	}
	if m.closed_at != nil {
		fields = append(fields, incident.FieldClosedAt)
	}
	if m.escalated_at != nil {
		fields = append(fields, incident.FieldEscalatedAt)
	}
	if m.escalation_level != nil {
		fields = append(fields, incident.FieldEscalationLevel)
	}
	if m.is_automated != nil {
		fields = append(fields, incident.FieldIsAutomated)
	}
	if m.source != nil {
		fields = append(fields, incident.FieldSource)
	}
	if m.metadata != nil {
		fields = append(fields, incident.FieldMetadata)
	}
	if m.tenant_id != nil {
		fields = append(fields, incident.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, incident.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, incident.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incident.FieldTitle:
		return m.Title()
	case incident.FieldDescription:
		return m.Description()
	case incident.FieldStatus:
		return m.Status()
	case incident.FieldPriority:
		return m.Priority()
	case incident.FieldSeverity:
		return m.Severity()
	case incident.FieldIncidentNumber:
		return m.IncidentNumber()
	case incident.FieldReporterID:
		return m.ReporterID()
	case incident.FieldAssigneeID:
		return m.AssigneeID()
	case incident.FieldConfigurationItemID:
		return m.ConfigurationItemID()
	case incident.FieldCategory:
		return m.Category()
	case incident.FieldSubcategory:
		return m.Subcategory()
	case incident.FieldImpactAnalysis:
		return m.ImpactAnalysis()
	case incident.FieldRootCause:
		return m.RootCause()
	case incident.FieldResolutionSteps:
		return m.ResolutionSteps()
	case incident.FieldDetectedAt:
		return m.DetectedAt()
	case incident.FieldResolvedAt:
		return m.ResolvedAt()
	case incident.FieldClosedAt:
		return m.ClosedAt()
	case incident.FieldEscalatedAt:
		return m.EscalatedAt()
	case incident.FieldEscalationLevel:
		return m.EscalationLevel()
	case incident.FieldIsAutomated:
		return m.IsAutomated()
	case incident.FieldSource:
		return m.Source()
	case incident.FieldMetadata:
		return m.Metadata()
	case incident.FieldTenantID:
		return m.TenantID()
	case incident.FieldCreatedAt:
		return m.CreatedAt()
	case incident.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incident.FieldTitle:
		return m.OldTitle(ctx)
	case incident.FieldDescription:
		return m.OldDescription(ctx)
	case incident.FieldStatus:
		return m.OldStatus(ctx)
	case incident.FieldPriority:
		return m.OldPriority(ctx)
	case incident.FieldSeverity:
		return m.OldSeverity(ctx)
	case incident.FieldIncidentNumber:
		return m.OldIncidentNumber(ctx)
	case incident.FieldReporterID:
		return m.OldReporterID(ctx)
	case incident.FieldAssigneeID:
		return m.OldAssigneeID(ctx)
	case incident.FieldConfigurationItemID:
		return m.OldConfigurationItemID(ctx)
	case incident.FieldCategory:
		return m.OldCategory(ctx)
	case incident.FieldSubcategory:
		return m.OldSubcategory(ctx)
	case incident.FieldImpactAnalysis:
		return m.OldImpactAnalysis(ctx)
	case incident.FieldRootCause:
		return m.OldRootCause(ctx)
	case incident.FieldResolutionSteps:
		return m.OldResolutionSteps(ctx)
	case incident.FieldDetectedAt:
		return m.OldDetectedAt(ctx)
	case incident.FieldResolvedAt:
		return m.OldResolvedAt(ctx)
	case incident.FieldClosedAt:
		return m.OldClosedAt(ctx)
	case incident.FieldEscalatedAt:
		return m.OldEscalatedAt(ctx)
	case incident.FieldEscalationLevel:
		return m.OldEscalationLevel(ctx)
	case incident.FieldIsAutomated:
		return m.OldIsAutomated(ctx)
	case incident.FieldSource:
		return m.OldSource(ctx)
	case incident.FieldMetadata:
		return m.OldMetadata(ctx)
	case incident.FieldTenantID:
		return m.OldTenantID(ctx)
	case incident.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incident.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Incident field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incident.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case incident.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incident.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case incident.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case incident.FieldSeverity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case incident.FieldIncidentNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentNumber(v)
		return nil
	case incident.FieldReporterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReporterID(v)
		return nil
	case incident.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeID(v)
		return nil
	case incident.FieldConfigurationItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigurationItemID(v)
		return nil
	case incident.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case incident.FieldSubcategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubcategory(v)
		return nil
	case incident.FieldImpactAnalysis:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpactAnalysis(v)
		return nil
	case incident.FieldRootCause:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootCause(v)
		return nil
	case incident.FieldResolutionSteps:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolutionSteps(v)
		return nil
	case incident.FieldDetectedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetectedAt(v)
		return nil
	case incident.FieldResolvedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedAt(v)
		return nil
	case incident.FieldClosedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	case incident.FieldEscalatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEscalatedAt(v)
		return nil
	case incident.FieldEscalationLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEscalationLevel(v)
		return nil
	case incident.FieldIsAutomated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAutomated(v)
		return nil
	case incident.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case incident.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case incident.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incident.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incident.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Incident field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentMutation) AddedFields() []string {
	var fields []string
	if m.addreporter_id != nil {
		fields = append(fields, incident.FieldReporterID)
	}
	if m.addassignee_id != nil {
		fields = append(fields, incident.FieldAssigneeID)
	}
	if m.addconfiguration_item_id != nil {
		fields = append(fields, incident.FieldConfigurationItemID)
	}
	if m.addescalation_level != nil {
		fields = append(fields, incident.FieldEscalationLevel)
	}
	if m.addtenant_id != nil {
		fields = append(fields, incident.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case incident.FieldReporterID:
		return m.AddedReporterID()
	case incident.FieldAssigneeID:
		return m.AddedAssigneeID()
	case incident.FieldConfigurationItemID:
		return m.AddedConfigurationItemID()
	case incident.FieldEscalationLevel:
		return m.AddedEscalationLevel()
	case incident.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case incident.FieldReporterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReporterID(v)
		return nil
	case incident.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssigneeID(v)
		return nil
	case incident.FieldConfigurationItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfigurationItemID(v)
		return nil
	case incident.FieldEscalationLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEscalationLevel(v)
		return nil
	case incident.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Incident numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incident.FieldDescription) {
		fields = append(fields, incident.FieldDescription)
	}
	if m.FieldCleared(incident.FieldAssigneeID) {
		fields = append(fields, incident.FieldAssigneeID)
	}
	if m.FieldCleared(incident.FieldConfigurationItemID) {
		fields = append(fields, incident.FieldConfigurationItemID)
	}
	if m.FieldCleared(incident.FieldCategory) {
		fields = append(fields, incident.FieldCategory)
	}
	if m.FieldCleared(incident.FieldSubcategory) {
		fields = append(fields, incident.FieldSubcategory)
	}
	if m.FieldCleared(incident.FieldImpactAnalysis) {
		fields = append(fields, incident.FieldImpactAnalysis)
	}
	if m.FieldCleared(incident.FieldRootCause) {
		fields = append(fields, incident.FieldRootCause)
	}
	if m.FieldCleared(incident.FieldResolutionSteps) {
		fields = append(fields, incident.FieldResolutionSteps)
	}
	if m.FieldCleared(incident.FieldResolvedAt) {
		fields = append(fields, incident.FieldResolvedAt)
	}
	if m.FieldCleared(incident.FieldClosedAt) {
		fields = append(fields, incident.FieldClosedAt)
	}
	if m.FieldCleared(incident.FieldEscalatedAt) {
		fields = append(fields, incident.FieldEscalatedAt)
	}
	if m.FieldCleared(incident.FieldMetadata) {
		fields = append(fields, incident.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentMutation) ClearField(name string) error {
	switch name {
	case incident.FieldDescription:
		m.ClearDescription()
		return nil
	case incident.FieldAssigneeID:
		m.ClearAssigneeID()
		return nil
	case incident.FieldConfigurationItemID:
		m.ClearConfigurationItemID()
		return nil
	case incident.FieldCategory:
		m.ClearCategory()
		return nil
	case incident.FieldSubcategory:
		m.ClearSubcategory()
		return nil
	case incident.FieldImpactAnalysis:
		m.ClearImpactAnalysis()
		return nil
	case incident.FieldRootCause:
		m.ClearRootCause()
		return nil
	case incident.FieldResolutionSteps:
		m.ClearResolutionSteps()
		return nil
	case incident.FieldResolvedAt:
		m.ClearResolvedAt()
		return nil
	case incident.FieldClosedAt:
		m.ClearClosedAt()
		return nil
	case incident.FieldEscalatedAt:
		m.ClearEscalatedAt()
		return nil
	case incident.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Incident nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentMutation) ResetField(name string) error {
	switch name {
	case incident.FieldTitle:
		m.ResetTitle()
		return nil
	case incident.FieldDescription:
		m.ResetDescription()
		return nil
	case incident.FieldStatus:
		m.ResetStatus()
		return nil
	case incident.FieldPriority:
		m.ResetPriority()
		return nil
	case incident.FieldSeverity:
		m.ResetSeverity()
		return nil
	case incident.FieldIncidentNumber:
		m.ResetIncidentNumber()
		return nil
	case incident.FieldReporterID:
		m.ResetReporterID()
		return nil
	case incident.FieldAssigneeID:
		m.ResetAssigneeID()
		return nil
	case incident.FieldConfigurationItemID:
		m.ResetConfigurationItemID()
		return nil
	case incident.FieldCategory:
		m.ResetCategory()
		return nil
	case incident.FieldSubcategory:
		m.ResetSubcategory()
		return nil
	case incident.FieldImpactAnalysis:
		m.ResetImpactAnalysis()
		return nil
	case incident.FieldRootCause:
		m.ResetRootCause()
		return nil
	case incident.FieldResolutionSteps:
		m.ResetResolutionSteps()
		return nil
	case incident.FieldDetectedAt:
		m.ResetDetectedAt()
		return nil
	case incident.FieldResolvedAt:
		m.ResetResolvedAt()
		return nil
	case incident.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	case incident.FieldEscalatedAt:
		m.ResetEscalatedAt()
		return nil
	case incident.FieldEscalationLevel:
		m.ResetEscalationLevel()
		return nil
	case incident.FieldIsAutomated:
		m.ResetIsAutomated()
		return nil
	case incident.FieldSource:
		m.ResetSource()
		return nil
	case incident.FieldMetadata:
		m.ResetMetadata()
		return nil
	case incident.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incident.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incident.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Incident field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.related_incidents != nil {
		edges = append(edges, incident.EdgeRelatedIncidents)
	}
	if m.incident_events != nil {
		edges = append(edges, incident.EdgeIncidentEvents)
	}
	if m.incident_alerts != nil {
		edges = append(edges, incident.EdgeIncidentAlerts)
	}
	if m.incident_metrics != nil {
		edges = append(edges, incident.EdgeIncidentMetrics)
	}
	if m.parent_incident != nil {
		edges = append(edges, incident.EdgeParentIncident)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incident.EdgeRelatedIncidents:
		ids := make([]ent.Value, 0, len(m.related_incidents))
		for id := range m.related_incidents {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeIncidentEvents:
		ids := make([]ent.Value, 0, len(m.incident_events))
		for id := range m.incident_events {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeIncidentAlerts:
		ids := make([]ent.Value, 0, len(m.incident_alerts))
		for id := range m.incident_alerts {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeIncidentMetrics:
		ids := make([]ent.Value, 0, len(m.incident_metrics))
		for id := range m.incident_metrics {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeParentIncident:
		ids := make([]ent.Value, 0, len(m.parent_incident))
		for id := range m.parent_incident {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedrelated_incidents != nil {
		edges = append(edges, incident.EdgeRelatedIncidents)
	}
	if m.removedincident_events != nil {
		edges = append(edges, incident.EdgeIncidentEvents)
	}
	if m.removedincident_alerts != nil {
		edges = append(edges, incident.EdgeIncidentAlerts)
	}
	if m.removedincident_metrics != nil {
		edges = append(edges, incident.EdgeIncidentMetrics)
	}
	if m.removedparent_incident != nil {
		edges = append(edges, incident.EdgeParentIncident)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incident.EdgeRelatedIncidents:
		ids := make([]ent.Value, 0, len(m.removedrelated_incidents))
		for id := range m.removedrelated_incidents {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeIncidentEvents:
		ids := make([]ent.Value, 0, len(m.removedincident_events))
		for id := range m.removedincident_events {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeIncidentAlerts:
		ids := make([]ent.Value, 0, len(m.removedincident_alerts))
		for id := range m.removedincident_alerts {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeIncidentMetrics:
		ids := make([]ent.Value, 0, len(m.removedincident_metrics))
		for id := range m.removedincident_metrics {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeParentIncident:
		ids := make([]ent.Value, 0, len(m.removedparent_incident))
		for id := range m.removedparent_incident {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedrelated_incidents {
		edges = append(edges, incident.EdgeRelatedIncidents)
	}
	if m.clearedincident_events {
		edges = append(edges, incident.EdgeIncidentEvents)
	}
	if m.clearedincident_alerts {
		edges = append(edges, incident.EdgeIncidentAlerts)
	}
	if m.clearedincident_metrics {
		edges = append(edges, incident.EdgeIncidentMetrics)
	}
	if m.clearedparent_incident {
		edges = append(edges, incident.EdgeParentIncident)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentMutation) EdgeCleared(name string) bool {
	switch name {
	case incident.EdgeRelatedIncidents:
		return m.clearedrelated_incidents
	case incident.EdgeIncidentEvents:
		return m.clearedincident_events
	case incident.EdgeIncidentAlerts:
		return m.clearedincident_alerts
	case incident.EdgeIncidentMetrics:
		return m.clearedincident_metrics
	case incident.EdgeParentIncident:
		return m.clearedparent_incident
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Incident unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentMutation) ResetEdge(name string) error {
	switch name {
	case incident.EdgeRelatedIncidents:
		m.ResetRelatedIncidents()
		return nil
	case incident.EdgeIncidentEvents:
		m.ResetIncidentEvents()
		return nil
	case incident.EdgeIncidentAlerts:
		m.ResetIncidentAlerts()
		return nil
	case incident.EdgeIncidentMetrics:
		m.ResetIncidentMetrics()
		return nil
	case incident.EdgeParentIncident:
		m.ResetParentIncident()
		return nil
	}
	return fmt.Errorf("unknown Incident edge %s", name)
}

// IncidentAlertMutation represents an operation that mutates the IncidentAlert nodes in the graph.
type IncidentAlertMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	alert_type         *string
	alert_name         *string
	message            *string
	severity           *string
	status             *string
	channels           *[]string
	appendchannels     []string
	recipients         *[]string
	appendrecipients   []string
	triggered_at       *time.Time
	acknowledged_at    *time.Time
	resolved_at        *time.Time
	acknowledged_by    *int
	addacknowledged_by *int
	metadata           *map[string]interface{}
	tenant_id          *int
	addtenant_id       *int
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	incident           *int
	clearedincident    bool
	done               bool
	oldValue           func(context.Context) (*IncidentAlert, error)
	predicates         []predicate.IncidentAlert
}

var _ ent.Mutation = (*IncidentAlertMutation)(nil)

// incidentalertOption allows management of the mutation configuration using functional options.
type incidentalertOption func(*IncidentAlertMutation)

// newIncidentAlertMutation creates new mutation for the IncidentAlert entity.
func newIncidentAlertMutation(c config, op Op, opts ...incidentalertOption) *IncidentAlertMutation {
	m := &IncidentAlertMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentAlert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentAlertID sets the ID field of the mutation.
func withIncidentAlertID(id int) incidentalertOption {
	return func(m *IncidentAlertMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentAlert
		)
		m.oldValue = func(ctx context.Context) (*IncidentAlert, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentAlert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentAlert sets the old IncidentAlert of the mutation.
func withIncidentAlert(node *IncidentAlert) incidentalertOption {
	return func(m *IncidentAlertMutation) {
		m.oldValue = func(context.Context) (*IncidentAlert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentAlertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentAlertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentAlertMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentAlertMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentAlert.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIncidentID sets the "incident_id" field.
func (m *IncidentAlertMutation) SetIncidentID(i int) {
	m.incident = &i
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *IncidentAlertMutation) IncidentID() (r int, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldIncidentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *IncidentAlertMutation) ResetIncidentID() {
	m.incident = nil
}

// SetAlertType sets the "alert_type" field.
func (m *IncidentAlertMutation) SetAlertType(s string) {
	m.alert_type = &s
}

// AlertType returns the value of the "alert_type" field in the mutation.
func (m *IncidentAlertMutation) AlertType() (r string, exists bool) {
	v := m.alert_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertType returns the old "alert_type" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldAlertType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertType: %w", err)
	}
	return oldValue.AlertType, nil
}

// ResetAlertType resets all changes to the "alert_type" field.
func (m *IncidentAlertMutation) ResetAlertType() {
	m.alert_type = nil
}

// SetAlertName sets the "alert_name" field.
func (m *IncidentAlertMutation) SetAlertName(s string) {
	m.alert_name = &s
}

// AlertName returns the value of the "alert_name" field in the mutation.
func (m *IncidentAlertMutation) AlertName() (r string, exists bool) {
	v := m.alert_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertName returns the old "alert_name" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldAlertName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertName: %w", err)
	}
	return oldValue.AlertName, nil
}

// ResetAlertName resets all changes to the "alert_name" field.
func (m *IncidentAlertMutation) ResetAlertName() {
	m.alert_name = nil
}

// SetMessage sets the "message" field.
func (m *IncidentAlertMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *IncidentAlertMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *IncidentAlertMutation) ResetMessage() {
	m.message = nil
}

// SetSeverity sets the "severity" field.
func (m *IncidentAlertMutation) SetSeverity(s string) {
	m.severity = &s
}

// Severity returns the value of the "severity" field in the mutation.
func (m *IncidentAlertMutation) Severity() (r string, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldSeverity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *IncidentAlertMutation) ResetSeverity() {
	m.severity = nil
}

// SetStatus sets the "status" field.
func (m *IncidentAlertMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *IncidentAlertMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *IncidentAlertMutation) ResetStatus() {
	m.status = nil
}

// SetChannels sets the "channels" field.
func (m *IncidentAlertMutation) SetChannels(s []string) {
	m.channels = &s
	m.appendchannels = nil
}

// Channels returns the value of the "channels" field in the mutation.
func (m *IncidentAlertMutation) Channels() (r []string, exists bool) {
	v := m.channels
	if v == nil {
		return
	}
	return *v, true
}

// OldChannels returns the old "channels" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldChannels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannels: %w", err)
	}
	return oldValue.Channels, nil
}

// AppendChannels adds s to the "channels" field.
func (m *IncidentAlertMutation) AppendChannels(s []string) {
	m.appendchannels = append(m.appendchannels, s...)
}

// AppendedChannels returns the list of values that were appended to the "channels" field in this mutation.
func (m *IncidentAlertMutation) AppendedChannels() ([]string, bool) {
	if len(m.appendchannels) == 0 {
		return nil, false
	}
	return m.appendchannels, true
}

// ClearChannels clears the value of the "channels" field.
func (m *IncidentAlertMutation) ClearChannels() {
	m.channels = nil
	m.appendchannels = nil
	m.clearedFields[incidentalert.FieldChannels] = struct{}{}
}

// ChannelsCleared returns if the "channels" field was cleared in this mutation.
func (m *IncidentAlertMutation) ChannelsCleared() bool {
	_, ok := m.clearedFields[incidentalert.FieldChannels]
	return ok
}

// ResetChannels resets all changes to the "channels" field.
func (m *IncidentAlertMutation) ResetChannels() {
	m.channels = nil
	m.appendchannels = nil
	delete(m.clearedFields, incidentalert.FieldChannels)
}

// SetRecipients sets the "recipients" field.
func (m *IncidentAlertMutation) SetRecipients(s []string) {
	m.recipients = &s
	m.appendrecipients = nil
}

// Recipients returns the value of the "recipients" field in the mutation.
func (m *IncidentAlertMutation) Recipients() (r []string, exists bool) {
	v := m.recipients
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipients returns the old "recipients" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldRecipients(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipients is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipients requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipients: %w", err)
	}
	return oldValue.Recipients, nil
}

// AppendRecipients adds s to the "recipients" field.
func (m *IncidentAlertMutation) AppendRecipients(s []string) {
	m.appendrecipients = append(m.appendrecipients, s...)
}

// AppendedRecipients returns the list of values that were appended to the "recipients" field in this mutation.
func (m *IncidentAlertMutation) AppendedRecipients() ([]string, bool) {
	if len(m.appendrecipients) == 0 {
		return nil, false
	}
	return m.appendrecipients, true
}

// ClearRecipients clears the value of the "recipients" field.
func (m *IncidentAlertMutation) ClearRecipients() {
	m.recipients = nil
	m.appendrecipients = nil
	m.clearedFields[incidentalert.FieldRecipients] = struct{}{}
}

// RecipientsCleared returns if the "recipients" field was cleared in this mutation.
func (m *IncidentAlertMutation) RecipientsCleared() bool {
	_, ok := m.clearedFields[incidentalert.FieldRecipients]
	return ok
}

// ResetRecipients resets all changes to the "recipients" field.
func (m *IncidentAlertMutation) ResetRecipients() {
	m.recipients = nil
	m.appendrecipients = nil
	delete(m.clearedFields, incidentalert.FieldRecipients)
}

// SetTriggeredAt sets the "triggered_at" field.
func (m *IncidentAlertMutation) SetTriggeredAt(t time.Time) {
	m.triggered_at = &t
}

// TriggeredAt returns the value of the "triggered_at" field in the mutation.
func (m *IncidentAlertMutation) TriggeredAt() (r time.Time, exists bool) {
	v := m.triggered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggeredAt returns the old "triggered_at" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldTriggeredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggeredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggeredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggeredAt: %w", err)
	}
	return oldValue.TriggeredAt, nil
}

// ResetTriggeredAt resets all changes to the "triggered_at" field.
func (m *IncidentAlertMutation) ResetTriggeredAt() {
	m.triggered_at = nil
}

// SetAcknowledgedAt sets the "acknowledged_at" field.
func (m *IncidentAlertMutation) SetAcknowledgedAt(t time.Time) {
	m.acknowledged_at = &t
}

// AcknowledgedAt returns the value of the "acknowledged_at" field in the mutation.
func (m *IncidentAlertMutation) AcknowledgedAt() (r time.Time, exists bool) {
	v := m.acknowledged_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAcknowledgedAt returns the old "acknowledged_at" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldAcknowledgedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcknowledgedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcknowledgedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcknowledgedAt: %w", err)
	}
	return oldValue.AcknowledgedAt, nil
}

// ClearAcknowledgedAt clears the value of the "acknowledged_at" field.
func (m *IncidentAlertMutation) ClearAcknowledgedAt() {
	m.acknowledged_at = nil
	m.clearedFields[incidentalert.FieldAcknowledgedAt] = struct{}{}
}

// AcknowledgedAtCleared returns if the "acknowledged_at" field was cleared in this mutation.
func (m *IncidentAlertMutation) AcknowledgedAtCleared() bool {
	_, ok := m.clearedFields[incidentalert.FieldAcknowledgedAt]
	return ok
}

// ResetAcknowledgedAt resets all changes to the "acknowledged_at" field.
func (m *IncidentAlertMutation) ResetAcknowledgedAt() {
	m.acknowledged_at = nil
	delete(m.clearedFields, incidentalert.FieldAcknowledgedAt)
}

// SetResolvedAt sets the "resolved_at" field.
func (m *IncidentAlertMutation) SetResolvedAt(t time.Time) {
	m.resolved_at = &t
}

// ResolvedAt returns the value of the "resolved_at" field in the mutation.
func (m *IncidentAlertMutation) ResolvedAt() (r time.Time, exists bool) {
	v := m.resolved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedAt returns the old "resolved_at" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldResolvedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedAt: %w", err)
	}
	return oldValue.ResolvedAt, nil
}

// ClearResolvedAt clears the value of the "resolved_at" field.
func (m *IncidentAlertMutation) ClearResolvedAt() {
	m.resolved_at = nil
	m.clearedFields[incidentalert.FieldResolvedAt] = struct{}{}
}

// ResolvedAtCleared returns if the "resolved_at" field was cleared in this mutation.
func (m *IncidentAlertMutation) ResolvedAtCleared() bool {
	_, ok := m.clearedFields[incidentalert.FieldResolvedAt]
	return ok
}

// ResetResolvedAt resets all changes to the "resolved_at" field.
func (m *IncidentAlertMutation) ResetResolvedAt() {
	m.resolved_at = nil
	delete(m.clearedFields, incidentalert.FieldResolvedAt)
}

// SetAcknowledgedBy sets the "acknowledged_by" field.
func (m *IncidentAlertMutation) SetAcknowledgedBy(i int) {
	m.acknowledged_by = &i
	m.addacknowledged_by = nil
}

// AcknowledgedBy returns the value of the "acknowledged_by" field in the mutation.
func (m *IncidentAlertMutation) AcknowledgedBy() (r int, exists bool) {
	v := m.acknowledged_by
	if v == nil {
		return
	}
	return *v, true
}

// OldAcknowledgedBy returns the old "acknowledged_by" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldAcknowledgedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcknowledgedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcknowledgedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcknowledgedBy: %w", err)
	}
	return oldValue.AcknowledgedBy, nil
}

// AddAcknowledgedBy adds i to the "acknowledged_by" field.
func (m *IncidentAlertMutation) AddAcknowledgedBy(i int) {
	if m.addacknowledged_by != nil {
		*m.addacknowledged_by += i
	} else {
		m.addacknowledged_by = &i
	}
}

// AddedAcknowledgedBy returns the value that was added to the "acknowledged_by" field in this mutation.
func (m *IncidentAlertMutation) AddedAcknowledgedBy() (r int, exists bool) {
	v := m.addacknowledged_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearAcknowledgedBy clears the value of the "acknowledged_by" field.
func (m *IncidentAlertMutation) ClearAcknowledgedBy() {
	m.acknowledged_by = nil
	m.addacknowledged_by = nil
	m.clearedFields[incidentalert.FieldAcknowledgedBy] = struct{}{}
}

// AcknowledgedByCleared returns if the "acknowledged_by" field was cleared in this mutation.
func (m *IncidentAlertMutation) AcknowledgedByCleared() bool {
	_, ok := m.clearedFields[incidentalert.FieldAcknowledgedBy]
	return ok
}

// ResetAcknowledgedBy resets all changes to the "acknowledged_by" field.
func (m *IncidentAlertMutation) ResetAcknowledgedBy() {
	m.acknowledged_by = nil
	m.addacknowledged_by = nil
	delete(m.clearedFields, incidentalert.FieldAcknowledgedBy)
}

// SetMetadata sets the "metadata" field.
func (m *IncidentAlertMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *IncidentAlertMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *IncidentAlertMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[incidentalert.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *IncidentAlertMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[incidentalert.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *IncidentAlertMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, incidentalert.FieldMetadata)
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentAlertMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentAlertMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *IncidentAlertMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *IncidentAlertMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentAlertMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentAlertMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentAlertMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentAlertMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IncidentAlertMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IncidentAlertMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IncidentAlert entity.
// If the IncidentAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentAlertMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IncidentAlertMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *IncidentAlertMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[incidentalert.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *IncidentAlertMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentAlertMutation) IncidentIDs() (ids []int) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *IncidentAlertMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// Where appends a list predicates to the IncidentAlertMutation builder.
func (m *IncidentAlertMutation) Where(ps ...predicate.IncidentAlert) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentAlertMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentAlertMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentAlert, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentAlertMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentAlertMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentAlert).
func (m *IncidentAlertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentAlertMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.incident != nil {
		fields = append(fields, incidentalert.FieldIncidentID)
	}
	if m.alert_type != nil {
		fields = append(fields, incidentalert.FieldAlertType)
	}
	if m.alert_name != nil {
		fields = append(fields, incidentalert.FieldAlertName)
	}
	if m.message != nil {
		fields = append(fields, incidentalert.FieldMessage)
	}
	if m.severity != nil {
		fields = append(fields, incidentalert.FieldSeverity)
	}
	if m.status != nil {
		fields = append(fields, incidentalert.FieldStatus)
	}
	if m.channels != nil {
		fields = append(fields, incidentalert.FieldChannels)
	}
	if m.recipients != nil {
		fields = append(fields, incidentalert.FieldRecipients)
	}
	if m.triggered_at != nil {
		fields = append(fields, incidentalert.FieldTriggeredAt)
	}
	if m.acknowledged_at != nil {
		fields = append(fields, incidentalert.FieldAcknowledgedAt)
	}
	if m.resolved_at != nil {
		fields = append(fields, incidentalert.FieldResolvedAt)
	}
	if m.acknowledged_by != nil {
		fields = append(fields, incidentalert.FieldAcknowledgedBy)
	}
	if m.metadata != nil {
		fields = append(fields, incidentalert.FieldMetadata)
	}
	if m.tenant_id != nil {
		fields = append(fields, incidentalert.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, incidentalert.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, incidentalert.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentAlertMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentalert.FieldIncidentID:
		return m.IncidentID()
	case incidentalert.FieldAlertType:
		return m.AlertType()
	case incidentalert.FieldAlertName:
		return m.AlertName()
	case incidentalert.FieldMessage:
		return m.Message()
	case incidentalert.FieldSeverity:
		return m.Severity()
	case incidentalert.FieldStatus:
		return m.Status()
	case incidentalert.FieldChannels:
		return m.Channels()
	case incidentalert.FieldRecipients:
		return m.Recipients()
	case incidentalert.FieldTriggeredAt:
		return m.TriggeredAt()
	case incidentalert.FieldAcknowledgedAt:
		return m.AcknowledgedAt()
	case incidentalert.FieldResolvedAt:
		return m.ResolvedAt()
	case incidentalert.FieldAcknowledgedBy:
		return m.AcknowledgedBy()
	case incidentalert.FieldMetadata:
		return m.Metadata()
	case incidentalert.FieldTenantID:
		return m.TenantID()
	case incidentalert.FieldCreatedAt:
		return m.CreatedAt()
	case incidentalert.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentAlertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentalert.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incidentalert.FieldAlertType:
		return m.OldAlertType(ctx)
	case incidentalert.FieldAlertName:
		return m.OldAlertName(ctx)
	case incidentalert.FieldMessage:
		return m.OldMessage(ctx)
	case incidentalert.FieldSeverity:
		return m.OldSeverity(ctx)
	case incidentalert.FieldStatus:
		return m.OldStatus(ctx)
	case incidentalert.FieldChannels:
		return m.OldChannels(ctx)
	case incidentalert.FieldRecipients:
		return m.OldRecipients(ctx)
	case incidentalert.FieldTriggeredAt:
		return m.OldTriggeredAt(ctx)
	case incidentalert.FieldAcknowledgedAt:
		return m.OldAcknowledgedAt(ctx)
	case incidentalert.FieldResolvedAt:
		return m.OldResolvedAt(ctx)
	case incidentalert.FieldAcknowledgedBy:
		return m.OldAcknowledgedBy(ctx)
	case incidentalert.FieldMetadata:
		return m.OldMetadata(ctx)
	case incidentalert.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentalert.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incidentalert.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentAlert field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentAlertMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentalert.FieldIncidentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incidentalert.FieldAlertType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertType(v)
		return nil
	case incidentalert.FieldAlertName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertName(v)
		return nil
	case incidentalert.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case incidentalert.FieldSeverity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case incidentalert.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case incidentalert.FieldChannels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannels(v)
		return nil
	case incidentalert.FieldRecipients:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipients(v)
		return nil
	case incidentalert.FieldTriggeredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggeredAt(v)
		return nil
	case incidentalert.FieldAcknowledgedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcknowledgedAt(v)
		return nil
	case incidentalert.FieldResolvedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedAt(v)
		return nil
	case incidentalert.FieldAcknowledgedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcknowledgedBy(v)
		return nil
	case incidentalert.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case incidentalert.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentalert.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incidentalert.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentAlert field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentAlertMutation) AddedFields() []string {
	var fields []string
	if m.addacknowledged_by != nil {
		fields = append(fields, incidentalert.FieldAcknowledgedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, incidentalert.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentAlertMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case incidentalert.FieldAcknowledgedBy:
		return m.AddedAcknowledgedBy()
	case incidentalert.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentAlertMutation) AddField(name string, value ent.Value) error {
	switch name {
	case incidentalert.FieldAcknowledgedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAcknowledgedBy(v)
		return nil
	case incidentalert.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentAlert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentAlertMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentalert.FieldChannels) {
		fields = append(fields, incidentalert.FieldChannels)
	}
	if m.FieldCleared(incidentalert.FieldRecipients) {
		fields = append(fields, incidentalert.FieldRecipients)
	}
	if m.FieldCleared(incidentalert.FieldAcknowledgedAt) {
		fields = append(fields, incidentalert.FieldAcknowledgedAt)
	}
	if m.FieldCleared(incidentalert.FieldResolvedAt) {
		fields = append(fields, incidentalert.FieldResolvedAt)
	}
	if m.FieldCleared(incidentalert.FieldAcknowledgedBy) {
		fields = append(fields, incidentalert.FieldAcknowledgedBy)
	}
	if m.FieldCleared(incidentalert.FieldMetadata) {
		fields = append(fields, incidentalert.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentAlertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentAlertMutation) ClearField(name string) error {
	switch name {
	case incidentalert.FieldChannels:
		m.ClearChannels()
		return nil
	case incidentalert.FieldRecipients:
		m.ClearRecipients()
		return nil
	case incidentalert.FieldAcknowledgedAt:
		m.ClearAcknowledgedAt()
		return nil
	case incidentalert.FieldResolvedAt:
		m.ClearResolvedAt()
		return nil
	case incidentalert.FieldAcknowledgedBy:
		m.ClearAcknowledgedBy()
		return nil
	case incidentalert.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown IncidentAlert nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentAlertMutation) ResetField(name string) error {
	switch name {
	case incidentalert.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incidentalert.FieldAlertType:
		m.ResetAlertType()
		return nil
	case incidentalert.FieldAlertName:
		m.ResetAlertName()
		return nil
	case incidentalert.FieldMessage:
		m.ResetMessage()
		return nil
	case incidentalert.FieldSeverity:
		m.ResetSeverity()
		return nil
	case incidentalert.FieldStatus:
		m.ResetStatus()
		return nil
	case incidentalert.FieldChannels:
		m.ResetChannels()
		return nil
	case incidentalert.FieldRecipients:
		m.ResetRecipients()
		return nil
	case incidentalert.FieldTriggeredAt:
		m.ResetTriggeredAt()
		return nil
	case incidentalert.FieldAcknowledgedAt:
		m.ResetAcknowledgedAt()
		return nil
	case incidentalert.FieldResolvedAt:
		m.ResetResolvedAt()
		return nil
	case incidentalert.FieldAcknowledgedBy:
		m.ResetAcknowledgedBy()
		return nil
	case incidentalert.FieldMetadata:
		m.ResetMetadata()
		return nil
	case incidentalert.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentalert.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incidentalert.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown IncidentAlert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentAlertMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.incident != nil {
		edges = append(edges, incidentalert.EdgeIncident)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentAlertMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentalert.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentAlertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentAlertMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentAlertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedincident {
		edges = append(edges, incidentalert.EdgeIncident)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentAlertMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentalert.EdgeIncident:
		return m.clearedincident
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentAlertMutation) ClearEdge(name string) error {
	switch name {
	case incidentalert.EdgeIncident:
		m.ClearIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentAlert unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentAlertMutation) ResetEdge(name string) error {
	switch name {
	case incidentalert.EdgeIncident:
		m.ResetIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentAlert edge %s", name)
}

// IncidentEventMutation represents an operation that mutates the IncidentEvent nodes in the graph.
type IncidentEventMutation struct {
	config
	op              Op
	typ             string
	id              *int
	event_type      *string
	event_name      *string
	description     *string
	status          *string
	severity        *string
	data            *map[string]interface{}
	occurred_at     *time.Time
	user_id         *int
	adduser_id      *int
	source          *string
	metadata        *map[string]interface{}
	tenant_id       *int
	addtenant_id    *int
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	incident        *int
	clearedincident bool
	done            bool
	oldValue        func(context.Context) (*IncidentEvent, error)
	predicates      []predicate.IncidentEvent
}

var _ ent.Mutation = (*IncidentEventMutation)(nil)

// incidenteventOption allows management of the mutation configuration using functional options.
type incidenteventOption func(*IncidentEventMutation)

// newIncidentEventMutation creates new mutation for the IncidentEvent entity.
func newIncidentEventMutation(c config, op Op, opts ...incidenteventOption) *IncidentEventMutation {
	m := &IncidentEventMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentEventID sets the ID field of the mutation.
func withIncidentEventID(id int) incidenteventOption {
	return func(m *IncidentEventMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentEvent
		)
		m.oldValue = func(ctx context.Context) (*IncidentEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentEvent sets the old IncidentEvent of the mutation.
func withIncidentEvent(node *IncidentEvent) incidenteventOption {
	return func(m *IncidentEventMutation) {
		m.oldValue = func(context.Context) (*IncidentEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIncidentID sets the "incident_id" field.
func (m *IncidentEventMutation) SetIncidentID(i int) {
	m.incident = &i
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *IncidentEventMutation) IncidentID() (r int, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldIncidentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *IncidentEventMutation) ResetIncidentID() {
	m.incident = nil
}

// SetEventType sets the "event_type" field.
func (m *IncidentEventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *IncidentEventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *IncidentEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetEventName sets the "event_name" field.
func (m *IncidentEventMutation) SetEventName(s string) {
	m.event_name = &s
}

// EventName returns the value of the "event_name" field in the mutation.
func (m *IncidentEventMutation) EventName() (r string, exists bool) {
	v := m.event_name
	if v == nil {
		return
	}
	return *v, true
}

// OldEventName returns the old "event_name" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldEventName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventName: %w", err)
	}
	return oldValue.EventName, nil
}

// ResetEventName resets all changes to the "event_name" field.
func (m *IncidentEventMutation) ResetEventName() {
	m.event_name = nil
}

// SetDescription sets the "description" field.
func (m *IncidentEventMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentEventMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentEventMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incidentevent.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentEventMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incidentevent.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentEventMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incidentevent.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *IncidentEventMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *IncidentEventMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *IncidentEventMutation) ResetStatus() {
	m.status = nil
}

// SetSeverity sets the "severity" field.
func (m *IncidentEventMutation) SetSeverity(s string) {
	m.severity = &s
}

// Severity returns the value of the "severity" field in the mutation.
func (m *IncidentEventMutation) Severity() (r string, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldSeverity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *IncidentEventMutation) ResetSeverity() {
	m.severity = nil
}

// SetData sets the "data" field.
func (m *IncidentEventMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *IncidentEventMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *IncidentEventMutation) ClearData() {
	m.data = nil
	m.clearedFields[incidentevent.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *IncidentEventMutation) DataCleared() bool {
	_, ok := m.clearedFields[incidentevent.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *IncidentEventMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, incidentevent.FieldData)
}

// SetOccurredAt sets the "occurred_at" field.
func (m *IncidentEventMutation) SetOccurredAt(t time.Time) {
	m.occurred_at = &t
}

// OccurredAt returns the value of the "occurred_at" field in the mutation.
func (m *IncidentEventMutation) OccurredAt() (r time.Time, exists bool) {
	v := m.occurred_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOccurredAt returns the old "occurred_at" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldOccurredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccurredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccurredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccurredAt: %w", err)
	}
	return oldValue.OccurredAt, nil
}

// ResetOccurredAt resets all changes to the "occurred_at" field.
func (m *IncidentEventMutation) ResetOccurredAt() {
	m.occurred_at = nil
}

// SetUserID sets the "user_id" field.
func (m *IncidentEventMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *IncidentEventMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *IncidentEventMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *IncidentEventMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *IncidentEventMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[incidentevent.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *IncidentEventMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[incidentevent.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *IncidentEventMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, incidentevent.FieldUserID)
}

// SetSource sets the "source" field.
func (m *IncidentEventMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *IncidentEventMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *IncidentEventMutation) ResetSource() {
	m.source = nil
}

// SetMetadata sets the "metadata" field.
func (m *IncidentEventMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *IncidentEventMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *IncidentEventMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[incidentevent.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *IncidentEventMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[incidentevent.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *IncidentEventMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, incidentevent.FieldMetadata)
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentEventMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentEventMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *IncidentEventMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *IncidentEventMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentEventMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IncidentEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IncidentEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IncidentEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *IncidentEventMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[incidentevent.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *IncidentEventMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentEventMutation) IncidentIDs() (ids []int) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *IncidentEventMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// Where appends a list predicates to the IncidentEventMutation builder.
func (m *IncidentEventMutation) Where(ps ...predicate.IncidentEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentEvent).
func (m *IncidentEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentEventMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.incident != nil {
		fields = append(fields, incidentevent.FieldIncidentID)
	}
	if m.event_type != nil {
		fields = append(fields, incidentevent.FieldEventType)
	}
	if m.event_name != nil {
		fields = append(fields, incidentevent.FieldEventName)
	}
	if m.description != nil {
		fields = append(fields, incidentevent.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, incidentevent.FieldStatus)
	}
	if m.severity != nil {
		fields = append(fields, incidentevent.FieldSeverity)
	}
	if m.data != nil {
		fields = append(fields, incidentevent.FieldData)
	}
	if m.occurred_at != nil {
		fields = append(fields, incidentevent.FieldOccurredAt)
	}
	if m.user_id != nil {
		fields = append(fields, incidentevent.FieldUserID)
	}
	if m.source != nil {
		fields = append(fields, incidentevent.FieldSource)
	}
	if m.metadata != nil {
		fields = append(fields, incidentevent.FieldMetadata)
	}
	if m.tenant_id != nil {
		fields = append(fields, incidentevent.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, incidentevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, incidentevent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentevent.FieldIncidentID:
		return m.IncidentID()
	case incidentevent.FieldEventType:
		return m.EventType()
	case incidentevent.FieldEventName:
		return m.EventName()
	case incidentevent.FieldDescription:
		return m.Description()
	case incidentevent.FieldStatus:
		return m.Status()
	case incidentevent.FieldSeverity:
		return m.Severity()
	case incidentevent.FieldData:
		return m.Data()
	case incidentevent.FieldOccurredAt:
		return m.OccurredAt()
	case incidentevent.FieldUserID:
		return m.UserID()
	case incidentevent.FieldSource:
		return m.Source()
	case incidentevent.FieldMetadata:
		return m.Metadata()
	case incidentevent.FieldTenantID:
		return m.TenantID()
	case incidentevent.FieldCreatedAt:
		return m.CreatedAt()
	case incidentevent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentevent.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incidentevent.FieldEventType:
		return m.OldEventType(ctx)
	case incidentevent.FieldEventName:
		return m.OldEventName(ctx)
	case incidentevent.FieldDescription:
		return m.OldDescription(ctx)
	case incidentevent.FieldStatus:
		return m.OldStatus(ctx)
	case incidentevent.FieldSeverity:
		return m.OldSeverity(ctx)
	case incidentevent.FieldData:
		return m.OldData(ctx)
	case incidentevent.FieldOccurredAt:
		return m.OldOccurredAt(ctx)
	case incidentevent.FieldUserID:
		return m.OldUserID(ctx)
	case incidentevent.FieldSource:
		return m.OldSource(ctx)
	case incidentevent.FieldMetadata:
		return m.OldMetadata(ctx)
	case incidentevent.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incidentevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentevent.FieldIncidentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incidentevent.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case incidentevent.FieldEventName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventName(v)
		return nil
	case incidentevent.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incidentevent.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case incidentevent.FieldSeverity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case incidentevent.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case incidentevent.FieldOccurredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccurredAt(v)
		return nil
	case incidentevent.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case incidentevent.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case incidentevent.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case incidentevent.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incidentevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentEventMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, incidentevent.FieldUserID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, incidentevent.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case incidentevent.FieldUserID:
		return m.AddedUserID()
	case incidentevent.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case incidentevent.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case incidentevent.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentevent.FieldDescription) {
		fields = append(fields, incidentevent.FieldDescription)
	}
	if m.FieldCleared(incidentevent.FieldData) {
		fields = append(fields, incidentevent.FieldData)
	}
	if m.FieldCleared(incidentevent.FieldUserID) {
		fields = append(fields, incidentevent.FieldUserID)
	}
	if m.FieldCleared(incidentevent.FieldMetadata) {
		fields = append(fields, incidentevent.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentEventMutation) ClearField(name string) error {
	switch name {
	case incidentevent.FieldDescription:
		m.ClearDescription()
		return nil
	case incidentevent.FieldData:
		m.ClearData()
		return nil
	case incidentevent.FieldUserID:
		m.ClearUserID()
		return nil
	case incidentevent.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentEventMutation) ResetField(name string) error {
	switch name {
	case incidentevent.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incidentevent.FieldEventType:
		m.ResetEventType()
		return nil
	case incidentevent.FieldEventName:
		m.ResetEventName()
		return nil
	case incidentevent.FieldDescription:
		m.ResetDescription()
		return nil
	case incidentevent.FieldStatus:
		m.ResetStatus()
		return nil
	case incidentevent.FieldSeverity:
		m.ResetSeverity()
		return nil
	case incidentevent.FieldData:
		m.ResetData()
		return nil
	case incidentevent.FieldOccurredAt:
		m.ResetOccurredAt()
		return nil
	case incidentevent.FieldUserID:
		m.ResetUserID()
		return nil
	case incidentevent.FieldSource:
		m.ResetSource()
		return nil
	case incidentevent.FieldMetadata:
		m.ResetMetadata()
		return nil
	case incidentevent.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incidentevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.incident != nil {
		edges = append(edges, incidentevent.EdgeIncident)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentevent.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedincident {
		edges = append(edges, incidentevent.EdgeIncident)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentEventMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentevent.EdgeIncident:
		return m.clearedincident
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentEventMutation) ClearEdge(name string) error {
	switch name {
	case incidentevent.EdgeIncident:
		m.ClearIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentEventMutation) ResetEdge(name string) error {
	switch name {
	case incidentevent.EdgeIncident:
		m.ResetIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent edge %s", name)
}

// IncidentMetricMutation represents an operation that mutates the IncidentMetric nodes in the graph.
type IncidentMetricMutation struct {
	config
	op              Op
	typ             string
	id              *int
	metric_type     *string
	metric_name     *string
	metric_value    *float64
	addmetric_value *float64
	unit            *string
	measured_at     *time.Time
	tags            *map[string]string
	metadata        *map[string]interface{}
	tenant_id       *int
	addtenant_id    *int
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	incident        *int
	clearedincident bool
	done            bool
	oldValue        func(context.Context) (*IncidentMetric, error)
	predicates      []predicate.IncidentMetric
}

var _ ent.Mutation = (*IncidentMetricMutation)(nil)

// incidentmetricOption allows management of the mutation configuration using functional options.
type incidentmetricOption func(*IncidentMetricMutation)

// newIncidentMetricMutation creates new mutation for the IncidentMetric entity.
func newIncidentMetricMutation(c config, op Op, opts ...incidentmetricOption) *IncidentMetricMutation {
	m := &IncidentMetricMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentMetric,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentMetricID sets the ID field of the mutation.
func withIncidentMetricID(id int) incidentmetricOption {
	return func(m *IncidentMetricMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentMetric
		)
		m.oldValue = func(ctx context.Context) (*IncidentMetric, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentMetric.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentMetric sets the old IncidentMetric of the mutation.
func withIncidentMetric(node *IncidentMetric) incidentmetricOption {
	return func(m *IncidentMetricMutation) {
		m.oldValue = func(context.Context) (*IncidentMetric, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentMetricMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentMetricMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentMetricMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentMetricMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentMetric.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIncidentID sets the "incident_id" field.
func (m *IncidentMetricMutation) SetIncidentID(i int) {
	m.incident = &i
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *IncidentMetricMutation) IncidentID() (r int, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the IncidentMetric entity.
// If the IncidentMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMetricMutation) OldIncidentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *IncidentMetricMutation) ResetIncidentID() {
	m.incident = nil
}

// SetMetricType sets the "metric_type" field.
func (m *IncidentMetricMutation) SetMetricType(s string) {
	m.metric_type = &s
}

// MetricType returns the value of the "metric_type" field in the mutation.
func (m *IncidentMetricMutation) MetricType() (r string, exists bool) {
	v := m.metric_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricType returns the old "metric_type" field's value of the IncidentMetric entity.
// If the IncidentMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMetricMutation) OldMetricType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricType: %w", err)
	}
	return oldValue.MetricType, nil
}

// ResetMetricType resets all changes to the "metric_type" field.
func (m *IncidentMetricMutation) ResetMetricType() {
	m.metric_type = nil
}

// SetMetricName sets the "metric_name" field.
func (m *IncidentMetricMutation) SetMetricName(s string) {
	m.metric_name = &s
}

// MetricName returns the value of the "metric_name" field in the mutation.
func (m *IncidentMetricMutation) MetricName() (r string, exists bool) {
	v := m.metric_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricName returns the old "metric_name" field's value of the IncidentMetric entity.
// If the IncidentMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMetricMutation) OldMetricName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricName: %w", err)
	}
	return oldValue.MetricName, nil
}

// ResetMetricName resets all changes to the "metric_name" field.
func (m *IncidentMetricMutation) ResetMetricName() {
	m.metric_name = nil
}

// SetMetricValue sets the "metric_value" field.
func (m *IncidentMetricMutation) SetMetricValue(f float64) {
	m.metric_value = &f
	m.addmetric_value = nil
}

// MetricValue returns the value of the "metric_value" field in the mutation.
func (m *IncidentMetricMutation) MetricValue() (r float64, exists bool) {
	v := m.metric_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricValue returns the old "metric_value" field's value of the IncidentMetric entity.
// If the IncidentMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMetricMutation) OldMetricValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricValue: %w", err)
	}
	return oldValue.MetricValue, nil
}

// AddMetricValue adds f to the "metric_value" field.
func (m *IncidentMetricMutation) AddMetricValue(f float64) {
	if m.addmetric_value != nil {
		*m.addmetric_value += f
	} else {
		m.addmetric_value = &f
	}
}

// AddedMetricValue returns the value that was added to the "metric_value" field in this mutation.
func (m *IncidentMetricMutation) AddedMetricValue() (r float64, exists bool) {
	v := m.addmetric_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetMetricValue resets all changes to the "metric_value" field.
func (m *IncidentMetricMutation) ResetMetricValue() {
	m.metric_value = nil
	m.addmetric_value = nil
}

// SetUnit sets the "unit" field.
func (m *IncidentMetricMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *IncidentMetricMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the IncidentMetric entity.
// If the IncidentMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMetricMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ClearUnit clears the value of the "unit" field.
func (m *IncidentMetricMutation) ClearUnit() {
	m.unit = nil
	m.clearedFields[incidentmetric.FieldUnit] = struct{}{}
}

// UnitCleared returns if the "unit" field was cleared in this mutation.
func (m *IncidentMetricMutation) UnitCleared() bool {
	_, ok := m.clearedFields[incidentmetric.FieldUnit]
	return ok
}

// ResetUnit resets all changes to the "unit" field.
func (m *IncidentMetricMutation) ResetUnit() {
	m.unit = nil
	delete(m.clearedFields, incidentmetric.FieldUnit)
}

// SetMeasuredAt sets the "measured_at" field.
func (m *IncidentMetricMutation) SetMeasuredAt(t time.Time) {
	m.measured_at = &t
}

// MeasuredAt returns the value of the "measured_at" field in the mutation.
func (m *IncidentMetricMutation) MeasuredAt() (r time.Time, exists bool) {
	v := m.measured_at
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasuredAt returns the old "measured_at" field's value of the IncidentMetric entity.
// If the IncidentMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMetricMutation) OldMeasuredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeasuredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeasuredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasuredAt: %w", err)
	}
	return oldValue.MeasuredAt, nil
}

// ResetMeasuredAt resets all changes to the "measured_at" field.
func (m *IncidentMetricMutation) ResetMeasuredAt() {
	m.measured_at = nil
}

// SetTags sets the "tags" field.
func (m *IncidentMetricMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *IncidentMetricMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the IncidentMetric entity.
// If the IncidentMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMetricMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *IncidentMetricMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[incidentmetric.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *IncidentMetricMutation) TagsCleared() bool {
	_, ok := m.clearedFields[incidentmetric.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *IncidentMetricMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, incidentmetric.FieldTags)
}

// SetMetadata sets the "metadata" field.
func (m *IncidentMetricMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *IncidentMetricMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the IncidentMetric entity.
// If the IncidentMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMetricMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *IncidentMetricMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[incidentmetric.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *IncidentMetricMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[incidentmetric.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *IncidentMetricMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, incidentmetric.FieldMetadata)
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentMetricMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentMetricMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentMetric entity.
// If the IncidentMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMetricMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *IncidentMetricMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *IncidentMetricMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentMetricMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentMetricMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentMetricMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentMetric entity.
// If the IncidentMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMetricMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentMetricMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IncidentMetricMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IncidentMetricMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IncidentMetric entity.
// If the IncidentMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMetricMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IncidentMetricMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *IncidentMetricMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[incidentmetric.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *IncidentMetricMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentMetricMutation) IncidentIDs() (ids []int) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *IncidentMetricMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// Where appends a list predicates to the IncidentMetricMutation builder.
func (m *IncidentMetricMutation) Where(ps ...predicate.IncidentMetric) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentMetricMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentMetricMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentMetric, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentMetricMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentMetricMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentMetric).
func (m *IncidentMetricMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentMetricMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.incident != nil {
		fields = append(fields, incidentmetric.FieldIncidentID)
	}
	if m.metric_type != nil {
		fields = append(fields, incidentmetric.FieldMetricType)
	}
	if m.metric_name != nil {
		fields = append(fields, incidentmetric.FieldMetricName)
	}
	if m.metric_value != nil {
		fields = append(fields, incidentmetric.FieldMetricValue)
	}
	if m.unit != nil {
		fields = append(fields, incidentmetric.FieldUnit)
	}
	if m.measured_at != nil {
		fields = append(fields, incidentmetric.FieldMeasuredAt)
	}
	if m.tags != nil {
		fields = append(fields, incidentmetric.FieldTags)
	}
	if m.metadata != nil {
		fields = append(fields, incidentmetric.FieldMetadata)
	}
	if m.tenant_id != nil {
		fields = append(fields, incidentmetric.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, incidentmetric.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, incidentmetric.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentMetricMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentmetric.FieldIncidentID:
		return m.IncidentID()
	case incidentmetric.FieldMetricType:
		return m.MetricType()
	case incidentmetric.FieldMetricName:
		return m.MetricName()
	case incidentmetric.FieldMetricValue:
		return m.MetricValue()
	case incidentmetric.FieldUnit:
		return m.Unit()
	case incidentmetric.FieldMeasuredAt:
		return m.MeasuredAt()
	case incidentmetric.FieldTags:
		return m.Tags()
	case incidentmetric.FieldMetadata:
		return m.Metadata()
	case incidentmetric.FieldTenantID:
		return m.TenantID()
	case incidentmetric.FieldCreatedAt:
		return m.CreatedAt()
	case incidentmetric.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentMetricMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentmetric.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incidentmetric.FieldMetricType:
		return m.OldMetricType(ctx)
	case incidentmetric.FieldMetricName:
		return m.OldMetricName(ctx)
	case incidentmetric.FieldMetricValue:
		return m.OldMetricValue(ctx)
	case incidentmetric.FieldUnit:
		return m.OldUnit(ctx)
	case incidentmetric.FieldMeasuredAt:
		return m.OldMeasuredAt(ctx)
	case incidentmetric.FieldTags:
		return m.OldTags(ctx)
	case incidentmetric.FieldMetadata:
		return m.OldMetadata(ctx)
	case incidentmetric.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentmetric.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incidentmetric.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentMetric field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMetricMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentmetric.FieldIncidentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incidentmetric.FieldMetricType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricType(v)
		return nil
	case incidentmetric.FieldMetricName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricName(v)
		return nil
	case incidentmetric.FieldMetricValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricValue(v)
		return nil
	case incidentmetric.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case incidentmetric.FieldMeasuredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasuredAt(v)
		return nil
	case incidentmetric.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case incidentmetric.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case incidentmetric.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentmetric.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incidentmetric.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentMetric field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentMetricMutation) AddedFields() []string {
	var fields []string
	if m.addmetric_value != nil {
		fields = append(fields, incidentmetric.FieldMetricValue)
	}
	if m.addtenant_id != nil {
		fields = append(fields, incidentmetric.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentMetricMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case incidentmetric.FieldMetricValue:
		return m.AddedMetricValue()
	case incidentmetric.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMetricMutation) AddField(name string, value ent.Value) error {
	switch name {
	case incidentmetric.FieldMetricValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMetricValue(v)
		return nil
	case incidentmetric.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentMetric numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentMetricMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentmetric.FieldUnit) {
		fields = append(fields, incidentmetric.FieldUnit)
	}
	if m.FieldCleared(incidentmetric.FieldTags) {
		fields = append(fields, incidentmetric.FieldTags)
	}
	if m.FieldCleared(incidentmetric.FieldMetadata) {
		fields = append(fields, incidentmetric.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentMetricMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentMetricMutation) ClearField(name string) error {
	switch name {
	case incidentmetric.FieldUnit:
		m.ClearUnit()
		return nil
	case incidentmetric.FieldTags:
		m.ClearTags()
		return nil
	case incidentmetric.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown IncidentMetric nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentMetricMutation) ResetField(name string) error {
	switch name {
	case incidentmetric.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incidentmetric.FieldMetricType:
		m.ResetMetricType()
		return nil
	case incidentmetric.FieldMetricName:
		m.ResetMetricName()
		return nil
	case incidentmetric.FieldMetricValue:
		m.ResetMetricValue()
		return nil
	case incidentmetric.FieldUnit:
		m.ResetUnit()
		return nil
	case incidentmetric.FieldMeasuredAt:
		m.ResetMeasuredAt()
		return nil
	case incidentmetric.FieldTags:
		m.ResetTags()
		return nil
	case incidentmetric.FieldMetadata:
		m.ResetMetadata()
		return nil
	case incidentmetric.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentmetric.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incidentmetric.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown IncidentMetric field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentMetricMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.incident != nil {
		edges = append(edges, incidentmetric.EdgeIncident)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentMetricMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentmetric.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentMetricMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentMetricMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentMetricMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedincident {
		edges = append(edges, incidentmetric.EdgeIncident)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentMetricMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentmetric.EdgeIncident:
		return m.clearedincident
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentMetricMutation) ClearEdge(name string) error {
	switch name {
	case incidentmetric.EdgeIncident:
		m.ClearIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentMetric unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentMetricMutation) ResetEdge(name string) error {
	switch name {
	case incidentmetric.EdgeIncident:
		m.ResetIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentMetric edge %s", name)
}

// IncidentRuleMutation represents an operation that mutates the IncidentRule nodes in the graph.
type IncidentRuleMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	name                   *string
	description            *string
	rule_type              *string
	conditions             *map[string]interface{}
	actions                *[]map[string]interface{}
	appendactions          []map[string]interface{}
	priority               *string
	is_active              *bool
	execution_count        *int
	addexecution_count     *int
	last_executed_at       *time.Time
	metadata               *map[string]interface{}
	tenant_id              *int
	addtenant_id           *int
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	rule_executions        map[int]struct{}
	removedrule_executions map[int]struct{}
	clearedrule_executions bool
	done                   bool
	oldValue               func(context.Context) (*IncidentRule, error)
	predicates             []predicate.IncidentRule
}

var _ ent.Mutation = (*IncidentRuleMutation)(nil)

// incidentruleOption allows management of the mutation configuration using functional options.
type incidentruleOption func(*IncidentRuleMutation)

// newIncidentRuleMutation creates new mutation for the IncidentRule entity.
func newIncidentRuleMutation(c config, op Op, opts ...incidentruleOption) *IncidentRuleMutation {
	m := &IncidentRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentRuleID sets the ID field of the mutation.
func withIncidentRuleID(id int) incidentruleOption {
	return func(m *IncidentRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentRule
		)
		m.oldValue = func(ctx context.Context) (*IncidentRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentRule sets the old IncidentRule of the mutation.
func withIncidentRule(node *IncidentRule) incidentruleOption {
	return func(m *IncidentRuleMutation) {
		m.oldValue = func(context.Context) (*IncidentRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentRuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentRuleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *IncidentRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IncidentRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IncidentRule entity.
// If the IncidentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IncidentRuleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *IncidentRuleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentRuleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IncidentRule entity.
// If the IncidentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentRuleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incidentrule.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentRuleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incidentrule.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentRuleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incidentrule.FieldDescription)
}

// SetRuleType sets the "rule_type" field.
func (m *IncidentRuleMutation) SetRuleType(s string) {
	m.rule_type = &s
}

// RuleType returns the value of the "rule_type" field in the mutation.
func (m *IncidentRuleMutation) RuleType() (r string, exists bool) {
	v := m.rule_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleType returns the old "rule_type" field's value of the IncidentRule entity.
// If the IncidentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleMutation) OldRuleType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleType: %w", err)
	}
	return oldValue.RuleType, nil
}

// ResetRuleType resets all changes to the "rule_type" field.
func (m *IncidentRuleMutation) ResetRuleType() {
	m.rule_type = nil
}

// SetConditions sets the "conditions" field.
func (m *IncidentRuleMutation) SetConditions(value map[string]interface{}) {
	m.conditions = &value
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *IncidentRuleMutation) Conditions() (r map[string]interface{}, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the IncidentRule entity.
// If the IncidentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleMutation) OldConditions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// ClearConditions clears the value of the "conditions" field.
func (m *IncidentRuleMutation) ClearConditions() {
	m.conditions = nil
	m.clearedFields[incidentrule.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *IncidentRuleMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[incidentrule.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *IncidentRuleMutation) ResetConditions() {
	m.conditions = nil
	delete(m.clearedFields, incidentrule.FieldConditions)
}

// SetActions sets the "actions" field.
func (m *IncidentRuleMutation) SetActions(value []map[string]interface{}) {
	m.actions = &value
	m.appendactions = nil
}

// Actions returns the value of the "actions" field in the mutation.
func (m *IncidentRuleMutation) Actions() (r []map[string]interface{}, exists bool) {
	v := m.actions
	if v == nil {
		return
	}
	return *v, true
}

// OldActions returns the old "actions" field's value of the IncidentRule entity.
// If the IncidentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleMutation) OldActions(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActions: %w", err)
	}
	return oldValue.Actions, nil
}

// AppendActions adds value to the "actions" field.
func (m *IncidentRuleMutation) AppendActions(value []map[string]interface{}) {
	m.appendactions = append(m.appendactions, value...)
}

// AppendedActions returns the list of values that were appended to the "actions" field in this mutation.
func (m *IncidentRuleMutation) AppendedActions() ([]map[string]interface{}, bool) {
	if len(m.appendactions) == 0 {
		return nil, false
	}
	return m.appendactions, true
}

// ClearActions clears the value of the "actions" field.
func (m *IncidentRuleMutation) ClearActions() {
	m.actions = nil
	m.appendactions = nil
	m.clearedFields[incidentrule.FieldActions] = struct{}{}
}

// ActionsCleared returns if the "actions" field was cleared in this mutation.
func (m *IncidentRuleMutation) ActionsCleared() bool {
	_, ok := m.clearedFields[incidentrule.FieldActions]
	return ok
}

// ResetActions resets all changes to the "actions" field.
func (m *IncidentRuleMutation) ResetActions() {
	m.actions = nil
	m.appendactions = nil
	delete(m.clearedFields, incidentrule.FieldActions)
}

// SetPriority sets the "priority" field.
func (m *IncidentRuleMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *IncidentRuleMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the IncidentRule entity.
// If the IncidentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *IncidentRuleMutation) ResetPriority() {
	m.priority = nil
}

// SetIsActive sets the "is_active" field.
func (m *IncidentRuleMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *IncidentRuleMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the IncidentRule entity.
// If the IncidentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *IncidentRuleMutation) ResetIsActive() {
	m.is_active = nil
}

// SetExecutionCount sets the "execution_count" field.
func (m *IncidentRuleMutation) SetExecutionCount(i int) {
	m.execution_count = &i
	m.addexecution_count = nil
}

// ExecutionCount returns the value of the "execution_count" field in the mutation.
func (m *IncidentRuleMutation) ExecutionCount() (r int, exists bool) {
	v := m.execution_count
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionCount returns the old "execution_count" field's value of the IncidentRule entity.
// If the IncidentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleMutation) OldExecutionCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionCount: %w", err)
	}
	return oldValue.ExecutionCount, nil
}

// AddExecutionCount adds i to the "execution_count" field.
func (m *IncidentRuleMutation) AddExecutionCount(i int) {
	if m.addexecution_count != nil {
		*m.addexecution_count += i
	} else {
		m.addexecution_count = &i
	}
}

// AddedExecutionCount returns the value that was added to the "execution_count" field in this mutation.
func (m *IncidentRuleMutation) AddedExecutionCount() (r int, exists bool) {
	v := m.addexecution_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetExecutionCount resets all changes to the "execution_count" field.
func (m *IncidentRuleMutation) ResetExecutionCount() {
	m.execution_count = nil
	m.addexecution_count = nil
}

// SetLastExecutedAt sets the "last_executed_at" field.
func (m *IncidentRuleMutation) SetLastExecutedAt(t time.Time) {
	m.last_executed_at = &t
}

// LastExecutedAt returns the value of the "last_executed_at" field in the mutation.
func (m *IncidentRuleMutation) LastExecutedAt() (r time.Time, exists bool) {
	v := m.last_executed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastExecutedAt returns the old "last_executed_at" field's value of the IncidentRule entity.
// If the IncidentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleMutation) OldLastExecutedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastExecutedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastExecutedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastExecutedAt: %w", err)
	}
	return oldValue.LastExecutedAt, nil
}

// ClearLastExecutedAt clears the value of the "last_executed_at" field.
func (m *IncidentRuleMutation) ClearLastExecutedAt() {
	m.last_executed_at = nil
	m.clearedFields[incidentrule.FieldLastExecutedAt] = struct{}{}
}

// LastExecutedAtCleared returns if the "last_executed_at" field was cleared in this mutation.
func (m *IncidentRuleMutation) LastExecutedAtCleared() bool {
	_, ok := m.clearedFields[incidentrule.FieldLastExecutedAt]
	return ok
}

// ResetLastExecutedAt resets all changes to the "last_executed_at" field.
func (m *IncidentRuleMutation) ResetLastExecutedAt() {
	m.last_executed_at = nil
	delete(m.clearedFields, incidentrule.FieldLastExecutedAt)
}

// SetMetadata sets the "metadata" field.
func (m *IncidentRuleMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *IncidentRuleMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the IncidentRule entity.
// If the IncidentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *IncidentRuleMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[incidentrule.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *IncidentRuleMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[incidentrule.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *IncidentRuleMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, incidentrule.FieldMetadata)
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentRuleMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentRuleMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentRule entity.
// If the IncidentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *IncidentRuleMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *IncidentRuleMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentRuleMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentRule entity.
// If the IncidentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IncidentRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IncidentRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IncidentRule entity.
// If the IncidentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IncidentRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddRuleExecutionIDs adds the "rule_executions" edge to the IncidentRuleExecution entity by ids.
func (m *IncidentRuleMutation) AddRuleExecutionIDs(ids ...int) {
	if m.rule_executions == nil {
		m.rule_executions = make(map[int]struct{})
	}
	for i := range ids {
		m.rule_executions[ids[i]] = struct{}{}
	}
}

// ClearRuleExecutions clears the "rule_executions" edge to the IncidentRuleExecution entity.
func (m *IncidentRuleMutation) ClearRuleExecutions() {
	m.clearedrule_executions = true
}

// RuleExecutionsCleared reports if the "rule_executions" edge to the IncidentRuleExecution entity was cleared.
func (m *IncidentRuleMutation) RuleExecutionsCleared() bool {
	return m.clearedrule_executions
}

// RemoveRuleExecutionIDs removes the "rule_executions" edge to the IncidentRuleExecution entity by IDs.
func (m *IncidentRuleMutation) RemoveRuleExecutionIDs(ids ...int) {
	if m.removedrule_executions == nil {
		m.removedrule_executions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.rule_executions, ids[i])
		m.removedrule_executions[ids[i]] = struct{}{}
	}
}

// RemovedRuleExecutions returns the removed IDs of the "rule_executions" edge to the IncidentRuleExecution entity.
func (m *IncidentRuleMutation) RemovedRuleExecutionsIDs() (ids []int) {
	for id := range m.removedrule_executions {
		ids = append(ids, id)
	}
	return
}

// RuleExecutionsIDs returns the "rule_executions" edge IDs in the mutation.
func (m *IncidentRuleMutation) RuleExecutionsIDs() (ids []int) {
	for id := range m.rule_executions {
		ids = append(ids, id)
	}
	return
}

// ResetRuleExecutions resets all changes to the "rule_executions" edge.
func (m *IncidentRuleMutation) ResetRuleExecutions() {
	m.rule_executions = nil
	m.clearedrule_executions = false
	m.removedrule_executions = nil
}

// Where appends a list predicates to the IncidentRuleMutation builder.
func (m *IncidentRuleMutation) Where(ps ...predicate.IncidentRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentRule).
func (m *IncidentRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentRuleMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, incidentrule.FieldName)
	}
	if m.description != nil {
		fields = append(fields, incidentrule.FieldDescription)
	}
	if m.rule_type != nil {
		fields = append(fields, incidentrule.FieldRuleType)
	}
	if m.conditions != nil {
		fields = append(fields, incidentrule.FieldConditions)
	}
	if m.actions != nil {
		fields = append(fields, incidentrule.FieldActions)
	}
	if m.priority != nil {
		fields = append(fields, incidentrule.FieldPriority)
	}
	if m.is_active != nil {
		fields = append(fields, incidentrule.FieldIsActive)
	}
	if m.execution_count != nil {
		fields = append(fields, incidentrule.FieldExecutionCount)
	}
	if m.last_executed_at != nil {
		fields = append(fields, incidentrule.FieldLastExecutedAt)
	}
	if m.metadata != nil {
		fields = append(fields, incidentrule.FieldMetadata)
	}
	if m.tenant_id != nil {
		fields = append(fields, incidentrule.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, incidentrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, incidentrule.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentrule.FieldName:
		return m.Name()
	case incidentrule.FieldDescription:
		return m.Description()
	case incidentrule.FieldRuleType:
		return m.RuleType()
	case incidentrule.FieldConditions:
		return m.Conditions()
	case incidentrule.FieldActions:
		return m.Actions()
	case incidentrule.FieldPriority:
		return m.Priority()
	case incidentrule.FieldIsActive:
		return m.IsActive()
	case incidentrule.FieldExecutionCount:
		return m.ExecutionCount()
	case incidentrule.FieldLastExecutedAt:
		return m.LastExecutedAt()
	case incidentrule.FieldMetadata:
		return m.Metadata()
	case incidentrule.FieldTenantID:
		return m.TenantID()
	case incidentrule.FieldCreatedAt:
		return m.CreatedAt()
	case incidentrule.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentrule.FieldName:
		return m.OldName(ctx)
	case incidentrule.FieldDescription:
		return m.OldDescription(ctx)
	case incidentrule.FieldRuleType:
		return m.OldRuleType(ctx)
	case incidentrule.FieldConditions:
		return m.OldConditions(ctx)
	case incidentrule.FieldActions:
		return m.OldActions(ctx)
	case incidentrule.FieldPriority:
		return m.OldPriority(ctx)
	case incidentrule.FieldIsActive:
		return m.OldIsActive(ctx)
	case incidentrule.FieldExecutionCount:
		return m.OldExecutionCount(ctx)
	case incidentrule.FieldLastExecutedAt:
		return m.OldLastExecutedAt(ctx)
	case incidentrule.FieldMetadata:
		return m.OldMetadata(ctx)
	case incidentrule.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incidentrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case incidentrule.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incidentrule.FieldRuleType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleType(v)
		return nil
	case incidentrule.FieldConditions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case incidentrule.FieldActions:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActions(v)
		return nil
	case incidentrule.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case incidentrule.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case incidentrule.FieldExecutionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionCount(v)
		return nil
	case incidentrule.FieldLastExecutedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastExecutedAt(v)
		return nil
	case incidentrule.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case incidentrule.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incidentrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentRuleMutation) AddedFields() []string {
	var fields []string
	if m.addexecution_count != nil {
		fields = append(fields, incidentrule.FieldExecutionCount)
	}
	if m.addtenant_id != nil {
		fields = append(fields, incidentrule.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case incidentrule.FieldExecutionCount:
		return m.AddedExecutionCount()
	case incidentrule.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case incidentrule.FieldExecutionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutionCount(v)
		return nil
	case incidentrule.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentrule.FieldDescription) {
		fields = append(fields, incidentrule.FieldDescription)
	}
	if m.FieldCleared(incidentrule.FieldConditions) {
		fields = append(fields, incidentrule.FieldConditions)
	}
	if m.FieldCleared(incidentrule.FieldActions) {
		fields = append(fields, incidentrule.FieldActions)
	}
	if m.FieldCleared(incidentrule.FieldLastExecutedAt) {
		fields = append(fields, incidentrule.FieldLastExecutedAt)
	}
	if m.FieldCleared(incidentrule.FieldMetadata) {
		fields = append(fields, incidentrule.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentRuleMutation) ClearField(name string) error {
	switch name {
	case incidentrule.FieldDescription:
		m.ClearDescription()
		return nil
	case incidentrule.FieldConditions:
		m.ClearConditions()
		return nil
	case incidentrule.FieldActions:
		m.ClearActions()
		return nil
	case incidentrule.FieldLastExecutedAt:
		m.ClearLastExecutedAt()
		return nil
	case incidentrule.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown IncidentRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentRuleMutation) ResetField(name string) error {
	switch name {
	case incidentrule.FieldName:
		m.ResetName()
		return nil
	case incidentrule.FieldDescription:
		m.ResetDescription()
		return nil
	case incidentrule.FieldRuleType:
		m.ResetRuleType()
		return nil
	case incidentrule.FieldConditions:
		m.ResetConditions()
		return nil
	case incidentrule.FieldActions:
		m.ResetActions()
		return nil
	case incidentrule.FieldPriority:
		m.ResetPriority()
		return nil
	case incidentrule.FieldIsActive:
		m.ResetIsActive()
		return nil
	case incidentrule.FieldExecutionCount:
		m.ResetExecutionCount()
		return nil
	case incidentrule.FieldLastExecutedAt:
		m.ResetLastExecutedAt()
		return nil
	case incidentrule.FieldMetadata:
		m.ResetMetadata()
		return nil
	case incidentrule.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incidentrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown IncidentRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rule_executions != nil {
		edges = append(edges, incidentrule.EdgeRuleExecutions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentRuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentrule.EdgeRuleExecutions:
		ids := make([]ent.Value, 0, len(m.rule_executions))
		for id := range m.rule_executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrule_executions != nil {
		edges = append(edges, incidentrule.EdgeRuleExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentRuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidentrule.EdgeRuleExecutions:
		ids := make([]ent.Value, 0, len(m.removedrule_executions))
		for id := range m.removedrule_executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrule_executions {
		edges = append(edges, incidentrule.EdgeRuleExecutions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentRuleMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentrule.EdgeRuleExecutions:
		return m.clearedrule_executions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentRuleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentRuleMutation) ResetEdge(name string) error {
	switch name {
	case incidentrule.EdgeRuleExecutions:
		m.ResetRuleExecutions()
		return nil
	}
	return fmt.Errorf("unknown IncidentRule edge %s", name)
}

// IncidentRuleExecutionMutation represents an operation that mutates the IncidentRuleExecution nodes in the graph.
type IncidentRuleExecutionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	incident_id          *int
	addincident_id       *int
	status               *string
	result               *string
	error_message        *string
	started_at           *time.Time
	completed_at         *time.Time
	execution_time_ms    *int
	addexecution_time_ms *int
	input_data           *map[string]interface{}
	output_data          *map[string]interface{}
	tenant_id            *int
	addtenant_id         *int
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	rule                 *int
	clearedrule          bool
	done                 bool
	oldValue             func(context.Context) (*IncidentRuleExecution, error)
	predicates           []predicate.IncidentRuleExecution
}

var _ ent.Mutation = (*IncidentRuleExecutionMutation)(nil)

// incidentruleexecutionOption allows management of the mutation configuration using functional options.
type incidentruleexecutionOption func(*IncidentRuleExecutionMutation)

// newIncidentRuleExecutionMutation creates new mutation for the IncidentRuleExecution entity.
func newIncidentRuleExecutionMutation(c config, op Op, opts ...incidentruleexecutionOption) *IncidentRuleExecutionMutation {
	m := &IncidentRuleExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentRuleExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentRuleExecutionID sets the ID field of the mutation.
func withIncidentRuleExecutionID(id int) incidentruleexecutionOption {
	return func(m *IncidentRuleExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentRuleExecution
		)
		m.oldValue = func(ctx context.Context) (*IncidentRuleExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentRuleExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentRuleExecution sets the old IncidentRuleExecution of the mutation.
func withIncidentRuleExecution(node *IncidentRuleExecution) incidentruleexecutionOption {
	return func(m *IncidentRuleExecutionMutation) {
		m.oldValue = func(context.Context) (*IncidentRuleExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentRuleExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentRuleExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentRuleExecutionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentRuleExecutionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentRuleExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRuleID sets the "rule_id" field.
func (m *IncidentRuleExecutionMutation) SetRuleID(i int) {
	m.rule = &i
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *IncidentRuleExecutionMutation) RuleID() (r int, exists bool) {
	v := m.rule
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the IncidentRuleExecution entity.
// If the IncidentRuleExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleExecutionMutation) OldRuleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *IncidentRuleExecutionMutation) ResetRuleID() {
	m.rule = nil
}

// SetIncidentID sets the "incident_id" field.
func (m *IncidentRuleExecutionMutation) SetIncidentID(i int) {
	m.incident_id = &i
	m.addincident_id = nil
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *IncidentRuleExecutionMutation) IncidentID() (r int, exists bool) {
	v := m.incident_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the IncidentRuleExecution entity.
// If the IncidentRuleExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleExecutionMutation) OldIncidentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// AddIncidentID adds i to the "incident_id" field.
func (m *IncidentRuleExecutionMutation) AddIncidentID(i int) {
	if m.addincident_id != nil {
		*m.addincident_id += i
	} else {
		m.addincident_id = &i
	}
}

// AddedIncidentID returns the value that was added to the "incident_id" field in this mutation.
func (m *IncidentRuleExecutionMutation) AddedIncidentID() (r int, exists bool) {
	v := m.addincident_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearIncidentID clears the value of the "incident_id" field.
func (m *IncidentRuleExecutionMutation) ClearIncidentID() {
	m.incident_id = nil
	m.addincident_id = nil
	m.clearedFields[incidentruleexecution.FieldIncidentID] = struct{}{}
}

// IncidentIDCleared returns if the "incident_id" field was cleared in this mutation.
func (m *IncidentRuleExecutionMutation) IncidentIDCleared() bool {
	_, ok := m.clearedFields[incidentruleexecution.FieldIncidentID]
	return ok
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *IncidentRuleExecutionMutation) ResetIncidentID() {
	m.incident_id = nil
	m.addincident_id = nil
	delete(m.clearedFields, incidentruleexecution.FieldIncidentID)
}

// SetStatus sets the "status" field.
func (m *IncidentRuleExecutionMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *IncidentRuleExecutionMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the IncidentRuleExecution entity.
// If the IncidentRuleExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleExecutionMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *IncidentRuleExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetResult sets the "result" field.
func (m *IncidentRuleExecutionMutation) SetResult(s string) {
	m.result = &s
}

// Result returns the value of the "result" field in the mutation.
func (m *IncidentRuleExecutionMutation) Result() (r string, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the IncidentRuleExecution entity.
// If the IncidentRuleExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleExecutionMutation) OldResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ClearResult clears the value of the "result" field.
func (m *IncidentRuleExecutionMutation) ClearResult() {
	m.result = nil
	m.clearedFields[incidentruleexecution.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *IncidentRuleExecutionMutation) ResultCleared() bool {
	_, ok := m.clearedFields[incidentruleexecution.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *IncidentRuleExecutionMutation) ResetResult() {
	m.result = nil
	delete(m.clearedFields, incidentruleexecution.FieldResult)
}

// SetErrorMessage sets the "error_message" field.
func (m *IncidentRuleExecutionMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *IncidentRuleExecutionMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the IncidentRuleExecution entity.
// If the IncidentRuleExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleExecutionMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *IncidentRuleExecutionMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[incidentruleexecution.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *IncidentRuleExecutionMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[incidentruleexecution.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *IncidentRuleExecutionMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, incidentruleexecution.FieldErrorMessage)
}

// SetStartedAt sets the "started_at" field.
func (m *IncidentRuleExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *IncidentRuleExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the IncidentRuleExecution entity.
// If the IncidentRuleExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *IncidentRuleExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *IncidentRuleExecutionMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *IncidentRuleExecutionMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the IncidentRuleExecution entity.
// If the IncidentRuleExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleExecutionMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *IncidentRuleExecutionMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[incidentruleexecution.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *IncidentRuleExecutionMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[incidentruleexecution.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *IncidentRuleExecutionMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, incidentruleexecution.FieldCompletedAt)
}

// SetExecutionTimeMs sets the "execution_time_ms" field.
func (m *IncidentRuleExecutionMutation) SetExecutionTimeMs(i int) {
	m.execution_time_ms = &i
	m.addexecution_time_ms = nil
}

// ExecutionTimeMs returns the value of the "execution_time_ms" field in the mutation.
func (m *IncidentRuleExecutionMutation) ExecutionTimeMs() (r int, exists bool) {
	v := m.execution_time_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionTimeMs returns the old "execution_time_ms" field's value of the IncidentRuleExecution entity.
// If the IncidentRuleExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleExecutionMutation) OldExecutionTimeMs(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionTimeMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionTimeMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionTimeMs: %w", err)
	}
	return oldValue.ExecutionTimeMs, nil
}

// AddExecutionTimeMs adds i to the "execution_time_ms" field.
func (m *IncidentRuleExecutionMutation) AddExecutionTimeMs(i int) {
	if m.addexecution_time_ms != nil {
		*m.addexecution_time_ms += i
	} else {
		m.addexecution_time_ms = &i
	}
}

// AddedExecutionTimeMs returns the value that was added to the "execution_time_ms" field in this mutation.
func (m *IncidentRuleExecutionMutation) AddedExecutionTimeMs() (r int, exists bool) {
	v := m.addexecution_time_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearExecutionTimeMs clears the value of the "execution_time_ms" field.
func (m *IncidentRuleExecutionMutation) ClearExecutionTimeMs() {
	m.execution_time_ms = nil
	m.addexecution_time_ms = nil
	m.clearedFields[incidentruleexecution.FieldExecutionTimeMs] = struct{}{}
}

// ExecutionTimeMsCleared returns if the "execution_time_ms" field was cleared in this mutation.
func (m *IncidentRuleExecutionMutation) ExecutionTimeMsCleared() bool {
	_, ok := m.clearedFields[incidentruleexecution.FieldExecutionTimeMs]
	return ok
}

// ResetExecutionTimeMs resets all changes to the "execution_time_ms" field.
func (m *IncidentRuleExecutionMutation) ResetExecutionTimeMs() {
	m.execution_time_ms = nil
	m.addexecution_time_ms = nil
	delete(m.clearedFields, incidentruleexecution.FieldExecutionTimeMs)
}

// SetInputData sets the "input_data" field.
func (m *IncidentRuleExecutionMutation) SetInputData(value map[string]interface{}) {
	m.input_data = &value
}

// InputData returns the value of the "input_data" field in the mutation.
func (m *IncidentRuleExecutionMutation) InputData() (r map[string]interface{}, exists bool) {
	v := m.input_data
	if v == nil {
		return
	}
	return *v, true
}

// OldInputData returns the old "input_data" field's value of the IncidentRuleExecution entity.
// If the IncidentRuleExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleExecutionMutation) OldInputData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputData: %w", err)
	}
	return oldValue.InputData, nil
}

// ClearInputData clears the value of the "input_data" field.
func (m *IncidentRuleExecutionMutation) ClearInputData() {
	m.input_data = nil
	m.clearedFields[incidentruleexecution.FieldInputData] = struct{}{}
}

// InputDataCleared returns if the "input_data" field was cleared in this mutation.
func (m *IncidentRuleExecutionMutation) InputDataCleared() bool {
	_, ok := m.clearedFields[incidentruleexecution.FieldInputData]
	return ok
}

// ResetInputData resets all changes to the "input_data" field.
func (m *IncidentRuleExecutionMutation) ResetInputData() {
	m.input_data = nil
	delete(m.clearedFields, incidentruleexecution.FieldInputData)
}

// SetOutputData sets the "output_data" field.
func (m *IncidentRuleExecutionMutation) SetOutputData(value map[string]interface{}) {
	m.output_data = &value
}

// OutputData returns the value of the "output_data" field in the mutation.
func (m *IncidentRuleExecutionMutation) OutputData() (r map[string]interface{}, exists bool) {
	v := m.output_data
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputData returns the old "output_data" field's value of the IncidentRuleExecution entity.
// If the IncidentRuleExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleExecutionMutation) OldOutputData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputData: %w", err)
	}
	return oldValue.OutputData, nil
}

// ClearOutputData clears the value of the "output_data" field.
func (m *IncidentRuleExecutionMutation) ClearOutputData() {
	m.output_data = nil
	m.clearedFields[incidentruleexecution.FieldOutputData] = struct{}{}
}

// OutputDataCleared returns if the "output_data" field was cleared in this mutation.
func (m *IncidentRuleExecutionMutation) OutputDataCleared() bool {
	_, ok := m.clearedFields[incidentruleexecution.FieldOutputData]
	return ok
}

// ResetOutputData resets all changes to the "output_data" field.
func (m *IncidentRuleExecutionMutation) ResetOutputData() {
	m.output_data = nil
	delete(m.clearedFields, incidentruleexecution.FieldOutputData)
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentRuleExecutionMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentRuleExecutionMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentRuleExecution entity.
// If the IncidentRuleExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleExecutionMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *IncidentRuleExecutionMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *IncidentRuleExecutionMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentRuleExecutionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentRuleExecutionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentRuleExecutionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentRuleExecution entity.
// If the IncidentRuleExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleExecutionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentRuleExecutionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IncidentRuleExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IncidentRuleExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IncidentRuleExecution entity.
// If the IncidentRuleExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRuleExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IncidentRuleExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRule clears the "rule" edge to the IncidentRule entity.
func (m *IncidentRuleExecutionMutation) ClearRule() {
	m.clearedrule = true
	m.clearedFields[incidentruleexecution.FieldRuleID] = struct{}{}
}

// RuleCleared reports if the "rule" edge to the IncidentRule entity was cleared.
func (m *IncidentRuleExecutionMutation) RuleCleared() bool {
	return m.clearedrule
}

// RuleIDs returns the "rule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RuleID instead. It exists only for internal usage by the builders.
func (m *IncidentRuleExecutionMutation) RuleIDs() (ids []int) {
	if id := m.rule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRule resets all changes to the "rule" edge.
func (m *IncidentRuleExecutionMutation) ResetRule() {
	m.rule = nil
	m.clearedrule = false
}

// Where appends a list predicates to the IncidentRuleExecutionMutation builder.
func (m *IncidentRuleExecutionMutation) Where(ps ...predicate.IncidentRuleExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentRuleExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentRuleExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentRuleExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentRuleExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentRuleExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentRuleExecution).
func (m *IncidentRuleExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentRuleExecutionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.rule != nil {
		fields = append(fields, incidentruleexecution.FieldRuleID)
	}
	if m.incident_id != nil {
		fields = append(fields, incidentruleexecution.FieldIncidentID)
	}
	if m.status != nil {
		fields = append(fields, incidentruleexecution.FieldStatus)
	}
	if m.result != nil {
		fields = append(fields, incidentruleexecution.FieldResult)
	}
	if m.error_message != nil {
		fields = append(fields, incidentruleexecution.FieldErrorMessage)
	}
	if m.started_at != nil {
		fields = append(fields, incidentruleexecution.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, incidentruleexecution.FieldCompletedAt)
	}
	if m.execution_time_ms != nil {
		fields = append(fields, incidentruleexecution.FieldExecutionTimeMs)
	}
	if m.input_data != nil {
		fields = append(fields, incidentruleexecution.FieldInputData)
	}
	if m.output_data != nil {
		fields = append(fields, incidentruleexecution.FieldOutputData)
	}
	if m.tenant_id != nil {
		fields = append(fields, incidentruleexecution.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, incidentruleexecution.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, incidentruleexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentRuleExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentruleexecution.FieldRuleID:
		return m.RuleID()
	case incidentruleexecution.FieldIncidentID:
		return m.IncidentID()
	case incidentruleexecution.FieldStatus:
		return m.Status()
	case incidentruleexecution.FieldResult:
		return m.Result()
	case incidentruleexecution.FieldErrorMessage:
		return m.ErrorMessage()
	case incidentruleexecution.FieldStartedAt:
		return m.StartedAt()
	case incidentruleexecution.FieldCompletedAt:
		return m.CompletedAt()
	case incidentruleexecution.FieldExecutionTimeMs:
		return m.ExecutionTimeMs()
	case incidentruleexecution.FieldInputData:
		return m.InputData()
	case incidentruleexecution.FieldOutputData:
		return m.OutputData()
	case incidentruleexecution.FieldTenantID:
		return m.TenantID()
	case incidentruleexecution.FieldCreatedAt:
		return m.CreatedAt()
	case incidentruleexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentRuleExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentruleexecution.FieldRuleID:
		return m.OldRuleID(ctx)
	case incidentruleexecution.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incidentruleexecution.FieldStatus:
		return m.OldStatus(ctx)
	case incidentruleexecution.FieldResult:
		return m.OldResult(ctx)
	case incidentruleexecution.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case incidentruleexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case incidentruleexecution.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case incidentruleexecution.FieldExecutionTimeMs:
		return m.OldExecutionTimeMs(ctx)
	case incidentruleexecution.FieldInputData:
		return m.OldInputData(ctx)
	case incidentruleexecution.FieldOutputData:
		return m.OldOutputData(ctx)
	case incidentruleexecution.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentruleexecution.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incidentruleexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentRuleExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentRuleExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentruleexecution.FieldRuleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case incidentruleexecution.FieldIncidentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incidentruleexecution.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case incidentruleexecution.FieldResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case incidentruleexecution.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case incidentruleexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case incidentruleexecution.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case incidentruleexecution.FieldExecutionTimeMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionTimeMs(v)
		return nil
	case incidentruleexecution.FieldInputData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputData(v)
		return nil
	case incidentruleexecution.FieldOutputData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputData(v)
		return nil
	case incidentruleexecution.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentruleexecution.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incidentruleexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentRuleExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentRuleExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addincident_id != nil {
		fields = append(fields, incidentruleexecution.FieldIncidentID)
	}
	if m.addexecution_time_ms != nil {
		fields = append(fields, incidentruleexecution.FieldExecutionTimeMs)
	}
	if m.addtenant_id != nil {
		fields = append(fields, incidentruleexecution.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentRuleExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case incidentruleexecution.FieldIncidentID:
		return m.AddedIncidentID()
	case incidentruleexecution.FieldExecutionTimeMs:
		return m.AddedExecutionTimeMs()
	case incidentruleexecution.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentRuleExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case incidentruleexecution.FieldIncidentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIncidentID(v)
		return nil
	case incidentruleexecution.FieldExecutionTimeMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutionTimeMs(v)
		return nil
	case incidentruleexecution.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentRuleExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentRuleExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentruleexecution.FieldIncidentID) {
		fields = append(fields, incidentruleexecution.FieldIncidentID)
	}
	if m.FieldCleared(incidentruleexecution.FieldResult) {
		fields = append(fields, incidentruleexecution.FieldResult)
	}
	if m.FieldCleared(incidentruleexecution.FieldErrorMessage) {
		fields = append(fields, incidentruleexecution.FieldErrorMessage)
	}
	if m.FieldCleared(incidentruleexecution.FieldCompletedAt) {
		fields = append(fields, incidentruleexecution.FieldCompletedAt)
	}
	if m.FieldCleared(incidentruleexecution.FieldExecutionTimeMs) {
		fields = append(fields, incidentruleexecution.FieldExecutionTimeMs)
	}
	if m.FieldCleared(incidentruleexecution.FieldInputData) {
		fields = append(fields, incidentruleexecution.FieldInputData)
	}
	if m.FieldCleared(incidentruleexecution.FieldOutputData) {
		fields = append(fields, incidentruleexecution.FieldOutputData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentRuleExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentRuleExecutionMutation) ClearField(name string) error {
	switch name {
	case incidentruleexecution.FieldIncidentID:
		m.ClearIncidentID()
		return nil
	case incidentruleexecution.FieldResult:
		m.ClearResult()
		return nil
	case incidentruleexecution.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case incidentruleexecution.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case incidentruleexecution.FieldExecutionTimeMs:
		m.ClearExecutionTimeMs()
		return nil
	case incidentruleexecution.FieldInputData:
		m.ClearInputData()
		return nil
	case incidentruleexecution.FieldOutputData:
		m.ClearOutputData()
		return nil
	}
	return fmt.Errorf("unknown IncidentRuleExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentRuleExecutionMutation) ResetField(name string) error {
	switch name {
	case incidentruleexecution.FieldRuleID:
		m.ResetRuleID()
		return nil
	case incidentruleexecution.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incidentruleexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case incidentruleexecution.FieldResult:
		m.ResetResult()
		return nil
	case incidentruleexecution.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case incidentruleexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case incidentruleexecution.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case incidentruleexecution.FieldExecutionTimeMs:
		m.ResetExecutionTimeMs()
		return nil
	case incidentruleexecution.FieldInputData:
		m.ResetInputData()
		return nil
	case incidentruleexecution.FieldOutputData:
		m.ResetOutputData()
		return nil
	case incidentruleexecution.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentruleexecution.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incidentruleexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown IncidentRuleExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentRuleExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rule != nil {
		edges = append(edges, incidentruleexecution.EdgeRule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentRuleExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentruleexecution.EdgeRule:
		if id := m.rule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentRuleExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentRuleExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentRuleExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrule {
		edges = append(edges, incidentruleexecution.EdgeRule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentRuleExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentruleexecution.EdgeRule:
		return m.clearedrule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentRuleExecutionMutation) ClearEdge(name string) error {
	switch name {
	case incidentruleexecution.EdgeRule:
		m.ClearRule()
		return nil
	}
	return fmt.Errorf("unknown IncidentRuleExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentRuleExecutionMutation) ResetEdge(name string) error {
	switch name {
	case incidentruleexecution.EdgeRule:
		m.ResetRule()
		return nil
	}
	return fmt.Errorf("unknown IncidentRuleExecution edge %s", name)
}

// KnowledgeArticleMutation represents an operation that mutates the KnowledgeArticle nodes in the graph.
type KnowledgeArticleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	content       *string
	category      *string
	tags          *string
	author_id     *int
	addauthor_id  *int
	tenant_id     *int
	addtenant_id  *int
	is_published  *bool
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*KnowledgeArticle, error)
	predicates    []predicate.KnowledgeArticle
}

var _ ent.Mutation = (*KnowledgeArticleMutation)(nil)

// knowledgearticleOption allows management of the mutation configuration using functional options.
type knowledgearticleOption func(*KnowledgeArticleMutation)

// newKnowledgeArticleMutation creates new mutation for the KnowledgeArticle entity.
func newKnowledgeArticleMutation(c config, op Op, opts ...knowledgearticleOption) *KnowledgeArticleMutation {
	m := &KnowledgeArticleMutation{
		config:        c,
		op:            op,
		typ:           TypeKnowledgeArticle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKnowledgeArticleID sets the ID field of the mutation.
func withKnowledgeArticleID(id int) knowledgearticleOption {
	return func(m *KnowledgeArticleMutation) {
		var (
			err   error
			once  sync.Once
			value *KnowledgeArticle
		)
		m.oldValue = func(ctx context.Context) (*KnowledgeArticle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KnowledgeArticle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKnowledgeArticle sets the old KnowledgeArticle of the mutation.
func withKnowledgeArticle(node *KnowledgeArticle) knowledgearticleOption {
	return func(m *KnowledgeArticleMutation) {
		m.oldValue = func(context.Context) (*KnowledgeArticle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KnowledgeArticleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KnowledgeArticleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KnowledgeArticleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KnowledgeArticleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KnowledgeArticle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *KnowledgeArticleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *KnowledgeArticleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *KnowledgeArticleMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *KnowledgeArticleMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *KnowledgeArticleMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *KnowledgeArticleMutation) ClearContent() {
	m.content = nil
	m.clearedFields[knowledgearticle.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *KnowledgeArticleMutation) ContentCleared() bool {
	_, ok := m.clearedFields[knowledgearticle.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *KnowledgeArticleMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, knowledgearticle.FieldContent)
}

// SetCategory sets the "category" field.
func (m *KnowledgeArticleMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *KnowledgeArticleMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *KnowledgeArticleMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[knowledgearticle.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *KnowledgeArticleMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[knowledgearticle.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *KnowledgeArticleMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, knowledgearticle.FieldCategory)
}

// SetTags sets the "tags" field.
func (m *KnowledgeArticleMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *KnowledgeArticleMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *KnowledgeArticleMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[knowledgearticle.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *KnowledgeArticleMutation) TagsCleared() bool {
	_, ok := m.clearedFields[knowledgearticle.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *KnowledgeArticleMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, knowledgearticle.FieldTags)
}

// SetAuthorID sets the "author_id" field.
func (m *KnowledgeArticleMutation) SetAuthorID(i int) {
	m.author_id = &i
	m.addauthor_id = nil
}

// AuthorID returns the value of the "author_id" field in the mutation.
func (m *KnowledgeArticleMutation) AuthorID() (r int, exists bool) {
	v := m.author_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorID returns the old "author_id" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldAuthorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorID: %w", err)
	}
	return oldValue.AuthorID, nil
}

// AddAuthorID adds i to the "author_id" field.
func (m *KnowledgeArticleMutation) AddAuthorID(i int) {
	if m.addauthor_id != nil {
		*m.addauthor_id += i
	} else {
		m.addauthor_id = &i
	}
}

// AddedAuthorID returns the value that was added to the "author_id" field in this mutation.
func (m *KnowledgeArticleMutation) AddedAuthorID() (r int, exists bool) {
	v := m.addauthor_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthorID resets all changes to the "author_id" field.
func (m *KnowledgeArticleMutation) ResetAuthorID() {
	m.author_id = nil
	m.addauthor_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *KnowledgeArticleMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *KnowledgeArticleMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *KnowledgeArticleMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *KnowledgeArticleMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *KnowledgeArticleMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetIsPublished sets the "is_published" field.
func (m *KnowledgeArticleMutation) SetIsPublished(b bool) {
	m.is_published = &b
}

// IsPublished returns the value of the "is_published" field in the mutation.
func (m *KnowledgeArticleMutation) IsPublished() (r bool, exists bool) {
	v := m.is_published
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublished returns the old "is_published" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldIsPublished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublished: %w", err)
	}
	return oldValue.IsPublished, nil
}

// ResetIsPublished resets all changes to the "is_published" field.
func (m *KnowledgeArticleMutation) ResetIsPublished() {
	m.is_published = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *KnowledgeArticleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KnowledgeArticleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KnowledgeArticleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KnowledgeArticleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KnowledgeArticleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KnowledgeArticleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the KnowledgeArticleMutation builder.
func (m *KnowledgeArticleMutation) Where(ps ...predicate.KnowledgeArticle) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KnowledgeArticleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KnowledgeArticleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.KnowledgeArticle, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KnowledgeArticleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KnowledgeArticleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (KnowledgeArticle).
func (m *KnowledgeArticleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KnowledgeArticleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.title != nil {
		fields = append(fields, knowledgearticle.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, knowledgearticle.FieldContent)
	}
	if m.category != nil {
		fields = append(fields, knowledgearticle.FieldCategory)
	}
	if m.tags != nil {
		fields = append(fields, knowledgearticle.FieldTags)
	}
	if m.author_id != nil {
		fields = append(fields, knowledgearticle.FieldAuthorID)
	}
	if m.tenant_id != nil {
		fields = append(fields, knowledgearticle.FieldTenantID)
	}
	if m.is_published != nil {
		fields = append(fields, knowledgearticle.FieldIsPublished)
	}
	if m.created_at != nil {
		fields = append(fields, knowledgearticle.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, knowledgearticle.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KnowledgeArticleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case knowledgearticle.FieldTitle:
		return m.Title()
	case knowledgearticle.FieldContent:
		return m.Content()
	case knowledgearticle.FieldCategory:
		return m.Category()
	case knowledgearticle.FieldTags:
		return m.Tags()
	case knowledgearticle.FieldAuthorID:
		return m.AuthorID()
	case knowledgearticle.FieldTenantID:
		return m.TenantID()
	case knowledgearticle.FieldIsPublished:
		return m.IsPublished()
	case knowledgearticle.FieldCreatedAt:
		return m.CreatedAt()
	case knowledgearticle.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KnowledgeArticleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case knowledgearticle.FieldTitle:
		return m.OldTitle(ctx)
	case knowledgearticle.FieldContent:
		return m.OldContent(ctx)
	case knowledgearticle.FieldCategory:
		return m.OldCategory(ctx)
	case knowledgearticle.FieldTags:
		return m.OldTags(ctx)
	case knowledgearticle.FieldAuthorID:
		return m.OldAuthorID(ctx)
	case knowledgearticle.FieldTenantID:
		return m.OldTenantID(ctx)
	case knowledgearticle.FieldIsPublished:
		return m.OldIsPublished(ctx)
	case knowledgearticle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case knowledgearticle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown KnowledgeArticle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KnowledgeArticleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case knowledgearticle.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case knowledgearticle.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case knowledgearticle.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case knowledgearticle.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case knowledgearticle.FieldAuthorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorID(v)
		return nil
	case knowledgearticle.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case knowledgearticle.FieldIsPublished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublished(v)
		return nil
	case knowledgearticle.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case knowledgearticle.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown KnowledgeArticle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KnowledgeArticleMutation) AddedFields() []string {
	var fields []string
	if m.addauthor_id != nil {
		fields = append(fields, knowledgearticle.FieldAuthorID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, knowledgearticle.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KnowledgeArticleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case knowledgearticle.FieldAuthorID:
		return m.AddedAuthorID()
	case knowledgearticle.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KnowledgeArticleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case knowledgearticle.FieldAuthorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthorID(v)
		return nil
	case knowledgearticle.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown KnowledgeArticle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KnowledgeArticleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(knowledgearticle.FieldContent) {
		fields = append(fields, knowledgearticle.FieldContent)
	}
	if m.FieldCleared(knowledgearticle.FieldCategory) {
		fields = append(fields, knowledgearticle.FieldCategory)
	}
	if m.FieldCleared(knowledgearticle.FieldTags) {
		fields = append(fields, knowledgearticle.FieldTags)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KnowledgeArticleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KnowledgeArticleMutation) ClearField(name string) error {
	switch name {
	case knowledgearticle.FieldContent:
		m.ClearContent()
		return nil
	case knowledgearticle.FieldCategory:
		m.ClearCategory()
		return nil
	case knowledgearticle.FieldTags:
		m.ClearTags()
		return nil
	}
	return fmt.Errorf("unknown KnowledgeArticle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KnowledgeArticleMutation) ResetField(name string) error {
	switch name {
	case knowledgearticle.FieldTitle:
		m.ResetTitle()
		return nil
	case knowledgearticle.FieldContent:
		m.ResetContent()
		return nil
	case knowledgearticle.FieldCategory:
		m.ResetCategory()
		return nil
	case knowledgearticle.FieldTags:
		m.ResetTags()
		return nil
	case knowledgearticle.FieldAuthorID:
		m.ResetAuthorID()
		return nil
	case knowledgearticle.FieldTenantID:
		m.ResetTenantID()
		return nil
	case knowledgearticle.FieldIsPublished:
		m.ResetIsPublished()
		return nil
	case knowledgearticle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case knowledgearticle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown KnowledgeArticle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KnowledgeArticleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KnowledgeArticleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KnowledgeArticleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KnowledgeArticleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KnowledgeArticleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KnowledgeArticleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KnowledgeArticleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown KnowledgeArticle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KnowledgeArticleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown KnowledgeArticle edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	role                *string
	content             *string
	request_id          *string
	clearedFields       map[string]struct{}
	conversation        *int
	clearedconversation bool
	done                bool
	oldValue            func(context.Context) (*Message, error)
	predicates          []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id int) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetConversationID sets the "conversation_id" field.
func (m *MessageMutation) SetConversationID(i int) {
	m.conversation = &i
}

// ConversationID returns the value of the "conversation_id" field in the mutation.
func (m *MessageMutation) ConversationID() (r int, exists bool) {
	v := m.conversation
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationID returns the old "conversation_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldConversationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationID: %w", err)
	}
	return oldValue.ConversationID, nil
}

// ResetConversationID resets all changes to the "conversation_id" field.
func (m *MessageMutation) ResetConversationID() {
	m.conversation = nil
}

// SetRole sets the "role" field.
func (m *MessageMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *MessageMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *MessageMutation) ResetRole() {
	m.role = nil
}

// SetContent sets the "content" field.
func (m *MessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MessageMutation) ResetContent() {
	m.content = nil
}

// SetRequestID sets the "request_id" field.
func (m *MessageMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *MessageMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *MessageMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[message.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *MessageMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[message.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *MessageMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, message.FieldRequestID)
}

// ClearConversation clears the "conversation" edge to the Conversation entity.
func (m *MessageMutation) ClearConversation() {
	m.clearedconversation = true
	m.clearedFields[message.FieldConversationID] = struct{}{}
}

// ConversationCleared reports if the "conversation" edge to the Conversation entity was cleared.
func (m *MessageMutation) ConversationCleared() bool {
	return m.clearedconversation
}

// ConversationIDs returns the "conversation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConversationID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) ConversationIDs() (ids []int) {
	if id := m.conversation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConversation resets all changes to the "conversation" edge.
func (m *MessageMutation) ResetConversation() {
	m.conversation = nil
	m.clearedconversation = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.conversation != nil {
		fields = append(fields, message.FieldConversationID)
	}
	if m.role != nil {
		fields = append(fields, message.FieldRole)
	}
	if m.content != nil {
		fields = append(fields, message.FieldContent)
	}
	if m.request_id != nil {
		fields = append(fields, message.FieldRequestID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldCreatedAt:
		return m.CreatedAt()
	case message.FieldConversationID:
		return m.ConversationID()
	case message.FieldRole:
		return m.Role()
	case message.FieldContent:
		return m.Content()
	case message.FieldRequestID:
		return m.RequestID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case message.FieldConversationID:
		return m.OldConversationID(ctx)
	case message.FieldRole:
		return m.OldRole(ctx)
	case message.FieldContent:
		return m.OldContent(ctx)
	case message.FieldRequestID:
		return m.OldRequestID(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case message.FieldConversationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationID(v)
		return nil
	case message.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case message.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case message.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldRequestID) {
		fields = append(fields, message.FieldRequestID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldRequestID:
		m.ClearRequestID()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case message.FieldConversationID:
		m.ResetConversationID()
		return nil
	case message.FieldRole:
		m.ResetRole()
		return nil
	case message.FieldContent:
		m.ResetContent()
		return nil
	case message.FieldRequestID:
		m.ResetRequestID()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.conversation != nil {
		edges = append(edges, message.EdgeConversation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeConversation:
		if id := m.conversation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconversation {
		edges = append(edges, message.EdgeConversation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeConversation:
		return m.clearedconversation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ClearConversation()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ResetConversation()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// MicroserviceMutation represents an operation that mutates the Microservice nodes in the graph.
type MicroserviceMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	code               *string
	description        *string
	language           *string
	framework          *string
	git_repo           *string
	ci_pipeline        *string
	status             *string
	tenant_id          *int
	addtenant_id       *int
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	application        *int
	clearedapplication bool
	tags               map[int]struct{}
	removedtags        map[int]struct{}
	clearedtags        bool
	done               bool
	oldValue           func(context.Context) (*Microservice, error)
	predicates         []predicate.Microservice
}

var _ ent.Mutation = (*MicroserviceMutation)(nil)

// microserviceOption allows management of the mutation configuration using functional options.
type microserviceOption func(*MicroserviceMutation)

// newMicroserviceMutation creates new mutation for the Microservice entity.
func newMicroserviceMutation(c config, op Op, opts ...microserviceOption) *MicroserviceMutation {
	m := &MicroserviceMutation{
		config:        c,
		op:            op,
		typ:           TypeMicroservice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMicroserviceID sets the ID field of the mutation.
func withMicroserviceID(id int) microserviceOption {
	return func(m *MicroserviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Microservice
		)
		m.oldValue = func(ctx context.Context) (*Microservice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Microservice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMicroservice sets the old Microservice of the mutation.
func withMicroservice(node *Microservice) microserviceOption {
	return func(m *MicroserviceMutation) {
		m.oldValue = func(context.Context) (*Microservice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MicroserviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MicroserviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MicroserviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MicroserviceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Microservice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MicroserviceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MicroserviceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Microservice entity.
// If the Microservice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MicroserviceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MicroserviceMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *MicroserviceMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *MicroserviceMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Microservice entity.
// If the Microservice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MicroserviceMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *MicroserviceMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *MicroserviceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MicroserviceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Microservice entity.
// If the Microservice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MicroserviceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MicroserviceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[microservice.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MicroserviceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[microservice.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MicroserviceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, microservice.FieldDescription)
}

// SetLanguage sets the "language" field.
func (m *MicroserviceMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *MicroserviceMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Microservice entity.
// If the Microservice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MicroserviceMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ClearLanguage clears the value of the "language" field.
func (m *MicroserviceMutation) ClearLanguage() {
	m.language = nil
	m.clearedFields[microservice.FieldLanguage] = struct{}{}
}

// LanguageCleared returns if the "language" field was cleared in this mutation.
func (m *MicroserviceMutation) LanguageCleared() bool {
	_, ok := m.clearedFields[microservice.FieldLanguage]
	return ok
}

// ResetLanguage resets all changes to the "language" field.
func (m *MicroserviceMutation) ResetLanguage() {
	m.language = nil
	delete(m.clearedFields, microservice.FieldLanguage)
}

// SetFramework sets the "framework" field.
func (m *MicroserviceMutation) SetFramework(s string) {
	m.framework = &s
}

// Framework returns the value of the "framework" field in the mutation.
func (m *MicroserviceMutation) Framework() (r string, exists bool) {
	v := m.framework
	if v == nil {
		return
	}
	return *v, true
}

// OldFramework returns the old "framework" field's value of the Microservice entity.
// If the Microservice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MicroserviceMutation) OldFramework(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFramework is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFramework requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFramework: %w", err)
	}
	return oldValue.Framework, nil
}

// ClearFramework clears the value of the "framework" field.
func (m *MicroserviceMutation) ClearFramework() {
	m.framework = nil
	m.clearedFields[microservice.FieldFramework] = struct{}{}
}

// FrameworkCleared returns if the "framework" field was cleared in this mutation.
func (m *MicroserviceMutation) FrameworkCleared() bool {
	_, ok := m.clearedFields[microservice.FieldFramework]
	return ok
}

// ResetFramework resets all changes to the "framework" field.
func (m *MicroserviceMutation) ResetFramework() {
	m.framework = nil
	delete(m.clearedFields, microservice.FieldFramework)
}

// SetGitRepo sets the "git_repo" field.
func (m *MicroserviceMutation) SetGitRepo(s string) {
	m.git_repo = &s
}

// GitRepo returns the value of the "git_repo" field in the mutation.
func (m *MicroserviceMutation) GitRepo() (r string, exists bool) {
	v := m.git_repo
	if v == nil {
		return
	}
	return *v, true
}

// OldGitRepo returns the old "git_repo" field's value of the Microservice entity.
// If the Microservice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MicroserviceMutation) OldGitRepo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitRepo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitRepo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitRepo: %w", err)
	}
	return oldValue.GitRepo, nil
}

// ClearGitRepo clears the value of the "git_repo" field.
func (m *MicroserviceMutation) ClearGitRepo() {
	m.git_repo = nil
	m.clearedFields[microservice.FieldGitRepo] = struct{}{}
}

// GitRepoCleared returns if the "git_repo" field was cleared in this mutation.
func (m *MicroserviceMutation) GitRepoCleared() bool {
	_, ok := m.clearedFields[microservice.FieldGitRepo]
	return ok
}

// ResetGitRepo resets all changes to the "git_repo" field.
func (m *MicroserviceMutation) ResetGitRepo() {
	m.git_repo = nil
	delete(m.clearedFields, microservice.FieldGitRepo)
}

// SetCiPipeline sets the "ci_pipeline" field.
func (m *MicroserviceMutation) SetCiPipeline(s string) {
	m.ci_pipeline = &s
}

// CiPipeline returns the value of the "ci_pipeline" field in the mutation.
func (m *MicroserviceMutation) CiPipeline() (r string, exists bool) {
	v := m.ci_pipeline
	if v == nil {
		return
	}
	return *v, true
}

// OldCiPipeline returns the old "ci_pipeline" field's value of the Microservice entity.
// If the Microservice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MicroserviceMutation) OldCiPipeline(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCiPipeline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCiPipeline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCiPipeline: %w", err)
	}
	return oldValue.CiPipeline, nil
}

// ClearCiPipeline clears the value of the "ci_pipeline" field.
func (m *MicroserviceMutation) ClearCiPipeline() {
	m.ci_pipeline = nil
	m.clearedFields[microservice.FieldCiPipeline] = struct{}{}
}

// CiPipelineCleared returns if the "ci_pipeline" field was cleared in this mutation.
func (m *MicroserviceMutation) CiPipelineCleared() bool {
	_, ok := m.clearedFields[microservice.FieldCiPipeline]
	return ok
}

// ResetCiPipeline resets all changes to the "ci_pipeline" field.
func (m *MicroserviceMutation) ResetCiPipeline() {
	m.ci_pipeline = nil
	delete(m.clearedFields, microservice.FieldCiPipeline)
}

// SetStatus sets the "status" field.
func (m *MicroserviceMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *MicroserviceMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Microservice entity.
// If the Microservice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MicroserviceMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MicroserviceMutation) ResetStatus() {
	m.status = nil
}

// SetApplicationID sets the "application_id" field.
func (m *MicroserviceMutation) SetApplicationID(i int) {
	m.application = &i
}

// ApplicationID returns the value of the "application_id" field in the mutation.
func (m *MicroserviceMutation) ApplicationID() (r int, exists bool) {
	v := m.application
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationID returns the old "application_id" field's value of the Microservice entity.
// If the Microservice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MicroserviceMutation) OldApplicationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationID: %w", err)
	}
	return oldValue.ApplicationID, nil
}

// ClearApplicationID clears the value of the "application_id" field.
func (m *MicroserviceMutation) ClearApplicationID() {
	m.application = nil
	m.clearedFields[microservice.FieldApplicationID] = struct{}{}
}

// ApplicationIDCleared returns if the "application_id" field was cleared in this mutation.
func (m *MicroserviceMutation) ApplicationIDCleared() bool {
	_, ok := m.clearedFields[microservice.FieldApplicationID]
	return ok
}

// ResetApplicationID resets all changes to the "application_id" field.
func (m *MicroserviceMutation) ResetApplicationID() {
	m.application = nil
	delete(m.clearedFields, microservice.FieldApplicationID)
}

// SetTenantID sets the "tenant_id" field.
func (m *MicroserviceMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *MicroserviceMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Microservice entity.
// If the Microservice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MicroserviceMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *MicroserviceMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *MicroserviceMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *MicroserviceMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MicroserviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MicroserviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Microservice entity.
// If the Microservice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MicroserviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MicroserviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MicroserviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MicroserviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Microservice entity.
// If the Microservice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MicroserviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MicroserviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearApplication clears the "application" edge to the Application entity.
func (m *MicroserviceMutation) ClearApplication() {
	m.clearedapplication = true
	m.clearedFields[microservice.FieldApplicationID] = struct{}{}
}

// ApplicationCleared reports if the "application" edge to the Application entity was cleared.
func (m *MicroserviceMutation) ApplicationCleared() bool {
	return m.ApplicationIDCleared() || m.clearedapplication
}

// ApplicationIDs returns the "application" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicationID instead. It exists only for internal usage by the builders.
func (m *MicroserviceMutation) ApplicationIDs() (ids []int) {
	if id := m.application; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplication resets all changes to the "application" edge.
func (m *MicroserviceMutation) ResetApplication() {
	m.application = nil
	m.clearedapplication = false
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *MicroserviceMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *MicroserviceMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *MicroserviceMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *MicroserviceMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *MicroserviceMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *MicroserviceMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *MicroserviceMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the MicroserviceMutation builder.
func (m *MicroserviceMutation) Where(ps ...predicate.Microservice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MicroserviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MicroserviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Microservice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MicroserviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MicroserviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Microservice).
func (m *MicroserviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MicroserviceMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, microservice.FieldName)
	}
	if m.code != nil {
		fields = append(fields, microservice.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, microservice.FieldDescription)
	}
	if m.language != nil {
		fields = append(fields, microservice.FieldLanguage)
	}
	if m.framework != nil {
		fields = append(fields, microservice.FieldFramework)
	}
	if m.git_repo != nil {
		fields = append(fields, microservice.FieldGitRepo)
	}
	if m.ci_pipeline != nil {
		fields = append(fields, microservice.FieldCiPipeline)
	}
	if m.status != nil {
		fields = append(fields, microservice.FieldStatus)
	}
	if m.application != nil {
		fields = append(fields, microservice.FieldApplicationID)
	}
	if m.tenant_id != nil {
		fields = append(fields, microservice.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, microservice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, microservice.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MicroserviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case microservice.FieldName:
		return m.Name()
	case microservice.FieldCode:
		return m.Code()
	case microservice.FieldDescription:
		return m.Description()
	case microservice.FieldLanguage:
		return m.Language()
	case microservice.FieldFramework:
		return m.Framework()
	case microservice.FieldGitRepo:
		return m.GitRepo()
	case microservice.FieldCiPipeline:
		return m.CiPipeline()
	case microservice.FieldStatus:
		return m.Status()
	case microservice.FieldApplicationID:
		return m.ApplicationID()
	case microservice.FieldTenantID:
		return m.TenantID()
	case microservice.FieldCreatedAt:
		return m.CreatedAt()
	case microservice.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MicroserviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case microservice.FieldName:
		return m.OldName(ctx)
	case microservice.FieldCode:
		return m.OldCode(ctx)
	case microservice.FieldDescription:
		return m.OldDescription(ctx)
	case microservice.FieldLanguage:
		return m.OldLanguage(ctx)
	case microservice.FieldFramework:
		return m.OldFramework(ctx)
	case microservice.FieldGitRepo:
		return m.OldGitRepo(ctx)
	case microservice.FieldCiPipeline:
		return m.OldCiPipeline(ctx)
	case microservice.FieldStatus:
		return m.OldStatus(ctx)
	case microservice.FieldApplicationID:
		return m.OldApplicationID(ctx)
	case microservice.FieldTenantID:
		return m.OldTenantID(ctx)
	case microservice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case microservice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Microservice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MicroserviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case microservice.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case microservice.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case microservice.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case microservice.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case microservice.FieldFramework:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFramework(v)
		return nil
	case microservice.FieldGitRepo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitRepo(v)
		return nil
	case microservice.FieldCiPipeline:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCiPipeline(v)
		return nil
	case microservice.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case microservice.FieldApplicationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationID(v)
		return nil
	case microservice.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case microservice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case microservice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Microservice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MicroserviceMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, microservice.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MicroserviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case microservice.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MicroserviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case microservice.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Microservice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MicroserviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(microservice.FieldDescription) {
		fields = append(fields, microservice.FieldDescription)
	}
	if m.FieldCleared(microservice.FieldLanguage) {
		fields = append(fields, microservice.FieldLanguage)
	}
	if m.FieldCleared(microservice.FieldFramework) {
		fields = append(fields, microservice.FieldFramework)
	}
	if m.FieldCleared(microservice.FieldGitRepo) {
		fields = append(fields, microservice.FieldGitRepo)
	}
	if m.FieldCleared(microservice.FieldCiPipeline) {
		fields = append(fields, microservice.FieldCiPipeline)
	}
	if m.FieldCleared(microservice.FieldApplicationID) {
		fields = append(fields, microservice.FieldApplicationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MicroserviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MicroserviceMutation) ClearField(name string) error {
	switch name {
	case microservice.FieldDescription:
		m.ClearDescription()
		return nil
	case microservice.FieldLanguage:
		m.ClearLanguage()
		return nil
	case microservice.FieldFramework:
		m.ClearFramework()
		return nil
	case microservice.FieldGitRepo:
		m.ClearGitRepo()
		return nil
	case microservice.FieldCiPipeline:
		m.ClearCiPipeline()
		return nil
	case microservice.FieldApplicationID:
		m.ClearApplicationID()
		return nil
	}
	return fmt.Errorf("unknown Microservice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MicroserviceMutation) ResetField(name string) error {
	switch name {
	case microservice.FieldName:
		m.ResetName()
		return nil
	case microservice.FieldCode:
		m.ResetCode()
		return nil
	case microservice.FieldDescription:
		m.ResetDescription()
		return nil
	case microservice.FieldLanguage:
		m.ResetLanguage()
		return nil
	case microservice.FieldFramework:
		m.ResetFramework()
		return nil
	case microservice.FieldGitRepo:
		m.ResetGitRepo()
		return nil
	case microservice.FieldCiPipeline:
		m.ResetCiPipeline()
		return nil
	case microservice.FieldStatus:
		m.ResetStatus()
		return nil
	case microservice.FieldApplicationID:
		m.ResetApplicationID()
		return nil
	case microservice.FieldTenantID:
		m.ResetTenantID()
		return nil
	case microservice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case microservice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Microservice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MicroserviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.application != nil {
		edges = append(edges, microservice.EdgeApplication)
	}
	if m.tags != nil {
		edges = append(edges, microservice.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MicroserviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case microservice.EdgeApplication:
		if id := m.application; id != nil {
			return []ent.Value{*id}
		}
	case microservice.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MicroserviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtags != nil {
		edges = append(edges, microservice.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MicroserviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case microservice.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MicroserviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapplication {
		edges = append(edges, microservice.EdgeApplication)
	}
	if m.clearedtags {
		edges = append(edges, microservice.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MicroserviceMutation) EdgeCleared(name string) bool {
	switch name {
	case microservice.EdgeApplication:
		return m.clearedapplication
	case microservice.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MicroserviceMutation) ClearEdge(name string) error {
	switch name {
	case microservice.EdgeApplication:
		m.ClearApplication()
		return nil
	}
	return fmt.Errorf("unknown Microservice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MicroserviceMutation) ResetEdge(name string) error {
	switch name {
	case microservice.EdgeApplication:
		m.ResetApplication()
		return nil
	case microservice.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Microservice edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	message       *string
	_type         *string
	read          *bool
	action_url    *string
	action_text   *string
	user_id       *int
	adduser_id    *int
	tenant_id     *int
	addtenant_id  *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Notification, error)
	predicates    []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id int) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *NotificationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *NotificationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *NotificationMutation) ResetTitle() {
	m.title = nil
}

// SetMessage sets the "message" field.
func (m *NotificationMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *NotificationMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *NotificationMutation) ResetMessage() {
	m.message = nil
}

// SetType sets the "type" field.
func (m *NotificationMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationMutation) ResetType() {
	m._type = nil
}

// SetRead sets the "read" field.
func (m *NotificationMutation) SetRead(b bool) {
	m.read = &b
}

// Read returns the value of the "read" field in the mutation.
func (m *NotificationMutation) Read() (r bool, exists bool) {
	v := m.read
	if v == nil {
		return
	}
	return *v, true
}

// OldRead returns the old "read" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRead: %w", err)
	}
	return oldValue.Read, nil
}

// ResetRead resets all changes to the "read" field.
func (m *NotificationMutation) ResetRead() {
	m.read = nil
}

// SetActionURL sets the "action_url" field.
func (m *NotificationMutation) SetActionURL(s string) {
	m.action_url = &s
}

// ActionURL returns the value of the "action_url" field in the mutation.
func (m *NotificationMutation) ActionURL() (r string, exists bool) {
	v := m.action_url
	if v == nil {
		return
	}
	return *v, true
}

// OldActionURL returns the old "action_url" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldActionURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionURL: %w", err)
	}
	return oldValue.ActionURL, nil
}

// ClearActionURL clears the value of the "action_url" field.
func (m *NotificationMutation) ClearActionURL() {
	m.action_url = nil
	m.clearedFields[notification.FieldActionURL] = struct{}{}
}

// ActionURLCleared returns if the "action_url" field was cleared in this mutation.
func (m *NotificationMutation) ActionURLCleared() bool {
	_, ok := m.clearedFields[notification.FieldActionURL]
	return ok
}

// ResetActionURL resets all changes to the "action_url" field.
func (m *NotificationMutation) ResetActionURL() {
	m.action_url = nil
	delete(m.clearedFields, notification.FieldActionURL)
}

// SetActionText sets the "action_text" field.
func (m *NotificationMutation) SetActionText(s string) {
	m.action_text = &s
}

// ActionText returns the value of the "action_text" field in the mutation.
func (m *NotificationMutation) ActionText() (r string, exists bool) {
	v := m.action_text
	if v == nil {
		return
	}
	return *v, true
}

// OldActionText returns the old "action_text" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldActionText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionText: %w", err)
	}
	return oldValue.ActionText, nil
}

// ClearActionText clears the value of the "action_text" field.
func (m *NotificationMutation) ClearActionText() {
	m.action_text = nil
	m.clearedFields[notification.FieldActionText] = struct{}{}
}

// ActionTextCleared returns if the "action_text" field was cleared in this mutation.
func (m *NotificationMutation) ActionTextCleared() bool {
	_, ok := m.clearedFields[notification.FieldActionText]
	return ok
}

// ResetActionText resets all changes to the "action_text" field.
func (m *NotificationMutation) ResetActionText() {
	m.action_text = nil
	delete(m.clearedFields, notification.FieldActionText)
}

// SetUserID sets the "user_id" field.
func (m *NotificationMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *NotificationMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *NotificationMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *NotificationMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *NotificationMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *NotificationMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *NotificationMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *NotificationMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *NotificationMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *NotificationMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.title != nil {
		fields = append(fields, notification.FieldTitle)
	}
	if m.message != nil {
		fields = append(fields, notification.FieldMessage)
	}
	if m._type != nil {
		fields = append(fields, notification.FieldType)
	}
	if m.read != nil {
		fields = append(fields, notification.FieldRead)
	}
	if m.action_url != nil {
		fields = append(fields, notification.FieldActionURL)
	}
	if m.action_text != nil {
		fields = append(fields, notification.FieldActionText)
	}
	if m.user_id != nil {
		fields = append(fields, notification.FieldUserID)
	}
	if m.tenant_id != nil {
		fields = append(fields, notification.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notification.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldTitle:
		return m.Title()
	case notification.FieldMessage:
		return m.Message()
	case notification.FieldType:
		return m.GetType()
	case notification.FieldRead:
		return m.Read()
	case notification.FieldActionURL:
		return m.ActionURL()
	case notification.FieldActionText:
		return m.ActionText()
	case notification.FieldUserID:
		return m.UserID()
	case notification.FieldTenantID:
		return m.TenantID()
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	case notification.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldTitle:
		return m.OldTitle(ctx)
	case notification.FieldMessage:
		return m.OldMessage(ctx)
	case notification.FieldType:
		return m.OldType(ctx)
	case notification.FieldRead:
		return m.OldRead(ctx)
	case notification.FieldActionURL:
		return m.OldActionURL(ctx)
	case notification.FieldActionText:
		return m.OldActionText(ctx)
	case notification.FieldUserID:
		return m.OldUserID(ctx)
	case notification.FieldTenantID:
		return m.OldTenantID(ctx)
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case notification.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case notification.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notification.FieldRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRead(v)
		return nil
	case notification.FieldActionURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionURL(v)
		return nil
	case notification.FieldActionText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionText(v)
		return nil
	case notification.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case notification.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, notification.FieldUserID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, notification.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldUserID:
		return m.AddedUserID()
	case notification.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notification.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case notification.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldActionURL) {
		fields = append(fields, notification.FieldActionURL)
	}
	if m.FieldCleared(notification.FieldActionText) {
		fields = append(fields, notification.FieldActionText)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldActionURL:
		m.ClearActionURL()
		return nil
	case notification.FieldActionText:
		m.ClearActionText()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldTitle:
		m.ResetTitle()
		return nil
	case notification.FieldMessage:
		m.ResetMessage()
		return nil
	case notification.FieldType:
		m.ResetType()
		return nil
	case notification.FieldRead:
		m.ResetRead()
		return nil
	case notification.FieldActionURL:
		m.ResetActionURL()
		return nil
	case notification.FieldActionText:
		m.ResetActionText()
		return nil
	case notification.FieldUserID:
		m.ResetUserID()
		return nil
	case notification.FieldTenantID:
		m.ResetTenantID()
		return nil
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Notification edge %s", name)
}

// ProblemMutation represents an operation that mutates the Problem nodes in the graph.
type ProblemMutation struct {
	config
	op             Op
	typ            string
	id             *int
	title          *string
	description    *string
	status         *string
	priority       *string
	category       *string
	root_cause     *string
	impact         *string
	assignee_id    *int
	addassignee_id *int
	created_by     *int
	addcreated_by  *int
	tenant_id      *int
	addtenant_id   *int
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Problem, error)
	predicates     []predicate.Problem
}

var _ ent.Mutation = (*ProblemMutation)(nil)

// problemOption allows management of the mutation configuration using functional options.
type problemOption func(*ProblemMutation)

// newProblemMutation creates new mutation for the Problem entity.
func newProblemMutation(c config, op Op, opts ...problemOption) *ProblemMutation {
	m := &ProblemMutation{
		config:        c,
		op:            op,
		typ:           TypeProblem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProblemID sets the ID field of the mutation.
func withProblemID(id int) problemOption {
	return func(m *ProblemMutation) {
		var (
			err   error
			once  sync.Once
			value *Problem
		)
		m.oldValue = func(ctx context.Context) (*Problem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Problem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProblem sets the old Problem of the mutation.
func withProblem(node *Problem) problemOption {
	return func(m *ProblemMutation) {
		m.oldValue = func(context.Context) (*Problem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProblemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProblemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProblemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProblemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Problem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ProblemMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ProblemMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ProblemMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ProblemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProblemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProblemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[problem.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProblemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[problem.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProblemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, problem.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *ProblemMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProblemMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProblemMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *ProblemMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ProblemMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *ProblemMutation) ResetPriority() {
	m.priority = nil
}

// SetCategory sets the "category" field.
func (m *ProblemMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ProblemMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ProblemMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[problem.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ProblemMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[problem.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ProblemMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, problem.FieldCategory)
}

// SetRootCause sets the "root_cause" field.
func (m *ProblemMutation) SetRootCause(s string) {
	m.root_cause = &s
}

// RootCause returns the value of the "root_cause" field in the mutation.
func (m *ProblemMutation) RootCause() (r string, exists bool) {
	v := m.root_cause
	if v == nil {
		return
	}
	return *v, true
}

// OldRootCause returns the old "root_cause" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldRootCause(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootCause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootCause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootCause: %w", err)
	}
	return oldValue.RootCause, nil
}

// ClearRootCause clears the value of the "root_cause" field.
func (m *ProblemMutation) ClearRootCause() {
	m.root_cause = nil
	m.clearedFields[problem.FieldRootCause] = struct{}{}
}

// RootCauseCleared returns if the "root_cause" field was cleared in this mutation.
func (m *ProblemMutation) RootCauseCleared() bool {
	_, ok := m.clearedFields[problem.FieldRootCause]
	return ok
}

// ResetRootCause resets all changes to the "root_cause" field.
func (m *ProblemMutation) ResetRootCause() {
	m.root_cause = nil
	delete(m.clearedFields, problem.FieldRootCause)
}

// SetImpact sets the "impact" field.
func (m *ProblemMutation) SetImpact(s string) {
	m.impact = &s
}

// Impact returns the value of the "impact" field in the mutation.
func (m *ProblemMutation) Impact() (r string, exists bool) {
	v := m.impact
	if v == nil {
		return
	}
	return *v, true
}

// OldImpact returns the old "impact" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldImpact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpact: %w", err)
	}
	return oldValue.Impact, nil
}

// ClearImpact clears the value of the "impact" field.
func (m *ProblemMutation) ClearImpact() {
	m.impact = nil
	m.clearedFields[problem.FieldImpact] = struct{}{}
}

// ImpactCleared returns if the "impact" field was cleared in this mutation.
func (m *ProblemMutation) ImpactCleared() bool {
	_, ok := m.clearedFields[problem.FieldImpact]
	return ok
}

// ResetImpact resets all changes to the "impact" field.
func (m *ProblemMutation) ResetImpact() {
	m.impact = nil
	delete(m.clearedFields, problem.FieldImpact)
}

// SetAssigneeID sets the "assignee_id" field.
func (m *ProblemMutation) SetAssigneeID(i int) {
	m.assignee_id = &i
	m.addassignee_id = nil
}

// AssigneeID returns the value of the "assignee_id" field in the mutation.
func (m *ProblemMutation) AssigneeID() (r int, exists bool) {
	v := m.assignee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeID returns the old "assignee_id" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldAssigneeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeID: %w", err)
	}
	return oldValue.AssigneeID, nil
}

// AddAssigneeID adds i to the "assignee_id" field.
func (m *ProblemMutation) AddAssigneeID(i int) {
	if m.addassignee_id != nil {
		*m.addassignee_id += i
	} else {
		m.addassignee_id = &i
	}
}

// AddedAssigneeID returns the value that was added to the "assignee_id" field in this mutation.
func (m *ProblemMutation) AddedAssigneeID() (r int, exists bool) {
	v := m.addassignee_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssigneeID clears the value of the "assignee_id" field.
func (m *ProblemMutation) ClearAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	m.clearedFields[problem.FieldAssigneeID] = struct{}{}
}

// AssigneeIDCleared returns if the "assignee_id" field was cleared in this mutation.
func (m *ProblemMutation) AssigneeIDCleared() bool {
	_, ok := m.clearedFields[problem.FieldAssigneeID]
	return ok
}

// ResetAssigneeID resets all changes to the "assignee_id" field.
func (m *ProblemMutation) ResetAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	delete(m.clearedFields, problem.FieldAssigneeID)
}

// SetCreatedBy sets the "created_by" field.
func (m *ProblemMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProblemMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ProblemMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ProblemMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProblemMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ProblemMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProblemMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProblemMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProblemMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProblemMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProblemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProblemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProblemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProblemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProblemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProblemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProblemMutation builder.
func (m *ProblemMutation) Where(ps ...predicate.Problem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProblemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProblemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Problem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProblemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProblemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Problem).
func (m *ProblemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProblemMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.title != nil {
		fields = append(fields, problem.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, problem.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, problem.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, problem.FieldPriority)
	}
	if m.category != nil {
		fields = append(fields, problem.FieldCategory)
	}
	if m.root_cause != nil {
		fields = append(fields, problem.FieldRootCause)
	}
	if m.impact != nil {
		fields = append(fields, problem.FieldImpact)
	}
	if m.assignee_id != nil {
		fields = append(fields, problem.FieldAssigneeID)
	}
	if m.created_by != nil {
		fields = append(fields, problem.FieldCreatedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, problem.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, problem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, problem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProblemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case problem.FieldTitle:
		return m.Title()
	case problem.FieldDescription:
		return m.Description()
	case problem.FieldStatus:
		return m.Status()
	case problem.FieldPriority:
		return m.Priority()
	case problem.FieldCategory:
		return m.Category()
	case problem.FieldRootCause:
		return m.RootCause()
	case problem.FieldImpact:
		return m.Impact()
	case problem.FieldAssigneeID:
		return m.AssigneeID()
	case problem.FieldCreatedBy:
		return m.CreatedBy()
	case problem.FieldTenantID:
		return m.TenantID()
	case problem.FieldCreatedAt:
		return m.CreatedAt()
	case problem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProblemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case problem.FieldTitle:
		return m.OldTitle(ctx)
	case problem.FieldDescription:
		return m.OldDescription(ctx)
	case problem.FieldStatus:
		return m.OldStatus(ctx)
	case problem.FieldPriority:
		return m.OldPriority(ctx)
	case problem.FieldCategory:
		return m.OldCategory(ctx)
	case problem.FieldRootCause:
		return m.OldRootCause(ctx)
	case problem.FieldImpact:
		return m.OldImpact(ctx)
	case problem.FieldAssigneeID:
		return m.OldAssigneeID(ctx)
	case problem.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case problem.FieldTenantID:
		return m.OldTenantID(ctx)
	case problem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case problem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Problem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProblemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case problem.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case problem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case problem.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case problem.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case problem.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case problem.FieldRootCause:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootCause(v)
		return nil
	case problem.FieldImpact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpact(v)
		return nil
	case problem.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeID(v)
		return nil
	case problem.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case problem.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case problem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case problem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Problem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProblemMutation) AddedFields() []string {
	var fields []string
	if m.addassignee_id != nil {
		fields = append(fields, problem.FieldAssigneeID)
	}
	if m.addcreated_by != nil {
		fields = append(fields, problem.FieldCreatedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, problem.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProblemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case problem.FieldAssigneeID:
		return m.AddedAssigneeID()
	case problem.FieldCreatedBy:
		return m.AddedCreatedBy()
	case problem.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProblemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case problem.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssigneeID(v)
		return nil
	case problem.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case problem.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Problem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProblemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(problem.FieldDescription) {
		fields = append(fields, problem.FieldDescription)
	}
	if m.FieldCleared(problem.FieldCategory) {
		fields = append(fields, problem.FieldCategory)
	}
	if m.FieldCleared(problem.FieldRootCause) {
		fields = append(fields, problem.FieldRootCause)
	}
	if m.FieldCleared(problem.FieldImpact) {
		fields = append(fields, problem.FieldImpact)
	}
	if m.FieldCleared(problem.FieldAssigneeID) {
		fields = append(fields, problem.FieldAssigneeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProblemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProblemMutation) ClearField(name string) error {
	switch name {
	case problem.FieldDescription:
		m.ClearDescription()
		return nil
	case problem.FieldCategory:
		m.ClearCategory()
		return nil
	case problem.FieldRootCause:
		m.ClearRootCause()
		return nil
	case problem.FieldImpact:
		m.ClearImpact()
		return nil
	case problem.FieldAssigneeID:
		m.ClearAssigneeID()
		return nil
	}
	return fmt.Errorf("unknown Problem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProblemMutation) ResetField(name string) error {
	switch name {
	case problem.FieldTitle:
		m.ResetTitle()
		return nil
	case problem.FieldDescription:
		m.ResetDescription()
		return nil
	case problem.FieldStatus:
		m.ResetStatus()
		return nil
	case problem.FieldPriority:
		m.ResetPriority()
		return nil
	case problem.FieldCategory:
		m.ResetCategory()
		return nil
	case problem.FieldRootCause:
		m.ResetRootCause()
		return nil
	case problem.FieldImpact:
		m.ResetImpact()
		return nil
	case problem.FieldAssigneeID:
		m.ResetAssigneeID()
		return nil
	case problem.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case problem.FieldTenantID:
		m.ResetTenantID()
		return nil
	case problem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case problem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Problem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProblemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProblemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProblemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProblemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProblemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProblemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProblemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Problem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProblemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Problem edge %s", name)
}

// ProcessDefinitionMutation represents an operation that mutates the ProcessDefinition nodes in the graph.
type ProcessDefinitionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	key               *string
	name              *string
	description       *string
	version           *string
	category          *string
	bpmn_xml          *[]uint8
	appendbpmn_xml    []uint8
	process_variables *map[string]interface{}
	is_active         *bool
	is_latest         *bool
	deployment_id     *int
	adddeployment_id  *int
	deployment_name   *string
	deployed_at       *time.Time
	tenant_id         *int
	addtenant_id      *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*ProcessDefinition, error)
	predicates        []predicate.ProcessDefinition
}

var _ ent.Mutation = (*ProcessDefinitionMutation)(nil)

// processdefinitionOption allows management of the mutation configuration using functional options.
type processdefinitionOption func(*ProcessDefinitionMutation)

// newProcessDefinitionMutation creates new mutation for the ProcessDefinition entity.
func newProcessDefinitionMutation(c config, op Op, opts ...processdefinitionOption) *ProcessDefinitionMutation {
	m := &ProcessDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessDefinitionID sets the ID field of the mutation.
func withProcessDefinitionID(id int) processdefinitionOption {
	return func(m *ProcessDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessDefinition
		)
		m.oldValue = func(ctx context.Context) (*ProcessDefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessDefinition sets the old ProcessDefinition of the mutation.
func withProcessDefinition(node *ProcessDefinition) processdefinitionOption {
	return func(m *ProcessDefinitionMutation) {
		m.oldValue = func(context.Context) (*ProcessDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessDefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessDefinitionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessDefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *ProcessDefinitionMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *ProcessDefinitionMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *ProcessDefinitionMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *ProcessDefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProcessDefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProcessDefinitionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProcessDefinitionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProcessDefinitionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProcessDefinitionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[processdefinition.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProcessDefinitionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[processdefinition.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProcessDefinitionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, processdefinition.FieldDescription)
}

// SetVersion sets the "version" field.
func (m *ProcessDefinitionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ProcessDefinitionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ProcessDefinitionMutation) ResetVersion() {
	m.version = nil
}

// SetCategory sets the "category" field.
func (m *ProcessDefinitionMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ProcessDefinitionMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ProcessDefinitionMutation) ResetCategory() {
	m.category = nil
}

// SetBpmnXML sets the "bpmn_xml" field.
func (m *ProcessDefinitionMutation) SetBpmnXML(u []uint8) {
	m.bpmn_xml = &u
	m.appendbpmn_xml = nil
}

// BpmnXML returns the value of the "bpmn_xml" field in the mutation.
func (m *ProcessDefinitionMutation) BpmnXML() (r []uint8, exists bool) {
	v := m.bpmn_xml
	if v == nil {
		return
	}
	return *v, true
}

// OldBpmnXML returns the old "bpmn_xml" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldBpmnXML(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBpmnXML is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBpmnXML requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBpmnXML: %w", err)
	}
	return oldValue.BpmnXML, nil
}

// AppendBpmnXML adds u to the "bpmn_xml" field.
func (m *ProcessDefinitionMutation) AppendBpmnXML(u []uint8) {
	m.appendbpmn_xml = append(m.appendbpmn_xml, u...)
}

// AppendedBpmnXML returns the list of values that were appended to the "bpmn_xml" field in this mutation.
func (m *ProcessDefinitionMutation) AppendedBpmnXML() ([]uint8, bool) {
	if len(m.appendbpmn_xml) == 0 {
		return nil, false
	}
	return m.appendbpmn_xml, true
}

// ResetBpmnXML resets all changes to the "bpmn_xml" field.
func (m *ProcessDefinitionMutation) ResetBpmnXML() {
	m.bpmn_xml = nil
	m.appendbpmn_xml = nil
}

// SetProcessVariables sets the "process_variables" field.
func (m *ProcessDefinitionMutation) SetProcessVariables(value map[string]interface{}) {
	m.process_variables = &value
}

// ProcessVariables returns the value of the "process_variables" field in the mutation.
func (m *ProcessDefinitionMutation) ProcessVariables() (r map[string]interface{}, exists bool) {
	v := m.process_variables
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessVariables returns the old "process_variables" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldProcessVariables(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessVariables: %w", err)
	}
	return oldValue.ProcessVariables, nil
}

// ClearProcessVariables clears the value of the "process_variables" field.
func (m *ProcessDefinitionMutation) ClearProcessVariables() {
	m.process_variables = nil
	m.clearedFields[processdefinition.FieldProcessVariables] = struct{}{}
}

// ProcessVariablesCleared returns if the "process_variables" field was cleared in this mutation.
func (m *ProcessDefinitionMutation) ProcessVariablesCleared() bool {
	_, ok := m.clearedFields[processdefinition.FieldProcessVariables]
	return ok
}

// ResetProcessVariables resets all changes to the "process_variables" field.
func (m *ProcessDefinitionMutation) ResetProcessVariables() {
	m.process_variables = nil
	delete(m.clearedFields, processdefinition.FieldProcessVariables)
}

// SetIsActive sets the "is_active" field.
func (m *ProcessDefinitionMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ProcessDefinitionMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ProcessDefinitionMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsLatest sets the "is_latest" field.
func (m *ProcessDefinitionMutation) SetIsLatest(b bool) {
	m.is_latest = &b
}

// IsLatest returns the value of the "is_latest" field in the mutation.
func (m *ProcessDefinitionMutation) IsLatest() (r bool, exists bool) {
	v := m.is_latest
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLatest returns the old "is_latest" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldIsLatest(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLatest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLatest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLatest: %w", err)
	}
	return oldValue.IsLatest, nil
}

// ResetIsLatest resets all changes to the "is_latest" field.
func (m *ProcessDefinitionMutation) ResetIsLatest() {
	m.is_latest = nil
}

// SetDeploymentID sets the "deployment_id" field.
func (m *ProcessDefinitionMutation) SetDeploymentID(i int) {
	m.deployment_id = &i
	m.adddeployment_id = nil
}

// DeploymentID returns the value of the "deployment_id" field in the mutation.
func (m *ProcessDefinitionMutation) DeploymentID() (r int, exists bool) {
	v := m.deployment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentID returns the old "deployment_id" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldDeploymentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentID: %w", err)
	}
	return oldValue.DeploymentID, nil
}

// AddDeploymentID adds i to the "deployment_id" field.
func (m *ProcessDefinitionMutation) AddDeploymentID(i int) {
	if m.adddeployment_id != nil {
		*m.adddeployment_id += i
	} else {
		m.adddeployment_id = &i
	}
}

// AddedDeploymentID returns the value that was added to the "deployment_id" field in this mutation.
func (m *ProcessDefinitionMutation) AddedDeploymentID() (r int, exists bool) {
	v := m.adddeployment_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeploymentID resets all changes to the "deployment_id" field.
func (m *ProcessDefinitionMutation) ResetDeploymentID() {
	m.deployment_id = nil
	m.adddeployment_id = nil
}

// SetDeploymentName sets the "deployment_name" field.
func (m *ProcessDefinitionMutation) SetDeploymentName(s string) {
	m.deployment_name = &s
}

// DeploymentName returns the value of the "deployment_name" field in the mutation.
func (m *ProcessDefinitionMutation) DeploymentName() (r string, exists bool) {
	v := m.deployment_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentName returns the old "deployment_name" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldDeploymentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentName: %w", err)
	}
	return oldValue.DeploymentName, nil
}

// ClearDeploymentName clears the value of the "deployment_name" field.
func (m *ProcessDefinitionMutation) ClearDeploymentName() {
	m.deployment_name = nil
	m.clearedFields[processdefinition.FieldDeploymentName] = struct{}{}
}

// DeploymentNameCleared returns if the "deployment_name" field was cleared in this mutation.
func (m *ProcessDefinitionMutation) DeploymentNameCleared() bool {
	_, ok := m.clearedFields[processdefinition.FieldDeploymentName]
	return ok
}

// ResetDeploymentName resets all changes to the "deployment_name" field.
func (m *ProcessDefinitionMutation) ResetDeploymentName() {
	m.deployment_name = nil
	delete(m.clearedFields, processdefinition.FieldDeploymentName)
}

// SetDeployedAt sets the "deployed_at" field.
func (m *ProcessDefinitionMutation) SetDeployedAt(t time.Time) {
	m.deployed_at = &t
}

// DeployedAt returns the value of the "deployed_at" field in the mutation.
func (m *ProcessDefinitionMutation) DeployedAt() (r time.Time, exists bool) {
	v := m.deployed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployedAt returns the old "deployed_at" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldDeployedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployedAt: %w", err)
	}
	return oldValue.DeployedAt, nil
}

// ResetDeployedAt resets all changes to the "deployed_at" field.
func (m *ProcessDefinitionMutation) ResetDeployedAt() {
	m.deployed_at = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcessDefinitionMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcessDefinitionMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProcessDefinitionMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProcessDefinitionMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcessDefinitionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessDefinitionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessDefinitionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessDefinitionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessDefinitionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessDefinitionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessDefinitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProcessDefinitionMutation builder.
func (m *ProcessDefinitionMutation) Where(ps ...predicate.ProcessDefinition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcessDefinitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcessDefinitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcessDefinition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcessDefinitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcessDefinitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcessDefinition).
func (m *ProcessDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.key != nil {
		fields = append(fields, processdefinition.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, processdefinition.FieldName)
	}
	if m.description != nil {
		fields = append(fields, processdefinition.FieldDescription)
	}
	if m.version != nil {
		fields = append(fields, processdefinition.FieldVersion)
	}
	if m.category != nil {
		fields = append(fields, processdefinition.FieldCategory)
	}
	if m.bpmn_xml != nil {
		fields = append(fields, processdefinition.FieldBpmnXML)
	}
	if m.process_variables != nil {
		fields = append(fields, processdefinition.FieldProcessVariables)
	}
	if m.is_active != nil {
		fields = append(fields, processdefinition.FieldIsActive)
	}
	if m.is_latest != nil {
		fields = append(fields, processdefinition.FieldIsLatest)
	}
	if m.deployment_id != nil {
		fields = append(fields, processdefinition.FieldDeploymentID)
	}
	if m.deployment_name != nil {
		fields = append(fields, processdefinition.FieldDeploymentName)
	}
	if m.deployed_at != nil {
		fields = append(fields, processdefinition.FieldDeployedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, processdefinition.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, processdefinition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, processdefinition.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processdefinition.FieldKey:
		return m.Key()
	case processdefinition.FieldName:
		return m.Name()
	case processdefinition.FieldDescription:
		return m.Description()
	case processdefinition.FieldVersion:
		return m.Version()
	case processdefinition.FieldCategory:
		return m.Category()
	case processdefinition.FieldBpmnXML:
		return m.BpmnXML()
	case processdefinition.FieldProcessVariables:
		return m.ProcessVariables()
	case processdefinition.FieldIsActive:
		return m.IsActive()
	case processdefinition.FieldIsLatest:
		return m.IsLatest()
	case processdefinition.FieldDeploymentID:
		return m.DeploymentID()
	case processdefinition.FieldDeploymentName:
		return m.DeploymentName()
	case processdefinition.FieldDeployedAt:
		return m.DeployedAt()
	case processdefinition.FieldTenantID:
		return m.TenantID()
	case processdefinition.FieldCreatedAt:
		return m.CreatedAt()
	case processdefinition.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processdefinition.FieldKey:
		return m.OldKey(ctx)
	case processdefinition.FieldName:
		return m.OldName(ctx)
	case processdefinition.FieldDescription:
		return m.OldDescription(ctx)
	case processdefinition.FieldVersion:
		return m.OldVersion(ctx)
	case processdefinition.FieldCategory:
		return m.OldCategory(ctx)
	case processdefinition.FieldBpmnXML:
		return m.OldBpmnXML(ctx)
	case processdefinition.FieldProcessVariables:
		return m.OldProcessVariables(ctx)
	case processdefinition.FieldIsActive:
		return m.OldIsActive(ctx)
	case processdefinition.FieldIsLatest:
		return m.OldIsLatest(ctx)
	case processdefinition.FieldDeploymentID:
		return m.OldDeploymentID(ctx)
	case processdefinition.FieldDeploymentName:
		return m.OldDeploymentName(ctx)
	case processdefinition.FieldDeployedAt:
		return m.OldDeployedAt(ctx)
	case processdefinition.FieldTenantID:
		return m.OldTenantID(ctx)
	case processdefinition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case processdefinition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessDefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processdefinition.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case processdefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case processdefinition.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case processdefinition.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case processdefinition.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case processdefinition.FieldBpmnXML:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBpmnXML(v)
		return nil
	case processdefinition.FieldProcessVariables:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessVariables(v)
		return nil
	case processdefinition.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case processdefinition.FieldIsLatest:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLatest(v)
		return nil
	case processdefinition.FieldDeploymentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentID(v)
		return nil
	case processdefinition.FieldDeploymentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentName(v)
		return nil
	case processdefinition.FieldDeployedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployedAt(v)
		return nil
	case processdefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case processdefinition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case processdefinition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessDefinitionMutation) AddedFields() []string {
	var fields []string
	if m.adddeployment_id != nil {
		fields = append(fields, processdefinition.FieldDeploymentID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, processdefinition.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processdefinition.FieldDeploymentID:
		return m.AddedDeploymentID()
	case processdefinition.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processdefinition.FieldDeploymentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeploymentID(v)
		return nil
	case processdefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(processdefinition.FieldDescription) {
		fields = append(fields, processdefinition.FieldDescription)
	}
	if m.FieldCleared(processdefinition.FieldProcessVariables) {
		fields = append(fields, processdefinition.FieldProcessVariables)
	}
	if m.FieldCleared(processdefinition.FieldDeploymentName) {
		fields = append(fields, processdefinition.FieldDeploymentName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessDefinitionMutation) ClearField(name string) error {
	switch name {
	case processdefinition.FieldDescription:
		m.ClearDescription()
		return nil
	case processdefinition.FieldProcessVariables:
		m.ClearProcessVariables()
		return nil
	case processdefinition.FieldDeploymentName:
		m.ClearDeploymentName()
		return nil
	}
	return fmt.Errorf("unknown ProcessDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessDefinitionMutation) ResetField(name string) error {
	switch name {
	case processdefinition.FieldKey:
		m.ResetKey()
		return nil
	case processdefinition.FieldName:
		m.ResetName()
		return nil
	case processdefinition.FieldDescription:
		m.ResetDescription()
		return nil
	case processdefinition.FieldVersion:
		m.ResetVersion()
		return nil
	case processdefinition.FieldCategory:
		m.ResetCategory()
		return nil
	case processdefinition.FieldBpmnXML:
		m.ResetBpmnXML()
		return nil
	case processdefinition.FieldProcessVariables:
		m.ResetProcessVariables()
		return nil
	case processdefinition.FieldIsActive:
		m.ResetIsActive()
		return nil
	case processdefinition.FieldIsLatest:
		m.ResetIsLatest()
		return nil
	case processdefinition.FieldDeploymentID:
		m.ResetDeploymentID()
		return nil
	case processdefinition.FieldDeploymentName:
		m.ResetDeploymentName()
		return nil
	case processdefinition.FieldDeployedAt:
		m.ResetDeployedAt()
		return nil
	case processdefinition.FieldTenantID:
		m.ResetTenantID()
		return nil
	case processdefinition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case processdefinition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessDefinitionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessDefinitionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessDefinitionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessDefinitionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessDefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessDefinitionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessDefinition edge %s", name)
}

// ProcessDeploymentMutation represents an operation that mutates the ProcessDeployment nodes in the graph.
type ProcessDeploymentMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	deployment_id       *string
	deployment_name     *string
	deployment_source   *string
	deployment_time     *time.Time
	deployed_by         *string
	deployment_comment  *string
	is_active           *bool
	deployment_category *string
	deployment_metadata *map[string]interface{}
	tenant_id           *int
	addtenant_id        *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*ProcessDeployment, error)
	predicates          []predicate.ProcessDeployment
}

var _ ent.Mutation = (*ProcessDeploymentMutation)(nil)

// processdeploymentOption allows management of the mutation configuration using functional options.
type processdeploymentOption func(*ProcessDeploymentMutation)

// newProcessDeploymentMutation creates new mutation for the ProcessDeployment entity.
func newProcessDeploymentMutation(c config, op Op, opts ...processdeploymentOption) *ProcessDeploymentMutation {
	m := &ProcessDeploymentMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessDeployment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessDeploymentID sets the ID field of the mutation.
func withProcessDeploymentID(id int) processdeploymentOption {
	return func(m *ProcessDeploymentMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessDeployment
		)
		m.oldValue = func(ctx context.Context) (*ProcessDeployment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessDeployment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessDeployment sets the old ProcessDeployment of the mutation.
func withProcessDeployment(node *ProcessDeployment) processdeploymentOption {
	return func(m *ProcessDeploymentMutation) {
		m.oldValue = func(context.Context) (*ProcessDeployment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessDeploymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessDeploymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessDeploymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessDeploymentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessDeployment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeploymentID sets the "deployment_id" field.
func (m *ProcessDeploymentMutation) SetDeploymentID(s string) {
	m.deployment_id = &s
}

// DeploymentID returns the value of the "deployment_id" field in the mutation.
func (m *ProcessDeploymentMutation) DeploymentID() (r string, exists bool) {
	v := m.deployment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentID returns the old "deployment_id" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeploymentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentID: %w", err)
	}
	return oldValue.DeploymentID, nil
}

// ResetDeploymentID resets all changes to the "deployment_id" field.
func (m *ProcessDeploymentMutation) ResetDeploymentID() {
	m.deployment_id = nil
}

// SetDeploymentName sets the "deployment_name" field.
func (m *ProcessDeploymentMutation) SetDeploymentName(s string) {
	m.deployment_name = &s
}

// DeploymentName returns the value of the "deployment_name" field in the mutation.
func (m *ProcessDeploymentMutation) DeploymentName() (r string, exists bool) {
	v := m.deployment_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentName returns the old "deployment_name" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeploymentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentName: %w", err)
	}
	return oldValue.DeploymentName, nil
}

// ResetDeploymentName resets all changes to the "deployment_name" field.
func (m *ProcessDeploymentMutation) ResetDeploymentName() {
	m.deployment_name = nil
}

// SetDeploymentSource sets the "deployment_source" field.
func (m *ProcessDeploymentMutation) SetDeploymentSource(s string) {
	m.deployment_source = &s
}

// DeploymentSource returns the value of the "deployment_source" field in the mutation.
func (m *ProcessDeploymentMutation) DeploymentSource() (r string, exists bool) {
	v := m.deployment_source
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentSource returns the old "deployment_source" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeploymentSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentSource: %w", err)
	}
	return oldValue.DeploymentSource, nil
}

// ClearDeploymentSource clears the value of the "deployment_source" field.
func (m *ProcessDeploymentMutation) ClearDeploymentSource() {
	m.deployment_source = nil
	m.clearedFields[processdeployment.FieldDeploymentSource] = struct{}{}
}

// DeploymentSourceCleared returns if the "deployment_source" field was cleared in this mutation.
func (m *ProcessDeploymentMutation) DeploymentSourceCleared() bool {
	_, ok := m.clearedFields[processdeployment.FieldDeploymentSource]
	return ok
}

// ResetDeploymentSource resets all changes to the "deployment_source" field.
func (m *ProcessDeploymentMutation) ResetDeploymentSource() {
	m.deployment_source = nil
	delete(m.clearedFields, processdeployment.FieldDeploymentSource)
}

// SetDeploymentTime sets the "deployment_time" field.
func (m *ProcessDeploymentMutation) SetDeploymentTime(t time.Time) {
	m.deployment_time = &t
}

// DeploymentTime returns the value of the "deployment_time" field in the mutation.
func (m *ProcessDeploymentMutation) DeploymentTime() (r time.Time, exists bool) {
	v := m.deployment_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentTime returns the old "deployment_time" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeploymentTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentTime: %w", err)
	}
	return oldValue.DeploymentTime, nil
}

// ResetDeploymentTime resets all changes to the "deployment_time" field.
func (m *ProcessDeploymentMutation) ResetDeploymentTime() {
	m.deployment_time = nil
}

// SetDeployedBy sets the "deployed_by" field.
func (m *ProcessDeploymentMutation) SetDeployedBy(s string) {
	m.deployed_by = &s
}

// DeployedBy returns the value of the "deployed_by" field in the mutation.
func (m *ProcessDeploymentMutation) DeployedBy() (r string, exists bool) {
	v := m.deployed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployedBy returns the old "deployed_by" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeployedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployedBy: %w", err)
	}
	return oldValue.DeployedBy, nil
}

// ClearDeployedBy clears the value of the "deployed_by" field.
func (m *ProcessDeploymentMutation) ClearDeployedBy() {
	m.deployed_by = nil
	m.clearedFields[processdeployment.FieldDeployedBy] = struct{}{}
}

// DeployedByCleared returns if the "deployed_by" field was cleared in this mutation.
func (m *ProcessDeploymentMutation) DeployedByCleared() bool {
	_, ok := m.clearedFields[processdeployment.FieldDeployedBy]
	return ok
}

// ResetDeployedBy resets all changes to the "deployed_by" field.
func (m *ProcessDeploymentMutation) ResetDeployedBy() {
	m.deployed_by = nil
	delete(m.clearedFields, processdeployment.FieldDeployedBy)
}

// SetDeploymentComment sets the "deployment_comment" field.
func (m *ProcessDeploymentMutation) SetDeploymentComment(s string) {
	m.deployment_comment = &s
}

// DeploymentComment returns the value of the "deployment_comment" field in the mutation.
func (m *ProcessDeploymentMutation) DeploymentComment() (r string, exists bool) {
	v := m.deployment_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentComment returns the old "deployment_comment" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeploymentComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentComment: %w", err)
	}
	return oldValue.DeploymentComment, nil
}

// ClearDeploymentComment clears the value of the "deployment_comment" field.
func (m *ProcessDeploymentMutation) ClearDeploymentComment() {
	m.deployment_comment = nil
	m.clearedFields[processdeployment.FieldDeploymentComment] = struct{}{}
}

// DeploymentCommentCleared returns if the "deployment_comment" field was cleared in this mutation.
func (m *ProcessDeploymentMutation) DeploymentCommentCleared() bool {
	_, ok := m.clearedFields[processdeployment.FieldDeploymentComment]
	return ok
}

// ResetDeploymentComment resets all changes to the "deployment_comment" field.
func (m *ProcessDeploymentMutation) ResetDeploymentComment() {
	m.deployment_comment = nil
	delete(m.clearedFields, processdeployment.FieldDeploymentComment)
}

// SetIsActive sets the "is_active" field.
func (m *ProcessDeploymentMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ProcessDeploymentMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ProcessDeploymentMutation) ResetIsActive() {
	m.is_active = nil
}

// SetDeploymentCategory sets the "deployment_category" field.
func (m *ProcessDeploymentMutation) SetDeploymentCategory(s string) {
	m.deployment_category = &s
}

// DeploymentCategory returns the value of the "deployment_category" field in the mutation.
func (m *ProcessDeploymentMutation) DeploymentCategory() (r string, exists bool) {
	v := m.deployment_category
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentCategory returns the old "deployment_category" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeploymentCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentCategory: %w", err)
	}
	return oldValue.DeploymentCategory, nil
}

// ResetDeploymentCategory resets all changes to the "deployment_category" field.
func (m *ProcessDeploymentMutation) ResetDeploymentCategory() {
	m.deployment_category = nil
}

// SetDeploymentMetadata sets the "deployment_metadata" field.
func (m *ProcessDeploymentMutation) SetDeploymentMetadata(value map[string]interface{}) {
	m.deployment_metadata = &value
}

// DeploymentMetadata returns the value of the "deployment_metadata" field in the mutation.
func (m *ProcessDeploymentMutation) DeploymentMetadata() (r map[string]interface{}, exists bool) {
	v := m.deployment_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentMetadata returns the old "deployment_metadata" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeploymentMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentMetadata: %w", err)
	}
	return oldValue.DeploymentMetadata, nil
}

// ClearDeploymentMetadata clears the value of the "deployment_metadata" field.
func (m *ProcessDeploymentMutation) ClearDeploymentMetadata() {
	m.deployment_metadata = nil
	m.clearedFields[processdeployment.FieldDeploymentMetadata] = struct{}{}
}

// DeploymentMetadataCleared returns if the "deployment_metadata" field was cleared in this mutation.
func (m *ProcessDeploymentMutation) DeploymentMetadataCleared() bool {
	_, ok := m.clearedFields[processdeployment.FieldDeploymentMetadata]
	return ok
}

// ResetDeploymentMetadata resets all changes to the "deployment_metadata" field.
func (m *ProcessDeploymentMutation) ResetDeploymentMetadata() {
	m.deployment_metadata = nil
	delete(m.clearedFields, processdeployment.FieldDeploymentMetadata)
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcessDeploymentMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcessDeploymentMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProcessDeploymentMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProcessDeploymentMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcessDeploymentMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessDeploymentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessDeploymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessDeploymentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessDeploymentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessDeploymentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessDeploymentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProcessDeploymentMutation builder.
func (m *ProcessDeploymentMutation) Where(ps ...predicate.ProcessDeployment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcessDeploymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcessDeploymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcessDeployment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcessDeploymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcessDeploymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcessDeployment).
func (m *ProcessDeploymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessDeploymentMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.deployment_id != nil {
		fields = append(fields, processdeployment.FieldDeploymentID)
	}
	if m.deployment_name != nil {
		fields = append(fields, processdeployment.FieldDeploymentName)
	}
	if m.deployment_source != nil {
		fields = append(fields, processdeployment.FieldDeploymentSource)
	}
	if m.deployment_time != nil {
		fields = append(fields, processdeployment.FieldDeploymentTime)
	}
	if m.deployed_by != nil {
		fields = append(fields, processdeployment.FieldDeployedBy)
	}
	if m.deployment_comment != nil {
		fields = append(fields, processdeployment.FieldDeploymentComment)
	}
	if m.is_active != nil {
		fields = append(fields, processdeployment.FieldIsActive)
	}
	if m.deployment_category != nil {
		fields = append(fields, processdeployment.FieldDeploymentCategory)
	}
	if m.deployment_metadata != nil {
		fields = append(fields, processdeployment.FieldDeploymentMetadata)
	}
	if m.tenant_id != nil {
		fields = append(fields, processdeployment.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, processdeployment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, processdeployment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessDeploymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processdeployment.FieldDeploymentID:
		return m.DeploymentID()
	case processdeployment.FieldDeploymentName:
		return m.DeploymentName()
	case processdeployment.FieldDeploymentSource:
		return m.DeploymentSource()
	case processdeployment.FieldDeploymentTime:
		return m.DeploymentTime()
	case processdeployment.FieldDeployedBy:
		return m.DeployedBy()
	case processdeployment.FieldDeploymentComment:
		return m.DeploymentComment()
	case processdeployment.FieldIsActive:
		return m.IsActive()
	case processdeployment.FieldDeploymentCategory:
		return m.DeploymentCategory()
	case processdeployment.FieldDeploymentMetadata:
		return m.DeploymentMetadata()
	case processdeployment.FieldTenantID:
		return m.TenantID()
	case processdeployment.FieldCreatedAt:
		return m.CreatedAt()
	case processdeployment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessDeploymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processdeployment.FieldDeploymentID:
		return m.OldDeploymentID(ctx)
	case processdeployment.FieldDeploymentName:
		return m.OldDeploymentName(ctx)
	case processdeployment.FieldDeploymentSource:
		return m.OldDeploymentSource(ctx)
	case processdeployment.FieldDeploymentTime:
		return m.OldDeploymentTime(ctx)
	case processdeployment.FieldDeployedBy:
		return m.OldDeployedBy(ctx)
	case processdeployment.FieldDeploymentComment:
		return m.OldDeploymentComment(ctx)
	case processdeployment.FieldIsActive:
		return m.OldIsActive(ctx)
	case processdeployment.FieldDeploymentCategory:
		return m.OldDeploymentCategory(ctx)
	case processdeployment.FieldDeploymentMetadata:
		return m.OldDeploymentMetadata(ctx)
	case processdeployment.FieldTenantID:
		return m.OldTenantID(ctx)
	case processdeployment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case processdeployment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessDeployment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessDeploymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processdeployment.FieldDeploymentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentID(v)
		return nil
	case processdeployment.FieldDeploymentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentName(v)
		return nil
	case processdeployment.FieldDeploymentSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentSource(v)
		return nil
	case processdeployment.FieldDeploymentTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentTime(v)
		return nil
	case processdeployment.FieldDeployedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployedBy(v)
		return nil
	case processdeployment.FieldDeploymentComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentComment(v)
		return nil
	case processdeployment.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case processdeployment.FieldDeploymentCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentCategory(v)
		return nil
	case processdeployment.FieldDeploymentMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentMetadata(v)
		return nil
	case processdeployment.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case processdeployment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case processdeployment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessDeployment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessDeploymentMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, processdeployment.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessDeploymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processdeployment.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessDeploymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processdeployment.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessDeployment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessDeploymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(processdeployment.FieldDeploymentSource) {
		fields = append(fields, processdeployment.FieldDeploymentSource)
	}
	if m.FieldCleared(processdeployment.FieldDeployedBy) {
		fields = append(fields, processdeployment.FieldDeployedBy)
	}
	if m.FieldCleared(processdeployment.FieldDeploymentComment) {
		fields = append(fields, processdeployment.FieldDeploymentComment)
	}
	if m.FieldCleared(processdeployment.FieldDeploymentMetadata) {
		fields = append(fields, processdeployment.FieldDeploymentMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessDeploymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessDeploymentMutation) ClearField(name string) error {
	switch name {
	case processdeployment.FieldDeploymentSource:
		m.ClearDeploymentSource()
		return nil
	case processdeployment.FieldDeployedBy:
		m.ClearDeployedBy()
		return nil
	case processdeployment.FieldDeploymentComment:
		m.ClearDeploymentComment()
		return nil
	case processdeployment.FieldDeploymentMetadata:
		m.ClearDeploymentMetadata()
		return nil
	}
	return fmt.Errorf("unknown ProcessDeployment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessDeploymentMutation) ResetField(name string) error {
	switch name {
	case processdeployment.FieldDeploymentID:
		m.ResetDeploymentID()
		return nil
	case processdeployment.FieldDeploymentName:
		m.ResetDeploymentName()
		return nil
	case processdeployment.FieldDeploymentSource:
		m.ResetDeploymentSource()
		return nil
	case processdeployment.FieldDeploymentTime:
		m.ResetDeploymentTime()
		return nil
	case processdeployment.FieldDeployedBy:
		m.ResetDeployedBy()
		return nil
	case processdeployment.FieldDeploymentComment:
		m.ResetDeploymentComment()
		return nil
	case processdeployment.FieldIsActive:
		m.ResetIsActive()
		return nil
	case processdeployment.FieldDeploymentCategory:
		m.ResetDeploymentCategory()
		return nil
	case processdeployment.FieldDeploymentMetadata:
		m.ResetDeploymentMetadata()
		return nil
	case processdeployment.FieldTenantID:
		m.ResetTenantID()
		return nil
	case processdeployment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case processdeployment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessDeployment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessDeploymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessDeploymentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessDeploymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessDeploymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessDeploymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessDeploymentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessDeploymentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessDeployment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessDeploymentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessDeployment edge %s", name)
}

// ProcessExecutionHistoryMutation represents an operation that mutates the ProcessExecutionHistory nodes in the graph.
type ProcessExecutionHistoryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	history_id             *string
	process_instance_id    *string
	process_definition_key *string
	activity_id            *string
	activity_name          *string
	activity_type          *string
	event_type             *string
	event_detail           *string
	variables              *map[string]interface{}
	user_id                *string
	user_name              *string
	timestamp              *time.Time
	comment                *string
	error_message          *string
	error_code             *string
	tenant_id              *int
	addtenant_id           *int
	created_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ProcessExecutionHistory, error)
	predicates             []predicate.ProcessExecutionHistory
}

var _ ent.Mutation = (*ProcessExecutionHistoryMutation)(nil)

// processexecutionhistoryOption allows management of the mutation configuration using functional options.
type processexecutionhistoryOption func(*ProcessExecutionHistoryMutation)

// newProcessExecutionHistoryMutation creates new mutation for the ProcessExecutionHistory entity.
func newProcessExecutionHistoryMutation(c config, op Op, opts ...processexecutionhistoryOption) *ProcessExecutionHistoryMutation {
	m := &ProcessExecutionHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessExecutionHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessExecutionHistoryID sets the ID field of the mutation.
func withProcessExecutionHistoryID(id int) processexecutionhistoryOption {
	return func(m *ProcessExecutionHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessExecutionHistory
		)
		m.oldValue = func(ctx context.Context) (*ProcessExecutionHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessExecutionHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessExecutionHistory sets the old ProcessExecutionHistory of the mutation.
func withProcessExecutionHistory(node *ProcessExecutionHistory) processexecutionhistoryOption {
	return func(m *ProcessExecutionHistoryMutation) {
		m.oldValue = func(context.Context) (*ProcessExecutionHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessExecutionHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessExecutionHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessExecutionHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessExecutionHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessExecutionHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryID sets the "history_id" field.
func (m *ProcessExecutionHistoryMutation) SetHistoryID(s string) {
	m.history_id = &s
}

// HistoryID returns the value of the "history_id" field in the mutation.
func (m *ProcessExecutionHistoryMutation) HistoryID() (r string, exists bool) {
	v := m.history_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryID returns the old "history_id" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldHistoryID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryID: %w", err)
	}
	return oldValue.HistoryID, nil
}

// ResetHistoryID resets all changes to the "history_id" field.
func (m *ProcessExecutionHistoryMutation) ResetHistoryID() {
	m.history_id = nil
}

// SetProcessInstanceID sets the "process_instance_id" field.
func (m *ProcessExecutionHistoryMutation) SetProcessInstanceID(s string) {
	m.process_instance_id = &s
}

// ProcessInstanceID returns the value of the "process_instance_id" field in the mutation.
func (m *ProcessExecutionHistoryMutation) ProcessInstanceID() (r string, exists bool) {
	v := m.process_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessInstanceID returns the old "process_instance_id" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldProcessInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessInstanceID: %w", err)
	}
	return oldValue.ProcessInstanceID, nil
}

// ResetProcessInstanceID resets all changes to the "process_instance_id" field.
func (m *ProcessExecutionHistoryMutation) ResetProcessInstanceID() {
	m.process_instance_id = nil
}

// SetProcessDefinitionKey sets the "process_definition_key" field.
func (m *ProcessExecutionHistoryMutation) SetProcessDefinitionKey(s string) {
	m.process_definition_key = &s
}

// ProcessDefinitionKey returns the value of the "process_definition_key" field in the mutation.
func (m *ProcessExecutionHistoryMutation) ProcessDefinitionKey() (r string, exists bool) {
	v := m.process_definition_key
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessDefinitionKey returns the old "process_definition_key" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldProcessDefinitionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessDefinitionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessDefinitionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessDefinitionKey: %w", err)
	}
	return oldValue.ProcessDefinitionKey, nil
}

// ResetProcessDefinitionKey resets all changes to the "process_definition_key" field.
func (m *ProcessExecutionHistoryMutation) ResetProcessDefinitionKey() {
	m.process_definition_key = nil
}

// SetActivityID sets the "activity_id" field.
func (m *ProcessExecutionHistoryMutation) SetActivityID(s string) {
	m.activity_id = &s
}

// ActivityID returns the value of the "activity_id" field in the mutation.
func (m *ProcessExecutionHistoryMutation) ActivityID() (r string, exists bool) {
	v := m.activity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityID returns the old "activity_id" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldActivityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityID: %w", err)
	}
	return oldValue.ActivityID, nil
}

// ClearActivityID clears the value of the "activity_id" field.
func (m *ProcessExecutionHistoryMutation) ClearActivityID() {
	m.activity_id = nil
	m.clearedFields[processexecutionhistory.FieldActivityID] = struct{}{}
}

// ActivityIDCleared returns if the "activity_id" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) ActivityIDCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldActivityID]
	return ok
}

// ResetActivityID resets all changes to the "activity_id" field.
func (m *ProcessExecutionHistoryMutation) ResetActivityID() {
	m.activity_id = nil
	delete(m.clearedFields, processexecutionhistory.FieldActivityID)
}

// SetActivityName sets the "activity_name" field.
func (m *ProcessExecutionHistoryMutation) SetActivityName(s string) {
	m.activity_name = &s
}

// ActivityName returns the value of the "activity_name" field in the mutation.
func (m *ProcessExecutionHistoryMutation) ActivityName() (r string, exists bool) {
	v := m.activity_name
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityName returns the old "activity_name" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldActivityName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityName: %w", err)
	}
	return oldValue.ActivityName, nil
}

// ClearActivityName clears the value of the "activity_name" field.
func (m *ProcessExecutionHistoryMutation) ClearActivityName() {
	m.activity_name = nil
	m.clearedFields[processexecutionhistory.FieldActivityName] = struct{}{}
}

// ActivityNameCleared returns if the "activity_name" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) ActivityNameCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldActivityName]
	return ok
}

// ResetActivityName resets all changes to the "activity_name" field.
func (m *ProcessExecutionHistoryMutation) ResetActivityName() {
	m.activity_name = nil
	delete(m.clearedFields, processexecutionhistory.FieldActivityName)
}

// SetActivityType sets the "activity_type" field.
func (m *ProcessExecutionHistoryMutation) SetActivityType(s string) {
	m.activity_type = &s
}

// ActivityType returns the value of the "activity_type" field in the mutation.
func (m *ProcessExecutionHistoryMutation) ActivityType() (r string, exists bool) {
	v := m.activity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityType returns the old "activity_type" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldActivityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityType: %w", err)
	}
	return oldValue.ActivityType, nil
}

// ResetActivityType resets all changes to the "activity_type" field.
func (m *ProcessExecutionHistoryMutation) ResetActivityType() {
	m.activity_type = nil
}

// SetEventType sets the "event_type" field.
func (m *ProcessExecutionHistoryMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *ProcessExecutionHistoryMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *ProcessExecutionHistoryMutation) ResetEventType() {
	m.event_type = nil
}

// SetEventDetail sets the "event_detail" field.
func (m *ProcessExecutionHistoryMutation) SetEventDetail(s string) {
	m.event_detail = &s
}

// EventDetail returns the value of the "event_detail" field in the mutation.
func (m *ProcessExecutionHistoryMutation) EventDetail() (r string, exists bool) {
	v := m.event_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldEventDetail returns the old "event_detail" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldEventDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventDetail: %w", err)
	}
	return oldValue.EventDetail, nil
}

// ClearEventDetail clears the value of the "event_detail" field.
func (m *ProcessExecutionHistoryMutation) ClearEventDetail() {
	m.event_detail = nil
	m.clearedFields[processexecutionhistory.FieldEventDetail] = struct{}{}
}

// EventDetailCleared returns if the "event_detail" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) EventDetailCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldEventDetail]
	return ok
}

// ResetEventDetail resets all changes to the "event_detail" field.
func (m *ProcessExecutionHistoryMutation) ResetEventDetail() {
	m.event_detail = nil
	delete(m.clearedFields, processexecutionhistory.FieldEventDetail)
}

// SetVariables sets the "variables" field.
func (m *ProcessExecutionHistoryMutation) SetVariables(value map[string]interface{}) {
	m.variables = &value
}

// Variables returns the value of the "variables" field in the mutation.
func (m *ProcessExecutionHistoryMutation) Variables() (r map[string]interface{}, exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old "variables" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldVariables(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// ClearVariables clears the value of the "variables" field.
func (m *ProcessExecutionHistoryMutation) ClearVariables() {
	m.variables = nil
	m.clearedFields[processexecutionhistory.FieldVariables] = struct{}{}
}

// VariablesCleared returns if the "variables" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) VariablesCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldVariables]
	return ok
}

// ResetVariables resets all changes to the "variables" field.
func (m *ProcessExecutionHistoryMutation) ResetVariables() {
	m.variables = nil
	delete(m.clearedFields, processexecutionhistory.FieldVariables)
}

// SetUserID sets the "user_id" field.
func (m *ProcessExecutionHistoryMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProcessExecutionHistoryMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ProcessExecutionHistoryMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[processexecutionhistory.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProcessExecutionHistoryMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, processexecutionhistory.FieldUserID)
}

// SetUserName sets the "user_name" field.
func (m *ProcessExecutionHistoryMutation) SetUserName(s string) {
	m.user_name = &s
}

// UserName returns the value of the "user_name" field in the mutation.
func (m *ProcessExecutionHistoryMutation) UserName() (r string, exists bool) {
	v := m.user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "user_name" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "user_name" field.
func (m *ProcessExecutionHistoryMutation) ClearUserName() {
	m.user_name = nil
	m.clearedFields[processexecutionhistory.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "user_name" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "user_name" field.
func (m *ProcessExecutionHistoryMutation) ResetUserName() {
	m.user_name = nil
	delete(m.clearedFields, processexecutionhistory.FieldUserName)
}

// SetTimestamp sets the "timestamp" field.
func (m *ProcessExecutionHistoryMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *ProcessExecutionHistoryMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *ProcessExecutionHistoryMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetComment sets the "comment" field.
func (m *ProcessExecutionHistoryMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *ProcessExecutionHistoryMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *ProcessExecutionHistoryMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[processexecutionhistory.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) CommentCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *ProcessExecutionHistoryMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, processexecutionhistory.FieldComment)
}

// SetErrorMessage sets the "error_message" field.
func (m *ProcessExecutionHistoryMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ProcessExecutionHistoryMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ProcessExecutionHistoryMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[processexecutionhistory.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ProcessExecutionHistoryMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, processexecutionhistory.FieldErrorMessage)
}

// SetErrorCode sets the "error_code" field.
func (m *ProcessExecutionHistoryMutation) SetErrorCode(s string) {
	m.error_code = &s
}

// ErrorCode returns the value of the "error_code" field in the mutation.
func (m *ProcessExecutionHistoryMutation) ErrorCode() (r string, exists bool) {
	v := m.error_code
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCode returns the old "error_code" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldErrorCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCode: %w", err)
	}
	return oldValue.ErrorCode, nil
}

// ClearErrorCode clears the value of the "error_code" field.
func (m *ProcessExecutionHistoryMutation) ClearErrorCode() {
	m.error_code = nil
	m.clearedFields[processexecutionhistory.FieldErrorCode] = struct{}{}
}

// ErrorCodeCleared returns if the "error_code" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) ErrorCodeCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldErrorCode]
	return ok
}

// ResetErrorCode resets all changes to the "error_code" field.
func (m *ProcessExecutionHistoryMutation) ResetErrorCode() {
	m.error_code = nil
	delete(m.clearedFields, processexecutionhistory.FieldErrorCode)
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcessExecutionHistoryMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcessExecutionHistoryMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProcessExecutionHistoryMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProcessExecutionHistoryMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcessExecutionHistoryMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessExecutionHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessExecutionHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessExecutionHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the ProcessExecutionHistoryMutation builder.
func (m *ProcessExecutionHistoryMutation) Where(ps ...predicate.ProcessExecutionHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcessExecutionHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcessExecutionHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcessExecutionHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcessExecutionHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcessExecutionHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcessExecutionHistory).
func (m *ProcessExecutionHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessExecutionHistoryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.history_id != nil {
		fields = append(fields, processexecutionhistory.FieldHistoryID)
	}
	if m.process_instance_id != nil {
		fields = append(fields, processexecutionhistory.FieldProcessInstanceID)
	}
	if m.process_definition_key != nil {
		fields = append(fields, processexecutionhistory.FieldProcessDefinitionKey)
	}
	if m.activity_id != nil {
		fields = append(fields, processexecutionhistory.FieldActivityID)
	}
	if m.activity_name != nil {
		fields = append(fields, processexecutionhistory.FieldActivityName)
	}
	if m.activity_type != nil {
		fields = append(fields, processexecutionhistory.FieldActivityType)
	}
	if m.event_type != nil {
		fields = append(fields, processexecutionhistory.FieldEventType)
	}
	if m.event_detail != nil {
		fields = append(fields, processexecutionhistory.FieldEventDetail)
	}
	if m.variables != nil {
		fields = append(fields, processexecutionhistory.FieldVariables)
	}
	if m.user_id != nil {
		fields = append(fields, processexecutionhistory.FieldUserID)
	}
	if m.user_name != nil {
		fields = append(fields, processexecutionhistory.FieldUserName)
	}
	if m.timestamp != nil {
		fields = append(fields, processexecutionhistory.FieldTimestamp)
	}
	if m.comment != nil {
		fields = append(fields, processexecutionhistory.FieldComment)
	}
	if m.error_message != nil {
		fields = append(fields, processexecutionhistory.FieldErrorMessage)
	}
	if m.error_code != nil {
		fields = append(fields, processexecutionhistory.FieldErrorCode)
	}
	if m.tenant_id != nil {
		fields = append(fields, processexecutionhistory.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, processexecutionhistory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessExecutionHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processexecutionhistory.FieldHistoryID:
		return m.HistoryID()
	case processexecutionhistory.FieldProcessInstanceID:
		return m.ProcessInstanceID()
	case processexecutionhistory.FieldProcessDefinitionKey:
		return m.ProcessDefinitionKey()
	case processexecutionhistory.FieldActivityID:
		return m.ActivityID()
	case processexecutionhistory.FieldActivityName:
		return m.ActivityName()
	case processexecutionhistory.FieldActivityType:
		return m.ActivityType()
	case processexecutionhistory.FieldEventType:
		return m.EventType()
	case processexecutionhistory.FieldEventDetail:
		return m.EventDetail()
	case processexecutionhistory.FieldVariables:
		return m.Variables()
	case processexecutionhistory.FieldUserID:
		return m.UserID()
	case processexecutionhistory.FieldUserName:
		return m.UserName()
	case processexecutionhistory.FieldTimestamp:
		return m.Timestamp()
	case processexecutionhistory.FieldComment:
		return m.Comment()
	case processexecutionhistory.FieldErrorMessage:
		return m.ErrorMessage()
	case processexecutionhistory.FieldErrorCode:
		return m.ErrorCode()
	case processexecutionhistory.FieldTenantID:
		return m.TenantID()
	case processexecutionhistory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessExecutionHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processexecutionhistory.FieldHistoryID:
		return m.OldHistoryID(ctx)
	case processexecutionhistory.FieldProcessInstanceID:
		return m.OldProcessInstanceID(ctx)
	case processexecutionhistory.FieldProcessDefinitionKey:
		return m.OldProcessDefinitionKey(ctx)
	case processexecutionhistory.FieldActivityID:
		return m.OldActivityID(ctx)
	case processexecutionhistory.FieldActivityName:
		return m.OldActivityName(ctx)
	case processexecutionhistory.FieldActivityType:
		return m.OldActivityType(ctx)
	case processexecutionhistory.FieldEventType:
		return m.OldEventType(ctx)
	case processexecutionhistory.FieldEventDetail:
		return m.OldEventDetail(ctx)
	case processexecutionhistory.FieldVariables:
		return m.OldVariables(ctx)
	case processexecutionhistory.FieldUserID:
		return m.OldUserID(ctx)
	case processexecutionhistory.FieldUserName:
		return m.OldUserName(ctx)
	case processexecutionhistory.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case processexecutionhistory.FieldComment:
		return m.OldComment(ctx)
	case processexecutionhistory.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case processexecutionhistory.FieldErrorCode:
		return m.OldErrorCode(ctx)
	case processexecutionhistory.FieldTenantID:
		return m.OldTenantID(ctx)
	case processexecutionhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessExecutionHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessExecutionHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processexecutionhistory.FieldHistoryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryID(v)
		return nil
	case processexecutionhistory.FieldProcessInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessInstanceID(v)
		return nil
	case processexecutionhistory.FieldProcessDefinitionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessDefinitionKey(v)
		return nil
	case processexecutionhistory.FieldActivityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityID(v)
		return nil
	case processexecutionhistory.FieldActivityName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityName(v)
		return nil
	case processexecutionhistory.FieldActivityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityType(v)
		return nil
	case processexecutionhistory.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case processexecutionhistory.FieldEventDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventDetail(v)
		return nil
	case processexecutionhistory.FieldVariables:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case processexecutionhistory.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case processexecutionhistory.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case processexecutionhistory.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case processexecutionhistory.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case processexecutionhistory.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case processexecutionhistory.FieldErrorCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCode(v)
		return nil
	case processexecutionhistory.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case processexecutionhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessExecutionHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessExecutionHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, processexecutionhistory.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessExecutionHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processexecutionhistory.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessExecutionHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processexecutionhistory.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessExecutionHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessExecutionHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(processexecutionhistory.FieldActivityID) {
		fields = append(fields, processexecutionhistory.FieldActivityID)
	}
	if m.FieldCleared(processexecutionhistory.FieldActivityName) {
		fields = append(fields, processexecutionhistory.FieldActivityName)
	}
	if m.FieldCleared(processexecutionhistory.FieldEventDetail) {
		fields = append(fields, processexecutionhistory.FieldEventDetail)
	}
	if m.FieldCleared(processexecutionhistory.FieldVariables) {
		fields = append(fields, processexecutionhistory.FieldVariables)
	}
	if m.FieldCleared(processexecutionhistory.FieldUserID) {
		fields = append(fields, processexecutionhistory.FieldUserID)
	}
	if m.FieldCleared(processexecutionhistory.FieldUserName) {
		fields = append(fields, processexecutionhistory.FieldUserName)
	}
	if m.FieldCleared(processexecutionhistory.FieldComment) {
		fields = append(fields, processexecutionhistory.FieldComment)
	}
	if m.FieldCleared(processexecutionhistory.FieldErrorMessage) {
		fields = append(fields, processexecutionhistory.FieldErrorMessage)
	}
	if m.FieldCleared(processexecutionhistory.FieldErrorCode) {
		fields = append(fields, processexecutionhistory.FieldErrorCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessExecutionHistoryMutation) ClearField(name string) error {
	switch name {
	case processexecutionhistory.FieldActivityID:
		m.ClearActivityID()
		return nil
	case processexecutionhistory.FieldActivityName:
		m.ClearActivityName()
		return nil
	case processexecutionhistory.FieldEventDetail:
		m.ClearEventDetail()
		return nil
	case processexecutionhistory.FieldVariables:
		m.ClearVariables()
		return nil
	case processexecutionhistory.FieldUserID:
		m.ClearUserID()
		return nil
	case processexecutionhistory.FieldUserName:
		m.ClearUserName()
		return nil
	case processexecutionhistory.FieldComment:
		m.ClearComment()
		return nil
	case processexecutionhistory.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case processexecutionhistory.FieldErrorCode:
		m.ClearErrorCode()
		return nil
	}
	return fmt.Errorf("unknown ProcessExecutionHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessExecutionHistoryMutation) ResetField(name string) error {
	switch name {
	case processexecutionhistory.FieldHistoryID:
		m.ResetHistoryID()
		return nil
	case processexecutionhistory.FieldProcessInstanceID:
		m.ResetProcessInstanceID()
		return nil
	case processexecutionhistory.FieldProcessDefinitionKey:
		m.ResetProcessDefinitionKey()
		return nil
	case processexecutionhistory.FieldActivityID:
		m.ResetActivityID()
		return nil
	case processexecutionhistory.FieldActivityName:
		m.ResetActivityName()
		return nil
	case processexecutionhistory.FieldActivityType:
		m.ResetActivityType()
		return nil
	case processexecutionhistory.FieldEventType:
		m.ResetEventType()
		return nil
	case processexecutionhistory.FieldEventDetail:
		m.ResetEventDetail()
		return nil
	case processexecutionhistory.FieldVariables:
		m.ResetVariables()
		return nil
	case processexecutionhistory.FieldUserID:
		m.ResetUserID()
		return nil
	case processexecutionhistory.FieldUserName:
		m.ResetUserName()
		return nil
	case processexecutionhistory.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case processexecutionhistory.FieldComment:
		m.ResetComment()
		return nil
	case processexecutionhistory.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case processexecutionhistory.FieldErrorCode:
		m.ResetErrorCode()
		return nil
	case processexecutionhistory.FieldTenantID:
		m.ResetTenantID()
		return nil
	case processexecutionhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessExecutionHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessExecutionHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessExecutionHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessExecutionHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessExecutionHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessExecutionHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessExecutionHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessExecutionHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessExecutionHistory edge %s", name)
}

// ProcessInstanceMutation represents an operation that mutates the ProcessInstance nodes in the graph.
type ProcessInstanceMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	process_instance_id        *string
	business_key               *string
	process_definition_key     *string
	process_definition_id      *string
	status                     *string
	current_activity_id        *string
	current_activity_name      *string
	variables                  *map[string]interface{}
	start_time                 *time.Time
	end_time                   *time.Time
	suspended_time             *time.Time
	suspended_reason           *string
	tenant_id                  *int
	addtenant_id               *int
	initiator                  *string
	parent_process_instance_id *string
	root_process_instance_id   *string
	state_snapshot             *[]uint8
	appendstate_snapshot       []uint8
	created_at                 *time.Time
	updated_at                 *time.Time
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*ProcessInstance, error)
	predicates                 []predicate.ProcessInstance
}

var _ ent.Mutation = (*ProcessInstanceMutation)(nil)

// processinstanceOption allows management of the mutation configuration using functional options.
type processinstanceOption func(*ProcessInstanceMutation)

// newProcessInstanceMutation creates new mutation for the ProcessInstance entity.
func newProcessInstanceMutation(c config, op Op, opts ...processinstanceOption) *ProcessInstanceMutation {
	m := &ProcessInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessInstanceID sets the ID field of the mutation.
func withProcessInstanceID(id int) processinstanceOption {
	return func(m *ProcessInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessInstance
		)
		m.oldValue = func(ctx context.Context) (*ProcessInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessInstance sets the old ProcessInstance of the mutation.
func withProcessInstance(node *ProcessInstance) processinstanceOption {
	return func(m *ProcessInstanceMutation) {
		m.oldValue = func(context.Context) (*ProcessInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessInstanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessInstanceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProcessInstanceID sets the "process_instance_id" field.
func (m *ProcessInstanceMutation) SetProcessInstanceID(s string) {
	m.process_instance_id = &s
}

// ProcessInstanceID returns the value of the "process_instance_id" field in the mutation.
func (m *ProcessInstanceMutation) ProcessInstanceID() (r string, exists bool) {
	v := m.process_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessInstanceID returns the old "process_instance_id" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldProcessInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessInstanceID: %w", err)
	}
	return oldValue.ProcessInstanceID, nil
}

// ResetProcessInstanceID resets all changes to the "process_instance_id" field.
func (m *ProcessInstanceMutation) ResetProcessInstanceID() {
	m.process_instance_id = nil
}

// SetBusinessKey sets the "business_key" field.
func (m *ProcessInstanceMutation) SetBusinessKey(s string) {
	m.business_key = &s
}

// BusinessKey returns the value of the "business_key" field in the mutation.
func (m *ProcessInstanceMutation) BusinessKey() (r string, exists bool) {
	v := m.business_key
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessKey returns the old "business_key" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldBusinessKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessKey: %w", err)
	}
	return oldValue.BusinessKey, nil
}

// ClearBusinessKey clears the value of the "business_key" field.
func (m *ProcessInstanceMutation) ClearBusinessKey() {
	m.business_key = nil
	m.clearedFields[processinstance.FieldBusinessKey] = struct{}{}
}

// BusinessKeyCleared returns if the "business_key" field was cleared in this mutation.
func (m *ProcessInstanceMutation) BusinessKeyCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldBusinessKey]
	return ok
}

// ResetBusinessKey resets all changes to the "business_key" field.
func (m *ProcessInstanceMutation) ResetBusinessKey() {
	m.business_key = nil
	delete(m.clearedFields, processinstance.FieldBusinessKey)
}

// SetProcessDefinitionKey sets the "process_definition_key" field.
func (m *ProcessInstanceMutation) SetProcessDefinitionKey(s string) {
	m.process_definition_key = &s
}

// ProcessDefinitionKey returns the value of the "process_definition_key" field in the mutation.
func (m *ProcessInstanceMutation) ProcessDefinitionKey() (r string, exists bool) {
	v := m.process_definition_key
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessDefinitionKey returns the old "process_definition_key" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldProcessDefinitionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessDefinitionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessDefinitionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessDefinitionKey: %w", err)
	}
	return oldValue.ProcessDefinitionKey, nil
}

// ResetProcessDefinitionKey resets all changes to the "process_definition_key" field.
func (m *ProcessInstanceMutation) ResetProcessDefinitionKey() {
	m.process_definition_key = nil
}

// SetProcessDefinitionID sets the "process_definition_id" field.
func (m *ProcessInstanceMutation) SetProcessDefinitionID(s string) {
	m.process_definition_id = &s
}

// ProcessDefinitionID returns the value of the "process_definition_id" field in the mutation.
func (m *ProcessInstanceMutation) ProcessDefinitionID() (r string, exists bool) {
	v := m.process_definition_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessDefinitionID returns the old "process_definition_id" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldProcessDefinitionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessDefinitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessDefinitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessDefinitionID: %w", err)
	}
	return oldValue.ProcessDefinitionID, nil
}

// ResetProcessDefinitionID resets all changes to the "process_definition_id" field.
func (m *ProcessInstanceMutation) ResetProcessDefinitionID() {
	m.process_definition_id = nil
}

// SetStatus sets the "status" field.
func (m *ProcessInstanceMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProcessInstanceMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProcessInstanceMutation) ResetStatus() {
	m.status = nil
}

// SetCurrentActivityID sets the "current_activity_id" field.
func (m *ProcessInstanceMutation) SetCurrentActivityID(s string) {
	m.current_activity_id = &s
}

// CurrentActivityID returns the value of the "current_activity_id" field in the mutation.
func (m *ProcessInstanceMutation) CurrentActivityID() (r string, exists bool) {
	v := m.current_activity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentActivityID returns the old "current_activity_id" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldCurrentActivityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentActivityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentActivityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentActivityID: %w", err)
	}
	return oldValue.CurrentActivityID, nil
}

// ClearCurrentActivityID clears the value of the "current_activity_id" field.
func (m *ProcessInstanceMutation) ClearCurrentActivityID() {
	m.current_activity_id = nil
	m.clearedFields[processinstance.FieldCurrentActivityID] = struct{}{}
}

// CurrentActivityIDCleared returns if the "current_activity_id" field was cleared in this mutation.
func (m *ProcessInstanceMutation) CurrentActivityIDCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldCurrentActivityID]
	return ok
}

// ResetCurrentActivityID resets all changes to the "current_activity_id" field.
func (m *ProcessInstanceMutation) ResetCurrentActivityID() {
	m.current_activity_id = nil
	delete(m.clearedFields, processinstance.FieldCurrentActivityID)
}

// SetCurrentActivityName sets the "current_activity_name" field.
func (m *ProcessInstanceMutation) SetCurrentActivityName(s string) {
	m.current_activity_name = &s
}

// CurrentActivityName returns the value of the "current_activity_name" field in the mutation.
func (m *ProcessInstanceMutation) CurrentActivityName() (r string, exists bool) {
	v := m.current_activity_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentActivityName returns the old "current_activity_name" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldCurrentActivityName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentActivityName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentActivityName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentActivityName: %w", err)
	}
	return oldValue.CurrentActivityName, nil
}

// ClearCurrentActivityName clears the value of the "current_activity_name" field.
func (m *ProcessInstanceMutation) ClearCurrentActivityName() {
	m.current_activity_name = nil
	m.clearedFields[processinstance.FieldCurrentActivityName] = struct{}{}
}

// CurrentActivityNameCleared returns if the "current_activity_name" field was cleared in this mutation.
func (m *ProcessInstanceMutation) CurrentActivityNameCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldCurrentActivityName]
	return ok
}

// ResetCurrentActivityName resets all changes to the "current_activity_name" field.
func (m *ProcessInstanceMutation) ResetCurrentActivityName() {
	m.current_activity_name = nil
	delete(m.clearedFields, processinstance.FieldCurrentActivityName)
}

// SetVariables sets the "variables" field.
func (m *ProcessInstanceMutation) SetVariables(value map[string]interface{}) {
	m.variables = &value
}

// Variables returns the value of the "variables" field in the mutation.
func (m *ProcessInstanceMutation) Variables() (r map[string]interface{}, exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old "variables" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldVariables(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// ClearVariables clears the value of the "variables" field.
func (m *ProcessInstanceMutation) ClearVariables() {
	m.variables = nil
	m.clearedFields[processinstance.FieldVariables] = struct{}{}
}

// VariablesCleared returns if the "variables" field was cleared in this mutation.
func (m *ProcessInstanceMutation) VariablesCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldVariables]
	return ok
}

// ResetVariables resets all changes to the "variables" field.
func (m *ProcessInstanceMutation) ResetVariables() {
	m.variables = nil
	delete(m.clearedFields, processinstance.FieldVariables)
}

// SetStartTime sets the "start_time" field.
func (m *ProcessInstanceMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ProcessInstanceMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ProcessInstanceMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *ProcessInstanceMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ProcessInstanceMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *ProcessInstanceMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[processinstance.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *ProcessInstanceMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ProcessInstanceMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, processinstance.FieldEndTime)
}

// SetSuspendedTime sets the "suspended_time" field.
func (m *ProcessInstanceMutation) SetSuspendedTime(t time.Time) {
	m.suspended_time = &t
}

// SuspendedTime returns the value of the "suspended_time" field in the mutation.
func (m *ProcessInstanceMutation) SuspendedTime() (r time.Time, exists bool) {
	v := m.suspended_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspendedTime returns the old "suspended_time" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldSuspendedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspendedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspendedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspendedTime: %w", err)
	}
	return oldValue.SuspendedTime, nil
}

// ClearSuspendedTime clears the value of the "suspended_time" field.
func (m *ProcessInstanceMutation) ClearSuspendedTime() {
	m.suspended_time = nil
	m.clearedFields[processinstance.FieldSuspendedTime] = struct{}{}
}

// SuspendedTimeCleared returns if the "suspended_time" field was cleared in this mutation.
func (m *ProcessInstanceMutation) SuspendedTimeCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldSuspendedTime]
	return ok
}

// ResetSuspendedTime resets all changes to the "suspended_time" field.
func (m *ProcessInstanceMutation) ResetSuspendedTime() {
	m.suspended_time = nil
	delete(m.clearedFields, processinstance.FieldSuspendedTime)
}

// SetSuspendedReason sets the "suspended_reason" field.
func (m *ProcessInstanceMutation) SetSuspendedReason(s string) {
	m.suspended_reason = &s
}

// SuspendedReason returns the value of the "suspended_reason" field in the mutation.
func (m *ProcessInstanceMutation) SuspendedReason() (r string, exists bool) {
	v := m.suspended_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspendedReason returns the old "suspended_reason" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldSuspendedReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspendedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspendedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspendedReason: %w", err)
	}
	return oldValue.SuspendedReason, nil
}

// ClearSuspendedReason clears the value of the "suspended_reason" field.
func (m *ProcessInstanceMutation) ClearSuspendedReason() {
	m.suspended_reason = nil
	m.clearedFields[processinstance.FieldSuspendedReason] = struct{}{}
}

// SuspendedReasonCleared returns if the "suspended_reason" field was cleared in this mutation.
func (m *ProcessInstanceMutation) SuspendedReasonCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldSuspendedReason]
	return ok
}

// ResetSuspendedReason resets all changes to the "suspended_reason" field.
func (m *ProcessInstanceMutation) ResetSuspendedReason() {
	m.suspended_reason = nil
	delete(m.clearedFields, processinstance.FieldSuspendedReason)
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcessInstanceMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcessInstanceMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProcessInstanceMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProcessInstanceMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcessInstanceMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetInitiator sets the "initiator" field.
func (m *ProcessInstanceMutation) SetInitiator(s string) {
	m.initiator = &s
}

// Initiator returns the value of the "initiator" field in the mutation.
func (m *ProcessInstanceMutation) Initiator() (r string, exists bool) {
	v := m.initiator
	if v == nil {
		return
	}
	return *v, true
}

// OldInitiator returns the old "initiator" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldInitiator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitiator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitiator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitiator: %w", err)
	}
	return oldValue.Initiator, nil
}

// ClearInitiator clears the value of the "initiator" field.
func (m *ProcessInstanceMutation) ClearInitiator() {
	m.initiator = nil
	m.clearedFields[processinstance.FieldInitiator] = struct{}{}
}

// InitiatorCleared returns if the "initiator" field was cleared in this mutation.
func (m *ProcessInstanceMutation) InitiatorCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldInitiator]
	return ok
}

// ResetInitiator resets all changes to the "initiator" field.
func (m *ProcessInstanceMutation) ResetInitiator() {
	m.initiator = nil
	delete(m.clearedFields, processinstance.FieldInitiator)
}

// SetParentProcessInstanceID sets the "parent_process_instance_id" field.
func (m *ProcessInstanceMutation) SetParentProcessInstanceID(s string) {
	m.parent_process_instance_id = &s
}

// ParentProcessInstanceID returns the value of the "parent_process_instance_id" field in the mutation.
func (m *ProcessInstanceMutation) ParentProcessInstanceID() (r string, exists bool) {
	v := m.parent_process_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentProcessInstanceID returns the old "parent_process_instance_id" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldParentProcessInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentProcessInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentProcessInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentProcessInstanceID: %w", err)
	}
	return oldValue.ParentProcessInstanceID, nil
}

// ClearParentProcessInstanceID clears the value of the "parent_process_instance_id" field.
func (m *ProcessInstanceMutation) ClearParentProcessInstanceID() {
	m.parent_process_instance_id = nil
	m.clearedFields[processinstance.FieldParentProcessInstanceID] = struct{}{}
}

// ParentProcessInstanceIDCleared returns if the "parent_process_instance_id" field was cleared in this mutation.
func (m *ProcessInstanceMutation) ParentProcessInstanceIDCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldParentProcessInstanceID]
	return ok
}

// ResetParentProcessInstanceID resets all changes to the "parent_process_instance_id" field.
func (m *ProcessInstanceMutation) ResetParentProcessInstanceID() {
	m.parent_process_instance_id = nil
	delete(m.clearedFields, processinstance.FieldParentProcessInstanceID)
}

// SetRootProcessInstanceID sets the "root_process_instance_id" field.
func (m *ProcessInstanceMutation) SetRootProcessInstanceID(s string) {
	m.root_process_instance_id = &s
}

// RootProcessInstanceID returns the value of the "root_process_instance_id" field in the mutation.
func (m *ProcessInstanceMutation) RootProcessInstanceID() (r string, exists bool) {
	v := m.root_process_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRootProcessInstanceID returns the old "root_process_instance_id" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldRootProcessInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootProcessInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootProcessInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootProcessInstanceID: %w", err)
	}
	return oldValue.RootProcessInstanceID, nil
}

// ClearRootProcessInstanceID clears the value of the "root_process_instance_id" field.
func (m *ProcessInstanceMutation) ClearRootProcessInstanceID() {
	m.root_process_instance_id = nil
	m.clearedFields[processinstance.FieldRootProcessInstanceID] = struct{}{}
}

// RootProcessInstanceIDCleared returns if the "root_process_instance_id" field was cleared in this mutation.
func (m *ProcessInstanceMutation) RootProcessInstanceIDCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldRootProcessInstanceID]
	return ok
}

// ResetRootProcessInstanceID resets all changes to the "root_process_instance_id" field.
func (m *ProcessInstanceMutation) ResetRootProcessInstanceID() {
	m.root_process_instance_id = nil
	delete(m.clearedFields, processinstance.FieldRootProcessInstanceID)
}

// SetStateSnapshot sets the "state_snapshot" field.
func (m *ProcessInstanceMutation) SetStateSnapshot(u []uint8) {
	m.state_snapshot = &u
	m.appendstate_snapshot = nil
}

// StateSnapshot returns the value of the "state_snapshot" field in the mutation.
func (m *ProcessInstanceMutation) StateSnapshot() (r []uint8, exists bool) {
	v := m.state_snapshot
	if v == nil {
		return
	}
	return *v, true
}

// OldStateSnapshot returns the old "state_snapshot" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldStateSnapshot(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateSnapshot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateSnapshot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateSnapshot: %w", err)
	}
	return oldValue.StateSnapshot, nil
}

// AppendStateSnapshot adds u to the "state_snapshot" field.
func (m *ProcessInstanceMutation) AppendStateSnapshot(u []uint8) {
	m.appendstate_snapshot = append(m.appendstate_snapshot, u...)
}

// AppendedStateSnapshot returns the list of values that were appended to the "state_snapshot" field in this mutation.
func (m *ProcessInstanceMutation) AppendedStateSnapshot() ([]uint8, bool) {
	if len(m.appendstate_snapshot) == 0 {
		return nil, false
	}
	return m.appendstate_snapshot, true
}

// ClearStateSnapshot clears the value of the "state_snapshot" field.
func (m *ProcessInstanceMutation) ClearStateSnapshot() {
	m.state_snapshot = nil
	m.appendstate_snapshot = nil
	m.clearedFields[processinstance.FieldStateSnapshot] = struct{}{}
}

// StateSnapshotCleared returns if the "state_snapshot" field was cleared in this mutation.
func (m *ProcessInstanceMutation) StateSnapshotCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldStateSnapshot]
	return ok
}

// ResetStateSnapshot resets all changes to the "state_snapshot" field.
func (m *ProcessInstanceMutation) ResetStateSnapshot() {
	m.state_snapshot = nil
	m.appendstate_snapshot = nil
	delete(m.clearedFields, processinstance.FieldStateSnapshot)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessInstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessInstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessInstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessInstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessInstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProcessInstanceMutation builder.
func (m *ProcessInstanceMutation) Where(ps ...predicate.ProcessInstance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcessInstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcessInstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcessInstance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcessInstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcessInstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcessInstance).
func (m *ProcessInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessInstanceMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.process_instance_id != nil {
		fields = append(fields, processinstance.FieldProcessInstanceID)
	}
	if m.business_key != nil {
		fields = append(fields, processinstance.FieldBusinessKey)
	}
	if m.process_definition_key != nil {
		fields = append(fields, processinstance.FieldProcessDefinitionKey)
	}
	if m.process_definition_id != nil {
		fields = append(fields, processinstance.FieldProcessDefinitionID)
	}
	if m.status != nil {
		fields = append(fields, processinstance.FieldStatus)
	}
	if m.current_activity_id != nil {
		fields = append(fields, processinstance.FieldCurrentActivityID)
	}
	if m.current_activity_name != nil {
		fields = append(fields, processinstance.FieldCurrentActivityName)
	}
	if m.variables != nil {
		fields = append(fields, processinstance.FieldVariables)
	}
	if m.start_time != nil {
		fields = append(fields, processinstance.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, processinstance.FieldEndTime)
	}
	if m.suspended_time != nil {
		fields = append(fields, processinstance.FieldSuspendedTime)
	}
	if m.suspended_reason != nil {
		fields = append(fields, processinstance.FieldSuspendedReason)
	}
	if m.tenant_id != nil {
		fields = append(fields, processinstance.FieldTenantID)
	}
	if m.initiator != nil {
		fields = append(fields, processinstance.FieldInitiator)
	}
	if m.parent_process_instance_id != nil {
		fields = append(fields, processinstance.FieldParentProcessInstanceID)
	}
	if m.root_process_instance_id != nil {
		fields = append(fields, processinstance.FieldRootProcessInstanceID)
	}
	if m.state_snapshot != nil {
		fields = append(fields, processinstance.FieldStateSnapshot)
	}
	if m.created_at != nil {
		fields = append(fields, processinstance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, processinstance.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processinstance.FieldProcessInstanceID:
		return m.ProcessInstanceID()
	case processinstance.FieldBusinessKey:
		return m.BusinessKey()
	case processinstance.FieldProcessDefinitionKey:
		return m.ProcessDefinitionKey()
	case processinstance.FieldProcessDefinitionID:
		return m.ProcessDefinitionID()
	case processinstance.FieldStatus:
		return m.Status()
	case processinstance.FieldCurrentActivityID:
		return m.CurrentActivityID()
	case processinstance.FieldCurrentActivityName:
		return m.CurrentActivityName()
	case processinstance.FieldVariables:
		return m.Variables()
	case processinstance.FieldStartTime:
		return m.StartTime()
	case processinstance.FieldEndTime:
		return m.EndTime()
	case processinstance.FieldSuspendedTime:
		return m.SuspendedTime()
	case processinstance.FieldSuspendedReason:
		return m.SuspendedReason()
	case processinstance.FieldTenantID:
		return m.TenantID()
	case processinstance.FieldInitiator:
		return m.Initiator()
	case processinstance.FieldParentProcessInstanceID:
		return m.ParentProcessInstanceID()
	case processinstance.FieldRootProcessInstanceID:
		return m.RootProcessInstanceID()
	case processinstance.FieldStateSnapshot:
		return m.StateSnapshot()
	case processinstance.FieldCreatedAt:
		return m.CreatedAt()
	case processinstance.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processinstance.FieldProcessInstanceID:
		return m.OldProcessInstanceID(ctx)
	case processinstance.FieldBusinessKey:
		return m.OldBusinessKey(ctx)
	case processinstance.FieldProcessDefinitionKey:
		return m.OldProcessDefinitionKey(ctx)
	case processinstance.FieldProcessDefinitionID:
		return m.OldProcessDefinitionID(ctx)
	case processinstance.FieldStatus:
		return m.OldStatus(ctx)
	case processinstance.FieldCurrentActivityID:
		return m.OldCurrentActivityID(ctx)
	case processinstance.FieldCurrentActivityName:
		return m.OldCurrentActivityName(ctx)
	case processinstance.FieldVariables:
		return m.OldVariables(ctx)
	case processinstance.FieldStartTime:
		return m.OldStartTime(ctx)
	case processinstance.FieldEndTime:
		return m.OldEndTime(ctx)
	case processinstance.FieldSuspendedTime:
		return m.OldSuspendedTime(ctx)
	case processinstance.FieldSuspendedReason:
		return m.OldSuspendedReason(ctx)
	case processinstance.FieldTenantID:
		return m.OldTenantID(ctx)
	case processinstance.FieldInitiator:
		return m.OldInitiator(ctx)
	case processinstance.FieldParentProcessInstanceID:
		return m.OldParentProcessInstanceID(ctx)
	case processinstance.FieldRootProcessInstanceID:
		return m.OldRootProcessInstanceID(ctx)
	case processinstance.FieldStateSnapshot:
		return m.OldStateSnapshot(ctx)
	case processinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case processinstance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processinstance.FieldProcessInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessInstanceID(v)
		return nil
	case processinstance.FieldBusinessKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessKey(v)
		return nil
	case processinstance.FieldProcessDefinitionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessDefinitionKey(v)
		return nil
	case processinstance.FieldProcessDefinitionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessDefinitionID(v)
		return nil
	case processinstance.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case processinstance.FieldCurrentActivityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentActivityID(v)
		return nil
	case processinstance.FieldCurrentActivityName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentActivityName(v)
		return nil
	case processinstance.FieldVariables:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case processinstance.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case processinstance.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case processinstance.FieldSuspendedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspendedTime(v)
		return nil
	case processinstance.FieldSuspendedReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspendedReason(v)
		return nil
	case processinstance.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case processinstance.FieldInitiator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitiator(v)
		return nil
	case processinstance.FieldParentProcessInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentProcessInstanceID(v)
		return nil
	case processinstance.FieldRootProcessInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootProcessInstanceID(v)
		return nil
	case processinstance.FieldStateSnapshot:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateSnapshot(v)
		return nil
	case processinstance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case processinstance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessInstanceMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, processinstance.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processinstance.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processinstance.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(processinstance.FieldBusinessKey) {
		fields = append(fields, processinstance.FieldBusinessKey)
	}
	if m.FieldCleared(processinstance.FieldCurrentActivityID) {
		fields = append(fields, processinstance.FieldCurrentActivityID)
	}
	if m.FieldCleared(processinstance.FieldCurrentActivityName) {
		fields = append(fields, processinstance.FieldCurrentActivityName)
	}
	if m.FieldCleared(processinstance.FieldVariables) {
		fields = append(fields, processinstance.FieldVariables)
	}
	if m.FieldCleared(processinstance.FieldEndTime) {
		fields = append(fields, processinstance.FieldEndTime)
	}
	if m.FieldCleared(processinstance.FieldSuspendedTime) {
		fields = append(fields, processinstance.FieldSuspendedTime)
	}
	if m.FieldCleared(processinstance.FieldSuspendedReason) {
		fields = append(fields, processinstance.FieldSuspendedReason)
	}
	if m.FieldCleared(processinstance.FieldInitiator) {
		fields = append(fields, processinstance.FieldInitiator)
	}
	if m.FieldCleared(processinstance.FieldParentProcessInstanceID) {
		fields = append(fields, processinstance.FieldParentProcessInstanceID)
	}
	if m.FieldCleared(processinstance.FieldRootProcessInstanceID) {
		fields = append(fields, processinstance.FieldRootProcessInstanceID)
	}
	if m.FieldCleared(processinstance.FieldStateSnapshot) {
		fields = append(fields, processinstance.FieldStateSnapshot)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessInstanceMutation) ClearField(name string) error {
	switch name {
	case processinstance.FieldBusinessKey:
		m.ClearBusinessKey()
		return nil
	case processinstance.FieldCurrentActivityID:
		m.ClearCurrentActivityID()
		return nil
	case processinstance.FieldCurrentActivityName:
		m.ClearCurrentActivityName()
		return nil
	case processinstance.FieldVariables:
		m.ClearVariables()
		return nil
	case processinstance.FieldEndTime:
		m.ClearEndTime()
		return nil
	case processinstance.FieldSuspendedTime:
		m.ClearSuspendedTime()
		return nil
	case processinstance.FieldSuspendedReason:
		m.ClearSuspendedReason()
		return nil
	case processinstance.FieldInitiator:
		m.ClearInitiator()
		return nil
	case processinstance.FieldParentProcessInstanceID:
		m.ClearParentProcessInstanceID()
		return nil
	case processinstance.FieldRootProcessInstanceID:
		m.ClearRootProcessInstanceID()
		return nil
	case processinstance.FieldStateSnapshot:
		m.ClearStateSnapshot()
		return nil
	}
	return fmt.Errorf("unknown ProcessInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessInstanceMutation) ResetField(name string) error {
	switch name {
	case processinstance.FieldProcessInstanceID:
		m.ResetProcessInstanceID()
		return nil
	case processinstance.FieldBusinessKey:
		m.ResetBusinessKey()
		return nil
	case processinstance.FieldProcessDefinitionKey:
		m.ResetProcessDefinitionKey()
		return nil
	case processinstance.FieldProcessDefinitionID:
		m.ResetProcessDefinitionID()
		return nil
	case processinstance.FieldStatus:
		m.ResetStatus()
		return nil
	case processinstance.FieldCurrentActivityID:
		m.ResetCurrentActivityID()
		return nil
	case processinstance.FieldCurrentActivityName:
		m.ResetCurrentActivityName()
		return nil
	case processinstance.FieldVariables:
		m.ResetVariables()
		return nil
	case processinstance.FieldStartTime:
		m.ResetStartTime()
		return nil
	case processinstance.FieldEndTime:
		m.ResetEndTime()
		return nil
	case processinstance.FieldSuspendedTime:
		m.ResetSuspendedTime()
		return nil
	case processinstance.FieldSuspendedReason:
		m.ResetSuspendedReason()
		return nil
	case processinstance.FieldTenantID:
		m.ResetTenantID()
		return nil
	case processinstance.FieldInitiator:
		m.ResetInitiator()
		return nil
	case processinstance.FieldParentProcessInstanceID:
		m.ResetParentProcessInstanceID()
		return nil
	case processinstance.FieldRootProcessInstanceID:
		m.ResetRootProcessInstanceID()
		return nil
	case processinstance.FieldStateSnapshot:
		m.ResetStateSnapshot()
		return nil
	case processinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case processinstance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessInstanceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessInstanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessInstanceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessInstanceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessInstanceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessInstance edge %s", name)
}

// ProcessTaskMutation represents an operation that mutates the ProcessTask nodes in the graph.
type ProcessTaskMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	task_id                *string
	process_instance_id    *string
	process_definition_key *string
	task_definition_key    *string
	task_name              *string
	task_type              *string
	assignee               *string
	candidate_users        *string
	candidate_groups       *string
	status                 *string
	priority               *string
	due_date               *time.Time
	created_time           *time.Time
	assigned_time          *time.Time
	started_time           *time.Time
	completed_time         *time.Time
	form_key               *string
	task_variables         *map[string]interface{}
	description            *string
	parent_task_id         *string
	root_task_id           *string
	tenant_id              *int
	addtenant_id           *int
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ProcessTask, error)
	predicates             []predicate.ProcessTask
}

var _ ent.Mutation = (*ProcessTaskMutation)(nil)

// processtaskOption allows management of the mutation configuration using functional options.
type processtaskOption func(*ProcessTaskMutation)

// newProcessTaskMutation creates new mutation for the ProcessTask entity.
func newProcessTaskMutation(c config, op Op, opts ...processtaskOption) *ProcessTaskMutation {
	m := &ProcessTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessTaskID sets the ID field of the mutation.
func withProcessTaskID(id int) processtaskOption {
	return func(m *ProcessTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessTask
		)
		m.oldValue = func(ctx context.Context) (*ProcessTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessTask sets the old ProcessTask of the mutation.
func withProcessTask(node *ProcessTask) processtaskOption {
	return func(m *ProcessTaskMutation) {
		m.oldValue = func(context.Context) (*ProcessTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessTaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessTaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *ProcessTaskMutation) SetTaskID(s string) {
	m.task_id = &s
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *ProcessTaskMutation) TaskID() (r string, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *ProcessTaskMutation) ResetTaskID() {
	m.task_id = nil
}

// SetProcessInstanceID sets the "process_instance_id" field.
func (m *ProcessTaskMutation) SetProcessInstanceID(s string) {
	m.process_instance_id = &s
}

// ProcessInstanceID returns the value of the "process_instance_id" field in the mutation.
func (m *ProcessTaskMutation) ProcessInstanceID() (r string, exists bool) {
	v := m.process_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessInstanceID returns the old "process_instance_id" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldProcessInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessInstanceID: %w", err)
	}
	return oldValue.ProcessInstanceID, nil
}

// ResetProcessInstanceID resets all changes to the "process_instance_id" field.
func (m *ProcessTaskMutation) ResetProcessInstanceID() {
	m.process_instance_id = nil
}

// SetProcessDefinitionKey sets the "process_definition_key" field.
func (m *ProcessTaskMutation) SetProcessDefinitionKey(s string) {
	m.process_definition_key = &s
}

// ProcessDefinitionKey returns the value of the "process_definition_key" field in the mutation.
func (m *ProcessTaskMutation) ProcessDefinitionKey() (r string, exists bool) {
	v := m.process_definition_key
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessDefinitionKey returns the old "process_definition_key" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldProcessDefinitionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessDefinitionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessDefinitionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessDefinitionKey: %w", err)
	}
	return oldValue.ProcessDefinitionKey, nil
}

// ResetProcessDefinitionKey resets all changes to the "process_definition_key" field.
func (m *ProcessTaskMutation) ResetProcessDefinitionKey() {
	m.process_definition_key = nil
}

// SetTaskDefinitionKey sets the "task_definition_key" field.
func (m *ProcessTaskMutation) SetTaskDefinitionKey(s string) {
	m.task_definition_key = &s
}

// TaskDefinitionKey returns the value of the "task_definition_key" field in the mutation.
func (m *ProcessTaskMutation) TaskDefinitionKey() (r string, exists bool) {
	v := m.task_definition_key
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskDefinitionKey returns the old "task_definition_key" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldTaskDefinitionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskDefinitionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskDefinitionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskDefinitionKey: %w", err)
	}
	return oldValue.TaskDefinitionKey, nil
}

// ResetTaskDefinitionKey resets all changes to the "task_definition_key" field.
func (m *ProcessTaskMutation) ResetTaskDefinitionKey() {
	m.task_definition_key = nil
}

// SetTaskName sets the "task_name" field.
func (m *ProcessTaskMutation) SetTaskName(s string) {
	m.task_name = &s
}

// TaskName returns the value of the "task_name" field in the mutation.
func (m *ProcessTaskMutation) TaskName() (r string, exists bool) {
	v := m.task_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskName returns the old "task_name" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldTaskName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskName: %w", err)
	}
	return oldValue.TaskName, nil
}

// ResetTaskName resets all changes to the "task_name" field.
func (m *ProcessTaskMutation) ResetTaskName() {
	m.task_name = nil
}

// SetTaskType sets the "task_type" field.
func (m *ProcessTaskMutation) SetTaskType(s string) {
	m.task_type = &s
}

// TaskType returns the value of the "task_type" field in the mutation.
func (m *ProcessTaskMutation) TaskType() (r string, exists bool) {
	v := m.task_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskType returns the old "task_type" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldTaskType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskType: %w", err)
	}
	return oldValue.TaskType, nil
}

// ResetTaskType resets all changes to the "task_type" field.
func (m *ProcessTaskMutation) ResetTaskType() {
	m.task_type = nil
}

// SetAssignee sets the "assignee" field.
func (m *ProcessTaskMutation) SetAssignee(s string) {
	m.assignee = &s
}

// Assignee returns the value of the "assignee" field in the mutation.
func (m *ProcessTaskMutation) Assignee() (r string, exists bool) {
	v := m.assignee
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignee returns the old "assignee" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldAssignee(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignee: %w", err)
	}
	return oldValue.Assignee, nil
}

// ClearAssignee clears the value of the "assignee" field.
func (m *ProcessTaskMutation) ClearAssignee() {
	m.assignee = nil
	m.clearedFields[processtask.FieldAssignee] = struct{}{}
}

// AssigneeCleared returns if the "assignee" field was cleared in this mutation.
func (m *ProcessTaskMutation) AssigneeCleared() bool {
	_, ok := m.clearedFields[processtask.FieldAssignee]
	return ok
}

// ResetAssignee resets all changes to the "assignee" field.
func (m *ProcessTaskMutation) ResetAssignee() {
	m.assignee = nil
	delete(m.clearedFields, processtask.FieldAssignee)
}

// SetCandidateUsers sets the "candidate_users" field.
func (m *ProcessTaskMutation) SetCandidateUsers(s string) {
	m.candidate_users = &s
}

// CandidateUsers returns the value of the "candidate_users" field in the mutation.
func (m *ProcessTaskMutation) CandidateUsers() (r string, exists bool) {
	v := m.candidate_users
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateUsers returns the old "candidate_users" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldCandidateUsers(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateUsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateUsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateUsers: %w", err)
	}
	return oldValue.CandidateUsers, nil
}

// ClearCandidateUsers clears the value of the "candidate_users" field.
func (m *ProcessTaskMutation) ClearCandidateUsers() {
	m.candidate_users = nil
	m.clearedFields[processtask.FieldCandidateUsers] = struct{}{}
}

// CandidateUsersCleared returns if the "candidate_users" field was cleared in this mutation.
func (m *ProcessTaskMutation) CandidateUsersCleared() bool {
	_, ok := m.clearedFields[processtask.FieldCandidateUsers]
	return ok
}

// ResetCandidateUsers resets all changes to the "candidate_users" field.
func (m *ProcessTaskMutation) ResetCandidateUsers() {
	m.candidate_users = nil
	delete(m.clearedFields, processtask.FieldCandidateUsers)
}

// SetCandidateGroups sets the "candidate_groups" field.
func (m *ProcessTaskMutation) SetCandidateGroups(s string) {
	m.candidate_groups = &s
}

// CandidateGroups returns the value of the "candidate_groups" field in the mutation.
func (m *ProcessTaskMutation) CandidateGroups() (r string, exists bool) {
	v := m.candidate_groups
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateGroups returns the old "candidate_groups" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldCandidateGroups(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateGroups: %w", err)
	}
	return oldValue.CandidateGroups, nil
}

// ClearCandidateGroups clears the value of the "candidate_groups" field.
func (m *ProcessTaskMutation) ClearCandidateGroups() {
	m.candidate_groups = nil
	m.clearedFields[processtask.FieldCandidateGroups] = struct{}{}
}

// CandidateGroupsCleared returns if the "candidate_groups" field was cleared in this mutation.
func (m *ProcessTaskMutation) CandidateGroupsCleared() bool {
	_, ok := m.clearedFields[processtask.FieldCandidateGroups]
	return ok
}

// ResetCandidateGroups resets all changes to the "candidate_groups" field.
func (m *ProcessTaskMutation) ResetCandidateGroups() {
	m.candidate_groups = nil
	delete(m.clearedFields, processtask.FieldCandidateGroups)
}

// SetStatus sets the "status" field.
func (m *ProcessTaskMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProcessTaskMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProcessTaskMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *ProcessTaskMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ProcessTaskMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *ProcessTaskMutation) ResetPriority() {
	m.priority = nil
}

// SetDueDate sets the "due_date" field.
func (m *ProcessTaskMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *ProcessTaskMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of the "due_date" field.
func (m *ProcessTaskMutation) ClearDueDate() {
	m.due_date = nil
	m.clearedFields[processtask.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "due_date" field was cleared in this mutation.
func (m *ProcessTaskMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[processtask.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *ProcessTaskMutation) ResetDueDate() {
	m.due_date = nil
	delete(m.clearedFields, processtask.FieldDueDate)
}

// SetCreatedTime sets the "created_time" field.
func (m *ProcessTaskMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *ProcessTaskMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *ProcessTaskMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetAssignedTime sets the "assigned_time" field.
func (m *ProcessTaskMutation) SetAssignedTime(t time.Time) {
	m.assigned_time = &t
}

// AssignedTime returns the value of the "assigned_time" field in the mutation.
func (m *ProcessTaskMutation) AssignedTime() (r time.Time, exists bool) {
	v := m.assigned_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedTime returns the old "assigned_time" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldAssignedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedTime: %w", err)
	}
	return oldValue.AssignedTime, nil
}

// ClearAssignedTime clears the value of the "assigned_time" field.
func (m *ProcessTaskMutation) ClearAssignedTime() {
	m.assigned_time = nil
	m.clearedFields[processtask.FieldAssignedTime] = struct{}{}
}

// AssignedTimeCleared returns if the "assigned_time" field was cleared in this mutation.
func (m *ProcessTaskMutation) AssignedTimeCleared() bool {
	_, ok := m.clearedFields[processtask.FieldAssignedTime]
	return ok
}

// ResetAssignedTime resets all changes to the "assigned_time" field.
func (m *ProcessTaskMutation) ResetAssignedTime() {
	m.assigned_time = nil
	delete(m.clearedFields, processtask.FieldAssignedTime)
}

// SetStartedTime sets the "started_time" field.
func (m *ProcessTaskMutation) SetStartedTime(t time.Time) {
	m.started_time = &t
}

// StartedTime returns the value of the "started_time" field in the mutation.
func (m *ProcessTaskMutation) StartedTime() (r time.Time, exists bool) {
	v := m.started_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedTime returns the old "started_time" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldStartedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedTime: %w", err)
	}
	return oldValue.StartedTime, nil
}

// ClearStartedTime clears the value of the "started_time" field.
func (m *ProcessTaskMutation) ClearStartedTime() {
	m.started_time = nil
	m.clearedFields[processtask.FieldStartedTime] = struct{}{}
}

// StartedTimeCleared returns if the "started_time" field was cleared in this mutation.
func (m *ProcessTaskMutation) StartedTimeCleared() bool {
	_, ok := m.clearedFields[processtask.FieldStartedTime]
	return ok
}

// ResetStartedTime resets all changes to the "started_time" field.
func (m *ProcessTaskMutation) ResetStartedTime() {
	m.started_time = nil
	delete(m.clearedFields, processtask.FieldStartedTime)
}

// SetCompletedTime sets the "completed_time" field.
func (m *ProcessTaskMutation) SetCompletedTime(t time.Time) {
	m.completed_time = &t
}

// CompletedTime returns the value of the "completed_time" field in the mutation.
func (m *ProcessTaskMutation) CompletedTime() (r time.Time, exists bool) {
	v := m.completed_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedTime returns the old "completed_time" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldCompletedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedTime: %w", err)
	}
	return oldValue.CompletedTime, nil
}

// ClearCompletedTime clears the value of the "completed_time" field.
func (m *ProcessTaskMutation) ClearCompletedTime() {
	m.completed_time = nil
	m.clearedFields[processtask.FieldCompletedTime] = struct{}{}
}

// CompletedTimeCleared returns if the "completed_time" field was cleared in this mutation.
func (m *ProcessTaskMutation) CompletedTimeCleared() bool {
	_, ok := m.clearedFields[processtask.FieldCompletedTime]
	return ok
}

// ResetCompletedTime resets all changes to the "completed_time" field.
func (m *ProcessTaskMutation) ResetCompletedTime() {
	m.completed_time = nil
	delete(m.clearedFields, processtask.FieldCompletedTime)
}

// SetFormKey sets the "form_key" field.
func (m *ProcessTaskMutation) SetFormKey(s string) {
	m.form_key = &s
}

// FormKey returns the value of the "form_key" field in the mutation.
func (m *ProcessTaskMutation) FormKey() (r string, exists bool) {
	v := m.form_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFormKey returns the old "form_key" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldFormKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormKey: %w", err)
	}
	return oldValue.FormKey, nil
}

// ClearFormKey clears the value of the "form_key" field.
func (m *ProcessTaskMutation) ClearFormKey() {
	m.form_key = nil
	m.clearedFields[processtask.FieldFormKey] = struct{}{}
}

// FormKeyCleared returns if the "form_key" field was cleared in this mutation.
func (m *ProcessTaskMutation) FormKeyCleared() bool {
	_, ok := m.clearedFields[processtask.FieldFormKey]
	return ok
}

// ResetFormKey resets all changes to the "form_key" field.
func (m *ProcessTaskMutation) ResetFormKey() {
	m.form_key = nil
	delete(m.clearedFields, processtask.FieldFormKey)
}

// SetTaskVariables sets the "task_variables" field.
func (m *ProcessTaskMutation) SetTaskVariables(value map[string]interface{}) {
	m.task_variables = &value
}

// TaskVariables returns the value of the "task_variables" field in the mutation.
func (m *ProcessTaskMutation) TaskVariables() (r map[string]interface{}, exists bool) {
	v := m.task_variables
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskVariables returns the old "task_variables" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldTaskVariables(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskVariables: %w", err)
	}
	return oldValue.TaskVariables, nil
}

// ClearTaskVariables clears the value of the "task_variables" field.
func (m *ProcessTaskMutation) ClearTaskVariables() {
	m.task_variables = nil
	m.clearedFields[processtask.FieldTaskVariables] = struct{}{}
}

// TaskVariablesCleared returns if the "task_variables" field was cleared in this mutation.
func (m *ProcessTaskMutation) TaskVariablesCleared() bool {
	_, ok := m.clearedFields[processtask.FieldTaskVariables]
	return ok
}

// ResetTaskVariables resets all changes to the "task_variables" field.
func (m *ProcessTaskMutation) ResetTaskVariables() {
	m.task_variables = nil
	delete(m.clearedFields, processtask.FieldTaskVariables)
}

// SetDescription sets the "description" field.
func (m *ProcessTaskMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProcessTaskMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProcessTaskMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[processtask.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProcessTaskMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[processtask.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProcessTaskMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, processtask.FieldDescription)
}

// SetParentTaskID sets the "parent_task_id" field.
func (m *ProcessTaskMutation) SetParentTaskID(s string) {
	m.parent_task_id = &s
}

// ParentTaskID returns the value of the "parent_task_id" field in the mutation.
func (m *ProcessTaskMutation) ParentTaskID() (r string, exists bool) {
	v := m.parent_task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentTaskID returns the old "parent_task_id" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldParentTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentTaskID: %w", err)
	}
	return oldValue.ParentTaskID, nil
}

// ClearParentTaskID clears the value of the "parent_task_id" field.
func (m *ProcessTaskMutation) ClearParentTaskID() {
	m.parent_task_id = nil
	m.clearedFields[processtask.FieldParentTaskID] = struct{}{}
}

// ParentTaskIDCleared returns if the "parent_task_id" field was cleared in this mutation.
func (m *ProcessTaskMutation) ParentTaskIDCleared() bool {
	_, ok := m.clearedFields[processtask.FieldParentTaskID]
	return ok
}

// ResetParentTaskID resets all changes to the "parent_task_id" field.
func (m *ProcessTaskMutation) ResetParentTaskID() {
	m.parent_task_id = nil
	delete(m.clearedFields, processtask.FieldParentTaskID)
}

// SetRootTaskID sets the "root_task_id" field.
func (m *ProcessTaskMutation) SetRootTaskID(s string) {
	m.root_task_id = &s
}

// RootTaskID returns the value of the "root_task_id" field in the mutation.
func (m *ProcessTaskMutation) RootTaskID() (r string, exists bool) {
	v := m.root_task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRootTaskID returns the old "root_task_id" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldRootTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootTaskID: %w", err)
	}
	return oldValue.RootTaskID, nil
}

// ClearRootTaskID clears the value of the "root_task_id" field.
func (m *ProcessTaskMutation) ClearRootTaskID() {
	m.root_task_id = nil
	m.clearedFields[processtask.FieldRootTaskID] = struct{}{}
}

// RootTaskIDCleared returns if the "root_task_id" field was cleared in this mutation.
func (m *ProcessTaskMutation) RootTaskIDCleared() bool {
	_, ok := m.clearedFields[processtask.FieldRootTaskID]
	return ok
}

// ResetRootTaskID resets all changes to the "root_task_id" field.
func (m *ProcessTaskMutation) ResetRootTaskID() {
	m.root_task_id = nil
	delete(m.clearedFields, processtask.FieldRootTaskID)
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcessTaskMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcessTaskMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProcessTaskMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProcessTaskMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcessTaskMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProcessTaskMutation builder.
func (m *ProcessTaskMutation) Where(ps ...predicate.ProcessTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcessTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcessTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcessTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcessTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcessTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcessTask).
func (m *ProcessTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessTaskMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.task_id != nil {
		fields = append(fields, processtask.FieldTaskID)
	}
	if m.process_instance_id != nil {
		fields = append(fields, processtask.FieldProcessInstanceID)
	}
	if m.process_definition_key != nil {
		fields = append(fields, processtask.FieldProcessDefinitionKey)
	}
	if m.task_definition_key != nil {
		fields = append(fields, processtask.FieldTaskDefinitionKey)
	}
	if m.task_name != nil {
		fields = append(fields, processtask.FieldTaskName)
	}
	if m.task_type != nil {
		fields = append(fields, processtask.FieldTaskType)
	}
	if m.assignee != nil {
		fields = append(fields, processtask.FieldAssignee)
	}
	if m.candidate_users != nil {
		fields = append(fields, processtask.FieldCandidateUsers)
	}
	if m.candidate_groups != nil {
		fields = append(fields, processtask.FieldCandidateGroups)
	}
	if m.status != nil {
		fields = append(fields, processtask.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, processtask.FieldPriority)
	}
	if m.due_date != nil {
		fields = append(fields, processtask.FieldDueDate)
	}
	if m.created_time != nil {
		fields = append(fields, processtask.FieldCreatedTime)
	}
	if m.assigned_time != nil {
		fields = append(fields, processtask.FieldAssignedTime)
	}
	if m.started_time != nil {
		fields = append(fields, processtask.FieldStartedTime)
	}
	if m.completed_time != nil {
		fields = append(fields, processtask.FieldCompletedTime)
	}
	if m.form_key != nil {
		fields = append(fields, processtask.FieldFormKey)
	}
	if m.task_variables != nil {
		fields = append(fields, processtask.FieldTaskVariables)
	}
	if m.description != nil {
		fields = append(fields, processtask.FieldDescription)
	}
	if m.parent_task_id != nil {
		fields = append(fields, processtask.FieldParentTaskID)
	}
	if m.root_task_id != nil {
		fields = append(fields, processtask.FieldRootTaskID)
	}
	if m.tenant_id != nil {
		fields = append(fields, processtask.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, processtask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, processtask.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processtask.FieldTaskID:
		return m.TaskID()
	case processtask.FieldProcessInstanceID:
		return m.ProcessInstanceID()
	case processtask.FieldProcessDefinitionKey:
		return m.ProcessDefinitionKey()
	case processtask.FieldTaskDefinitionKey:
		return m.TaskDefinitionKey()
	case processtask.FieldTaskName:
		return m.TaskName()
	case processtask.FieldTaskType:
		return m.TaskType()
	case processtask.FieldAssignee:
		return m.Assignee()
	case processtask.FieldCandidateUsers:
		return m.CandidateUsers()
	case processtask.FieldCandidateGroups:
		return m.CandidateGroups()
	case processtask.FieldStatus:
		return m.Status()
	case processtask.FieldPriority:
		return m.Priority()
	case processtask.FieldDueDate:
		return m.DueDate()
	case processtask.FieldCreatedTime:
		return m.CreatedTime()
	case processtask.FieldAssignedTime:
		return m.AssignedTime()
	case processtask.FieldStartedTime:
		return m.StartedTime()
	case processtask.FieldCompletedTime:
		return m.CompletedTime()
	case processtask.FieldFormKey:
		return m.FormKey()
	case processtask.FieldTaskVariables:
		return m.TaskVariables()
	case processtask.FieldDescription:
		return m.Description()
	case processtask.FieldParentTaskID:
		return m.ParentTaskID()
	case processtask.FieldRootTaskID:
		return m.RootTaskID()
	case processtask.FieldTenantID:
		return m.TenantID()
	case processtask.FieldCreatedAt:
		return m.CreatedAt()
	case processtask.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processtask.FieldTaskID:
		return m.OldTaskID(ctx)
	case processtask.FieldProcessInstanceID:
		return m.OldProcessInstanceID(ctx)
	case processtask.FieldProcessDefinitionKey:
		return m.OldProcessDefinitionKey(ctx)
	case processtask.FieldTaskDefinitionKey:
		return m.OldTaskDefinitionKey(ctx)
	case processtask.FieldTaskName:
		return m.OldTaskName(ctx)
	case processtask.FieldTaskType:
		return m.OldTaskType(ctx)
	case processtask.FieldAssignee:
		return m.OldAssignee(ctx)
	case processtask.FieldCandidateUsers:
		return m.OldCandidateUsers(ctx)
	case processtask.FieldCandidateGroups:
		return m.OldCandidateGroups(ctx)
	case processtask.FieldStatus:
		return m.OldStatus(ctx)
	case processtask.FieldPriority:
		return m.OldPriority(ctx)
	case processtask.FieldDueDate:
		return m.OldDueDate(ctx)
	case processtask.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case processtask.FieldAssignedTime:
		return m.OldAssignedTime(ctx)
	case processtask.FieldStartedTime:
		return m.OldStartedTime(ctx)
	case processtask.FieldCompletedTime:
		return m.OldCompletedTime(ctx)
	case processtask.FieldFormKey:
		return m.OldFormKey(ctx)
	case processtask.FieldTaskVariables:
		return m.OldTaskVariables(ctx)
	case processtask.FieldDescription:
		return m.OldDescription(ctx)
	case processtask.FieldParentTaskID:
		return m.OldParentTaskID(ctx)
	case processtask.FieldRootTaskID:
		return m.OldRootTaskID(ctx)
	case processtask.FieldTenantID:
		return m.OldTenantID(ctx)
	case processtask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case processtask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processtask.FieldTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case processtask.FieldProcessInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessInstanceID(v)
		return nil
	case processtask.FieldProcessDefinitionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessDefinitionKey(v)
		return nil
	case processtask.FieldTaskDefinitionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskDefinitionKey(v)
		return nil
	case processtask.FieldTaskName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskName(v)
		return nil
	case processtask.FieldTaskType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskType(v)
		return nil
	case processtask.FieldAssignee:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignee(v)
		return nil
	case processtask.FieldCandidateUsers:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateUsers(v)
		return nil
	case processtask.FieldCandidateGroups:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateGroups(v)
		return nil
	case processtask.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case processtask.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case processtask.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case processtask.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case processtask.FieldAssignedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedTime(v)
		return nil
	case processtask.FieldStartedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedTime(v)
		return nil
	case processtask.FieldCompletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedTime(v)
		return nil
	case processtask.FieldFormKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormKey(v)
		return nil
	case processtask.FieldTaskVariables:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskVariables(v)
		return nil
	case processtask.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case processtask.FieldParentTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentTaskID(v)
		return nil
	case processtask.FieldRootTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootTaskID(v)
		return nil
	case processtask.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case processtask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case processtask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessTaskMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, processtask.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processtask.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processtask.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(processtask.FieldAssignee) {
		fields = append(fields, processtask.FieldAssignee)
	}
	if m.FieldCleared(processtask.FieldCandidateUsers) {
		fields = append(fields, processtask.FieldCandidateUsers)
	}
	if m.FieldCleared(processtask.FieldCandidateGroups) {
		fields = append(fields, processtask.FieldCandidateGroups)
	}
	if m.FieldCleared(processtask.FieldDueDate) {
		fields = append(fields, processtask.FieldDueDate)
	}
	if m.FieldCleared(processtask.FieldAssignedTime) {
		fields = append(fields, processtask.FieldAssignedTime)
	}
	if m.FieldCleared(processtask.FieldStartedTime) {
		fields = append(fields, processtask.FieldStartedTime)
	}
	if m.FieldCleared(processtask.FieldCompletedTime) {
		fields = append(fields, processtask.FieldCompletedTime)
	}
	if m.FieldCleared(processtask.FieldFormKey) {
		fields = append(fields, processtask.FieldFormKey)
	}
	if m.FieldCleared(processtask.FieldTaskVariables) {
		fields = append(fields, processtask.FieldTaskVariables)
	}
	if m.FieldCleared(processtask.FieldDescription) {
		fields = append(fields, processtask.FieldDescription)
	}
	if m.FieldCleared(processtask.FieldParentTaskID) {
		fields = append(fields, processtask.FieldParentTaskID)
	}
	if m.FieldCleared(processtask.FieldRootTaskID) {
		fields = append(fields, processtask.FieldRootTaskID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessTaskMutation) ClearField(name string) error {
	switch name {
	case processtask.FieldAssignee:
		m.ClearAssignee()
		return nil
	case processtask.FieldCandidateUsers:
		m.ClearCandidateUsers()
		return nil
	case processtask.FieldCandidateGroups:
		m.ClearCandidateGroups()
		return nil
	case processtask.FieldDueDate:
		m.ClearDueDate()
		return nil
	case processtask.FieldAssignedTime:
		m.ClearAssignedTime()
		return nil
	case processtask.FieldStartedTime:
		m.ClearStartedTime()
		return nil
	case processtask.FieldCompletedTime:
		m.ClearCompletedTime()
		return nil
	case processtask.FieldFormKey:
		m.ClearFormKey()
		return nil
	case processtask.FieldTaskVariables:
		m.ClearTaskVariables()
		return nil
	case processtask.FieldDescription:
		m.ClearDescription()
		return nil
	case processtask.FieldParentTaskID:
		m.ClearParentTaskID()
		return nil
	case processtask.FieldRootTaskID:
		m.ClearRootTaskID()
		return nil
	}
	return fmt.Errorf("unknown ProcessTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessTaskMutation) ResetField(name string) error {
	switch name {
	case processtask.FieldTaskID:
		m.ResetTaskID()
		return nil
	case processtask.FieldProcessInstanceID:
		m.ResetProcessInstanceID()
		return nil
	case processtask.FieldProcessDefinitionKey:
		m.ResetProcessDefinitionKey()
		return nil
	case processtask.FieldTaskDefinitionKey:
		m.ResetTaskDefinitionKey()
		return nil
	case processtask.FieldTaskName:
		m.ResetTaskName()
		return nil
	case processtask.FieldTaskType:
		m.ResetTaskType()
		return nil
	case processtask.FieldAssignee:
		m.ResetAssignee()
		return nil
	case processtask.FieldCandidateUsers:
		m.ResetCandidateUsers()
		return nil
	case processtask.FieldCandidateGroups:
		m.ResetCandidateGroups()
		return nil
	case processtask.FieldStatus:
		m.ResetStatus()
		return nil
	case processtask.FieldPriority:
		m.ResetPriority()
		return nil
	case processtask.FieldDueDate:
		m.ResetDueDate()
		return nil
	case processtask.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case processtask.FieldAssignedTime:
		m.ResetAssignedTime()
		return nil
	case processtask.FieldStartedTime:
		m.ResetStartedTime()
		return nil
	case processtask.FieldCompletedTime:
		m.ResetCompletedTime()
		return nil
	case processtask.FieldFormKey:
		m.ResetFormKey()
		return nil
	case processtask.FieldTaskVariables:
		m.ResetTaskVariables()
		return nil
	case processtask.FieldDescription:
		m.ResetDescription()
		return nil
	case processtask.FieldParentTaskID:
		m.ResetParentTaskID()
		return nil
	case processtask.FieldRootTaskID:
		m.ResetRootTaskID()
		return nil
	case processtask.FieldTenantID:
		m.ResetTenantID()
		return nil
	case processtask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case processtask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessTaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessTaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessTaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessTaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessTask edge %s", name)
}

// ProcessVariableMutation represents an operation that mutates the ProcessVariable nodes in the graph.
type ProcessVariableMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	variable_id          *string
	process_instance_id  *string
	task_id              *string
	variable_name        *string
	variable_type        *string
	variable_value       *string
	scope                *string
	is_transient         *bool
	serialization_format *string
	tenant_id            *int
	addtenant_id         *int
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*ProcessVariable, error)
	predicates           []predicate.ProcessVariable
}

var _ ent.Mutation = (*ProcessVariableMutation)(nil)

// processvariableOption allows management of the mutation configuration using functional options.
type processvariableOption func(*ProcessVariableMutation)

// newProcessVariableMutation creates new mutation for the ProcessVariable entity.
func newProcessVariableMutation(c config, op Op, opts ...processvariableOption) *ProcessVariableMutation {
	m := &ProcessVariableMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessVariable,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessVariableID sets the ID field of the mutation.
func withProcessVariableID(id int) processvariableOption {
	return func(m *ProcessVariableMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessVariable
		)
		m.oldValue = func(ctx context.Context) (*ProcessVariable, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessVariable.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessVariable sets the old ProcessVariable of the mutation.
func withProcessVariable(node *ProcessVariable) processvariableOption {
	return func(m *ProcessVariableMutation) {
		m.oldValue = func(context.Context) (*ProcessVariable, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessVariableMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessVariableMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessVariableMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessVariableMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessVariable.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVariableID sets the "variable_id" field.
func (m *ProcessVariableMutation) SetVariableID(s string) {
	m.variable_id = &s
}

// VariableID returns the value of the "variable_id" field in the mutation.
func (m *ProcessVariableMutation) VariableID() (r string, exists bool) {
	v := m.variable_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVariableID returns the old "variable_id" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldVariableID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariableID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariableID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariableID: %w", err)
	}
	return oldValue.VariableID, nil
}

// ResetVariableID resets all changes to the "variable_id" field.
func (m *ProcessVariableMutation) ResetVariableID() {
	m.variable_id = nil
}

// SetProcessInstanceID sets the "process_instance_id" field.
func (m *ProcessVariableMutation) SetProcessInstanceID(s string) {
	m.process_instance_id = &s
}

// ProcessInstanceID returns the value of the "process_instance_id" field in the mutation.
func (m *ProcessVariableMutation) ProcessInstanceID() (r string, exists bool) {
	v := m.process_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessInstanceID returns the old "process_instance_id" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldProcessInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessInstanceID: %w", err)
	}
	return oldValue.ProcessInstanceID, nil
}

// ResetProcessInstanceID resets all changes to the "process_instance_id" field.
func (m *ProcessVariableMutation) ResetProcessInstanceID() {
	m.process_instance_id = nil
}

// SetTaskID sets the "task_id" field.
func (m *ProcessVariableMutation) SetTaskID(s string) {
	m.task_id = &s
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *ProcessVariableMutation) TaskID() (r string, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ClearTaskID clears the value of the "task_id" field.
func (m *ProcessVariableMutation) ClearTaskID() {
	m.task_id = nil
	m.clearedFields[processvariable.FieldTaskID] = struct{}{}
}

// TaskIDCleared returns if the "task_id" field was cleared in this mutation.
func (m *ProcessVariableMutation) TaskIDCleared() bool {
	_, ok := m.clearedFields[processvariable.FieldTaskID]
	return ok
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *ProcessVariableMutation) ResetTaskID() {
	m.task_id = nil
	delete(m.clearedFields, processvariable.FieldTaskID)
}

// SetVariableName sets the "variable_name" field.
func (m *ProcessVariableMutation) SetVariableName(s string) {
	m.variable_name = &s
}

// VariableName returns the value of the "variable_name" field in the mutation.
func (m *ProcessVariableMutation) VariableName() (r string, exists bool) {
	v := m.variable_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVariableName returns the old "variable_name" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldVariableName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariableName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariableName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariableName: %w", err)
	}
	return oldValue.VariableName, nil
}

// ResetVariableName resets all changes to the "variable_name" field.
func (m *ProcessVariableMutation) ResetVariableName() {
	m.variable_name = nil
}

// SetVariableType sets the "variable_type" field.
func (m *ProcessVariableMutation) SetVariableType(s string) {
	m.variable_type = &s
}

// VariableType returns the value of the "variable_type" field in the mutation.
func (m *ProcessVariableMutation) VariableType() (r string, exists bool) {
	v := m.variable_type
	if v == nil {
		return
	}
	return *v, true
}

// OldVariableType returns the old "variable_type" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldVariableType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariableType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariableType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariableType: %w", err)
	}
	return oldValue.VariableType, nil
}

// ResetVariableType resets all changes to the "variable_type" field.
func (m *ProcessVariableMutation) ResetVariableType() {
	m.variable_type = nil
}

// SetVariableValue sets the "variable_value" field.
func (m *ProcessVariableMutation) SetVariableValue(s string) {
	m.variable_value = &s
}

// VariableValue returns the value of the "variable_value" field in the mutation.
func (m *ProcessVariableMutation) VariableValue() (r string, exists bool) {
	v := m.variable_value
	if v == nil {
		return
	}
	return *v, true
}

// OldVariableValue returns the old "variable_value" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldVariableValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariableValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariableValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariableValue: %w", err)
	}
	return oldValue.VariableValue, nil
}

// ClearVariableValue clears the value of the "variable_value" field.
func (m *ProcessVariableMutation) ClearVariableValue() {
	m.variable_value = nil
	m.clearedFields[processvariable.FieldVariableValue] = struct{}{}
}

// VariableValueCleared returns if the "variable_value" field was cleared in this mutation.
func (m *ProcessVariableMutation) VariableValueCleared() bool {
	_, ok := m.clearedFields[processvariable.FieldVariableValue]
	return ok
}

// ResetVariableValue resets all changes to the "variable_value" field.
func (m *ProcessVariableMutation) ResetVariableValue() {
	m.variable_value = nil
	delete(m.clearedFields, processvariable.FieldVariableValue)
}

// SetScope sets the "scope" field.
func (m *ProcessVariableMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *ProcessVariableMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *ProcessVariableMutation) ResetScope() {
	m.scope = nil
}

// SetIsTransient sets the "is_transient" field.
func (m *ProcessVariableMutation) SetIsTransient(b bool) {
	m.is_transient = &b
}

// IsTransient returns the value of the "is_transient" field in the mutation.
func (m *ProcessVariableMutation) IsTransient() (r bool, exists bool) {
	v := m.is_transient
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTransient returns the old "is_transient" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldIsTransient(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTransient is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTransient requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTransient: %w", err)
	}
	return oldValue.IsTransient, nil
}

// ResetIsTransient resets all changes to the "is_transient" field.
func (m *ProcessVariableMutation) ResetIsTransient() {
	m.is_transient = nil
}

// SetSerializationFormat sets the "serialization_format" field.
func (m *ProcessVariableMutation) SetSerializationFormat(s string) {
	m.serialization_format = &s
}

// SerializationFormat returns the value of the "serialization_format" field in the mutation.
func (m *ProcessVariableMutation) SerializationFormat() (r string, exists bool) {
	v := m.serialization_format
	if v == nil {
		return
	}
	return *v, true
}

// OldSerializationFormat returns the old "serialization_format" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldSerializationFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerializationFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerializationFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerializationFormat: %w", err)
	}
	return oldValue.SerializationFormat, nil
}

// ResetSerializationFormat resets all changes to the "serialization_format" field.
func (m *ProcessVariableMutation) ResetSerializationFormat() {
	m.serialization_format = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcessVariableMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcessVariableMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProcessVariableMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProcessVariableMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcessVariableMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessVariableMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessVariableMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessVariableMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessVariableMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessVariableMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessVariableMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProcessVariableMutation builder.
func (m *ProcessVariableMutation) Where(ps ...predicate.ProcessVariable) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcessVariableMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcessVariableMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcessVariable, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcessVariableMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcessVariableMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcessVariable).
func (m *ProcessVariableMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessVariableMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.variable_id != nil {
		fields = append(fields, processvariable.FieldVariableID)
	}
	if m.process_instance_id != nil {
		fields = append(fields, processvariable.FieldProcessInstanceID)
	}
	if m.task_id != nil {
		fields = append(fields, processvariable.FieldTaskID)
	}
	if m.variable_name != nil {
		fields = append(fields, processvariable.FieldVariableName)
	}
	if m.variable_type != nil {
		fields = append(fields, processvariable.FieldVariableType)
	}
	if m.variable_value != nil {
		fields = append(fields, processvariable.FieldVariableValue)
	}
	if m.scope != nil {
		fields = append(fields, processvariable.FieldScope)
	}
	if m.is_transient != nil {
		fields = append(fields, processvariable.FieldIsTransient)
	}
	if m.serialization_format != nil {
		fields = append(fields, processvariable.FieldSerializationFormat)
	}
	if m.tenant_id != nil {
		fields = append(fields, processvariable.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, processvariable.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, processvariable.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessVariableMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processvariable.FieldVariableID:
		return m.VariableID()
	case processvariable.FieldProcessInstanceID:
		return m.ProcessInstanceID()
	case processvariable.FieldTaskID:
		return m.TaskID()
	case processvariable.FieldVariableName:
		return m.VariableName()
	case processvariable.FieldVariableType:
		return m.VariableType()
	case processvariable.FieldVariableValue:
		return m.VariableValue()
	case processvariable.FieldScope:
		return m.Scope()
	case processvariable.FieldIsTransient:
		return m.IsTransient()
	case processvariable.FieldSerializationFormat:
		return m.SerializationFormat()
	case processvariable.FieldTenantID:
		return m.TenantID()
	case processvariable.FieldCreatedAt:
		return m.CreatedAt()
	case processvariable.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessVariableMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processvariable.FieldVariableID:
		return m.OldVariableID(ctx)
	case processvariable.FieldProcessInstanceID:
		return m.OldProcessInstanceID(ctx)
	case processvariable.FieldTaskID:
		return m.OldTaskID(ctx)
	case processvariable.FieldVariableName:
		return m.OldVariableName(ctx)
	case processvariable.FieldVariableType:
		return m.OldVariableType(ctx)
	case processvariable.FieldVariableValue:
		return m.OldVariableValue(ctx)
	case processvariable.FieldScope:
		return m.OldScope(ctx)
	case processvariable.FieldIsTransient:
		return m.OldIsTransient(ctx)
	case processvariable.FieldSerializationFormat:
		return m.OldSerializationFormat(ctx)
	case processvariable.FieldTenantID:
		return m.OldTenantID(ctx)
	case processvariable.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case processvariable.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessVariable field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessVariableMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processvariable.FieldVariableID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariableID(v)
		return nil
	case processvariable.FieldProcessInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessInstanceID(v)
		return nil
	case processvariable.FieldTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case processvariable.FieldVariableName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariableName(v)
		return nil
	case processvariable.FieldVariableType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariableType(v)
		return nil
	case processvariable.FieldVariableValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariableValue(v)
		return nil
	case processvariable.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case processvariable.FieldIsTransient:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTransient(v)
		return nil
	case processvariable.FieldSerializationFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerializationFormat(v)
		return nil
	case processvariable.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case processvariable.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case processvariable.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessVariable field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessVariableMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, processvariable.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessVariableMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processvariable.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessVariableMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processvariable.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessVariable numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessVariableMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(processvariable.FieldTaskID) {
		fields = append(fields, processvariable.FieldTaskID)
	}
	if m.FieldCleared(processvariable.FieldVariableValue) {
		fields = append(fields, processvariable.FieldVariableValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessVariableMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessVariableMutation) ClearField(name string) error {
	switch name {
	case processvariable.FieldTaskID:
		m.ClearTaskID()
		return nil
	case processvariable.FieldVariableValue:
		m.ClearVariableValue()
		return nil
	}
	return fmt.Errorf("unknown ProcessVariable nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessVariableMutation) ResetField(name string) error {
	switch name {
	case processvariable.FieldVariableID:
		m.ResetVariableID()
		return nil
	case processvariable.FieldProcessInstanceID:
		m.ResetProcessInstanceID()
		return nil
	case processvariable.FieldTaskID:
		m.ResetTaskID()
		return nil
	case processvariable.FieldVariableName:
		m.ResetVariableName()
		return nil
	case processvariable.FieldVariableType:
		m.ResetVariableType()
		return nil
	case processvariable.FieldVariableValue:
		m.ResetVariableValue()
		return nil
	case processvariable.FieldScope:
		m.ResetScope()
		return nil
	case processvariable.FieldIsTransient:
		m.ResetIsTransient()
		return nil
	case processvariable.FieldSerializationFormat:
		m.ResetSerializationFormat()
		return nil
	case processvariable.FieldTenantID:
		m.ResetTenantID()
		return nil
	case processvariable.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case processvariable.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessVariable field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessVariableMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessVariableMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessVariableMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessVariableMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessVariableMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessVariableMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessVariableMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessVariable unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessVariableMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessVariable edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	code                *string
	description         *string
	manager_id          *int
	addmanager_id       *int
	start_date          *time.Time
	end_date            *time.Time
	status              *string
	tenant_id           *int
	addtenant_id        *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	department          *int
	cleareddepartment   bool
	applications        map[int]struct{}
	removedapplications map[int]struct{}
	clearedapplications bool
	tags                map[int]struct{}
	removedtags         map[int]struct{}
	clearedtags         bool
	done                bool
	oldValue            func(context.Context) (*Project, error)
	predicates          []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *ProjectMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ProjectMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ProjectMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[project.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[project.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, project.FieldDescription)
}

// SetManagerID sets the "manager_id" field.
func (m *ProjectMutation) SetManagerID(i int) {
	m.manager_id = &i
	m.addmanager_id = nil
}

// ManagerID returns the value of the "manager_id" field in the mutation.
func (m *ProjectMutation) ManagerID() (r int, exists bool) {
	v := m.manager_id
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerID returns the old "manager_id" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldManagerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerID: %w", err)
	}
	return oldValue.ManagerID, nil
}

// AddManagerID adds i to the "manager_id" field.
func (m *ProjectMutation) AddManagerID(i int) {
	if m.addmanager_id != nil {
		*m.addmanager_id += i
	} else {
		m.addmanager_id = &i
	}
}

// AddedManagerID returns the value that was added to the "manager_id" field in this mutation.
func (m *ProjectMutation) AddedManagerID() (r int, exists bool) {
	v := m.addmanager_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearManagerID clears the value of the "manager_id" field.
func (m *ProjectMutation) ClearManagerID() {
	m.manager_id = nil
	m.addmanager_id = nil
	m.clearedFields[project.FieldManagerID] = struct{}{}
}

// ManagerIDCleared returns if the "manager_id" field was cleared in this mutation.
func (m *ProjectMutation) ManagerIDCleared() bool {
	_, ok := m.clearedFields[project.FieldManagerID]
	return ok
}

// ResetManagerID resets all changes to the "manager_id" field.
func (m *ProjectMutation) ResetManagerID() {
	m.manager_id = nil
	m.addmanager_id = nil
	delete(m.clearedFields, project.FieldManagerID)
}

// SetDepartmentID sets the "department_id" field.
func (m *ProjectMutation) SetDepartmentID(i int) {
	m.department = &i
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *ProjectMutation) DepartmentID() (r int, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDepartmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ClearDepartmentID clears the value of the "department_id" field.
func (m *ProjectMutation) ClearDepartmentID() {
	m.department = nil
	m.clearedFields[project.FieldDepartmentID] = struct{}{}
}

// DepartmentIDCleared returns if the "department_id" field was cleared in this mutation.
func (m *ProjectMutation) DepartmentIDCleared() bool {
	_, ok := m.clearedFields[project.FieldDepartmentID]
	return ok
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *ProjectMutation) ResetDepartmentID() {
	m.department = nil
	delete(m.clearedFields, project.FieldDepartmentID)
}

// SetStartDate sets the "start_date" field.
func (m *ProjectMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ProjectMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *ProjectMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[project.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *ProjectMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[project.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ProjectMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, project.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *ProjectMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ProjectMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ProjectMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[project.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ProjectMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[project.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ProjectMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, project.FieldEndDate)
}

// SetStatus sets the "status" field.
func (m *ProjectMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProjectMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProjectMutation) ResetStatus() {
	m.status = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ProjectMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProjectMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProjectMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProjectMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProjectMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *ProjectMutation) ClearDepartment() {
	m.cleareddepartment = true
	m.clearedFields[project.FieldDepartmentID] = struct{}{}
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *ProjectMutation) DepartmentCleared() bool {
	return m.DepartmentIDCleared() || m.cleareddepartment
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *ProjectMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *ProjectMutation) AddApplicationIDs(ids ...int) {
	if m.applications == nil {
		m.applications = make(map[int]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *ProjectMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *ProjectMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *ProjectMutation) RemoveApplicationIDs(ids ...int) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *ProjectMutation) RemovedApplicationsIDs() (ids []int) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *ProjectMutation) ApplicationsIDs() (ids []int) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *ProjectMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *ProjectMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ProjectMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ProjectMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *ProjectMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *ProjectMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ProjectMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ProjectMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.code != nil {
		fields = append(fields, project.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.manager_id != nil {
		fields = append(fields, project.FieldManagerID)
	}
	if m.department != nil {
		fields = append(fields, project.FieldDepartmentID)
	}
	if m.start_date != nil {
		fields = append(fields, project.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, project.FieldEndDate)
	}
	if m.status != nil {
		fields = append(fields, project.FieldStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, project.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldName:
		return m.Name()
	case project.FieldCode:
		return m.Code()
	case project.FieldDescription:
		return m.Description()
	case project.FieldManagerID:
		return m.ManagerID()
	case project.FieldDepartmentID:
		return m.DepartmentID()
	case project.FieldStartDate:
		return m.StartDate()
	case project.FieldEndDate:
		return m.EndDate()
	case project.FieldStatus:
		return m.Status()
	case project.FieldTenantID:
		return m.TenantID()
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldCode:
		return m.OldCode(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldManagerID:
		return m.OldManagerID(ctx)
	case project.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case project.FieldStartDate:
		return m.OldStartDate(ctx)
	case project.FieldEndDate:
		return m.OldEndDate(ctx)
	case project.FieldStatus:
		return m.OldStatus(ctx)
	case project.FieldTenantID:
		return m.OldTenantID(ctx)
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldManagerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerID(v)
		return nil
	case project.FieldDepartmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case project.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case project.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case project.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case project.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.addmanager_id != nil {
		fields = append(fields, project.FieldManagerID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, project.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldManagerID:
		return m.AddedManagerID()
	case project.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldManagerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddManagerID(v)
		return nil
	case project.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDescription) {
		fields = append(fields, project.FieldDescription)
	}
	if m.FieldCleared(project.FieldManagerID) {
		fields = append(fields, project.FieldManagerID)
	}
	if m.FieldCleared(project.FieldDepartmentID) {
		fields = append(fields, project.FieldDepartmentID)
	}
	if m.FieldCleared(project.FieldStartDate) {
		fields = append(fields, project.FieldStartDate)
	}
	if m.FieldCleared(project.FieldEndDate) {
		fields = append(fields, project.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDescription:
		m.ClearDescription()
		return nil
	case project.FieldManagerID:
		m.ClearManagerID()
		return nil
	case project.FieldDepartmentID:
		m.ClearDepartmentID()
		return nil
	case project.FieldStartDate:
		m.ClearStartDate()
		return nil
	case project.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldCode:
		m.ResetCode()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldManagerID:
		m.ResetManagerID()
		return nil
	case project.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case project.FieldStartDate:
		m.ResetStartDate()
		return nil
	case project.FieldEndDate:
		m.ResetEndDate()
		return nil
	case project.FieldStatus:
		m.ResetStatus()
		return nil
	case project.FieldTenantID:
		m.ResetTenantID()
		return nil
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.department != nil {
		edges = append(edges, project.EdgeDepartment)
	}
	if m.applications != nil {
		edges = append(edges, project.EdgeApplications)
	}
	if m.tags != nil {
		edges = append(edges, project.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedapplications != nil {
		edges = append(edges, project.EdgeApplications)
	}
	if m.removedtags != nil {
		edges = append(edges, project.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddepartment {
		edges = append(edges, project.EdgeDepartment)
	}
	if m.clearedapplications {
		edges = append(edges, project.EdgeApplications)
	}
	if m.clearedtags {
		edges = append(edges, project.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeDepartment:
		return m.cleareddepartment
	case project.EdgeApplications:
		return m.clearedapplications
	case project.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case project.EdgeApplications:
		m.ResetApplications()
		return nil
	case project.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// PromptTemplateMutation represents an operation that mutates the PromptTemplate nodes in the graph.
type PromptTemplateMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	version       *string
	template      *string
	description   *string
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PromptTemplate, error)
	predicates    []predicate.PromptTemplate
}

var _ ent.Mutation = (*PromptTemplateMutation)(nil)

// prompttemplateOption allows management of the mutation configuration using functional options.
type prompttemplateOption func(*PromptTemplateMutation)

// newPromptTemplateMutation creates new mutation for the PromptTemplate entity.
func newPromptTemplateMutation(c config, op Op, opts ...prompttemplateOption) *PromptTemplateMutation {
	m := &PromptTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypePromptTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromptTemplateID sets the ID field of the mutation.
func withPromptTemplateID(id int) prompttemplateOption {
	return func(m *PromptTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *PromptTemplate
		)
		m.oldValue = func(ctx context.Context) (*PromptTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromptTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromptTemplate sets the old PromptTemplate of the mutation.
func withPromptTemplate(node *PromptTemplate) prompttemplateOption {
	return func(m *PromptTemplateMutation) {
		m.oldValue = func(context.Context) (*PromptTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromptTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromptTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromptTemplateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromptTemplateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromptTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromptTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromptTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromptTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromptTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromptTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromptTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PromptTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PromptTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PromptTemplateMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *PromptTemplateMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PromptTemplateMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PromptTemplateMutation) ResetVersion() {
	m.version = nil
}

// SetTemplate sets the "template" field.
func (m *PromptTemplateMutation) SetTemplate(s string) {
	m.template = &s
}

// Template returns the value of the "template" field in the mutation.
func (m *PromptTemplateMutation) Template() (r string, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old "template" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ResetTemplate resets all changes to the "template" field.
func (m *PromptTemplateMutation) ResetTemplate() {
	m.template = nil
}

// SetDescription sets the "description" field.
func (m *PromptTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PromptTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PromptTemplateMutation) ResetDescription() {
	m.description = nil
}

// SetMetadata sets the "metadata" field.
func (m *PromptTemplateMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PromptTemplateMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PromptTemplateMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[prompttemplate.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PromptTemplateMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[prompttemplate.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PromptTemplateMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, prompttemplate.FieldMetadata)
}

// Where appends a list predicates to the PromptTemplateMutation builder.
func (m *PromptTemplateMutation) Where(ps ...predicate.PromptTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromptTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromptTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromptTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromptTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromptTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromptTemplate).
func (m *PromptTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromptTemplateMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, prompttemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, prompttemplate.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, prompttemplate.FieldName)
	}
	if m.version != nil {
		fields = append(fields, prompttemplate.FieldVersion)
	}
	if m.template != nil {
		fields = append(fields, prompttemplate.FieldTemplate)
	}
	if m.description != nil {
		fields = append(fields, prompttemplate.FieldDescription)
	}
	if m.metadata != nil {
		fields = append(fields, prompttemplate.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromptTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prompttemplate.FieldCreatedAt:
		return m.CreatedAt()
	case prompttemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	case prompttemplate.FieldName:
		return m.Name()
	case prompttemplate.FieldVersion:
		return m.Version()
	case prompttemplate.FieldTemplate:
		return m.Template()
	case prompttemplate.FieldDescription:
		return m.Description()
	case prompttemplate.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromptTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prompttemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case prompttemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case prompttemplate.FieldName:
		return m.OldName(ctx)
	case prompttemplate.FieldVersion:
		return m.OldVersion(ctx)
	case prompttemplate.FieldTemplate:
		return m.OldTemplate(ctx)
	case prompttemplate.FieldDescription:
		return m.OldDescription(ctx)
	case prompttemplate.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown PromptTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prompttemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case prompttemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case prompttemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case prompttemplate.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case prompttemplate.FieldTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	case prompttemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case prompttemplate.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown PromptTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromptTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromptTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PromptTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromptTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(prompttemplate.FieldMetadata) {
		fields = append(fields, prompttemplate.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromptTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromptTemplateMutation) ClearField(name string) error {
	switch name {
	case prompttemplate.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown PromptTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromptTemplateMutation) ResetField(name string) error {
	switch name {
	case prompttemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case prompttemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case prompttemplate.FieldName:
		m.ResetName()
		return nil
	case prompttemplate.FieldVersion:
		m.ResetVersion()
		return nil
	case prompttemplate.FieldTemplate:
		m.ResetTemplate()
		return nil
	case prompttemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case prompttemplate.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown PromptTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromptTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromptTemplateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromptTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromptTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromptTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromptTemplateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromptTemplateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PromptTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromptTemplateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PromptTemplate edge %s", name)
}

// RootCauseAnalysisMutation represents an operation that mutates the RootCauseAnalysis nodes in the graph.
type RootCauseAnalysisMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	ticket_number       *string
	ticket_title        *string
	analysis_date       *string
	root_causes         *[]map[string]interface{}
	appendroot_causes   []map[string]interface{}
	analysis_summary    *string
	confidence_score    *float64
	addconfidence_score *float64
	analysis_method     *string
	tenant_id           *int
	addtenant_id        *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	ticket              *int
	clearedticket       bool
	done                bool
	oldValue            func(context.Context) (*RootCauseAnalysis, error)
	predicates          []predicate.RootCauseAnalysis
}

var _ ent.Mutation = (*RootCauseAnalysisMutation)(nil)

// rootcauseanalysisOption allows management of the mutation configuration using functional options.
type rootcauseanalysisOption func(*RootCauseAnalysisMutation)

// newRootCauseAnalysisMutation creates new mutation for the RootCauseAnalysis entity.
func newRootCauseAnalysisMutation(c config, op Op, opts ...rootcauseanalysisOption) *RootCauseAnalysisMutation {
	m := &RootCauseAnalysisMutation{
		config:        c,
		op:            op,
		typ:           TypeRootCauseAnalysis,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRootCauseAnalysisID sets the ID field of the mutation.
func withRootCauseAnalysisID(id int) rootcauseanalysisOption {
	return func(m *RootCauseAnalysisMutation) {
		var (
			err   error
			once  sync.Once
			value *RootCauseAnalysis
		)
		m.oldValue = func(ctx context.Context) (*RootCauseAnalysis, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RootCauseAnalysis.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRootCauseAnalysis sets the old RootCauseAnalysis of the mutation.
func withRootCauseAnalysis(node *RootCauseAnalysis) rootcauseanalysisOption {
	return func(m *RootCauseAnalysisMutation) {
		m.oldValue = func(context.Context) (*RootCauseAnalysis, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RootCauseAnalysisMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RootCauseAnalysisMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RootCauseAnalysisMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RootCauseAnalysisMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RootCauseAnalysis.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTicketID sets the "ticket_id" field.
func (m *RootCauseAnalysisMutation) SetTicketID(i int) {
	m.ticket = &i
}

// TicketID returns the value of the "ticket_id" field in the mutation.
func (m *RootCauseAnalysisMutation) TicketID() (r int, exists bool) {
	v := m.ticket
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketID returns the old "ticket_id" field's value of the RootCauseAnalysis entity.
// If the RootCauseAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootCauseAnalysisMutation) OldTicketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketID: %w", err)
	}
	return oldValue.TicketID, nil
}

// ResetTicketID resets all changes to the "ticket_id" field.
func (m *RootCauseAnalysisMutation) ResetTicketID() {
	m.ticket = nil
}

// SetTicketNumber sets the "ticket_number" field.
func (m *RootCauseAnalysisMutation) SetTicketNumber(s string) {
	m.ticket_number = &s
}

// TicketNumber returns the value of the "ticket_number" field in the mutation.
func (m *RootCauseAnalysisMutation) TicketNumber() (r string, exists bool) {
	v := m.ticket_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketNumber returns the old "ticket_number" field's value of the RootCauseAnalysis entity.
// If the RootCauseAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootCauseAnalysisMutation) OldTicketNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketNumber: %w", err)
	}
	return oldValue.TicketNumber, nil
}

// ResetTicketNumber resets all changes to the "ticket_number" field.
func (m *RootCauseAnalysisMutation) ResetTicketNumber() {
	m.ticket_number = nil
}

// SetTicketTitle sets the "ticket_title" field.
func (m *RootCauseAnalysisMutation) SetTicketTitle(s string) {
	m.ticket_title = &s
}

// TicketTitle returns the value of the "ticket_title" field in the mutation.
func (m *RootCauseAnalysisMutation) TicketTitle() (r string, exists bool) {
	v := m.ticket_title
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketTitle returns the old "ticket_title" field's value of the RootCauseAnalysis entity.
// If the RootCauseAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootCauseAnalysisMutation) OldTicketTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketTitle: %w", err)
	}
	return oldValue.TicketTitle, nil
}

// ResetTicketTitle resets all changes to the "ticket_title" field.
func (m *RootCauseAnalysisMutation) ResetTicketTitle() {
	m.ticket_title = nil
}

// SetAnalysisDate sets the "analysis_date" field.
func (m *RootCauseAnalysisMutation) SetAnalysisDate(s string) {
	m.analysis_date = &s
}

// AnalysisDate returns the value of the "analysis_date" field in the mutation.
func (m *RootCauseAnalysisMutation) AnalysisDate() (r string, exists bool) {
	v := m.analysis_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAnalysisDate returns the old "analysis_date" field's value of the RootCauseAnalysis entity.
// If the RootCauseAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootCauseAnalysisMutation) OldAnalysisDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnalysisDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnalysisDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnalysisDate: %w", err)
	}
	return oldValue.AnalysisDate, nil
}

// ResetAnalysisDate resets all changes to the "analysis_date" field.
func (m *RootCauseAnalysisMutation) ResetAnalysisDate() {
	m.analysis_date = nil
}

// SetRootCauses sets the "root_causes" field.
func (m *RootCauseAnalysisMutation) SetRootCauses(value []map[string]interface{}) {
	m.root_causes = &value
	m.appendroot_causes = nil
}

// RootCauses returns the value of the "root_causes" field in the mutation.
func (m *RootCauseAnalysisMutation) RootCauses() (r []map[string]interface{}, exists bool) {
	v := m.root_causes
	if v == nil {
		return
	}
	return *v, true
}

// OldRootCauses returns the old "root_causes" field's value of the RootCauseAnalysis entity.
// If the RootCauseAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootCauseAnalysisMutation) OldRootCauses(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootCauses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootCauses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootCauses: %w", err)
	}
	return oldValue.RootCauses, nil
}

// AppendRootCauses adds value to the "root_causes" field.
func (m *RootCauseAnalysisMutation) AppendRootCauses(value []map[string]interface{}) {
	m.appendroot_causes = append(m.appendroot_causes, value...)
}

// AppendedRootCauses returns the list of values that were appended to the "root_causes" field in this mutation.
func (m *RootCauseAnalysisMutation) AppendedRootCauses() ([]map[string]interface{}, bool) {
	if len(m.appendroot_causes) == 0 {
		return nil, false
	}
	return m.appendroot_causes, true
}

// ResetRootCauses resets all changes to the "root_causes" field.
func (m *RootCauseAnalysisMutation) ResetRootCauses() {
	m.root_causes = nil
	m.appendroot_causes = nil
}

// SetAnalysisSummary sets the "analysis_summary" field.
func (m *RootCauseAnalysisMutation) SetAnalysisSummary(s string) {
	m.analysis_summary = &s
}

// AnalysisSummary returns the value of the "analysis_summary" field in the mutation.
func (m *RootCauseAnalysisMutation) AnalysisSummary() (r string, exists bool) {
	v := m.analysis_summary
	if v == nil {
		return
	}
	return *v, true
}

// OldAnalysisSummary returns the old "analysis_summary" field's value of the RootCauseAnalysis entity.
// If the RootCauseAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootCauseAnalysisMutation) OldAnalysisSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnalysisSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnalysisSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnalysisSummary: %w", err)
	}
	return oldValue.AnalysisSummary, nil
}

// ClearAnalysisSummary clears the value of the "analysis_summary" field.
func (m *RootCauseAnalysisMutation) ClearAnalysisSummary() {
	m.analysis_summary = nil
	m.clearedFields[rootcauseanalysis.FieldAnalysisSummary] = struct{}{}
}

// AnalysisSummaryCleared returns if the "analysis_summary" field was cleared in this mutation.
func (m *RootCauseAnalysisMutation) AnalysisSummaryCleared() bool {
	_, ok := m.clearedFields[rootcauseanalysis.FieldAnalysisSummary]
	return ok
}

// ResetAnalysisSummary resets all changes to the "analysis_summary" field.
func (m *RootCauseAnalysisMutation) ResetAnalysisSummary() {
	m.analysis_summary = nil
	delete(m.clearedFields, rootcauseanalysis.FieldAnalysisSummary)
}

// SetConfidenceScore sets the "confidence_score" field.
func (m *RootCauseAnalysisMutation) SetConfidenceScore(f float64) {
	m.confidence_score = &f
	m.addconfidence_score = nil
}

// ConfidenceScore returns the value of the "confidence_score" field in the mutation.
func (m *RootCauseAnalysisMutation) ConfidenceScore() (r float64, exists bool) {
	v := m.confidence_score
	if v == nil {
		return
	}
	return *v, true
}

// OldConfidenceScore returns the old "confidence_score" field's value of the RootCauseAnalysis entity.
// If the RootCauseAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootCauseAnalysisMutation) OldConfidenceScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfidenceScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfidenceScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfidenceScore: %w", err)
	}
	return oldValue.ConfidenceScore, nil
}

// AddConfidenceScore adds f to the "confidence_score" field.
func (m *RootCauseAnalysisMutation) AddConfidenceScore(f float64) {
	if m.addconfidence_score != nil {
		*m.addconfidence_score += f
	} else {
		m.addconfidence_score = &f
	}
}

// AddedConfidenceScore returns the value that was added to the "confidence_score" field in this mutation.
func (m *RootCauseAnalysisMutation) AddedConfidenceScore() (r float64, exists bool) {
	v := m.addconfidence_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetConfidenceScore resets all changes to the "confidence_score" field.
func (m *RootCauseAnalysisMutation) ResetConfidenceScore() {
	m.confidence_score = nil
	m.addconfidence_score = nil
}

// SetAnalysisMethod sets the "analysis_method" field.
func (m *RootCauseAnalysisMutation) SetAnalysisMethod(s string) {
	m.analysis_method = &s
}

// AnalysisMethod returns the value of the "analysis_method" field in the mutation.
func (m *RootCauseAnalysisMutation) AnalysisMethod() (r string, exists bool) {
	v := m.analysis_method
	if v == nil {
		return
	}
	return *v, true
}

// OldAnalysisMethod returns the old "analysis_method" field's value of the RootCauseAnalysis entity.
// If the RootCauseAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootCauseAnalysisMutation) OldAnalysisMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnalysisMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnalysisMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnalysisMethod: %w", err)
	}
	return oldValue.AnalysisMethod, nil
}

// ResetAnalysisMethod resets all changes to the "analysis_method" field.
func (m *RootCauseAnalysisMutation) ResetAnalysisMethod() {
	m.analysis_method = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *RootCauseAnalysisMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *RootCauseAnalysisMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the RootCauseAnalysis entity.
// If the RootCauseAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootCauseAnalysisMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *RootCauseAnalysisMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *RootCauseAnalysisMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *RootCauseAnalysisMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RootCauseAnalysisMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RootCauseAnalysisMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RootCauseAnalysis entity.
// If the RootCauseAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootCauseAnalysisMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RootCauseAnalysisMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RootCauseAnalysisMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RootCauseAnalysisMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RootCauseAnalysis entity.
// If the RootCauseAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootCauseAnalysisMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RootCauseAnalysisMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTicket clears the "ticket" edge to the Ticket entity.
func (m *RootCauseAnalysisMutation) ClearTicket() {
	m.clearedticket = true
	m.clearedFields[rootcauseanalysis.FieldTicketID] = struct{}{}
}

// TicketCleared reports if the "ticket" edge to the Ticket entity was cleared.
func (m *RootCauseAnalysisMutation) TicketCleared() bool {
	return m.clearedticket
}

// TicketIDs returns the "ticket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TicketID instead. It exists only for internal usage by the builders.
func (m *RootCauseAnalysisMutation) TicketIDs() (ids []int) {
	if id := m.ticket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicket resets all changes to the "ticket" edge.
func (m *RootCauseAnalysisMutation) ResetTicket() {
	m.ticket = nil
	m.clearedticket = false
}

// Where appends a list predicates to the RootCauseAnalysisMutation builder.
func (m *RootCauseAnalysisMutation) Where(ps ...predicate.RootCauseAnalysis) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RootCauseAnalysisMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RootCauseAnalysisMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RootCauseAnalysis, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RootCauseAnalysisMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RootCauseAnalysisMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RootCauseAnalysis).
func (m *RootCauseAnalysisMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RootCauseAnalysisMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.ticket != nil {
		fields = append(fields, rootcauseanalysis.FieldTicketID)
	}
	if m.ticket_number != nil {
		fields = append(fields, rootcauseanalysis.FieldTicketNumber)
	}
	if m.ticket_title != nil {
		fields = append(fields, rootcauseanalysis.FieldTicketTitle)
	}
	if m.analysis_date != nil {
		fields = append(fields, rootcauseanalysis.FieldAnalysisDate)
	}
	if m.root_causes != nil {
		fields = append(fields, rootcauseanalysis.FieldRootCauses)
	}
	if m.analysis_summary != nil {
		fields = append(fields, rootcauseanalysis.FieldAnalysisSummary)
	}
	if m.confidence_score != nil {
		fields = append(fields, rootcauseanalysis.FieldConfidenceScore)
	}
	if m.analysis_method != nil {
		fields = append(fields, rootcauseanalysis.FieldAnalysisMethod)
	}
	if m.tenant_id != nil {
		fields = append(fields, rootcauseanalysis.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, rootcauseanalysis.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rootcauseanalysis.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RootCauseAnalysisMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rootcauseanalysis.FieldTicketID:
		return m.TicketID()
	case rootcauseanalysis.FieldTicketNumber:
		return m.TicketNumber()
	case rootcauseanalysis.FieldTicketTitle:
		return m.TicketTitle()
	case rootcauseanalysis.FieldAnalysisDate:
		return m.AnalysisDate()
	case rootcauseanalysis.FieldRootCauses:
		return m.RootCauses()
	case rootcauseanalysis.FieldAnalysisSummary:
		return m.AnalysisSummary()
	case rootcauseanalysis.FieldConfidenceScore:
		return m.ConfidenceScore()
	case rootcauseanalysis.FieldAnalysisMethod:
		return m.AnalysisMethod()
	case rootcauseanalysis.FieldTenantID:
		return m.TenantID()
	case rootcauseanalysis.FieldCreatedAt:
		return m.CreatedAt()
	case rootcauseanalysis.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RootCauseAnalysisMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rootcauseanalysis.FieldTicketID:
		return m.OldTicketID(ctx)
	case rootcauseanalysis.FieldTicketNumber:
		return m.OldTicketNumber(ctx)
	case rootcauseanalysis.FieldTicketTitle:
		return m.OldTicketTitle(ctx)
	case rootcauseanalysis.FieldAnalysisDate:
		return m.OldAnalysisDate(ctx)
	case rootcauseanalysis.FieldRootCauses:
		return m.OldRootCauses(ctx)
	case rootcauseanalysis.FieldAnalysisSummary:
		return m.OldAnalysisSummary(ctx)
	case rootcauseanalysis.FieldConfidenceScore:
		return m.OldConfidenceScore(ctx)
	case rootcauseanalysis.FieldAnalysisMethod:
		return m.OldAnalysisMethod(ctx)
	case rootcauseanalysis.FieldTenantID:
		return m.OldTenantID(ctx)
	case rootcauseanalysis.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rootcauseanalysis.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RootCauseAnalysis field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RootCauseAnalysisMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rootcauseanalysis.FieldTicketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketID(v)
		return nil
	case rootcauseanalysis.FieldTicketNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketNumber(v)
		return nil
	case rootcauseanalysis.FieldTicketTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketTitle(v)
		return nil
	case rootcauseanalysis.FieldAnalysisDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnalysisDate(v)
		return nil
	case rootcauseanalysis.FieldRootCauses:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootCauses(v)
		return nil
	case rootcauseanalysis.FieldAnalysisSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnalysisSummary(v)
		return nil
	case rootcauseanalysis.FieldConfidenceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfidenceScore(v)
		return nil
	case rootcauseanalysis.FieldAnalysisMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnalysisMethod(v)
		return nil
	case rootcauseanalysis.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case rootcauseanalysis.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rootcauseanalysis.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RootCauseAnalysis field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RootCauseAnalysisMutation) AddedFields() []string {
	var fields []string
	if m.addconfidence_score != nil {
		fields = append(fields, rootcauseanalysis.FieldConfidenceScore)
	}
	if m.addtenant_id != nil {
		fields = append(fields, rootcauseanalysis.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RootCauseAnalysisMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rootcauseanalysis.FieldConfidenceScore:
		return m.AddedConfidenceScore()
	case rootcauseanalysis.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RootCauseAnalysisMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rootcauseanalysis.FieldConfidenceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfidenceScore(v)
		return nil
	case rootcauseanalysis.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown RootCauseAnalysis numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RootCauseAnalysisMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rootcauseanalysis.FieldAnalysisSummary) {
		fields = append(fields, rootcauseanalysis.FieldAnalysisSummary)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RootCauseAnalysisMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RootCauseAnalysisMutation) ClearField(name string) error {
	switch name {
	case rootcauseanalysis.FieldAnalysisSummary:
		m.ClearAnalysisSummary()
		return nil
	}
	return fmt.Errorf("unknown RootCauseAnalysis nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RootCauseAnalysisMutation) ResetField(name string) error {
	switch name {
	case rootcauseanalysis.FieldTicketID:
		m.ResetTicketID()
		return nil
	case rootcauseanalysis.FieldTicketNumber:
		m.ResetTicketNumber()
		return nil
	case rootcauseanalysis.FieldTicketTitle:
		m.ResetTicketTitle()
		return nil
	case rootcauseanalysis.FieldAnalysisDate:
		m.ResetAnalysisDate()
		return nil
	case rootcauseanalysis.FieldRootCauses:
		m.ResetRootCauses()
		return nil
	case rootcauseanalysis.FieldAnalysisSummary:
		m.ResetAnalysisSummary()
		return nil
	case rootcauseanalysis.FieldConfidenceScore:
		m.ResetConfidenceScore()
		return nil
	case rootcauseanalysis.FieldAnalysisMethod:
		m.ResetAnalysisMethod()
		return nil
	case rootcauseanalysis.FieldTenantID:
		m.ResetTenantID()
		return nil
	case rootcauseanalysis.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rootcauseanalysis.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown RootCauseAnalysis field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RootCauseAnalysisMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.ticket != nil {
		edges = append(edges, rootcauseanalysis.EdgeTicket)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RootCauseAnalysisMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rootcauseanalysis.EdgeTicket:
		if id := m.ticket; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RootCauseAnalysisMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RootCauseAnalysisMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RootCauseAnalysisMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedticket {
		edges = append(edges, rootcauseanalysis.EdgeTicket)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RootCauseAnalysisMutation) EdgeCleared(name string) bool {
	switch name {
	case rootcauseanalysis.EdgeTicket:
		return m.clearedticket
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RootCauseAnalysisMutation) ClearEdge(name string) error {
	switch name {
	case rootcauseanalysis.EdgeTicket:
		m.ClearTicket()
		return nil
	}
	return fmt.Errorf("unknown RootCauseAnalysis unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RootCauseAnalysisMutation) ResetEdge(name string) error {
	switch name {
	case rootcauseanalysis.EdgeTicket:
		m.ResetTicket()
		return nil
	}
	return fmt.Errorf("unknown RootCauseAnalysis edge %s", name)
}

// SLAAlertHistoryMutation represents an operation that mutates the SLAAlertHistory nodes in the graph.
type SLAAlertHistoryMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	ticket_number           *string
	ticket_title            *string
	alert_rule_name         *string
	alert_level             *string
	threshold_percentage    *int
	addthreshold_percentage *int
	actual_percentage       *float64
	addactual_percentage    *float64
	notification_sent       *bool
	escalation_level        *int
	addescalation_level     *int
	tenant_id               *int
	addtenant_id            *int
	created_at              *time.Time
	resolved_at             *time.Time
	clearedFields           map[string]struct{}
	ticket                  *int
	clearedticket           bool
	alert_rule              *int
	clearedalert_rule       bool
	done                    bool
	oldValue                func(context.Context) (*SLAAlertHistory, error)
	predicates              []predicate.SLAAlertHistory
}

var _ ent.Mutation = (*SLAAlertHistoryMutation)(nil)

// slaalerthistoryOption allows management of the mutation configuration using functional options.
type slaalerthistoryOption func(*SLAAlertHistoryMutation)

// newSLAAlertHistoryMutation creates new mutation for the SLAAlertHistory entity.
func newSLAAlertHistoryMutation(c config, op Op, opts ...slaalerthistoryOption) *SLAAlertHistoryMutation {
	m := &SLAAlertHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeSLAAlertHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSLAAlertHistoryID sets the ID field of the mutation.
func withSLAAlertHistoryID(id int) slaalerthistoryOption {
	return func(m *SLAAlertHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *SLAAlertHistory
		)
		m.oldValue = func(ctx context.Context) (*SLAAlertHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SLAAlertHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSLAAlertHistory sets the old SLAAlertHistory of the mutation.
func withSLAAlertHistory(node *SLAAlertHistory) slaalerthistoryOption {
	return func(m *SLAAlertHistoryMutation) {
		m.oldValue = func(context.Context) (*SLAAlertHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SLAAlertHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SLAAlertHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SLAAlertHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SLAAlertHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SLAAlertHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTicketID sets the "ticket_id" field.
func (m *SLAAlertHistoryMutation) SetTicketID(i int) {
	m.ticket = &i
}

// TicketID returns the value of the "ticket_id" field in the mutation.
func (m *SLAAlertHistoryMutation) TicketID() (r int, exists bool) {
	v := m.ticket
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketID returns the old "ticket_id" field's value of the SLAAlertHistory entity.
// If the SLAAlertHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertHistoryMutation) OldTicketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketID: %w", err)
	}
	return oldValue.TicketID, nil
}

// ResetTicketID resets all changes to the "ticket_id" field.
func (m *SLAAlertHistoryMutation) ResetTicketID() {
	m.ticket = nil
}

// SetTicketNumber sets the "ticket_number" field.
func (m *SLAAlertHistoryMutation) SetTicketNumber(s string) {
	m.ticket_number = &s
}

// TicketNumber returns the value of the "ticket_number" field in the mutation.
func (m *SLAAlertHistoryMutation) TicketNumber() (r string, exists bool) {
	v := m.ticket_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketNumber returns the old "ticket_number" field's value of the SLAAlertHistory entity.
// If the SLAAlertHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertHistoryMutation) OldTicketNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketNumber: %w", err)
	}
	return oldValue.TicketNumber, nil
}

// ResetTicketNumber resets all changes to the "ticket_number" field.
func (m *SLAAlertHistoryMutation) ResetTicketNumber() {
	m.ticket_number = nil
}

// SetTicketTitle sets the "ticket_title" field.
func (m *SLAAlertHistoryMutation) SetTicketTitle(s string) {
	m.ticket_title = &s
}

// TicketTitle returns the value of the "ticket_title" field in the mutation.
func (m *SLAAlertHistoryMutation) TicketTitle() (r string, exists bool) {
	v := m.ticket_title
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketTitle returns the old "ticket_title" field's value of the SLAAlertHistory entity.
// If the SLAAlertHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertHistoryMutation) OldTicketTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketTitle: %w", err)
	}
	return oldValue.TicketTitle, nil
}

// ResetTicketTitle resets all changes to the "ticket_title" field.
func (m *SLAAlertHistoryMutation) ResetTicketTitle() {
	m.ticket_title = nil
}

// SetAlertRuleID sets the "alert_rule_id" field.
func (m *SLAAlertHistoryMutation) SetAlertRuleID(i int) {
	m.alert_rule = &i
}

// AlertRuleID returns the value of the "alert_rule_id" field in the mutation.
func (m *SLAAlertHistoryMutation) AlertRuleID() (r int, exists bool) {
	v := m.alert_rule
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertRuleID returns the old "alert_rule_id" field's value of the SLAAlertHistory entity.
// If the SLAAlertHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertHistoryMutation) OldAlertRuleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertRuleID: %w", err)
	}
	return oldValue.AlertRuleID, nil
}

// ResetAlertRuleID resets all changes to the "alert_rule_id" field.
func (m *SLAAlertHistoryMutation) ResetAlertRuleID() {
	m.alert_rule = nil
}

// SetAlertRuleName sets the "alert_rule_name" field.
func (m *SLAAlertHistoryMutation) SetAlertRuleName(s string) {
	m.alert_rule_name = &s
}

// AlertRuleName returns the value of the "alert_rule_name" field in the mutation.
func (m *SLAAlertHistoryMutation) AlertRuleName() (r string, exists bool) {
	v := m.alert_rule_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertRuleName returns the old "alert_rule_name" field's value of the SLAAlertHistory entity.
// If the SLAAlertHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertHistoryMutation) OldAlertRuleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertRuleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertRuleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertRuleName: %w", err)
	}
	return oldValue.AlertRuleName, nil
}

// ResetAlertRuleName resets all changes to the "alert_rule_name" field.
func (m *SLAAlertHistoryMutation) ResetAlertRuleName() {
	m.alert_rule_name = nil
}

// SetAlertLevel sets the "alert_level" field.
func (m *SLAAlertHistoryMutation) SetAlertLevel(s string) {
	m.alert_level = &s
}

// AlertLevel returns the value of the "alert_level" field in the mutation.
func (m *SLAAlertHistoryMutation) AlertLevel() (r string, exists bool) {
	v := m.alert_level
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertLevel returns the old "alert_level" field's value of the SLAAlertHistory entity.
// If the SLAAlertHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertHistoryMutation) OldAlertLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertLevel: %w", err)
	}
	return oldValue.AlertLevel, nil
}

// ResetAlertLevel resets all changes to the "alert_level" field.
func (m *SLAAlertHistoryMutation) ResetAlertLevel() {
	m.alert_level = nil
}

// SetThresholdPercentage sets the "threshold_percentage" field.
func (m *SLAAlertHistoryMutation) SetThresholdPercentage(i int) {
	m.threshold_percentage = &i
	m.addthreshold_percentage = nil
}

// ThresholdPercentage returns the value of the "threshold_percentage" field in the mutation.
func (m *SLAAlertHistoryMutation) ThresholdPercentage() (r int, exists bool) {
	v := m.threshold_percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldThresholdPercentage returns the old "threshold_percentage" field's value of the SLAAlertHistory entity.
// If the SLAAlertHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertHistoryMutation) OldThresholdPercentage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThresholdPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThresholdPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThresholdPercentage: %w", err)
	}
	return oldValue.ThresholdPercentage, nil
}

// AddThresholdPercentage adds i to the "threshold_percentage" field.
func (m *SLAAlertHistoryMutation) AddThresholdPercentage(i int) {
	if m.addthreshold_percentage != nil {
		*m.addthreshold_percentage += i
	} else {
		m.addthreshold_percentage = &i
	}
}

// AddedThresholdPercentage returns the value that was added to the "threshold_percentage" field in this mutation.
func (m *SLAAlertHistoryMutation) AddedThresholdPercentage() (r int, exists bool) {
	v := m.addthreshold_percentage
	if v == nil {
		return
	}
	return *v, true
}

// ResetThresholdPercentage resets all changes to the "threshold_percentage" field.
func (m *SLAAlertHistoryMutation) ResetThresholdPercentage() {
	m.threshold_percentage = nil
	m.addthreshold_percentage = nil
}

// SetActualPercentage sets the "actual_percentage" field.
func (m *SLAAlertHistoryMutation) SetActualPercentage(f float64) {
	m.actual_percentage = &f
	m.addactual_percentage = nil
}

// ActualPercentage returns the value of the "actual_percentage" field in the mutation.
func (m *SLAAlertHistoryMutation) ActualPercentage() (r float64, exists bool) {
	v := m.actual_percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldActualPercentage returns the old "actual_percentage" field's value of the SLAAlertHistory entity.
// If the SLAAlertHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertHistoryMutation) OldActualPercentage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualPercentage: %w", err)
	}
	return oldValue.ActualPercentage, nil
}

// AddActualPercentage adds f to the "actual_percentage" field.
func (m *SLAAlertHistoryMutation) AddActualPercentage(f float64) {
	if m.addactual_percentage != nil {
		*m.addactual_percentage += f
	} else {
		m.addactual_percentage = &f
	}
}

// AddedActualPercentage returns the value that was added to the "actual_percentage" field in this mutation.
func (m *SLAAlertHistoryMutation) AddedActualPercentage() (r float64, exists bool) {
	v := m.addactual_percentage
	if v == nil {
		return
	}
	return *v, true
}

// ResetActualPercentage resets all changes to the "actual_percentage" field.
func (m *SLAAlertHistoryMutation) ResetActualPercentage() {
	m.actual_percentage = nil
	m.addactual_percentage = nil
}

// SetNotificationSent sets the "notification_sent" field.
func (m *SLAAlertHistoryMutation) SetNotificationSent(b bool) {
	m.notification_sent = &b
}

// NotificationSent returns the value of the "notification_sent" field in the mutation.
func (m *SLAAlertHistoryMutation) NotificationSent() (r bool, exists bool) {
	v := m.notification_sent
	if v == nil {
		return
	}
	return *v, true
}

// OldNotificationSent returns the old "notification_sent" field's value of the SLAAlertHistory entity.
// If the SLAAlertHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertHistoryMutation) OldNotificationSent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotificationSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotificationSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotificationSent: %w", err)
	}
	return oldValue.NotificationSent, nil
}

// ResetNotificationSent resets all changes to the "notification_sent" field.
func (m *SLAAlertHistoryMutation) ResetNotificationSent() {
	m.notification_sent = nil
}

// SetEscalationLevel sets the "escalation_level" field.
func (m *SLAAlertHistoryMutation) SetEscalationLevel(i int) {
	m.escalation_level = &i
	m.addescalation_level = nil
}

// EscalationLevel returns the value of the "escalation_level" field in the mutation.
func (m *SLAAlertHistoryMutation) EscalationLevel() (r int, exists bool) {
	v := m.escalation_level
	if v == nil {
		return
	}
	return *v, true
}

// OldEscalationLevel returns the old "escalation_level" field's value of the SLAAlertHistory entity.
// If the SLAAlertHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertHistoryMutation) OldEscalationLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEscalationLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEscalationLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEscalationLevel: %w", err)
	}
	return oldValue.EscalationLevel, nil
}

// AddEscalationLevel adds i to the "escalation_level" field.
func (m *SLAAlertHistoryMutation) AddEscalationLevel(i int) {
	if m.addescalation_level != nil {
		*m.addescalation_level += i
	} else {
		m.addescalation_level = &i
	}
}

// AddedEscalationLevel returns the value that was added to the "escalation_level" field in this mutation.
func (m *SLAAlertHistoryMutation) AddedEscalationLevel() (r int, exists bool) {
	v := m.addescalation_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetEscalationLevel resets all changes to the "escalation_level" field.
func (m *SLAAlertHistoryMutation) ResetEscalationLevel() {
	m.escalation_level = nil
	m.addescalation_level = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *SLAAlertHistoryMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SLAAlertHistoryMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SLAAlertHistory entity.
// If the SLAAlertHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertHistoryMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *SLAAlertHistoryMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *SLAAlertHistoryMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SLAAlertHistoryMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SLAAlertHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SLAAlertHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SLAAlertHistory entity.
// If the SLAAlertHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SLAAlertHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetResolvedAt sets the "resolved_at" field.
func (m *SLAAlertHistoryMutation) SetResolvedAt(t time.Time) {
	m.resolved_at = &t
}

// ResolvedAt returns the value of the "resolved_at" field in the mutation.
func (m *SLAAlertHistoryMutation) ResolvedAt() (r time.Time, exists bool) {
	v := m.resolved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedAt returns the old "resolved_at" field's value of the SLAAlertHistory entity.
// If the SLAAlertHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertHistoryMutation) OldResolvedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedAt: %w", err)
	}
	return oldValue.ResolvedAt, nil
}

// ClearResolvedAt clears the value of the "resolved_at" field.
func (m *SLAAlertHistoryMutation) ClearResolvedAt() {
	m.resolved_at = nil
	m.clearedFields[slaalerthistory.FieldResolvedAt] = struct{}{}
}

// ResolvedAtCleared returns if the "resolved_at" field was cleared in this mutation.
func (m *SLAAlertHistoryMutation) ResolvedAtCleared() bool {
	_, ok := m.clearedFields[slaalerthistory.FieldResolvedAt]
	return ok
}

// ResetResolvedAt resets all changes to the "resolved_at" field.
func (m *SLAAlertHistoryMutation) ResetResolvedAt() {
	m.resolved_at = nil
	delete(m.clearedFields, slaalerthistory.FieldResolvedAt)
}

// ClearTicket clears the "ticket" edge to the Ticket entity.
func (m *SLAAlertHistoryMutation) ClearTicket() {
	m.clearedticket = true
	m.clearedFields[slaalerthistory.FieldTicketID] = struct{}{}
}

// TicketCleared reports if the "ticket" edge to the Ticket entity was cleared.
func (m *SLAAlertHistoryMutation) TicketCleared() bool {
	return m.clearedticket
}

// TicketIDs returns the "ticket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TicketID instead. It exists only for internal usage by the builders.
func (m *SLAAlertHistoryMutation) TicketIDs() (ids []int) {
	if id := m.ticket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicket resets all changes to the "ticket" edge.
func (m *SLAAlertHistoryMutation) ResetTicket() {
	m.ticket = nil
	m.clearedticket = false
}

// ClearAlertRule clears the "alert_rule" edge to the SLAAlertRule entity.
func (m *SLAAlertHistoryMutation) ClearAlertRule() {
	m.clearedalert_rule = true
	m.clearedFields[slaalerthistory.FieldAlertRuleID] = struct{}{}
}

// AlertRuleCleared reports if the "alert_rule" edge to the SLAAlertRule entity was cleared.
func (m *SLAAlertHistoryMutation) AlertRuleCleared() bool {
	return m.clearedalert_rule
}

// AlertRuleIDs returns the "alert_rule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlertRuleID instead. It exists only for internal usage by the builders.
func (m *SLAAlertHistoryMutation) AlertRuleIDs() (ids []int) {
	if id := m.alert_rule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlertRule resets all changes to the "alert_rule" edge.
func (m *SLAAlertHistoryMutation) ResetAlertRule() {
	m.alert_rule = nil
	m.clearedalert_rule = false
}

// Where appends a list predicates to the SLAAlertHistoryMutation builder.
func (m *SLAAlertHistoryMutation) Where(ps ...predicate.SLAAlertHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SLAAlertHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SLAAlertHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SLAAlertHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SLAAlertHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SLAAlertHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SLAAlertHistory).
func (m *SLAAlertHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SLAAlertHistoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.ticket != nil {
		fields = append(fields, slaalerthistory.FieldTicketID)
	}
	if m.ticket_number != nil {
		fields = append(fields, slaalerthistory.FieldTicketNumber)
	}
	if m.ticket_title != nil {
		fields = append(fields, slaalerthistory.FieldTicketTitle)
	}
	if m.alert_rule != nil {
		fields = append(fields, slaalerthistory.FieldAlertRuleID)
	}
	if m.alert_rule_name != nil {
		fields = append(fields, slaalerthistory.FieldAlertRuleName)
	}
	if m.alert_level != nil {
		fields = append(fields, slaalerthistory.FieldAlertLevel)
	}
	if m.threshold_percentage != nil {
		fields = append(fields, slaalerthistory.FieldThresholdPercentage)
	}
	if m.actual_percentage != nil {
		fields = append(fields, slaalerthistory.FieldActualPercentage)
	}
	if m.notification_sent != nil {
		fields = append(fields, slaalerthistory.FieldNotificationSent)
	}
	if m.escalation_level != nil {
		fields = append(fields, slaalerthistory.FieldEscalationLevel)
	}
	if m.tenant_id != nil {
		fields = append(fields, slaalerthistory.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, slaalerthistory.FieldCreatedAt)
	}
	if m.resolved_at != nil {
		fields = append(fields, slaalerthistory.FieldResolvedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SLAAlertHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case slaalerthistory.FieldTicketID:
		return m.TicketID()
	case slaalerthistory.FieldTicketNumber:
		return m.TicketNumber()
	case slaalerthistory.FieldTicketTitle:
		return m.TicketTitle()
	case slaalerthistory.FieldAlertRuleID:
		return m.AlertRuleID()
	case slaalerthistory.FieldAlertRuleName:
		return m.AlertRuleName()
	case slaalerthistory.FieldAlertLevel:
		return m.AlertLevel()
	case slaalerthistory.FieldThresholdPercentage:
		return m.ThresholdPercentage()
	case slaalerthistory.FieldActualPercentage:
		return m.ActualPercentage()
	case slaalerthistory.FieldNotificationSent:
		return m.NotificationSent()
	case slaalerthistory.FieldEscalationLevel:
		return m.EscalationLevel()
	case slaalerthistory.FieldTenantID:
		return m.TenantID()
	case slaalerthistory.FieldCreatedAt:
		return m.CreatedAt()
	case slaalerthistory.FieldResolvedAt:
		return m.ResolvedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SLAAlertHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case slaalerthistory.FieldTicketID:
		return m.OldTicketID(ctx)
	case slaalerthistory.FieldTicketNumber:
		return m.OldTicketNumber(ctx)
	case slaalerthistory.FieldTicketTitle:
		return m.OldTicketTitle(ctx)
	case slaalerthistory.FieldAlertRuleID:
		return m.OldAlertRuleID(ctx)
	case slaalerthistory.FieldAlertRuleName:
		return m.OldAlertRuleName(ctx)
	case slaalerthistory.FieldAlertLevel:
		return m.OldAlertLevel(ctx)
	case slaalerthistory.FieldThresholdPercentage:
		return m.OldThresholdPercentage(ctx)
	case slaalerthistory.FieldActualPercentage:
		return m.OldActualPercentage(ctx)
	case slaalerthistory.FieldNotificationSent:
		return m.OldNotificationSent(ctx)
	case slaalerthistory.FieldEscalationLevel:
		return m.OldEscalationLevel(ctx)
	case slaalerthistory.FieldTenantID:
		return m.OldTenantID(ctx)
	case slaalerthistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case slaalerthistory.FieldResolvedAt:
		return m.OldResolvedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SLAAlertHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLAAlertHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case slaalerthistory.FieldTicketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketID(v)
		return nil
	case slaalerthistory.FieldTicketNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketNumber(v)
		return nil
	case slaalerthistory.FieldTicketTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketTitle(v)
		return nil
	case slaalerthistory.FieldAlertRuleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertRuleID(v)
		return nil
	case slaalerthistory.FieldAlertRuleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertRuleName(v)
		return nil
	case slaalerthistory.FieldAlertLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertLevel(v)
		return nil
	case slaalerthistory.FieldThresholdPercentage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThresholdPercentage(v)
		return nil
	case slaalerthistory.FieldActualPercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualPercentage(v)
		return nil
	case slaalerthistory.FieldNotificationSent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotificationSent(v)
		return nil
	case slaalerthistory.FieldEscalationLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEscalationLevel(v)
		return nil
	case slaalerthistory.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case slaalerthistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case slaalerthistory.FieldResolvedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SLAAlertHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SLAAlertHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addthreshold_percentage != nil {
		fields = append(fields, slaalerthistory.FieldThresholdPercentage)
	}
	if m.addactual_percentage != nil {
		fields = append(fields, slaalerthistory.FieldActualPercentage)
	}
	if m.addescalation_level != nil {
		fields = append(fields, slaalerthistory.FieldEscalationLevel)
	}
	if m.addtenant_id != nil {
		fields = append(fields, slaalerthistory.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SLAAlertHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case slaalerthistory.FieldThresholdPercentage:
		return m.AddedThresholdPercentage()
	case slaalerthistory.FieldActualPercentage:
		return m.AddedActualPercentage()
	case slaalerthistory.FieldEscalationLevel:
		return m.AddedEscalationLevel()
	case slaalerthistory.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLAAlertHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case slaalerthistory.FieldThresholdPercentage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThresholdPercentage(v)
		return nil
	case slaalerthistory.FieldActualPercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActualPercentage(v)
		return nil
	case slaalerthistory.FieldEscalationLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEscalationLevel(v)
		return nil
	case slaalerthistory.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown SLAAlertHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SLAAlertHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(slaalerthistory.FieldResolvedAt) {
		fields = append(fields, slaalerthistory.FieldResolvedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SLAAlertHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SLAAlertHistoryMutation) ClearField(name string) error {
	switch name {
	case slaalerthistory.FieldResolvedAt:
		m.ClearResolvedAt()
		return nil
	}
	return fmt.Errorf("unknown SLAAlertHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SLAAlertHistoryMutation) ResetField(name string) error {
	switch name {
	case slaalerthistory.FieldTicketID:
		m.ResetTicketID()
		return nil
	case slaalerthistory.FieldTicketNumber:
		m.ResetTicketNumber()
		return nil
	case slaalerthistory.FieldTicketTitle:
		m.ResetTicketTitle()
		return nil
	case slaalerthistory.FieldAlertRuleID:
		m.ResetAlertRuleID()
		return nil
	case slaalerthistory.FieldAlertRuleName:
		m.ResetAlertRuleName()
		return nil
	case slaalerthistory.FieldAlertLevel:
		m.ResetAlertLevel()
		return nil
	case slaalerthistory.FieldThresholdPercentage:
		m.ResetThresholdPercentage()
		return nil
	case slaalerthistory.FieldActualPercentage:
		m.ResetActualPercentage()
		return nil
	case slaalerthistory.FieldNotificationSent:
		m.ResetNotificationSent()
		return nil
	case slaalerthistory.FieldEscalationLevel:
		m.ResetEscalationLevel()
		return nil
	case slaalerthistory.FieldTenantID:
		m.ResetTenantID()
		return nil
	case slaalerthistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case slaalerthistory.FieldResolvedAt:
		m.ResetResolvedAt()
		return nil
	}
	return fmt.Errorf("unknown SLAAlertHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SLAAlertHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.ticket != nil {
		edges = append(edges, slaalerthistory.EdgeTicket)
	}
	if m.alert_rule != nil {
		edges = append(edges, slaalerthistory.EdgeAlertRule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SLAAlertHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case slaalerthistory.EdgeTicket:
		if id := m.ticket; id != nil {
			return []ent.Value{*id}
		}
	case slaalerthistory.EdgeAlertRule:
		if id := m.alert_rule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SLAAlertHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SLAAlertHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SLAAlertHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedticket {
		edges = append(edges, slaalerthistory.EdgeTicket)
	}
	if m.clearedalert_rule {
		edges = append(edges, slaalerthistory.EdgeAlertRule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SLAAlertHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case slaalerthistory.EdgeTicket:
		return m.clearedticket
	case slaalerthistory.EdgeAlertRule:
		return m.clearedalert_rule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SLAAlertHistoryMutation) ClearEdge(name string) error {
	switch name {
	case slaalerthistory.EdgeTicket:
		m.ClearTicket()
		return nil
	case slaalerthistory.EdgeAlertRule:
		m.ClearAlertRule()
		return nil
	}
	return fmt.Errorf("unknown SLAAlertHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SLAAlertHistoryMutation) ResetEdge(name string) error {
	switch name {
	case slaalerthistory.EdgeTicket:
		m.ResetTicket()
		return nil
	case slaalerthistory.EdgeAlertRule:
		m.ResetAlertRule()
		return nil
	}
	return fmt.Errorf("unknown SLAAlertHistory edge %s", name)
}

// SLAAlertRuleMutation represents an operation that mutates the SLAAlertRule nodes in the graph.
type SLAAlertRuleMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	name                        *string
	alert_level                 *string
	threshold_percentage        *int
	addthreshold_percentage     *int
	notification_channels       *[]string
	appendnotification_channels []string
	escalation_enabled          *bool
	escalation_levels           *[]map[string]interface{}
	appendescalation_levels     []map[string]interface{}
	is_active                   *bool
	tenant_id                   *int
	addtenant_id                *int
	created_at                  *time.Time
	updated_at                  *time.Time
	clearedFields               map[string]struct{}
	sla_definition              *int
	clearedsla_definition       bool
	alert_history               map[int]struct{}
	removedalert_history        map[int]struct{}
	clearedalert_history        bool
	done                        bool
	oldValue                    func(context.Context) (*SLAAlertRule, error)
	predicates                  []predicate.SLAAlertRule
}

var _ ent.Mutation = (*SLAAlertRuleMutation)(nil)

// slaalertruleOption allows management of the mutation configuration using functional options.
type slaalertruleOption func(*SLAAlertRuleMutation)

// newSLAAlertRuleMutation creates new mutation for the SLAAlertRule entity.
func newSLAAlertRuleMutation(c config, op Op, opts ...slaalertruleOption) *SLAAlertRuleMutation {
	m := &SLAAlertRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeSLAAlertRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSLAAlertRuleID sets the ID field of the mutation.
func withSLAAlertRuleID(id int) slaalertruleOption {
	return func(m *SLAAlertRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *SLAAlertRule
		)
		m.oldValue = func(ctx context.Context) (*SLAAlertRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SLAAlertRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSLAAlertRule sets the old SLAAlertRule of the mutation.
func withSLAAlertRule(node *SLAAlertRule) slaalertruleOption {
	return func(m *SLAAlertRuleMutation) {
		m.oldValue = func(context.Context) (*SLAAlertRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SLAAlertRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SLAAlertRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SLAAlertRuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SLAAlertRuleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SLAAlertRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SLAAlertRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SLAAlertRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SLAAlertRule entity.
// If the SLAAlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SLAAlertRuleMutation) ResetName() {
	m.name = nil
}

// SetSLADefinitionID sets the "sla_definition_id" field.
func (m *SLAAlertRuleMutation) SetSLADefinitionID(i int) {
	m.sla_definition = &i
}

// SLADefinitionID returns the value of the "sla_definition_id" field in the mutation.
func (m *SLAAlertRuleMutation) SLADefinitionID() (r int, exists bool) {
	v := m.sla_definition
	if v == nil {
		return
	}
	return *v, true
}

// OldSLADefinitionID returns the old "sla_definition_id" field's value of the SLAAlertRule entity.
// If the SLAAlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertRuleMutation) OldSLADefinitionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSLADefinitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSLADefinitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSLADefinitionID: %w", err)
	}
	return oldValue.SLADefinitionID, nil
}

// ResetSLADefinitionID resets all changes to the "sla_definition_id" field.
func (m *SLAAlertRuleMutation) ResetSLADefinitionID() {
	m.sla_definition = nil
}

// SetAlertLevel sets the "alert_level" field.
func (m *SLAAlertRuleMutation) SetAlertLevel(s string) {
	m.alert_level = &s
}

// AlertLevel returns the value of the "alert_level" field in the mutation.
func (m *SLAAlertRuleMutation) AlertLevel() (r string, exists bool) {
	v := m.alert_level
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertLevel returns the old "alert_level" field's value of the SLAAlertRule entity.
// If the SLAAlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertRuleMutation) OldAlertLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertLevel: %w", err)
	}
	return oldValue.AlertLevel, nil
}

// ResetAlertLevel resets all changes to the "alert_level" field.
func (m *SLAAlertRuleMutation) ResetAlertLevel() {
	m.alert_level = nil
}

// SetThresholdPercentage sets the "threshold_percentage" field.
func (m *SLAAlertRuleMutation) SetThresholdPercentage(i int) {
	m.threshold_percentage = &i
	m.addthreshold_percentage = nil
}

// ThresholdPercentage returns the value of the "threshold_percentage" field in the mutation.
func (m *SLAAlertRuleMutation) ThresholdPercentage() (r int, exists bool) {
	v := m.threshold_percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldThresholdPercentage returns the old "threshold_percentage" field's value of the SLAAlertRule entity.
// If the SLAAlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertRuleMutation) OldThresholdPercentage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThresholdPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThresholdPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThresholdPercentage: %w", err)
	}
	return oldValue.ThresholdPercentage, nil
}

// AddThresholdPercentage adds i to the "threshold_percentage" field.
func (m *SLAAlertRuleMutation) AddThresholdPercentage(i int) {
	if m.addthreshold_percentage != nil {
		*m.addthreshold_percentage += i
	} else {
		m.addthreshold_percentage = &i
	}
}

// AddedThresholdPercentage returns the value that was added to the "threshold_percentage" field in this mutation.
func (m *SLAAlertRuleMutation) AddedThresholdPercentage() (r int, exists bool) {
	v := m.addthreshold_percentage
	if v == nil {
		return
	}
	return *v, true
}

// ResetThresholdPercentage resets all changes to the "threshold_percentage" field.
func (m *SLAAlertRuleMutation) ResetThresholdPercentage() {
	m.threshold_percentage = nil
	m.addthreshold_percentage = nil
}

// SetNotificationChannels sets the "notification_channels" field.
func (m *SLAAlertRuleMutation) SetNotificationChannels(s []string) {
	m.notification_channels = &s
	m.appendnotification_channels = nil
}

// NotificationChannels returns the value of the "notification_channels" field in the mutation.
func (m *SLAAlertRuleMutation) NotificationChannels() (r []string, exists bool) {
	v := m.notification_channels
	if v == nil {
		return
	}
	return *v, true
}

// OldNotificationChannels returns the old "notification_channels" field's value of the SLAAlertRule entity.
// If the SLAAlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertRuleMutation) OldNotificationChannels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotificationChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotificationChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotificationChannels: %w", err)
	}
	return oldValue.NotificationChannels, nil
}

// AppendNotificationChannels adds s to the "notification_channels" field.
func (m *SLAAlertRuleMutation) AppendNotificationChannels(s []string) {
	m.appendnotification_channels = append(m.appendnotification_channels, s...)
}

// AppendedNotificationChannels returns the list of values that were appended to the "notification_channels" field in this mutation.
func (m *SLAAlertRuleMutation) AppendedNotificationChannels() ([]string, bool) {
	if len(m.appendnotification_channels) == 0 {
		return nil, false
	}
	return m.appendnotification_channels, true
}

// ResetNotificationChannels resets all changes to the "notification_channels" field.
func (m *SLAAlertRuleMutation) ResetNotificationChannels() {
	m.notification_channels = nil
	m.appendnotification_channels = nil
}

// SetEscalationEnabled sets the "escalation_enabled" field.
func (m *SLAAlertRuleMutation) SetEscalationEnabled(b bool) {
	m.escalation_enabled = &b
}

// EscalationEnabled returns the value of the "escalation_enabled" field in the mutation.
func (m *SLAAlertRuleMutation) EscalationEnabled() (r bool, exists bool) {
	v := m.escalation_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEscalationEnabled returns the old "escalation_enabled" field's value of the SLAAlertRule entity.
// If the SLAAlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertRuleMutation) OldEscalationEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEscalationEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEscalationEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEscalationEnabled: %w", err)
	}
	return oldValue.EscalationEnabled, nil
}

// ResetEscalationEnabled resets all changes to the "escalation_enabled" field.
func (m *SLAAlertRuleMutation) ResetEscalationEnabled() {
	m.escalation_enabled = nil
}

// SetEscalationLevels sets the "escalation_levels" field.
func (m *SLAAlertRuleMutation) SetEscalationLevels(value []map[string]interface{}) {
	m.escalation_levels = &value
	m.appendescalation_levels = nil
}

// EscalationLevels returns the value of the "escalation_levels" field in the mutation.
func (m *SLAAlertRuleMutation) EscalationLevels() (r []map[string]interface{}, exists bool) {
	v := m.escalation_levels
	if v == nil {
		return
	}
	return *v, true
}

// OldEscalationLevels returns the old "escalation_levels" field's value of the SLAAlertRule entity.
// If the SLAAlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertRuleMutation) OldEscalationLevels(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEscalationLevels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEscalationLevels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEscalationLevels: %w", err)
	}
	return oldValue.EscalationLevels, nil
}

// AppendEscalationLevels adds value to the "escalation_levels" field.
func (m *SLAAlertRuleMutation) AppendEscalationLevels(value []map[string]interface{}) {
	m.appendescalation_levels = append(m.appendescalation_levels, value...)
}

// AppendedEscalationLevels returns the list of values that were appended to the "escalation_levels" field in this mutation.
func (m *SLAAlertRuleMutation) AppendedEscalationLevels() ([]map[string]interface{}, bool) {
	if len(m.appendescalation_levels) == 0 {
		return nil, false
	}
	return m.appendescalation_levels, true
}

// ClearEscalationLevels clears the value of the "escalation_levels" field.
func (m *SLAAlertRuleMutation) ClearEscalationLevels() {
	m.escalation_levels = nil
	m.appendescalation_levels = nil
	m.clearedFields[slaalertrule.FieldEscalationLevels] = struct{}{}
}

// EscalationLevelsCleared returns if the "escalation_levels" field was cleared in this mutation.
func (m *SLAAlertRuleMutation) EscalationLevelsCleared() bool {
	_, ok := m.clearedFields[slaalertrule.FieldEscalationLevels]
	return ok
}

// ResetEscalationLevels resets all changes to the "escalation_levels" field.
func (m *SLAAlertRuleMutation) ResetEscalationLevels() {
	m.escalation_levels = nil
	m.appendescalation_levels = nil
	delete(m.clearedFields, slaalertrule.FieldEscalationLevels)
}

// SetIsActive sets the "is_active" field.
func (m *SLAAlertRuleMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *SLAAlertRuleMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the SLAAlertRule entity.
// If the SLAAlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertRuleMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *SLAAlertRuleMutation) ResetIsActive() {
	m.is_active = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *SLAAlertRuleMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SLAAlertRuleMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SLAAlertRule entity.
// If the SLAAlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertRuleMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *SLAAlertRuleMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *SLAAlertRuleMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SLAAlertRuleMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SLAAlertRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SLAAlertRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SLAAlertRule entity.
// If the SLAAlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SLAAlertRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SLAAlertRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SLAAlertRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SLAAlertRule entity.
// If the SLAAlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAAlertRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SLAAlertRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearSLADefinition clears the "sla_definition" edge to the SLADefinition entity.
func (m *SLAAlertRuleMutation) ClearSLADefinition() {
	m.clearedsla_definition = true
	m.clearedFields[slaalertrule.FieldSLADefinitionID] = struct{}{}
}

// SLADefinitionCleared reports if the "sla_definition" edge to the SLADefinition entity was cleared.
func (m *SLAAlertRuleMutation) SLADefinitionCleared() bool {
	return m.clearedsla_definition
}

// SLADefinitionIDs returns the "sla_definition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SLADefinitionID instead. It exists only for internal usage by the builders.
func (m *SLAAlertRuleMutation) SLADefinitionIDs() (ids []int) {
	if id := m.sla_definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSLADefinition resets all changes to the "sla_definition" edge.
func (m *SLAAlertRuleMutation) ResetSLADefinition() {
	m.sla_definition = nil
	m.clearedsla_definition = false
}

// AddAlertHistoryIDs adds the "alert_history" edge to the SLAAlertHistory entity by ids.
func (m *SLAAlertRuleMutation) AddAlertHistoryIDs(ids ...int) {
	if m.alert_history == nil {
		m.alert_history = make(map[int]struct{})
	}
	for i := range ids {
		m.alert_history[ids[i]] = struct{}{}
	}
}

// ClearAlertHistory clears the "alert_history" edge to the SLAAlertHistory entity.
func (m *SLAAlertRuleMutation) ClearAlertHistory() {
	m.clearedalert_history = true
}

// AlertHistoryCleared reports if the "alert_history" edge to the SLAAlertHistory entity was cleared.
func (m *SLAAlertRuleMutation) AlertHistoryCleared() bool {
	return m.clearedalert_history
}

// RemoveAlertHistoryIDs removes the "alert_history" edge to the SLAAlertHistory entity by IDs.
func (m *SLAAlertRuleMutation) RemoveAlertHistoryIDs(ids ...int) {
	if m.removedalert_history == nil {
		m.removedalert_history = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.alert_history, ids[i])
		m.removedalert_history[ids[i]] = struct{}{}
	}
}

// RemovedAlertHistory returns the removed IDs of the "alert_history" edge to the SLAAlertHistory entity.
func (m *SLAAlertRuleMutation) RemovedAlertHistoryIDs() (ids []int) {
	for id := range m.removedalert_history {
		ids = append(ids, id)
	}
	return
}

// AlertHistoryIDs returns the "alert_history" edge IDs in the mutation.
func (m *SLAAlertRuleMutation) AlertHistoryIDs() (ids []int) {
	for id := range m.alert_history {
		ids = append(ids, id)
	}
	return
}

// ResetAlertHistory resets all changes to the "alert_history" edge.
func (m *SLAAlertRuleMutation) ResetAlertHistory() {
	m.alert_history = nil
	m.clearedalert_history = false
	m.removedalert_history = nil
}

// Where appends a list predicates to the SLAAlertRuleMutation builder.
func (m *SLAAlertRuleMutation) Where(ps ...predicate.SLAAlertRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SLAAlertRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SLAAlertRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SLAAlertRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SLAAlertRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SLAAlertRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SLAAlertRule).
func (m *SLAAlertRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SLAAlertRuleMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, slaalertrule.FieldName)
	}
	if m.sla_definition != nil {
		fields = append(fields, slaalertrule.FieldSLADefinitionID)
	}
	if m.alert_level != nil {
		fields = append(fields, slaalertrule.FieldAlertLevel)
	}
	if m.threshold_percentage != nil {
		fields = append(fields, slaalertrule.FieldThresholdPercentage)
	}
	if m.notification_channels != nil {
		fields = append(fields, slaalertrule.FieldNotificationChannels)
	}
	if m.escalation_enabled != nil {
		fields = append(fields, slaalertrule.FieldEscalationEnabled)
	}
	if m.escalation_levels != nil {
		fields = append(fields, slaalertrule.FieldEscalationLevels)
	}
	if m.is_active != nil {
		fields = append(fields, slaalertrule.FieldIsActive)
	}
	if m.tenant_id != nil {
		fields = append(fields, slaalertrule.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, slaalertrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, slaalertrule.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SLAAlertRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case slaalertrule.FieldName:
		return m.Name()
	case slaalertrule.FieldSLADefinitionID:
		return m.SLADefinitionID()
	case slaalertrule.FieldAlertLevel:
		return m.AlertLevel()
	case slaalertrule.FieldThresholdPercentage:
		return m.ThresholdPercentage()
	case slaalertrule.FieldNotificationChannels:
		return m.NotificationChannels()
	case slaalertrule.FieldEscalationEnabled:
		return m.EscalationEnabled()
	case slaalertrule.FieldEscalationLevels:
		return m.EscalationLevels()
	case slaalertrule.FieldIsActive:
		return m.IsActive()
	case slaalertrule.FieldTenantID:
		return m.TenantID()
	case slaalertrule.FieldCreatedAt:
		return m.CreatedAt()
	case slaalertrule.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SLAAlertRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case slaalertrule.FieldName:
		return m.OldName(ctx)
	case slaalertrule.FieldSLADefinitionID:
		return m.OldSLADefinitionID(ctx)
	case slaalertrule.FieldAlertLevel:
		return m.OldAlertLevel(ctx)
	case slaalertrule.FieldThresholdPercentage:
		return m.OldThresholdPercentage(ctx)
	case slaalertrule.FieldNotificationChannels:
		return m.OldNotificationChannels(ctx)
	case slaalertrule.FieldEscalationEnabled:
		return m.OldEscalationEnabled(ctx)
	case slaalertrule.FieldEscalationLevels:
		return m.OldEscalationLevels(ctx)
	case slaalertrule.FieldIsActive:
		return m.OldIsActive(ctx)
	case slaalertrule.FieldTenantID:
		return m.OldTenantID(ctx)
	case slaalertrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case slaalertrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SLAAlertRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLAAlertRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case slaalertrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case slaalertrule.FieldSLADefinitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSLADefinitionID(v)
		return nil
	case slaalertrule.FieldAlertLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertLevel(v)
		return nil
	case slaalertrule.FieldThresholdPercentage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThresholdPercentage(v)
		return nil
	case slaalertrule.FieldNotificationChannels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotificationChannels(v)
		return nil
	case slaalertrule.FieldEscalationEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEscalationEnabled(v)
		return nil
	case slaalertrule.FieldEscalationLevels:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEscalationLevels(v)
		return nil
	case slaalertrule.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case slaalertrule.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case slaalertrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case slaalertrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SLAAlertRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SLAAlertRuleMutation) AddedFields() []string {
	var fields []string
	if m.addthreshold_percentage != nil {
		fields = append(fields, slaalertrule.FieldThresholdPercentage)
	}
	if m.addtenant_id != nil {
		fields = append(fields, slaalertrule.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SLAAlertRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case slaalertrule.FieldThresholdPercentage:
		return m.AddedThresholdPercentage()
	case slaalertrule.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLAAlertRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case slaalertrule.FieldThresholdPercentage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThresholdPercentage(v)
		return nil
	case slaalertrule.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown SLAAlertRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SLAAlertRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(slaalertrule.FieldEscalationLevels) {
		fields = append(fields, slaalertrule.FieldEscalationLevels)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SLAAlertRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SLAAlertRuleMutation) ClearField(name string) error {
	switch name {
	case slaalertrule.FieldEscalationLevels:
		m.ClearEscalationLevels()
		return nil
	}
	return fmt.Errorf("unknown SLAAlertRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SLAAlertRuleMutation) ResetField(name string) error {
	switch name {
	case slaalertrule.FieldName:
		m.ResetName()
		return nil
	case slaalertrule.FieldSLADefinitionID:
		m.ResetSLADefinitionID()
		return nil
	case slaalertrule.FieldAlertLevel:
		m.ResetAlertLevel()
		return nil
	case slaalertrule.FieldThresholdPercentage:
		m.ResetThresholdPercentage()
		return nil
	case slaalertrule.FieldNotificationChannels:
		m.ResetNotificationChannels()
		return nil
	case slaalertrule.FieldEscalationEnabled:
		m.ResetEscalationEnabled()
		return nil
	case slaalertrule.FieldEscalationLevels:
		m.ResetEscalationLevels()
		return nil
	case slaalertrule.FieldIsActive:
		m.ResetIsActive()
		return nil
	case slaalertrule.FieldTenantID:
		m.ResetTenantID()
		return nil
	case slaalertrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case slaalertrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SLAAlertRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SLAAlertRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.sla_definition != nil {
		edges = append(edges, slaalertrule.EdgeSLADefinition)
	}
	if m.alert_history != nil {
		edges = append(edges, slaalertrule.EdgeAlertHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SLAAlertRuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case slaalertrule.EdgeSLADefinition:
		if id := m.sla_definition; id != nil {
			return []ent.Value{*id}
		}
	case slaalertrule.EdgeAlertHistory:
		ids := make([]ent.Value, 0, len(m.alert_history))
		for id := range m.alert_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SLAAlertRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedalert_history != nil {
		edges = append(edges, slaalertrule.EdgeAlertHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SLAAlertRuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case slaalertrule.EdgeAlertHistory:
		ids := make([]ent.Value, 0, len(m.removedalert_history))
		for id := range m.removedalert_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SLAAlertRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsla_definition {
		edges = append(edges, slaalertrule.EdgeSLADefinition)
	}
	if m.clearedalert_history {
		edges = append(edges, slaalertrule.EdgeAlertHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SLAAlertRuleMutation) EdgeCleared(name string) bool {
	switch name {
	case slaalertrule.EdgeSLADefinition:
		return m.clearedsla_definition
	case slaalertrule.EdgeAlertHistory:
		return m.clearedalert_history
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SLAAlertRuleMutation) ClearEdge(name string) error {
	switch name {
	case slaalertrule.EdgeSLADefinition:
		m.ClearSLADefinition()
		return nil
	}
	return fmt.Errorf("unknown SLAAlertRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SLAAlertRuleMutation) ResetEdge(name string) error {
	switch name {
	case slaalertrule.EdgeSLADefinition:
		m.ResetSLADefinition()
		return nil
	case slaalertrule.EdgeAlertHistory:
		m.ResetAlertHistory()
		return nil
	}
	return fmt.Errorf("unknown SLAAlertRule edge %s", name)
}

// SLADefinitionMutation represents an operation that mutates the SLADefinition nodes in the graph.
type SLADefinitionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	description        *string
	service_type       *string
	priority           *string
	response_time      *int
	addresponse_time   *int
	resolution_time    *int
	addresolution_time *int
	business_hours     *map[string]interface{}
	escalation_rules   *map[string]interface{}
	conditions         *map[string]interface{}
	is_active          *bool
	tenant_id          *int
	addtenant_id       *int
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	violations         map[int]struct{}
	removedviolations  map[int]struct{}
	clearedviolations  bool
	metrics            map[int]struct{}
	removedmetrics     map[int]struct{}
	clearedmetrics     bool
	tickets            map[int]struct{}
	removedtickets     map[int]struct{}
	clearedtickets     bool
	alert_rules        map[int]struct{}
	removedalert_rules map[int]struct{}
	clearedalert_rules bool
	done               bool
	oldValue           func(context.Context) (*SLADefinition, error)
	predicates         []predicate.SLADefinition
}

var _ ent.Mutation = (*SLADefinitionMutation)(nil)

// sladefinitionOption allows management of the mutation configuration using functional options.
type sladefinitionOption func(*SLADefinitionMutation)

// newSLADefinitionMutation creates new mutation for the SLADefinition entity.
func newSLADefinitionMutation(c config, op Op, opts ...sladefinitionOption) *SLADefinitionMutation {
	m := &SLADefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeSLADefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSLADefinitionID sets the ID field of the mutation.
func withSLADefinitionID(id int) sladefinitionOption {
	return func(m *SLADefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *SLADefinition
		)
		m.oldValue = func(ctx context.Context) (*SLADefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SLADefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSLADefinition sets the old SLADefinition of the mutation.
func withSLADefinition(node *SLADefinition) sladefinitionOption {
	return func(m *SLADefinitionMutation) {
		m.oldValue = func(context.Context) (*SLADefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SLADefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SLADefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SLADefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SLADefinitionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SLADefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SLADefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SLADefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SLADefinitionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SLADefinitionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SLADefinitionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SLADefinitionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[sladefinition.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SLADefinitionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[sladefinition.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SLADefinitionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, sladefinition.FieldDescription)
}

// SetServiceType sets the "service_type" field.
func (m *SLADefinitionMutation) SetServiceType(s string) {
	m.service_type = &s
}

// ServiceType returns the value of the "service_type" field in the mutation.
func (m *SLADefinitionMutation) ServiceType() (r string, exists bool) {
	v := m.service_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceType returns the old "service_type" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldServiceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceType: %w", err)
	}
	return oldValue.ServiceType, nil
}

// ClearServiceType clears the value of the "service_type" field.
func (m *SLADefinitionMutation) ClearServiceType() {
	m.service_type = nil
	m.clearedFields[sladefinition.FieldServiceType] = struct{}{}
}

// ServiceTypeCleared returns if the "service_type" field was cleared in this mutation.
func (m *SLADefinitionMutation) ServiceTypeCleared() bool {
	_, ok := m.clearedFields[sladefinition.FieldServiceType]
	return ok
}

// ResetServiceType resets all changes to the "service_type" field.
func (m *SLADefinitionMutation) ResetServiceType() {
	m.service_type = nil
	delete(m.clearedFields, sladefinition.FieldServiceType)
}

// SetPriority sets the "priority" field.
func (m *SLADefinitionMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *SLADefinitionMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ClearPriority clears the value of the "priority" field.
func (m *SLADefinitionMutation) ClearPriority() {
	m.priority = nil
	m.clearedFields[sladefinition.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *SLADefinitionMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[sladefinition.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *SLADefinitionMutation) ResetPriority() {
	m.priority = nil
	delete(m.clearedFields, sladefinition.FieldPriority)
}

// SetResponseTime sets the "response_time" field.
func (m *SLADefinitionMutation) SetResponseTime(i int) {
	m.response_time = &i
	m.addresponse_time = nil
}

// ResponseTime returns the value of the "response_time" field in the mutation.
func (m *SLADefinitionMutation) ResponseTime() (r int, exists bool) {
	v := m.response_time
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseTime returns the old "response_time" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldResponseTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseTime: %w", err)
	}
	return oldValue.ResponseTime, nil
}

// AddResponseTime adds i to the "response_time" field.
func (m *SLADefinitionMutation) AddResponseTime(i int) {
	if m.addresponse_time != nil {
		*m.addresponse_time += i
	} else {
		m.addresponse_time = &i
	}
}

// AddedResponseTime returns the value that was added to the "response_time" field in this mutation.
func (m *SLADefinitionMutation) AddedResponseTime() (r int, exists bool) {
	v := m.addresponse_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetResponseTime resets all changes to the "response_time" field.
func (m *SLADefinitionMutation) ResetResponseTime() {
	m.response_time = nil
	m.addresponse_time = nil
}

// SetResolutionTime sets the "resolution_time" field.
func (m *SLADefinitionMutation) SetResolutionTime(i int) {
	m.resolution_time = &i
	m.addresolution_time = nil
}

// ResolutionTime returns the value of the "resolution_time" field in the mutation.
func (m *SLADefinitionMutation) ResolutionTime() (r int, exists bool) {
	v := m.resolution_time
	if v == nil {
		return
	}
	return *v, true
}

// OldResolutionTime returns the old "resolution_time" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldResolutionTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolutionTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolutionTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolutionTime: %w", err)
	}
	return oldValue.ResolutionTime, nil
}

// AddResolutionTime adds i to the "resolution_time" field.
func (m *SLADefinitionMutation) AddResolutionTime(i int) {
	if m.addresolution_time != nil {
		*m.addresolution_time += i
	} else {
		m.addresolution_time = &i
	}
}

// AddedResolutionTime returns the value that was added to the "resolution_time" field in this mutation.
func (m *SLADefinitionMutation) AddedResolutionTime() (r int, exists bool) {
	v := m.addresolution_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetResolutionTime resets all changes to the "resolution_time" field.
func (m *SLADefinitionMutation) ResetResolutionTime() {
	m.resolution_time = nil
	m.addresolution_time = nil
}

// SetBusinessHours sets the "business_hours" field.
func (m *SLADefinitionMutation) SetBusinessHours(value map[string]interface{}) {
	m.business_hours = &value
}

// BusinessHours returns the value of the "business_hours" field in the mutation.
func (m *SLADefinitionMutation) BusinessHours() (r map[string]interface{}, exists bool) {
	v := m.business_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessHours returns the old "business_hours" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldBusinessHours(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessHours: %w", err)
	}
	return oldValue.BusinessHours, nil
}

// ClearBusinessHours clears the value of the "business_hours" field.
func (m *SLADefinitionMutation) ClearBusinessHours() {
	m.business_hours = nil
	m.clearedFields[sladefinition.FieldBusinessHours] = struct{}{}
}

// BusinessHoursCleared returns if the "business_hours" field was cleared in this mutation.
func (m *SLADefinitionMutation) BusinessHoursCleared() bool {
	_, ok := m.clearedFields[sladefinition.FieldBusinessHours]
	return ok
}

// ResetBusinessHours resets all changes to the "business_hours" field.
func (m *SLADefinitionMutation) ResetBusinessHours() {
	m.business_hours = nil
	delete(m.clearedFields, sladefinition.FieldBusinessHours)
}

// SetEscalationRules sets the "escalation_rules" field.
func (m *SLADefinitionMutation) SetEscalationRules(value map[string]interface{}) {
	m.escalation_rules = &value
}

// EscalationRules returns the value of the "escalation_rules" field in the mutation.
func (m *SLADefinitionMutation) EscalationRules() (r map[string]interface{}, exists bool) {
	v := m.escalation_rules
	if v == nil {
		return
	}
	return *v, true
}

// OldEscalationRules returns the old "escalation_rules" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldEscalationRules(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEscalationRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEscalationRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEscalationRules: %w", err)
	}
	return oldValue.EscalationRules, nil
}

// ClearEscalationRules clears the value of the "escalation_rules" field.
func (m *SLADefinitionMutation) ClearEscalationRules() {
	m.escalation_rules = nil
	m.clearedFields[sladefinition.FieldEscalationRules] = struct{}{}
}

// EscalationRulesCleared returns if the "escalation_rules" field was cleared in this mutation.
func (m *SLADefinitionMutation) EscalationRulesCleared() bool {
	_, ok := m.clearedFields[sladefinition.FieldEscalationRules]
	return ok
}

// ResetEscalationRules resets all changes to the "escalation_rules" field.
func (m *SLADefinitionMutation) ResetEscalationRules() {
	m.escalation_rules = nil
	delete(m.clearedFields, sladefinition.FieldEscalationRules)
}

// SetConditions sets the "conditions" field.
func (m *SLADefinitionMutation) SetConditions(value map[string]interface{}) {
	m.conditions = &value
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *SLADefinitionMutation) Conditions() (r map[string]interface{}, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldConditions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// ClearConditions clears the value of the "conditions" field.
func (m *SLADefinitionMutation) ClearConditions() {
	m.conditions = nil
	m.clearedFields[sladefinition.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *SLADefinitionMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[sladefinition.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *SLADefinitionMutation) ResetConditions() {
	m.conditions = nil
	delete(m.clearedFields, sladefinition.FieldConditions)
}

// SetIsActive sets the "is_active" field.
func (m *SLADefinitionMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *SLADefinitionMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *SLADefinitionMutation) ResetIsActive() {
	m.is_active = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *SLADefinitionMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SLADefinitionMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *SLADefinitionMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *SLADefinitionMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SLADefinitionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SLADefinitionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SLADefinitionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SLADefinitionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SLADefinitionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SLADefinitionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SLADefinitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddViolationIDs adds the "violations" edge to the SLAViolation entity by ids.
func (m *SLADefinitionMutation) AddViolationIDs(ids ...int) {
	if m.violations == nil {
		m.violations = make(map[int]struct{})
	}
	for i := range ids {
		m.violations[ids[i]] = struct{}{}
	}
}

// ClearViolations clears the "violations" edge to the SLAViolation entity.
func (m *SLADefinitionMutation) ClearViolations() {
	m.clearedviolations = true
}

// ViolationsCleared reports if the "violations" edge to the SLAViolation entity was cleared.
func (m *SLADefinitionMutation) ViolationsCleared() bool {
	return m.clearedviolations
}

// RemoveViolationIDs removes the "violations" edge to the SLAViolation entity by IDs.
func (m *SLADefinitionMutation) RemoveViolationIDs(ids ...int) {
	if m.removedviolations == nil {
		m.removedviolations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.violations, ids[i])
		m.removedviolations[ids[i]] = struct{}{}
	}
}

// RemovedViolations returns the removed IDs of the "violations" edge to the SLAViolation entity.
func (m *SLADefinitionMutation) RemovedViolationsIDs() (ids []int) {
	for id := range m.removedviolations {
		ids = append(ids, id)
	}
	return
}

// ViolationsIDs returns the "violations" edge IDs in the mutation.
func (m *SLADefinitionMutation) ViolationsIDs() (ids []int) {
	for id := range m.violations {
		ids = append(ids, id)
	}
	return
}

// ResetViolations resets all changes to the "violations" edge.
func (m *SLADefinitionMutation) ResetViolations() {
	m.violations = nil
	m.clearedviolations = false
	m.removedviolations = nil
}

// AddMetricIDs adds the "metrics" edge to the SLAMetric entity by ids.
func (m *SLADefinitionMutation) AddMetricIDs(ids ...int) {
	if m.metrics == nil {
		m.metrics = make(map[int]struct{})
	}
	for i := range ids {
		m.metrics[ids[i]] = struct{}{}
	}
}

// ClearMetrics clears the "metrics" edge to the SLAMetric entity.
func (m *SLADefinitionMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the SLAMetric entity was cleared.
func (m *SLADefinitionMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// RemoveMetricIDs removes the "metrics" edge to the SLAMetric entity by IDs.
func (m *SLADefinitionMutation) RemoveMetricIDs(ids ...int) {
	if m.removedmetrics == nil {
		m.removedmetrics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metrics, ids[i])
		m.removedmetrics[ids[i]] = struct{}{}
	}
}

// RemovedMetrics returns the removed IDs of the "metrics" edge to the SLAMetric entity.
func (m *SLADefinitionMutation) RemovedMetricsIDs() (ids []int) {
	for id := range m.removedmetrics {
		ids = append(ids, id)
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
func (m *SLADefinitionMutation) MetricsIDs() (ids []int) {
	for id := range m.metrics {
		ids = append(ids, id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *SLADefinitionMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
	m.removedmetrics = nil
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by ids.
func (m *SLADefinitionMutation) AddTicketIDs(ids ...int) {
	if m.tickets == nil {
		m.tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.tickets[ids[i]] = struct{}{}
	}
}

// ClearTickets clears the "tickets" edge to the Ticket entity.
func (m *SLADefinitionMutation) ClearTickets() {
	m.clearedtickets = true
}

// TicketsCleared reports if the "tickets" edge to the Ticket entity was cleared.
func (m *SLADefinitionMutation) TicketsCleared() bool {
	return m.clearedtickets
}

// RemoveTicketIDs removes the "tickets" edge to the Ticket entity by IDs.
func (m *SLADefinitionMutation) RemoveTicketIDs(ids ...int) {
	if m.removedtickets == nil {
		m.removedtickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tickets, ids[i])
		m.removedtickets[ids[i]] = struct{}{}
	}
}

// RemovedTickets returns the removed IDs of the "tickets" edge to the Ticket entity.
func (m *SLADefinitionMutation) RemovedTicketsIDs() (ids []int) {
	for id := range m.removedtickets {
		ids = append(ids, id)
	}
	return
}

// TicketsIDs returns the "tickets" edge IDs in the mutation.
func (m *SLADefinitionMutation) TicketsIDs() (ids []int) {
	for id := range m.tickets {
		ids = append(ids, id)
	}
	return
}

// ResetTickets resets all changes to the "tickets" edge.
func (m *SLADefinitionMutation) ResetTickets() {
	m.tickets = nil
	m.clearedtickets = false
	m.removedtickets = nil
}

// AddAlertRuleIDs adds the "alert_rules" edge to the SLAAlertRule entity by ids.
func (m *SLADefinitionMutation) AddAlertRuleIDs(ids ...int) {
	if m.alert_rules == nil {
		m.alert_rules = make(map[int]struct{})
	}
	for i := range ids {
		m.alert_rules[ids[i]] = struct{}{}
	}
}

// ClearAlertRules clears the "alert_rules" edge to the SLAAlertRule entity.
func (m *SLADefinitionMutation) ClearAlertRules() {
	m.clearedalert_rules = true
}

// AlertRulesCleared reports if the "alert_rules" edge to the SLAAlertRule entity was cleared.
func (m *SLADefinitionMutation) AlertRulesCleared() bool {
	return m.clearedalert_rules
}

// RemoveAlertRuleIDs removes the "alert_rules" edge to the SLAAlertRule entity by IDs.
func (m *SLADefinitionMutation) RemoveAlertRuleIDs(ids ...int) {
	if m.removedalert_rules == nil {
		m.removedalert_rules = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.alert_rules, ids[i])
		m.removedalert_rules[ids[i]] = struct{}{}
	}
}

// RemovedAlertRules returns the removed IDs of the "alert_rules" edge to the SLAAlertRule entity.
func (m *SLADefinitionMutation) RemovedAlertRulesIDs() (ids []int) {
	for id := range m.removedalert_rules {
		ids = append(ids, id)
	}
	return
}

// AlertRulesIDs returns the "alert_rules" edge IDs in the mutation.
func (m *SLADefinitionMutation) AlertRulesIDs() (ids []int) {
	for id := range m.alert_rules {
		ids = append(ids, id)
	}
	return
}

// ResetAlertRules resets all changes to the "alert_rules" edge.
func (m *SLADefinitionMutation) ResetAlertRules() {
	m.alert_rules = nil
	m.clearedalert_rules = false
	m.removedalert_rules = nil
}

// Where appends a list predicates to the SLADefinitionMutation builder.
func (m *SLADefinitionMutation) Where(ps ...predicate.SLADefinition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SLADefinitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SLADefinitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SLADefinition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SLADefinitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SLADefinitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SLADefinition).
func (m *SLADefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SLADefinitionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, sladefinition.FieldName)
	}
	if m.description != nil {
		fields = append(fields, sladefinition.FieldDescription)
	}
	if m.service_type != nil {
		fields = append(fields, sladefinition.FieldServiceType)
	}
	if m.priority != nil {
		fields = append(fields, sladefinition.FieldPriority)
	}
	if m.response_time != nil {
		fields = append(fields, sladefinition.FieldResponseTime)
	}
	if m.resolution_time != nil {
		fields = append(fields, sladefinition.FieldResolutionTime)
	}
	if m.business_hours != nil {
		fields = append(fields, sladefinition.FieldBusinessHours)
	}
	if m.escalation_rules != nil {
		fields = append(fields, sladefinition.FieldEscalationRules)
	}
	if m.conditions != nil {
		fields = append(fields, sladefinition.FieldConditions)
	}
	if m.is_active != nil {
		fields = append(fields, sladefinition.FieldIsActive)
	}
	if m.tenant_id != nil {
		fields = append(fields, sladefinition.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, sladefinition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sladefinition.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SLADefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sladefinition.FieldName:
		return m.Name()
	case sladefinition.FieldDescription:
		return m.Description()
	case sladefinition.FieldServiceType:
		return m.ServiceType()
	case sladefinition.FieldPriority:
		return m.Priority()
	case sladefinition.FieldResponseTime:
		return m.ResponseTime()
	case sladefinition.FieldResolutionTime:
		return m.ResolutionTime()
	case sladefinition.FieldBusinessHours:
		return m.BusinessHours()
	case sladefinition.FieldEscalationRules:
		return m.EscalationRules()
	case sladefinition.FieldConditions:
		return m.Conditions()
	case sladefinition.FieldIsActive:
		return m.IsActive()
	case sladefinition.FieldTenantID:
		return m.TenantID()
	case sladefinition.FieldCreatedAt:
		return m.CreatedAt()
	case sladefinition.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SLADefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sladefinition.FieldName:
		return m.OldName(ctx)
	case sladefinition.FieldDescription:
		return m.OldDescription(ctx)
	case sladefinition.FieldServiceType:
		return m.OldServiceType(ctx)
	case sladefinition.FieldPriority:
		return m.OldPriority(ctx)
	case sladefinition.FieldResponseTime:
		return m.OldResponseTime(ctx)
	case sladefinition.FieldResolutionTime:
		return m.OldResolutionTime(ctx)
	case sladefinition.FieldBusinessHours:
		return m.OldBusinessHours(ctx)
	case sladefinition.FieldEscalationRules:
		return m.OldEscalationRules(ctx)
	case sladefinition.FieldConditions:
		return m.OldConditions(ctx)
	case sladefinition.FieldIsActive:
		return m.OldIsActive(ctx)
	case sladefinition.FieldTenantID:
		return m.OldTenantID(ctx)
	case sladefinition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sladefinition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SLADefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLADefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sladefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sladefinition.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case sladefinition.FieldServiceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceType(v)
		return nil
	case sladefinition.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case sladefinition.FieldResponseTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseTime(v)
		return nil
	case sladefinition.FieldResolutionTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolutionTime(v)
		return nil
	case sladefinition.FieldBusinessHours:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessHours(v)
		return nil
	case sladefinition.FieldEscalationRules:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEscalationRules(v)
		return nil
	case sladefinition.FieldConditions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case sladefinition.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case sladefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case sladefinition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sladefinition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SLADefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SLADefinitionMutation) AddedFields() []string {
	var fields []string
	if m.addresponse_time != nil {
		fields = append(fields, sladefinition.FieldResponseTime)
	}
	if m.addresolution_time != nil {
		fields = append(fields, sladefinition.FieldResolutionTime)
	}
	if m.addtenant_id != nil {
		fields = append(fields, sladefinition.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SLADefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sladefinition.FieldResponseTime:
		return m.AddedResponseTime()
	case sladefinition.FieldResolutionTime:
		return m.AddedResolutionTime()
	case sladefinition.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLADefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sladefinition.FieldResponseTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResponseTime(v)
		return nil
	case sladefinition.FieldResolutionTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResolutionTime(v)
		return nil
	case sladefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown SLADefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SLADefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sladefinition.FieldDescription) {
		fields = append(fields, sladefinition.FieldDescription)
	}
	if m.FieldCleared(sladefinition.FieldServiceType) {
		fields = append(fields, sladefinition.FieldServiceType)
	}
	if m.FieldCleared(sladefinition.FieldPriority) {
		fields = append(fields, sladefinition.FieldPriority)
	}
	if m.FieldCleared(sladefinition.FieldBusinessHours) {
		fields = append(fields, sladefinition.FieldBusinessHours)
	}
	if m.FieldCleared(sladefinition.FieldEscalationRules) {
		fields = append(fields, sladefinition.FieldEscalationRules)
	}
	if m.FieldCleared(sladefinition.FieldConditions) {
		fields = append(fields, sladefinition.FieldConditions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SLADefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SLADefinitionMutation) ClearField(name string) error {
	switch name {
	case sladefinition.FieldDescription:
		m.ClearDescription()
		return nil
	case sladefinition.FieldServiceType:
		m.ClearServiceType()
		return nil
	case sladefinition.FieldPriority:
		m.ClearPriority()
		return nil
	case sladefinition.FieldBusinessHours:
		m.ClearBusinessHours()
		return nil
	case sladefinition.FieldEscalationRules:
		m.ClearEscalationRules()
		return nil
	case sladefinition.FieldConditions:
		m.ClearConditions()
		return nil
	}
	return fmt.Errorf("unknown SLADefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SLADefinitionMutation) ResetField(name string) error {
	switch name {
	case sladefinition.FieldName:
		m.ResetName()
		return nil
	case sladefinition.FieldDescription:
		m.ResetDescription()
		return nil
	case sladefinition.FieldServiceType:
		m.ResetServiceType()
		return nil
	case sladefinition.FieldPriority:
		m.ResetPriority()
		return nil
	case sladefinition.FieldResponseTime:
		m.ResetResponseTime()
		return nil
	case sladefinition.FieldResolutionTime:
		m.ResetResolutionTime()
		return nil
	case sladefinition.FieldBusinessHours:
		m.ResetBusinessHours()
		return nil
	case sladefinition.FieldEscalationRules:
		m.ResetEscalationRules()
		return nil
	case sladefinition.FieldConditions:
		m.ResetConditions()
		return nil
	case sladefinition.FieldIsActive:
		m.ResetIsActive()
		return nil
	case sladefinition.FieldTenantID:
		m.ResetTenantID()
		return nil
	case sladefinition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sladefinition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SLADefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SLADefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.violations != nil {
		edges = append(edges, sladefinition.EdgeViolations)
	}
	if m.metrics != nil {
		edges = append(edges, sladefinition.EdgeMetrics)
	}
	if m.tickets != nil {
		edges = append(edges, sladefinition.EdgeTickets)
	}
	if m.alert_rules != nil {
		edges = append(edges, sladefinition.EdgeAlertRules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SLADefinitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sladefinition.EdgeViolations:
		ids := make([]ent.Value, 0, len(m.violations))
		for id := range m.violations {
			ids = append(ids, id)
		}
		return ids
	case sladefinition.EdgeMetrics:
		ids := make([]ent.Value, 0, len(m.metrics))
		for id := range m.metrics {
			ids = append(ids, id)
		}
		return ids
	case sladefinition.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.tickets))
		for id := range m.tickets {
			ids = append(ids, id)
		}
		return ids
	case sladefinition.EdgeAlertRules:
		ids := make([]ent.Value, 0, len(m.alert_rules))
		for id := range m.alert_rules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SLADefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedviolations != nil {
		edges = append(edges, sladefinition.EdgeViolations)
	}
	if m.removedmetrics != nil {
		edges = append(edges, sladefinition.EdgeMetrics)
	}
	if m.removedtickets != nil {
		edges = append(edges, sladefinition.EdgeTickets)
	}
	if m.removedalert_rules != nil {
		edges = append(edges, sladefinition.EdgeAlertRules)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SLADefinitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sladefinition.EdgeViolations:
		ids := make([]ent.Value, 0, len(m.removedviolations))
		for id := range m.removedviolations {
			ids = append(ids, id)
		}
		return ids
	case sladefinition.EdgeMetrics:
		ids := make([]ent.Value, 0, len(m.removedmetrics))
		for id := range m.removedmetrics {
			ids = append(ids, id)
		}
		return ids
	case sladefinition.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.removedtickets))
		for id := range m.removedtickets {
			ids = append(ids, id)
		}
		return ids
	case sladefinition.EdgeAlertRules:
		ids := make([]ent.Value, 0, len(m.removedalert_rules))
		for id := range m.removedalert_rules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SLADefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedviolations {
		edges = append(edges, sladefinition.EdgeViolations)
	}
	if m.clearedmetrics {
		edges = append(edges, sladefinition.EdgeMetrics)
	}
	if m.clearedtickets {
		edges = append(edges, sladefinition.EdgeTickets)
	}
	if m.clearedalert_rules {
		edges = append(edges, sladefinition.EdgeAlertRules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SLADefinitionMutation) EdgeCleared(name string) bool {
	switch name {
	case sladefinition.EdgeViolations:
		return m.clearedviolations
	case sladefinition.EdgeMetrics:
		return m.clearedmetrics
	case sladefinition.EdgeTickets:
		return m.clearedtickets
	case sladefinition.EdgeAlertRules:
		return m.clearedalert_rules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SLADefinitionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SLADefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SLADefinitionMutation) ResetEdge(name string) error {
	switch name {
	case sladefinition.EdgeViolations:
		m.ResetViolations()
		return nil
	case sladefinition.EdgeMetrics:
		m.ResetMetrics()
		return nil
	case sladefinition.EdgeTickets:
		m.ResetTickets()
		return nil
	case sladefinition.EdgeAlertRules:
		m.ResetAlertRules()
		return nil
	}
	return fmt.Errorf("unknown SLADefinition edge %s", name)
}

// SLAMetricMutation represents an operation that mutates the SLAMetric nodes in the graph.
type SLAMetricMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	metric_type           *string
	metric_name           *string
	metric_value          *float64
	addmetric_value       *float64
	unit                  *string
	measurement_time      *time.Time
	metadata              *map[string]interface{}
	tenant_id             *int
	addtenant_id          *int
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	sla_definition        *int
	clearedsla_definition bool
	done                  bool
	oldValue              func(context.Context) (*SLAMetric, error)
	predicates            []predicate.SLAMetric
}

var _ ent.Mutation = (*SLAMetricMutation)(nil)

// slametricOption allows management of the mutation configuration using functional options.
type slametricOption func(*SLAMetricMutation)

// newSLAMetricMutation creates new mutation for the SLAMetric entity.
func newSLAMetricMutation(c config, op Op, opts ...slametricOption) *SLAMetricMutation {
	m := &SLAMetricMutation{
		config:        c,
		op:            op,
		typ:           TypeSLAMetric,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSLAMetricID sets the ID field of the mutation.
func withSLAMetricID(id int) slametricOption {
	return func(m *SLAMetricMutation) {
		var (
			err   error
			once  sync.Once
			value *SLAMetric
		)
		m.oldValue = func(ctx context.Context) (*SLAMetric, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SLAMetric.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSLAMetric sets the old SLAMetric of the mutation.
func withSLAMetric(node *SLAMetric) slametricOption {
	return func(m *SLAMetricMutation) {
		m.oldValue = func(context.Context) (*SLAMetric, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SLAMetricMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SLAMetricMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SLAMetricMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SLAMetricMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SLAMetric.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSLADefinitionID sets the "sla_definition_id" field.
func (m *SLAMetricMutation) SetSLADefinitionID(i int) {
	m.sla_definition = &i
}

// SLADefinitionID returns the value of the "sla_definition_id" field in the mutation.
func (m *SLAMetricMutation) SLADefinitionID() (r int, exists bool) {
	v := m.sla_definition
	if v == nil {
		return
	}
	return *v, true
}

// OldSLADefinitionID returns the old "sla_definition_id" field's value of the SLAMetric entity.
// If the SLAMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAMetricMutation) OldSLADefinitionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSLADefinitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSLADefinitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSLADefinitionID: %w", err)
	}
	return oldValue.SLADefinitionID, nil
}

// ResetSLADefinitionID resets all changes to the "sla_definition_id" field.
func (m *SLAMetricMutation) ResetSLADefinitionID() {
	m.sla_definition = nil
}

// SetMetricType sets the "metric_type" field.
func (m *SLAMetricMutation) SetMetricType(s string) {
	m.metric_type = &s
}

// MetricType returns the value of the "metric_type" field in the mutation.
func (m *SLAMetricMutation) MetricType() (r string, exists bool) {
	v := m.metric_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricType returns the old "metric_type" field's value of the SLAMetric entity.
// If the SLAMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAMetricMutation) OldMetricType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricType: %w", err)
	}
	return oldValue.MetricType, nil
}

// ResetMetricType resets all changes to the "metric_type" field.
func (m *SLAMetricMutation) ResetMetricType() {
	m.metric_type = nil
}

// SetMetricName sets the "metric_name" field.
func (m *SLAMetricMutation) SetMetricName(s string) {
	m.metric_name = &s
}

// MetricName returns the value of the "metric_name" field in the mutation.
func (m *SLAMetricMutation) MetricName() (r string, exists bool) {
	v := m.metric_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricName returns the old "metric_name" field's value of the SLAMetric entity.
// If the SLAMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAMetricMutation) OldMetricName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricName: %w", err)
	}
	return oldValue.MetricName, nil
}

// ResetMetricName resets all changes to the "metric_name" field.
func (m *SLAMetricMutation) ResetMetricName() {
	m.metric_name = nil
}

// SetMetricValue sets the "metric_value" field.
func (m *SLAMetricMutation) SetMetricValue(f float64) {
	m.metric_value = &f
	m.addmetric_value = nil
}

// MetricValue returns the value of the "metric_value" field in the mutation.
func (m *SLAMetricMutation) MetricValue() (r float64, exists bool) {
	v := m.metric_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricValue returns the old "metric_value" field's value of the SLAMetric entity.
// If the SLAMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAMetricMutation) OldMetricValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricValue: %w", err)
	}
	return oldValue.MetricValue, nil
}

// AddMetricValue adds f to the "metric_value" field.
func (m *SLAMetricMutation) AddMetricValue(f float64) {
	if m.addmetric_value != nil {
		*m.addmetric_value += f
	} else {
		m.addmetric_value = &f
	}
}

// AddedMetricValue returns the value that was added to the "metric_value" field in this mutation.
func (m *SLAMetricMutation) AddedMetricValue() (r float64, exists bool) {
	v := m.addmetric_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetMetricValue resets all changes to the "metric_value" field.
func (m *SLAMetricMutation) ResetMetricValue() {
	m.metric_value = nil
	m.addmetric_value = nil
}

// SetUnit sets the "unit" field.
func (m *SLAMetricMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *SLAMetricMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the SLAMetric entity.
// If the SLAMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAMetricMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ClearUnit clears the value of the "unit" field.
func (m *SLAMetricMutation) ClearUnit() {
	m.unit = nil
	m.clearedFields[slametric.FieldUnit] = struct{}{}
}

// UnitCleared returns if the "unit" field was cleared in this mutation.
func (m *SLAMetricMutation) UnitCleared() bool {
	_, ok := m.clearedFields[slametric.FieldUnit]
	return ok
}

// ResetUnit resets all changes to the "unit" field.
func (m *SLAMetricMutation) ResetUnit() {
	m.unit = nil
	delete(m.clearedFields, slametric.FieldUnit)
}

// SetMeasurementTime sets the "measurement_time" field.
func (m *SLAMetricMutation) SetMeasurementTime(t time.Time) {
	m.measurement_time = &t
}

// MeasurementTime returns the value of the "measurement_time" field in the mutation.
func (m *SLAMetricMutation) MeasurementTime() (r time.Time, exists bool) {
	v := m.measurement_time
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasurementTime returns the old "measurement_time" field's value of the SLAMetric entity.
// If the SLAMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAMetricMutation) OldMeasurementTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeasurementTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeasurementTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasurementTime: %w", err)
	}
	return oldValue.MeasurementTime, nil
}

// ResetMeasurementTime resets all changes to the "measurement_time" field.
func (m *SLAMetricMutation) ResetMeasurementTime() {
	m.measurement_time = nil
}

// SetMetadata sets the "metadata" field.
func (m *SLAMetricMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SLAMetricMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the SLAMetric entity.
// If the SLAMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAMetricMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SLAMetricMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[slametric.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SLAMetricMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[slametric.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SLAMetricMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, slametric.FieldMetadata)
}

// SetTenantID sets the "tenant_id" field.
func (m *SLAMetricMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SLAMetricMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SLAMetric entity.
// If the SLAMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAMetricMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *SLAMetricMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *SLAMetricMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SLAMetricMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SLAMetricMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SLAMetricMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SLAMetric entity.
// If the SLAMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAMetricMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SLAMetricMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SLAMetricMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SLAMetricMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SLAMetric entity.
// If the SLAMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAMetricMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SLAMetricMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearSLADefinition clears the "sla_definition" edge to the SLADefinition entity.
func (m *SLAMetricMutation) ClearSLADefinition() {
	m.clearedsla_definition = true
	m.clearedFields[slametric.FieldSLADefinitionID] = struct{}{}
}

// SLADefinitionCleared reports if the "sla_definition" edge to the SLADefinition entity was cleared.
func (m *SLAMetricMutation) SLADefinitionCleared() bool {
	return m.clearedsla_definition
}

// SLADefinitionIDs returns the "sla_definition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SLADefinitionID instead. It exists only for internal usage by the builders.
func (m *SLAMetricMutation) SLADefinitionIDs() (ids []int) {
	if id := m.sla_definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSLADefinition resets all changes to the "sla_definition" edge.
func (m *SLAMetricMutation) ResetSLADefinition() {
	m.sla_definition = nil
	m.clearedsla_definition = false
}

// Where appends a list predicates to the SLAMetricMutation builder.
func (m *SLAMetricMutation) Where(ps ...predicate.SLAMetric) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SLAMetricMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SLAMetricMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SLAMetric, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SLAMetricMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SLAMetricMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SLAMetric).
func (m *SLAMetricMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SLAMetricMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.sla_definition != nil {
		fields = append(fields, slametric.FieldSLADefinitionID)
	}
	if m.metric_type != nil {
		fields = append(fields, slametric.FieldMetricType)
	}
	if m.metric_name != nil {
		fields = append(fields, slametric.FieldMetricName)
	}
	if m.metric_value != nil {
		fields = append(fields, slametric.FieldMetricValue)
	}
	if m.unit != nil {
		fields = append(fields, slametric.FieldUnit)
	}
	if m.measurement_time != nil {
		fields = append(fields, slametric.FieldMeasurementTime)
	}
	if m.metadata != nil {
		fields = append(fields, slametric.FieldMetadata)
	}
	if m.tenant_id != nil {
		fields = append(fields, slametric.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, slametric.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, slametric.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SLAMetricMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case slametric.FieldSLADefinitionID:
		return m.SLADefinitionID()
	case slametric.FieldMetricType:
		return m.MetricType()
	case slametric.FieldMetricName:
		return m.MetricName()
	case slametric.FieldMetricValue:
		return m.MetricValue()
	case slametric.FieldUnit:
		return m.Unit()
	case slametric.FieldMeasurementTime:
		return m.MeasurementTime()
	case slametric.FieldMetadata:
		return m.Metadata()
	case slametric.FieldTenantID:
		return m.TenantID()
	case slametric.FieldCreatedAt:
		return m.CreatedAt()
	case slametric.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SLAMetricMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case slametric.FieldSLADefinitionID:
		return m.OldSLADefinitionID(ctx)
	case slametric.FieldMetricType:
		return m.OldMetricType(ctx)
	case slametric.FieldMetricName:
		return m.OldMetricName(ctx)
	case slametric.FieldMetricValue:
		return m.OldMetricValue(ctx)
	case slametric.FieldUnit:
		return m.OldUnit(ctx)
	case slametric.FieldMeasurementTime:
		return m.OldMeasurementTime(ctx)
	case slametric.FieldMetadata:
		return m.OldMetadata(ctx)
	case slametric.FieldTenantID:
		return m.OldTenantID(ctx)
	case slametric.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case slametric.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SLAMetric field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLAMetricMutation) SetField(name string, value ent.Value) error {
	switch name {
	case slametric.FieldSLADefinitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSLADefinitionID(v)
		return nil
	case slametric.FieldMetricType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricType(v)
		return nil
	case slametric.FieldMetricName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricName(v)
		return nil
	case slametric.FieldMetricValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricValue(v)
		return nil
	case slametric.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case slametric.FieldMeasurementTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasurementTime(v)
		return nil
	case slametric.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case slametric.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case slametric.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case slametric.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SLAMetric field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SLAMetricMutation) AddedFields() []string {
	var fields []string
	if m.addmetric_value != nil {
		fields = append(fields, slametric.FieldMetricValue)
	}
	if m.addtenant_id != nil {
		fields = append(fields, slametric.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SLAMetricMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case slametric.FieldMetricValue:
		return m.AddedMetricValue()
	case slametric.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLAMetricMutation) AddField(name string, value ent.Value) error {
	switch name {
	case slametric.FieldMetricValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMetricValue(v)
		return nil
	case slametric.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown SLAMetric numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SLAMetricMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(slametric.FieldUnit) {
		fields = append(fields, slametric.FieldUnit)
	}
	if m.FieldCleared(slametric.FieldMetadata) {
		fields = append(fields, slametric.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SLAMetricMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SLAMetricMutation) ClearField(name string) error {
	switch name {
	case slametric.FieldUnit:
		m.ClearUnit()
		return nil
	case slametric.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown SLAMetric nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SLAMetricMutation) ResetField(name string) error {
	switch name {
	case slametric.FieldSLADefinitionID:
		m.ResetSLADefinitionID()
		return nil
	case slametric.FieldMetricType:
		m.ResetMetricType()
		return nil
	case slametric.FieldMetricName:
		m.ResetMetricName()
		return nil
	case slametric.FieldMetricValue:
		m.ResetMetricValue()
		return nil
	case slametric.FieldUnit:
		m.ResetUnit()
		return nil
	case slametric.FieldMeasurementTime:
		m.ResetMeasurementTime()
		return nil
	case slametric.FieldMetadata:
		m.ResetMetadata()
		return nil
	case slametric.FieldTenantID:
		m.ResetTenantID()
		return nil
	case slametric.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case slametric.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SLAMetric field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SLAMetricMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sla_definition != nil {
		edges = append(edges, slametric.EdgeSLADefinition)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SLAMetricMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case slametric.EdgeSLADefinition:
		if id := m.sla_definition; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SLAMetricMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SLAMetricMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SLAMetricMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsla_definition {
		edges = append(edges, slametric.EdgeSLADefinition)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SLAMetricMutation) EdgeCleared(name string) bool {
	switch name {
	case slametric.EdgeSLADefinition:
		return m.clearedsla_definition
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SLAMetricMutation) ClearEdge(name string) error {
	switch name {
	case slametric.EdgeSLADefinition:
		m.ClearSLADefinition()
		return nil
	}
	return fmt.Errorf("unknown SLAMetric unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SLAMetricMutation) ResetEdge(name string) error {
	switch name {
	case slametric.EdgeSLADefinition:
		m.ResetSLADefinition()
		return nil
	}
	return fmt.Errorf("unknown SLAMetric edge %s", name)
}

// SLAViolationMutation represents an operation that mutates the SLAViolation nodes in the graph.
type SLAViolationMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	violation_type        *string
	violation_time        *time.Time
	description           *string
	severity              *string
	is_resolved           *bool
	resolved_at           *time.Time
	resolution_notes      *string
	tenant_id             *int
	addtenant_id          *int
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	sla_definition        *int
	clearedsla_definition bool
	ticket                *int
	clearedticket         bool
	done                  bool
	oldValue              func(context.Context) (*SLAViolation, error)
	predicates            []predicate.SLAViolation
}

var _ ent.Mutation = (*SLAViolationMutation)(nil)

// slaviolationOption allows management of the mutation configuration using functional options.
type slaviolationOption func(*SLAViolationMutation)

// newSLAViolationMutation creates new mutation for the SLAViolation entity.
func newSLAViolationMutation(c config, op Op, opts ...slaviolationOption) *SLAViolationMutation {
	m := &SLAViolationMutation{
		config:        c,
		op:            op,
		typ:           TypeSLAViolation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSLAViolationID sets the ID field of the mutation.
func withSLAViolationID(id int) slaviolationOption {
	return func(m *SLAViolationMutation) {
		var (
			err   error
			once  sync.Once
			value *SLAViolation
		)
		m.oldValue = func(ctx context.Context) (*SLAViolation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SLAViolation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSLAViolation sets the old SLAViolation of the mutation.
func withSLAViolation(node *SLAViolation) slaviolationOption {
	return func(m *SLAViolationMutation) {
		m.oldValue = func(context.Context) (*SLAViolation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SLAViolationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SLAViolationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SLAViolationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SLAViolationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SLAViolation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSLADefinitionID sets the "sla_definition_id" field.
func (m *SLAViolationMutation) SetSLADefinitionID(i int) {
	m.sla_definition = &i
}

// SLADefinitionID returns the value of the "sla_definition_id" field in the mutation.
func (m *SLAViolationMutation) SLADefinitionID() (r int, exists bool) {
	v := m.sla_definition
	if v == nil {
		return
	}
	return *v, true
}

// OldSLADefinitionID returns the old "sla_definition_id" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldSLADefinitionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSLADefinitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSLADefinitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSLADefinitionID: %w", err)
	}
	return oldValue.SLADefinitionID, nil
}

// ResetSLADefinitionID resets all changes to the "sla_definition_id" field.
func (m *SLAViolationMutation) ResetSLADefinitionID() {
	m.sla_definition = nil
}

// SetTicketID sets the "ticket_id" field.
func (m *SLAViolationMutation) SetTicketID(i int) {
	m.ticket = &i
}

// TicketID returns the value of the "ticket_id" field in the mutation.
func (m *SLAViolationMutation) TicketID() (r int, exists bool) {
	v := m.ticket
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketID returns the old "ticket_id" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldTicketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketID: %w", err)
	}
	return oldValue.TicketID, nil
}

// ResetTicketID resets all changes to the "ticket_id" field.
func (m *SLAViolationMutation) ResetTicketID() {
	m.ticket = nil
}

// SetViolationType sets the "violation_type" field.
func (m *SLAViolationMutation) SetViolationType(s string) {
	m.violation_type = &s
}

// ViolationType returns the value of the "violation_type" field in the mutation.
func (m *SLAViolationMutation) ViolationType() (r string, exists bool) {
	v := m.violation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldViolationType returns the old "violation_type" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldViolationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViolationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViolationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViolationType: %w", err)
	}
	return oldValue.ViolationType, nil
}

// ResetViolationType resets all changes to the "violation_type" field.
func (m *SLAViolationMutation) ResetViolationType() {
	m.violation_type = nil
}

// SetViolationTime sets the "violation_time" field.
func (m *SLAViolationMutation) SetViolationTime(t time.Time) {
	m.violation_time = &t
}

// ViolationTime returns the value of the "violation_time" field in the mutation.
func (m *SLAViolationMutation) ViolationTime() (r time.Time, exists bool) {
	v := m.violation_time
	if v == nil {
		return
	}
	return *v, true
}

// OldViolationTime returns the old "violation_time" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldViolationTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViolationTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViolationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViolationTime: %w", err)
	}
	return oldValue.ViolationTime, nil
}

// ResetViolationTime resets all changes to the "violation_time" field.
func (m *SLAViolationMutation) ResetViolationTime() {
	m.violation_time = nil
}

// SetDescription sets the "description" field.
func (m *SLAViolationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SLAViolationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SLAViolationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[slaviolation.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SLAViolationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[slaviolation.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SLAViolationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, slaviolation.FieldDescription)
}

// SetSeverity sets the "severity" field.
func (m *SLAViolationMutation) SetSeverity(s string) {
	m.severity = &s
}

// Severity returns the value of the "severity" field in the mutation.
func (m *SLAViolationMutation) Severity() (r string, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldSeverity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *SLAViolationMutation) ResetSeverity() {
	m.severity = nil
}

// SetIsResolved sets the "is_resolved" field.
func (m *SLAViolationMutation) SetIsResolved(b bool) {
	m.is_resolved = &b
}

// IsResolved returns the value of the "is_resolved" field in the mutation.
func (m *SLAViolationMutation) IsResolved() (r bool, exists bool) {
	v := m.is_resolved
	if v == nil {
		return
	}
	return *v, true
}

// OldIsResolved returns the old "is_resolved" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldIsResolved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsResolved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsResolved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsResolved: %w", err)
	}
	return oldValue.IsResolved, nil
}

// ResetIsResolved resets all changes to the "is_resolved" field.
func (m *SLAViolationMutation) ResetIsResolved() {
	m.is_resolved = nil
}

// SetResolvedAt sets the "resolved_at" field.
func (m *SLAViolationMutation) SetResolvedAt(t time.Time) {
	m.resolved_at = &t
}

// ResolvedAt returns the value of the "resolved_at" field in the mutation.
func (m *SLAViolationMutation) ResolvedAt() (r time.Time, exists bool) {
	v := m.resolved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedAt returns the old "resolved_at" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldResolvedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedAt: %w", err)
	}
	return oldValue.ResolvedAt, nil
}

// ClearResolvedAt clears the value of the "resolved_at" field.
func (m *SLAViolationMutation) ClearResolvedAt() {
	m.resolved_at = nil
	m.clearedFields[slaviolation.FieldResolvedAt] = struct{}{}
}

// ResolvedAtCleared returns if the "resolved_at" field was cleared in this mutation.
func (m *SLAViolationMutation) ResolvedAtCleared() bool {
	_, ok := m.clearedFields[slaviolation.FieldResolvedAt]
	return ok
}

// ResetResolvedAt resets all changes to the "resolved_at" field.
func (m *SLAViolationMutation) ResetResolvedAt() {
	m.resolved_at = nil
	delete(m.clearedFields, slaviolation.FieldResolvedAt)
}

// SetResolutionNotes sets the "resolution_notes" field.
func (m *SLAViolationMutation) SetResolutionNotes(s string) {
	m.resolution_notes = &s
}

// ResolutionNotes returns the value of the "resolution_notes" field in the mutation.
func (m *SLAViolationMutation) ResolutionNotes() (r string, exists bool) {
	v := m.resolution_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldResolutionNotes returns the old "resolution_notes" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldResolutionNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolutionNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolutionNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolutionNotes: %w", err)
	}
	return oldValue.ResolutionNotes, nil
}

// ClearResolutionNotes clears the value of the "resolution_notes" field.
func (m *SLAViolationMutation) ClearResolutionNotes() {
	m.resolution_notes = nil
	m.clearedFields[slaviolation.FieldResolutionNotes] = struct{}{}
}

// ResolutionNotesCleared returns if the "resolution_notes" field was cleared in this mutation.
func (m *SLAViolationMutation) ResolutionNotesCleared() bool {
	_, ok := m.clearedFields[slaviolation.FieldResolutionNotes]
	return ok
}

// ResetResolutionNotes resets all changes to the "resolution_notes" field.
func (m *SLAViolationMutation) ResetResolutionNotes() {
	m.resolution_notes = nil
	delete(m.clearedFields, slaviolation.FieldResolutionNotes)
}

// SetTenantID sets the "tenant_id" field.
func (m *SLAViolationMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SLAViolationMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *SLAViolationMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *SLAViolationMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SLAViolationMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SLAViolationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SLAViolationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SLAViolationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SLAViolationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SLAViolationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SLAViolationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearSLADefinition clears the "sla_definition" edge to the SLADefinition entity.
func (m *SLAViolationMutation) ClearSLADefinition() {
	m.clearedsla_definition = true
	m.clearedFields[slaviolation.FieldSLADefinitionID] = struct{}{}
}

// SLADefinitionCleared reports if the "sla_definition" edge to the SLADefinition entity was cleared.
func (m *SLAViolationMutation) SLADefinitionCleared() bool {
	return m.clearedsla_definition
}

// SLADefinitionIDs returns the "sla_definition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SLADefinitionID instead. It exists only for internal usage by the builders.
func (m *SLAViolationMutation) SLADefinitionIDs() (ids []int) {
	if id := m.sla_definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSLADefinition resets all changes to the "sla_definition" edge.
func (m *SLAViolationMutation) ResetSLADefinition() {
	m.sla_definition = nil
	m.clearedsla_definition = false
}

// ClearTicket clears the "ticket" edge to the Ticket entity.
func (m *SLAViolationMutation) ClearTicket() {
	m.clearedticket = true
	m.clearedFields[slaviolation.FieldTicketID] = struct{}{}
}

// TicketCleared reports if the "ticket" edge to the Ticket entity was cleared.
func (m *SLAViolationMutation) TicketCleared() bool {
	return m.clearedticket
}

// TicketIDs returns the "ticket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TicketID instead. It exists only for internal usage by the builders.
func (m *SLAViolationMutation) TicketIDs() (ids []int) {
	if id := m.ticket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicket resets all changes to the "ticket" edge.
func (m *SLAViolationMutation) ResetTicket() {
	m.ticket = nil
	m.clearedticket = false
}

// Where appends a list predicates to the SLAViolationMutation builder.
func (m *SLAViolationMutation) Where(ps ...predicate.SLAViolation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SLAViolationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SLAViolationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SLAViolation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SLAViolationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SLAViolationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SLAViolation).
func (m *SLAViolationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SLAViolationMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.sla_definition != nil {
		fields = append(fields, slaviolation.FieldSLADefinitionID)
	}
	if m.ticket != nil {
		fields = append(fields, slaviolation.FieldTicketID)
	}
	if m.violation_type != nil {
		fields = append(fields, slaviolation.FieldViolationType)
	}
	if m.violation_time != nil {
		fields = append(fields, slaviolation.FieldViolationTime)
	}
	if m.description != nil {
		fields = append(fields, slaviolation.FieldDescription)
	}
	if m.severity != nil {
		fields = append(fields, slaviolation.FieldSeverity)
	}
	if m.is_resolved != nil {
		fields = append(fields, slaviolation.FieldIsResolved)
	}
	if m.resolved_at != nil {
		fields = append(fields, slaviolation.FieldResolvedAt)
	}
	if m.resolution_notes != nil {
		fields = append(fields, slaviolation.FieldResolutionNotes)
	}
	if m.tenant_id != nil {
		fields = append(fields, slaviolation.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, slaviolation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, slaviolation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SLAViolationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		return m.SLADefinitionID()
	case slaviolation.FieldTicketID:
		return m.TicketID()
	case slaviolation.FieldViolationType:
		return m.ViolationType()
	case slaviolation.FieldViolationTime:
		return m.ViolationTime()
	case slaviolation.FieldDescription:
		return m.Description()
	case slaviolation.FieldSeverity:
		return m.Severity()
	case slaviolation.FieldIsResolved:
		return m.IsResolved()
	case slaviolation.FieldResolvedAt:
		return m.ResolvedAt()
	case slaviolation.FieldResolutionNotes:
		return m.ResolutionNotes()
	case slaviolation.FieldTenantID:
		return m.TenantID()
	case slaviolation.FieldCreatedAt:
		return m.CreatedAt()
	case slaviolation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SLAViolationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		return m.OldSLADefinitionID(ctx)
	case slaviolation.FieldTicketID:
		return m.OldTicketID(ctx)
	case slaviolation.FieldViolationType:
		return m.OldViolationType(ctx)
	case slaviolation.FieldViolationTime:
		return m.OldViolationTime(ctx)
	case slaviolation.FieldDescription:
		return m.OldDescription(ctx)
	case slaviolation.FieldSeverity:
		return m.OldSeverity(ctx)
	case slaviolation.FieldIsResolved:
		return m.OldIsResolved(ctx)
	case slaviolation.FieldResolvedAt:
		return m.OldResolvedAt(ctx)
	case slaviolation.FieldResolutionNotes:
		return m.OldResolutionNotes(ctx)
	case slaviolation.FieldTenantID:
		return m.OldTenantID(ctx)
	case slaviolation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case slaviolation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SLAViolation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLAViolationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSLADefinitionID(v)
		return nil
	case slaviolation.FieldTicketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketID(v)
		return nil
	case slaviolation.FieldViolationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViolationType(v)
		return nil
	case slaviolation.FieldViolationTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViolationTime(v)
		return nil
	case slaviolation.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case slaviolation.FieldSeverity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case slaviolation.FieldIsResolved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsResolved(v)
		return nil
	case slaviolation.FieldResolvedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedAt(v)
		return nil
	case slaviolation.FieldResolutionNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolutionNotes(v)
		return nil
	case slaviolation.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case slaviolation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case slaviolation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SLAViolation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SLAViolationMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, slaviolation.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SLAViolationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case slaviolation.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLAViolationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case slaviolation.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown SLAViolation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SLAViolationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(slaviolation.FieldDescription) {
		fields = append(fields, slaviolation.FieldDescription)
	}
	if m.FieldCleared(slaviolation.FieldResolvedAt) {
		fields = append(fields, slaviolation.FieldResolvedAt)
	}
	if m.FieldCleared(slaviolation.FieldResolutionNotes) {
		fields = append(fields, slaviolation.FieldResolutionNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SLAViolationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SLAViolationMutation) ClearField(name string) error {
	switch name {
	case slaviolation.FieldDescription:
		m.ClearDescription()
		return nil
	case slaviolation.FieldResolvedAt:
		m.ClearResolvedAt()
		return nil
	case slaviolation.FieldResolutionNotes:
		m.ClearResolutionNotes()
		return nil
	}
	return fmt.Errorf("unknown SLAViolation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SLAViolationMutation) ResetField(name string) error {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		m.ResetSLADefinitionID()
		return nil
	case slaviolation.FieldTicketID:
		m.ResetTicketID()
		return nil
	case slaviolation.FieldViolationType:
		m.ResetViolationType()
		return nil
	case slaviolation.FieldViolationTime:
		m.ResetViolationTime()
		return nil
	case slaviolation.FieldDescription:
		m.ResetDescription()
		return nil
	case slaviolation.FieldSeverity:
		m.ResetSeverity()
		return nil
	case slaviolation.FieldIsResolved:
		m.ResetIsResolved()
		return nil
	case slaviolation.FieldResolvedAt:
		m.ResetResolvedAt()
		return nil
	case slaviolation.FieldResolutionNotes:
		m.ResetResolutionNotes()
		return nil
	case slaviolation.FieldTenantID:
		m.ResetTenantID()
		return nil
	case slaviolation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case slaviolation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SLAViolation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SLAViolationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.sla_definition != nil {
		edges = append(edges, slaviolation.EdgeSLADefinition)
	}
	if m.ticket != nil {
		edges = append(edges, slaviolation.EdgeTicket)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SLAViolationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case slaviolation.EdgeSLADefinition:
		if id := m.sla_definition; id != nil {
			return []ent.Value{*id}
		}
	case slaviolation.EdgeTicket:
		if id := m.ticket; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SLAViolationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SLAViolationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SLAViolationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsla_definition {
		edges = append(edges, slaviolation.EdgeSLADefinition)
	}
	if m.clearedticket {
		edges = append(edges, slaviolation.EdgeTicket)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SLAViolationMutation) EdgeCleared(name string) bool {
	switch name {
	case slaviolation.EdgeSLADefinition:
		return m.clearedsla_definition
	case slaviolation.EdgeTicket:
		return m.clearedticket
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SLAViolationMutation) ClearEdge(name string) error {
	switch name {
	case slaviolation.EdgeSLADefinition:
		m.ClearSLADefinition()
		return nil
	case slaviolation.EdgeTicket:
		m.ClearTicket()
		return nil
	}
	return fmt.Errorf("unknown SLAViolation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SLAViolationMutation) ResetEdge(name string) error {
	switch name {
	case slaviolation.EdgeSLADefinition:
		m.ResetSLADefinition()
		return nil
	case slaviolation.EdgeTicket:
		m.ResetTicket()
		return nil
	}
	return fmt.Errorf("unknown SLAViolation edge %s", name)
}

// ServiceCatalogMutation represents an operation that mutates the ServiceCatalog nodes in the graph.
type ServiceCatalogMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	description      *string
	category         *string
	price            *float64
	addprice         *float64
	delivery_time    *int
	adddelivery_time *int
	status           *string
	tenant_id        *int
	addtenant_id     *int
	is_active        *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*ServiceCatalog, error)
	predicates       []predicate.ServiceCatalog
}

var _ ent.Mutation = (*ServiceCatalogMutation)(nil)

// servicecatalogOption allows management of the mutation configuration using functional options.
type servicecatalogOption func(*ServiceCatalogMutation)

// newServiceCatalogMutation creates new mutation for the ServiceCatalog entity.
func newServiceCatalogMutation(c config, op Op, opts ...servicecatalogOption) *ServiceCatalogMutation {
	m := &ServiceCatalogMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceCatalog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceCatalogID sets the ID field of the mutation.
func withServiceCatalogID(id int) servicecatalogOption {
	return func(m *ServiceCatalogMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceCatalog
		)
		m.oldValue = func(ctx context.Context) (*ServiceCatalog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceCatalog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceCatalog sets the old ServiceCatalog of the mutation.
func withServiceCatalog(node *ServiceCatalog) servicecatalogOption {
	return func(m *ServiceCatalogMutation) {
		m.oldValue = func(context.Context) (*ServiceCatalog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceCatalogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceCatalogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceCatalogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceCatalogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceCatalog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ServiceCatalogMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceCatalogMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceCatalogMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ServiceCatalogMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServiceCatalogMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ServiceCatalogMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[servicecatalog.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ServiceCatalogMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[servicecatalog.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ServiceCatalogMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, servicecatalog.FieldDescription)
}

// SetCategory sets the "category" field.
func (m *ServiceCatalogMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ServiceCatalogMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ServiceCatalogMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[servicecatalog.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ServiceCatalogMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[servicecatalog.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ServiceCatalogMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, servicecatalog.FieldCategory)
}

// SetPrice sets the "price" field.
func (m *ServiceCatalogMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ServiceCatalogMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ServiceCatalogMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ServiceCatalogMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *ServiceCatalogMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[servicecatalog.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *ServiceCatalogMutation) PriceCleared() bool {
	_, ok := m.clearedFields[servicecatalog.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *ServiceCatalogMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, servicecatalog.FieldPrice)
}

// SetDeliveryTime sets the "delivery_time" field.
func (m *ServiceCatalogMutation) SetDeliveryTime(i int) {
	m.delivery_time = &i
	m.adddelivery_time = nil
}

// DeliveryTime returns the value of the "delivery_time" field in the mutation.
func (m *ServiceCatalogMutation) DeliveryTime() (r int, exists bool) {
	v := m.delivery_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryTime returns the old "delivery_time" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldDeliveryTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryTime: %w", err)
	}
	return oldValue.DeliveryTime, nil
}

// AddDeliveryTime adds i to the "delivery_time" field.
func (m *ServiceCatalogMutation) AddDeliveryTime(i int) {
	if m.adddelivery_time != nil {
		*m.adddelivery_time += i
	} else {
		m.adddelivery_time = &i
	}
}

// AddedDeliveryTime returns the value that was added to the "delivery_time" field in this mutation.
func (m *ServiceCatalogMutation) AddedDeliveryTime() (r int, exists bool) {
	v := m.adddelivery_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeliveryTime clears the value of the "delivery_time" field.
func (m *ServiceCatalogMutation) ClearDeliveryTime() {
	m.delivery_time = nil
	m.adddelivery_time = nil
	m.clearedFields[servicecatalog.FieldDeliveryTime] = struct{}{}
}

// DeliveryTimeCleared returns if the "delivery_time" field was cleared in this mutation.
func (m *ServiceCatalogMutation) DeliveryTimeCleared() bool {
	_, ok := m.clearedFields[servicecatalog.FieldDeliveryTime]
	return ok
}

// ResetDeliveryTime resets all changes to the "delivery_time" field.
func (m *ServiceCatalogMutation) ResetDeliveryTime() {
	m.delivery_time = nil
	m.adddelivery_time = nil
	delete(m.clearedFields, servicecatalog.FieldDeliveryTime)
}

// SetStatus sets the "status" field.
func (m *ServiceCatalogMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceCatalogMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceCatalogMutation) ResetStatus() {
	m.status = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ServiceCatalogMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ServiceCatalogMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ServiceCatalogMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ServiceCatalogMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ServiceCatalogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetIsActive sets the "is_active" field.
func (m *ServiceCatalogMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ServiceCatalogMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ServiceCatalogMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceCatalogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceCatalogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceCatalogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServiceCatalogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServiceCatalogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServiceCatalogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ServiceCatalogMutation builder.
func (m *ServiceCatalogMutation) Where(ps ...predicate.ServiceCatalog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceCatalogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceCatalogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceCatalog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceCatalogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceCatalogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceCatalog).
func (m *ServiceCatalogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceCatalogMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, servicecatalog.FieldName)
	}
	if m.description != nil {
		fields = append(fields, servicecatalog.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, servicecatalog.FieldCategory)
	}
	if m.price != nil {
		fields = append(fields, servicecatalog.FieldPrice)
	}
	if m.delivery_time != nil {
		fields = append(fields, servicecatalog.FieldDeliveryTime)
	}
	if m.status != nil {
		fields = append(fields, servicecatalog.FieldStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, servicecatalog.FieldTenantID)
	}
	if m.is_active != nil {
		fields = append(fields, servicecatalog.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, servicecatalog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servicecatalog.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceCatalogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicecatalog.FieldName:
		return m.Name()
	case servicecatalog.FieldDescription:
		return m.Description()
	case servicecatalog.FieldCategory:
		return m.Category()
	case servicecatalog.FieldPrice:
		return m.Price()
	case servicecatalog.FieldDeliveryTime:
		return m.DeliveryTime()
	case servicecatalog.FieldStatus:
		return m.Status()
	case servicecatalog.FieldTenantID:
		return m.TenantID()
	case servicecatalog.FieldIsActive:
		return m.IsActive()
	case servicecatalog.FieldCreatedAt:
		return m.CreatedAt()
	case servicecatalog.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceCatalogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicecatalog.FieldName:
		return m.OldName(ctx)
	case servicecatalog.FieldDescription:
		return m.OldDescription(ctx)
	case servicecatalog.FieldCategory:
		return m.OldCategory(ctx)
	case servicecatalog.FieldPrice:
		return m.OldPrice(ctx)
	case servicecatalog.FieldDeliveryTime:
		return m.OldDeliveryTime(ctx)
	case servicecatalog.FieldStatus:
		return m.OldStatus(ctx)
	case servicecatalog.FieldTenantID:
		return m.OldTenantID(ctx)
	case servicecatalog.FieldIsActive:
		return m.OldIsActive(ctx)
	case servicecatalog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servicecatalog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceCatalog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceCatalogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicecatalog.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case servicecatalog.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case servicecatalog.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case servicecatalog.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case servicecatalog.FieldDeliveryTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryTime(v)
		return nil
	case servicecatalog.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case servicecatalog.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case servicecatalog.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case servicecatalog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servicecatalog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceCatalog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceCatalogMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, servicecatalog.FieldPrice)
	}
	if m.adddelivery_time != nil {
		fields = append(fields, servicecatalog.FieldDeliveryTime)
	}
	if m.addtenant_id != nil {
		fields = append(fields, servicecatalog.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceCatalogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servicecatalog.FieldPrice:
		return m.AddedPrice()
	case servicecatalog.FieldDeliveryTime:
		return m.AddedDeliveryTime()
	case servicecatalog.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceCatalogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servicecatalog.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case servicecatalog.FieldDeliveryTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveryTime(v)
		return nil
	case servicecatalog.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceCatalog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceCatalogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicecatalog.FieldDescription) {
		fields = append(fields, servicecatalog.FieldDescription)
	}
	if m.FieldCleared(servicecatalog.FieldCategory) {
		fields = append(fields, servicecatalog.FieldCategory)
	}
	if m.FieldCleared(servicecatalog.FieldPrice) {
		fields = append(fields, servicecatalog.FieldPrice)
	}
	if m.FieldCleared(servicecatalog.FieldDeliveryTime) {
		fields = append(fields, servicecatalog.FieldDeliveryTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceCatalogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceCatalogMutation) ClearField(name string) error {
	switch name {
	case servicecatalog.FieldDescription:
		m.ClearDescription()
		return nil
	case servicecatalog.FieldCategory:
		m.ClearCategory()
		return nil
	case servicecatalog.FieldPrice:
		m.ClearPrice()
		return nil
	case servicecatalog.FieldDeliveryTime:
		m.ClearDeliveryTime()
		return nil
	}
	return fmt.Errorf("unknown ServiceCatalog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceCatalogMutation) ResetField(name string) error {
	switch name {
	case servicecatalog.FieldName:
		m.ResetName()
		return nil
	case servicecatalog.FieldDescription:
		m.ResetDescription()
		return nil
	case servicecatalog.FieldCategory:
		m.ResetCategory()
		return nil
	case servicecatalog.FieldPrice:
		m.ResetPrice()
		return nil
	case servicecatalog.FieldDeliveryTime:
		m.ResetDeliveryTime()
		return nil
	case servicecatalog.FieldStatus:
		m.ResetStatus()
		return nil
	case servicecatalog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case servicecatalog.FieldIsActive:
		m.ResetIsActive()
		return nil
	case servicecatalog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servicecatalog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ServiceCatalog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceCatalogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceCatalogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceCatalogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceCatalogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceCatalogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceCatalogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceCatalogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ServiceCatalog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceCatalogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ServiceCatalog edge %s", name)
}

// ServiceRequestMutation represents an operation that mutates the ServiceRequest nodes in the graph.
type ServiceRequestMutation struct {
	config
	op              Op
	typ             string
	id              *int
	tenant_id       *int
	addtenant_id    *int
	catalog_id      *int
	addcatalog_id   *int
	requester_id    *int
	addrequester_id *int
	status          *string
	reason          *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*ServiceRequest, error)
	predicates      []predicate.ServiceRequest
}

var _ ent.Mutation = (*ServiceRequestMutation)(nil)

// servicerequestOption allows management of the mutation configuration using functional options.
type servicerequestOption func(*ServiceRequestMutation)

// newServiceRequestMutation creates new mutation for the ServiceRequest entity.
func newServiceRequestMutation(c config, op Op, opts ...servicerequestOption) *ServiceRequestMutation {
	m := &ServiceRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceRequestID sets the ID field of the mutation.
func withServiceRequestID(id int) servicerequestOption {
	return func(m *ServiceRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceRequest
		)
		m.oldValue = func(ctx context.Context) (*ServiceRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceRequest sets the old ServiceRequest of the mutation.
func withServiceRequest(node *ServiceRequest) servicerequestOption {
	return func(m *ServiceRequestMutation) {
		m.oldValue = func(context.Context) (*ServiceRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceRequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceRequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ServiceRequestMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ServiceRequestMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ServiceRequestMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ServiceRequestMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ServiceRequestMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCatalogID sets the "catalog_id" field.
func (m *ServiceRequestMutation) SetCatalogID(i int) {
	m.catalog_id = &i
	m.addcatalog_id = nil
}

// CatalogID returns the value of the "catalog_id" field in the mutation.
func (m *ServiceRequestMutation) CatalogID() (r int, exists bool) {
	v := m.catalog_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCatalogID returns the old "catalog_id" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldCatalogID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCatalogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCatalogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCatalogID: %w", err)
	}
	return oldValue.CatalogID, nil
}

// AddCatalogID adds i to the "catalog_id" field.
func (m *ServiceRequestMutation) AddCatalogID(i int) {
	if m.addcatalog_id != nil {
		*m.addcatalog_id += i
	} else {
		m.addcatalog_id = &i
	}
}

// AddedCatalogID returns the value that was added to the "catalog_id" field in this mutation.
func (m *ServiceRequestMutation) AddedCatalogID() (r int, exists bool) {
	v := m.addcatalog_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCatalogID resets all changes to the "catalog_id" field.
func (m *ServiceRequestMutation) ResetCatalogID() {
	m.catalog_id = nil
	m.addcatalog_id = nil
}

// SetRequesterID sets the "requester_id" field.
func (m *ServiceRequestMutation) SetRequesterID(i int) {
	m.requester_id = &i
	m.addrequester_id = nil
}

// RequesterID returns the value of the "requester_id" field in the mutation.
func (m *ServiceRequestMutation) RequesterID() (r int, exists bool) {
	v := m.requester_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequesterID returns the old "requester_id" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldRequesterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequesterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequesterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequesterID: %w", err)
	}
	return oldValue.RequesterID, nil
}

// AddRequesterID adds i to the "requester_id" field.
func (m *ServiceRequestMutation) AddRequesterID(i int) {
	if m.addrequester_id != nil {
		*m.addrequester_id += i
	} else {
		m.addrequester_id = &i
	}
}

// AddedRequesterID returns the value that was added to the "requester_id" field in this mutation.
func (m *ServiceRequestMutation) AddedRequesterID() (r int, exists bool) {
	v := m.addrequester_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequesterID resets all changes to the "requester_id" field.
func (m *ServiceRequestMutation) ResetRequesterID() {
	m.requester_id = nil
	m.addrequester_id = nil
}

// SetStatus sets the "status" field.
func (m *ServiceRequestMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceRequestMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceRequestMutation) ResetStatus() {
	m.status = nil
}

// SetReason sets the "reason" field.
func (m *ServiceRequestMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *ServiceRequestMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *ServiceRequestMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[servicerequest.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *ServiceRequestMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[servicerequest.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *ServiceRequestMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, servicerequest.FieldReason)
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServiceRequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServiceRequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServiceRequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ServiceRequestMutation builder.
func (m *ServiceRequestMutation) Where(ps ...predicate.ServiceRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceRequest).
func (m *ServiceRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceRequestMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant_id != nil {
		fields = append(fields, servicerequest.FieldTenantID)
	}
	if m.catalog_id != nil {
		fields = append(fields, servicerequest.FieldCatalogID)
	}
	if m.requester_id != nil {
		fields = append(fields, servicerequest.FieldRequesterID)
	}
	if m.status != nil {
		fields = append(fields, servicerequest.FieldStatus)
	}
	if m.reason != nil {
		fields = append(fields, servicerequest.FieldReason)
	}
	if m.created_at != nil {
		fields = append(fields, servicerequest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servicerequest.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicerequest.FieldTenantID:
		return m.TenantID()
	case servicerequest.FieldCatalogID:
		return m.CatalogID()
	case servicerequest.FieldRequesterID:
		return m.RequesterID()
	case servicerequest.FieldStatus:
		return m.Status()
	case servicerequest.FieldReason:
		return m.Reason()
	case servicerequest.FieldCreatedAt:
		return m.CreatedAt()
	case servicerequest.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicerequest.FieldTenantID:
		return m.OldTenantID(ctx)
	case servicerequest.FieldCatalogID:
		return m.OldCatalogID(ctx)
	case servicerequest.FieldRequesterID:
		return m.OldRequesterID(ctx)
	case servicerequest.FieldStatus:
		return m.OldStatus(ctx)
	case servicerequest.FieldReason:
		return m.OldReason(ctx)
	case servicerequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servicerequest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicerequest.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case servicerequest.FieldCatalogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCatalogID(v)
		return nil
	case servicerequest.FieldRequesterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequesterID(v)
		return nil
	case servicerequest.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case servicerequest.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case servicerequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servicerequest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceRequestMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, servicerequest.FieldTenantID)
	}
	if m.addcatalog_id != nil {
		fields = append(fields, servicerequest.FieldCatalogID)
	}
	if m.addrequester_id != nil {
		fields = append(fields, servicerequest.FieldRequesterID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceRequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servicerequest.FieldTenantID:
		return m.AddedTenantID()
	case servicerequest.FieldCatalogID:
		return m.AddedCatalogID()
	case servicerequest.FieldRequesterID:
		return m.AddedRequesterID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servicerequest.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case servicerequest.FieldCatalogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCatalogID(v)
		return nil
	case servicerequest.FieldRequesterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequesterID(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicerequest.FieldReason) {
		fields = append(fields, servicerequest.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceRequestMutation) ClearField(name string) error {
	switch name {
	case servicerequest.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown ServiceRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceRequestMutation) ResetField(name string) error {
	switch name {
	case servicerequest.FieldTenantID:
		m.ResetTenantID()
		return nil
	case servicerequest.FieldCatalogID:
		m.ResetCatalogID()
		return nil
	case servicerequest.FieldRequesterID:
		m.ResetRequesterID()
		return nil
	case servicerequest.FieldStatus:
		m.ResetStatus()
		return nil
	case servicerequest.FieldReason:
		m.ResetReason()
		return nil
	case servicerequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servicerequest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ServiceRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceRequestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceRequestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceRequestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ServiceRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceRequestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ServiceRequest edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	code                 *string
	description          *string
	color                *string
	tenant_id            *int
	addtenant_id         *int
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	projects             map[int]struct{}
	removedprojects      map[int]struct{}
	clearedprojects      bool
	applications         map[int]struct{}
	removedapplications  map[int]struct{}
	clearedapplications  bool
	microservices        map[int]struct{}
	removedmicroservices map[int]struct{}
	clearedmicroservices bool
	departments          map[int]struct{}
	removeddepartments   map[int]struct{}
	cleareddepartments   bool
	teams                map[int]struct{}
	removedteams         map[int]struct{}
	clearedteams         bool
	done                 bool
	oldValue             func(context.Context) (*Tag, error)
	predicates           []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *TagMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TagMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TagMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tag.FieldDescription)
}

// SetColor sets the "color" field.
func (m *TagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *TagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *TagMutation) ResetColor() {
	m.color = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *TagMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TagMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TagMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TagMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TagMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *TagMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *TagMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *TagMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *TagMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *TagMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *TagMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *TagMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *TagMutation) AddApplicationIDs(ids ...int) {
	if m.applications == nil {
		m.applications = make(map[int]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *TagMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *TagMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *TagMutation) RemoveApplicationIDs(ids ...int) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *TagMutation) RemovedApplicationsIDs() (ids []int) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *TagMutation) ApplicationsIDs() (ids []int) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *TagMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// AddMicroserviceIDs adds the "microservices" edge to the Microservice entity by ids.
func (m *TagMutation) AddMicroserviceIDs(ids ...int) {
	if m.microservices == nil {
		m.microservices = make(map[int]struct{})
	}
	for i := range ids {
		m.microservices[ids[i]] = struct{}{}
	}
}

// ClearMicroservices clears the "microservices" edge to the Microservice entity.
func (m *TagMutation) ClearMicroservices() {
	m.clearedmicroservices = true
}

// MicroservicesCleared reports if the "microservices" edge to the Microservice entity was cleared.
func (m *TagMutation) MicroservicesCleared() bool {
	return m.clearedmicroservices
}

// RemoveMicroserviceIDs removes the "microservices" edge to the Microservice entity by IDs.
func (m *TagMutation) RemoveMicroserviceIDs(ids ...int) {
	if m.removedmicroservices == nil {
		m.removedmicroservices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.microservices, ids[i])
		m.removedmicroservices[ids[i]] = struct{}{}
	}
}

// RemovedMicroservices returns the removed IDs of the "microservices" edge to the Microservice entity.
func (m *TagMutation) RemovedMicroservicesIDs() (ids []int) {
	for id := range m.removedmicroservices {
		ids = append(ids, id)
	}
	return
}

// MicroservicesIDs returns the "microservices" edge IDs in the mutation.
func (m *TagMutation) MicroservicesIDs() (ids []int) {
	for id := range m.microservices {
		ids = append(ids, id)
	}
	return
}

// ResetMicroservices resets all changes to the "microservices" edge.
func (m *TagMutation) ResetMicroservices() {
	m.microservices = nil
	m.clearedmicroservices = false
	m.removedmicroservices = nil
}

// AddDepartmentIDs adds the "departments" edge to the Department entity by ids.
func (m *TagMutation) AddDepartmentIDs(ids ...int) {
	if m.departments == nil {
		m.departments = make(map[int]struct{})
	}
	for i := range ids {
		m.departments[ids[i]] = struct{}{}
	}
}

// ClearDepartments clears the "departments" edge to the Department entity.
func (m *TagMutation) ClearDepartments() {
	m.cleareddepartments = true
}

// DepartmentsCleared reports if the "departments" edge to the Department entity was cleared.
func (m *TagMutation) DepartmentsCleared() bool {
	return m.cleareddepartments
}

// RemoveDepartmentIDs removes the "departments" edge to the Department entity by IDs.
func (m *TagMutation) RemoveDepartmentIDs(ids ...int) {
	if m.removeddepartments == nil {
		m.removeddepartments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.departments, ids[i])
		m.removeddepartments[ids[i]] = struct{}{}
	}
}

// RemovedDepartments returns the removed IDs of the "departments" edge to the Department entity.
func (m *TagMutation) RemovedDepartmentsIDs() (ids []int) {
	for id := range m.removeddepartments {
		ids = append(ids, id)
	}
	return
}

// DepartmentsIDs returns the "departments" edge IDs in the mutation.
func (m *TagMutation) DepartmentsIDs() (ids []int) {
	for id := range m.departments {
		ids = append(ids, id)
	}
	return
}

// ResetDepartments resets all changes to the "departments" edge.
func (m *TagMutation) ResetDepartments() {
	m.departments = nil
	m.cleareddepartments = false
	m.removeddepartments = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *TagMutation) AddTeamIDs(ids ...int) {
	if m.teams == nil {
		m.teams = make(map[int]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *TagMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *TagMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *TagMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteams == nil {
		m.removedteams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *TagMutation) RemovedTeamsIDs() (ids []int) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *TagMutation) TeamsIDs() (ids []int) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *TagMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.code != nil {
		fields = append(fields, tag.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, tag.FieldColor)
	}
	if m.tenant_id != nil {
		fields = append(fields, tag.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldName:
		return m.Name()
	case tag.FieldCode:
		return m.Code()
	case tag.FieldDescription:
		return m.Description()
	case tag.FieldColor:
		return m.Color()
	case tag.FieldTenantID:
		return m.TenantID()
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldCode:
		return m.OldCode(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	case tag.FieldColor:
		return m.OldColor(ctx)
	case tag.FieldTenantID:
		return m.OldTenantID(ctx)
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case tag.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, tag.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tag.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDescription) {
		fields = append(fields, tag.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldCode:
		m.ResetCode()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	case tag.FieldColor:
		m.ResetColor()
		return nil
	case tag.FieldTenantID:
		m.ResetTenantID()
		return nil
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.projects != nil {
		edges = append(edges, tag.EdgeProjects)
	}
	if m.applications != nil {
		edges = append(edges, tag.EdgeApplications)
	}
	if m.microservices != nil {
		edges = append(edges, tag.EdgeMicroservices)
	}
	if m.departments != nil {
		edges = append(edges, tag.EdgeDepartments)
	}
	if m.teams != nil {
		edges = append(edges, tag.EdgeTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeMicroservices:
		ids := make([]ent.Value, 0, len(m.microservices))
		for id := range m.microservices {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.departments))
		for id := range m.departments {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedprojects != nil {
		edges = append(edges, tag.EdgeProjects)
	}
	if m.removedapplications != nil {
		edges = append(edges, tag.EdgeApplications)
	}
	if m.removedmicroservices != nil {
		edges = append(edges, tag.EdgeMicroservices)
	}
	if m.removeddepartments != nil {
		edges = append(edges, tag.EdgeDepartments)
	}
	if m.removedteams != nil {
		edges = append(edges, tag.EdgeTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeMicroservices:
		ids := make([]ent.Value, 0, len(m.removedmicroservices))
		for id := range m.removedmicroservices {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.removeddepartments))
		for id := range m.removeddepartments {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedprojects {
		edges = append(edges, tag.EdgeProjects)
	}
	if m.clearedapplications {
		edges = append(edges, tag.EdgeApplications)
	}
	if m.clearedmicroservices {
		edges = append(edges, tag.EdgeMicroservices)
	}
	if m.cleareddepartments {
		edges = append(edges, tag.EdgeDepartments)
	}
	if m.clearedteams {
		edges = append(edges, tag.EdgeTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeProjects:
		return m.clearedprojects
	case tag.EdgeApplications:
		return m.clearedapplications
	case tag.EdgeMicroservices:
		return m.clearedmicroservices
	case tag.EdgeDepartments:
		return m.cleareddepartments
	case tag.EdgeTeams:
		return m.clearedteams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeProjects:
		m.ResetProjects()
		return nil
	case tag.EdgeApplications:
		m.ResetApplications()
		return nil
	case tag.EdgeMicroservices:
		m.ResetMicroservices()
		return nil
	case tag.EdgeDepartments:
		m.ResetDepartments()
		return nil
	case tag.EdgeTeams:
		m.ResetTeams()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	code          *string
	description   *string
	status        *string
	manager_id    *int
	addmanager_id *int
	tenant_id     *int
	addtenant_id  *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	users         map[int]struct{}
	removedusers  map[int]struct{}
	clearedusers  bool
	tags          map[int]struct{}
	removedtags   map[int]struct{}
	clearedtags   bool
	done          bool
	oldValue      func(context.Context) (*Team, error)
	predicates    []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id int) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *TeamMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TeamMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TeamMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *TeamMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TeamMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TeamMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[team.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TeamMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[team.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TeamMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, team.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *TeamMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TeamMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TeamMutation) ResetStatus() {
	m.status = nil
}

// SetManagerID sets the "manager_id" field.
func (m *TeamMutation) SetManagerID(i int) {
	m.manager_id = &i
	m.addmanager_id = nil
}

// ManagerID returns the value of the "manager_id" field in the mutation.
func (m *TeamMutation) ManagerID() (r int, exists bool) {
	v := m.manager_id
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerID returns the old "manager_id" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldManagerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerID: %w", err)
	}
	return oldValue.ManagerID, nil
}

// AddManagerID adds i to the "manager_id" field.
func (m *TeamMutation) AddManagerID(i int) {
	if m.addmanager_id != nil {
		*m.addmanager_id += i
	} else {
		m.addmanager_id = &i
	}
}

// AddedManagerID returns the value that was added to the "manager_id" field in this mutation.
func (m *TeamMutation) AddedManagerID() (r int, exists bool) {
	v := m.addmanager_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearManagerID clears the value of the "manager_id" field.
func (m *TeamMutation) ClearManagerID() {
	m.manager_id = nil
	m.addmanager_id = nil
	m.clearedFields[team.FieldManagerID] = struct{}{}
}

// ManagerIDCleared returns if the "manager_id" field was cleared in this mutation.
func (m *TeamMutation) ManagerIDCleared() bool {
	_, ok := m.clearedFields[team.FieldManagerID]
	return ok
}

// ResetManagerID resets all changes to the "manager_id" field.
func (m *TeamMutation) ResetManagerID() {
	m.manager_id = nil
	m.addmanager_id = nil
	delete(m.clearedFields, team.FieldManagerID)
}

// SetTenantID sets the "tenant_id" field.
func (m *TeamMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TeamMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TeamMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TeamMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TeamMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *TeamMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *TeamMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *TeamMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *TeamMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *TeamMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *TeamMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *TeamMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *TeamMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *TeamMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *TeamMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *TeamMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *TeamMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *TeamMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *TeamMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.code != nil {
		fields = append(fields, team.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, team.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, team.FieldStatus)
	}
	if m.manager_id != nil {
		fields = append(fields, team.FieldManagerID)
	}
	if m.tenant_id != nil {
		fields = append(fields, team.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, team.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, team.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldName:
		return m.Name()
	case team.FieldCode:
		return m.Code()
	case team.FieldDescription:
		return m.Description()
	case team.FieldStatus:
		return m.Status()
	case team.FieldManagerID:
		return m.ManagerID()
	case team.FieldTenantID:
		return m.TenantID()
	case team.FieldCreatedAt:
		return m.CreatedAt()
	case team.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldCode:
		return m.OldCode(ctx)
	case team.FieldDescription:
		return m.OldDescription(ctx)
	case team.FieldStatus:
		return m.OldStatus(ctx)
	case team.FieldManagerID:
		return m.OldManagerID(ctx)
	case team.FieldTenantID:
		return m.OldTenantID(ctx)
	case team.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case team.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case team.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case team.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case team.FieldManagerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerID(v)
		return nil
	case team.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case team.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case team.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	var fields []string
	if m.addmanager_id != nil {
		fields = append(fields, team.FieldManagerID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, team.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case team.FieldManagerID:
		return m.AddedManagerID()
	case team.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case team.FieldManagerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddManagerID(v)
		return nil
	case team.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(team.FieldDescription) {
		fields = append(fields, team.FieldDescription)
	}
	if m.FieldCleared(team.FieldManagerID) {
		fields = append(fields, team.FieldManagerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	switch name {
	case team.FieldDescription:
		m.ClearDescription()
		return nil
	case team.FieldManagerID:
		m.ClearManagerID()
		return nil
	}
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldCode:
		m.ResetCode()
		return nil
	case team.FieldDescription:
		m.ResetDescription()
		return nil
	case team.FieldStatus:
		m.ResetStatus()
		return nil
	case team.FieldManagerID:
		m.ResetManagerID()
		return nil
	case team.FieldTenantID:
		m.ResetTenantID()
		return nil
	case team.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case team.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, team.EdgeUsers)
	}
	if m.tags != nil {
		edges = append(edges, team.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, team.EdgeUsers)
	}
	if m.removedtags != nil {
		edges = append(edges, team.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, team.EdgeUsers)
	}
	if m.clearedtags {
		edges = append(edges, team.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeUsers:
		return m.clearedusers
	case team.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeUsers:
		m.ResetUsers()
		return nil
	case team.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	code          *string
	domain        *string
	_type         *string
	status        *string
	expires_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tenant, error)
	predicates    []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id int) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *TenantMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TenantMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TenantMutation) ResetCode() {
	m.code = nil
}

// SetDomain sets the "domain" field.
func (m *TenantMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *TenantMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *TenantMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[tenant.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *TenantMutation) DomainCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *TenantMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, tenant.FieldDomain)
}

// SetType sets the "type" field.
func (m *TenantMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TenantMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TenantMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *TenantMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TenantMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TenantMutation) ResetStatus() {
	m.status = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *TenantMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *TenantMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *TenantMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[tenant.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *TenantMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *TenantMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, tenant.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	if m.code != nil {
		fields = append(fields, tenant.FieldCode)
	}
	if m.domain != nil {
		fields = append(fields, tenant.FieldDomain)
	}
	if m._type != nil {
		fields = append(fields, tenant.FieldType)
	}
	if m.status != nil {
		fields = append(fields, tenant.FieldStatus)
	}
	if m.expires_at != nil {
		fields = append(fields, tenant.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenant.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldName:
		return m.Name()
	case tenant.FieldCode:
		return m.Code()
	case tenant.FieldDomain:
		return m.Domain()
	case tenant.FieldType:
		return m.GetType()
	case tenant.FieldStatus:
		return m.Status()
	case tenant.FieldExpiresAt:
		return m.ExpiresAt()
	case tenant.FieldCreatedAt:
		return m.CreatedAt()
	case tenant.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldName:
		return m.OldName(ctx)
	case tenant.FieldCode:
		return m.OldCode(ctx)
	case tenant.FieldDomain:
		return m.OldDomain(ctx)
	case tenant.FieldType:
		return m.OldType(ctx)
	case tenant.FieldStatus:
		return m.OldStatus(ctx)
	case tenant.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case tenant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tenant.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case tenant.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case tenant.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case tenant.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tenant.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case tenant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenant.FieldDomain) {
		fields = append(fields, tenant.FieldDomain)
	}
	if m.FieldCleared(tenant.FieldExpiresAt) {
		fields = append(fields, tenant.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	switch name {
	case tenant.FieldDomain:
		m.ClearDomain()
		return nil
	case tenant.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldName:
		m.ResetName()
		return nil
	case tenant.FieldCode:
		m.ResetCode()
		return nil
	case tenant.FieldDomain:
		m.ResetDomain()
		return nil
	case tenant.FieldType:
		m.ResetType()
		return nil
	case tenant.FieldStatus:
		m.ResetStatus()
		return nil
	case tenant.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case tenant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// TicketMutation represents an operation that mutates the Ticket nodes in the graph.
type TicketMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	title                      *string
	description                *string
	status                     *string
	priority                   *string
	ticket_number              *string
	requester_id               *int
	addrequester_id            *int
	assignee_id                *int
	addassignee_id             *int
	tenant_id                  *int
	addtenant_id               *int
	sla_response_deadline      *time.Time
	sla_resolution_deadline    *time.Time
	first_response_at          *time.Time
	resolved_at                *time.Time
	rating                     *int
	addrating                  *int
	rating_comment             *string
	rated_at                   *time.Time
	rated_by                   *int
	addrated_by                *int
	created_at                 *time.Time
	updated_at                 *time.Time
	clearedFields              map[string]struct{}
	template                   *int
	clearedtemplate            bool
	category                   *int
	clearedcategory            bool
	department                 *int
	cleareddepartment          bool
	tags                       map[int]struct{}
	removedtags                map[int]struct{}
	clearedtags                bool
	related_tickets            map[int]struct{}
	removedrelated_tickets     map[int]struct{}
	clearedrelated_tickets     bool
	parent_ticket              *int
	clearedparent_ticket       bool
	workflow_instances         map[int]struct{}
	removedworkflow_instances  map[int]struct{}
	clearedworkflow_instances  bool
	sla_definition             *int
	clearedsla_definition      bool
	sla_violations             map[int]struct{}
	removedsla_violations      map[int]struct{}
	clearedsla_violations      bool
	comments                   map[int]struct{}
	removedcomments            map[int]struct{}
	clearedcomments            bool
	attachments                map[int]struct{}
	removedattachments         map[int]struct{}
	clearedattachments         bool
	notifications              map[int]struct{}
	removednotifications       map[int]struct{}
	clearednotifications       bool
	sla_alert_history          map[int]struct{}
	removedsla_alert_history   map[int]struct{}
	clearedsla_alert_history   bool
	approval_records           map[int]struct{}
	removedapproval_records    map[int]struct{}
	clearedapproval_records    bool
	root_cause_analyses        map[int]struct{}
	removedroot_cause_analyses map[int]struct{}
	clearedroot_cause_analyses bool
	done                       bool
	oldValue                   func(context.Context) (*Ticket, error)
	predicates                 []predicate.Ticket
}

var _ ent.Mutation = (*TicketMutation)(nil)

// ticketOption allows management of the mutation configuration using functional options.
type ticketOption func(*TicketMutation)

// newTicketMutation creates new mutation for the Ticket entity.
func newTicketMutation(c config, op Op, opts ...ticketOption) *TicketMutation {
	m := &TicketMutation{
		config:        c,
		op:            op,
		typ:           TypeTicket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketID sets the ID field of the mutation.
func withTicketID(id int) ticketOption {
	return func(m *TicketMutation) {
		var (
			err   error
			once  sync.Once
			value *Ticket
		)
		m.oldValue = func(ctx context.Context) (*Ticket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ticket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicket sets the old Ticket of the mutation.
func withTicket(node *Ticket) ticketOption {
	return func(m *TicketMutation) {
		m.oldValue = func(context.Context) (*Ticket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ticket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *TicketMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TicketMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TicketMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TicketMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TicketMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TicketMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ticket.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TicketMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ticket.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TicketMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ticket.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *TicketMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TicketMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TicketMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *TicketMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TicketMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *TicketMutation) ResetPriority() {
	m.priority = nil
}

// SetTicketNumber sets the "ticket_number" field.
func (m *TicketMutation) SetTicketNumber(s string) {
	m.ticket_number = &s
}

// TicketNumber returns the value of the "ticket_number" field in the mutation.
func (m *TicketMutation) TicketNumber() (r string, exists bool) {
	v := m.ticket_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketNumber returns the old "ticket_number" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldTicketNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketNumber: %w", err)
	}
	return oldValue.TicketNumber, nil
}

// ResetTicketNumber resets all changes to the "ticket_number" field.
func (m *TicketMutation) ResetTicketNumber() {
	m.ticket_number = nil
}

// SetRequesterID sets the "requester_id" field.
func (m *TicketMutation) SetRequesterID(i int) {
	m.requester_id = &i
	m.addrequester_id = nil
}

// RequesterID returns the value of the "requester_id" field in the mutation.
func (m *TicketMutation) RequesterID() (r int, exists bool) {
	v := m.requester_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequesterID returns the old "requester_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldRequesterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequesterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequesterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequesterID: %w", err)
	}
	return oldValue.RequesterID, nil
}

// AddRequesterID adds i to the "requester_id" field.
func (m *TicketMutation) AddRequesterID(i int) {
	if m.addrequester_id != nil {
		*m.addrequester_id += i
	} else {
		m.addrequester_id = &i
	}
}

// AddedRequesterID returns the value that was added to the "requester_id" field in this mutation.
func (m *TicketMutation) AddedRequesterID() (r int, exists bool) {
	v := m.addrequester_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequesterID resets all changes to the "requester_id" field.
func (m *TicketMutation) ResetRequesterID() {
	m.requester_id = nil
	m.addrequester_id = nil
}

// SetAssigneeID sets the "assignee_id" field.
func (m *TicketMutation) SetAssigneeID(i int) {
	m.assignee_id = &i
	m.addassignee_id = nil
}

// AssigneeID returns the value of the "assignee_id" field in the mutation.
func (m *TicketMutation) AssigneeID() (r int, exists bool) {
	v := m.assignee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeID returns the old "assignee_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldAssigneeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeID: %w", err)
	}
	return oldValue.AssigneeID, nil
}

// AddAssigneeID adds i to the "assignee_id" field.
func (m *TicketMutation) AddAssigneeID(i int) {
	if m.addassignee_id != nil {
		*m.addassignee_id += i
	} else {
		m.addassignee_id = &i
	}
}

// AddedAssigneeID returns the value that was added to the "assignee_id" field in this mutation.
func (m *TicketMutation) AddedAssigneeID() (r int, exists bool) {
	v := m.addassignee_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssigneeID clears the value of the "assignee_id" field.
func (m *TicketMutation) ClearAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	m.clearedFields[ticket.FieldAssigneeID] = struct{}{}
}

// AssigneeIDCleared returns if the "assignee_id" field was cleared in this mutation.
func (m *TicketMutation) AssigneeIDCleared() bool {
	_, ok := m.clearedFields[ticket.FieldAssigneeID]
	return ok
}

// ResetAssigneeID resets all changes to the "assignee_id" field.
func (m *TicketMutation) ResetAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	delete(m.clearedFields, ticket.FieldAssigneeID)
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TicketMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TicketMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetTemplateID sets the "template_id" field.
func (m *TicketMutation) SetTemplateID(i int) {
	m.template = &i
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *TicketMutation) TemplateID() (r int, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldTemplateID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ClearTemplateID clears the value of the "template_id" field.
func (m *TicketMutation) ClearTemplateID() {
	m.template = nil
	m.clearedFields[ticket.FieldTemplateID] = struct{}{}
}

// TemplateIDCleared returns if the "template_id" field was cleared in this mutation.
func (m *TicketMutation) TemplateIDCleared() bool {
	_, ok := m.clearedFields[ticket.FieldTemplateID]
	return ok
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *TicketMutation) ResetTemplateID() {
	m.template = nil
	delete(m.clearedFields, ticket.FieldTemplateID)
}

// SetCategoryID sets the "category_id" field.
func (m *TicketMutation) SetCategoryID(i int) {
	m.category = &i
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *TicketMutation) CategoryID() (r int, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *TicketMutation) ClearCategoryID() {
	m.category = nil
	m.clearedFields[ticket.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *TicketMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[ticket.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *TicketMutation) ResetCategoryID() {
	m.category = nil
	delete(m.clearedFields, ticket.FieldCategoryID)
}

// SetDepartmentID sets the "department_id" field.
func (m *TicketMutation) SetDepartmentID(i int) {
	m.department = &i
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *TicketMutation) DepartmentID() (r int, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldDepartmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ClearDepartmentID clears the value of the "department_id" field.
func (m *TicketMutation) ClearDepartmentID() {
	m.department = nil
	m.clearedFields[ticket.FieldDepartmentID] = struct{}{}
}

// DepartmentIDCleared returns if the "department_id" field was cleared in this mutation.
func (m *TicketMutation) DepartmentIDCleared() bool {
	_, ok := m.clearedFields[ticket.FieldDepartmentID]
	return ok
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *TicketMutation) ResetDepartmentID() {
	m.department = nil
	delete(m.clearedFields, ticket.FieldDepartmentID)
}

// SetParentTicketID sets the "parent_ticket_id" field.
func (m *TicketMutation) SetParentTicketID(i int) {
	m.parent_ticket = &i
}

// ParentTicketID returns the value of the "parent_ticket_id" field in the mutation.
func (m *TicketMutation) ParentTicketID() (r int, exists bool) {
	v := m.parent_ticket
	if v == nil {
		return
	}
	return *v, true
}

// OldParentTicketID returns the old "parent_ticket_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldParentTicketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentTicketID: %w", err)
	}
	return oldValue.ParentTicketID, nil
}

// ClearParentTicketID clears the value of the "parent_ticket_id" field.
func (m *TicketMutation) ClearParentTicketID() {
	m.parent_ticket = nil
	m.clearedFields[ticket.FieldParentTicketID] = struct{}{}
}

// ParentTicketIDCleared returns if the "parent_ticket_id" field was cleared in this mutation.
func (m *TicketMutation) ParentTicketIDCleared() bool {
	_, ok := m.clearedFields[ticket.FieldParentTicketID]
	return ok
}

// ResetParentTicketID resets all changes to the "parent_ticket_id" field.
func (m *TicketMutation) ResetParentTicketID() {
	m.parent_ticket = nil
	delete(m.clearedFields, ticket.FieldParentTicketID)
}

// SetSLADefinitionID sets the "sla_definition_id" field.
func (m *TicketMutation) SetSLADefinitionID(i int) {
	m.sla_definition = &i
}

// SLADefinitionID returns the value of the "sla_definition_id" field in the mutation.
func (m *TicketMutation) SLADefinitionID() (r int, exists bool) {
	v := m.sla_definition
	if v == nil {
		return
	}
	return *v, true
}

// OldSLADefinitionID returns the old "sla_definition_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldSLADefinitionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSLADefinitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSLADefinitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSLADefinitionID: %w", err)
	}
	return oldValue.SLADefinitionID, nil
}

// ClearSLADefinitionID clears the value of the "sla_definition_id" field.
func (m *TicketMutation) ClearSLADefinitionID() {
	m.sla_definition = nil
	m.clearedFields[ticket.FieldSLADefinitionID] = struct{}{}
}

// SLADefinitionIDCleared returns if the "sla_definition_id" field was cleared in this mutation.
func (m *TicketMutation) SLADefinitionIDCleared() bool {
	_, ok := m.clearedFields[ticket.FieldSLADefinitionID]
	return ok
}

// ResetSLADefinitionID resets all changes to the "sla_definition_id" field.
func (m *TicketMutation) ResetSLADefinitionID() {
	m.sla_definition = nil
	delete(m.clearedFields, ticket.FieldSLADefinitionID)
}

// SetSLAResponseDeadline sets the "sla_response_deadline" field.
func (m *TicketMutation) SetSLAResponseDeadline(t time.Time) {
	m.sla_response_deadline = &t
}

// SLAResponseDeadline returns the value of the "sla_response_deadline" field in the mutation.
func (m *TicketMutation) SLAResponseDeadline() (r time.Time, exists bool) {
	v := m.sla_response_deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldSLAResponseDeadline returns the old "sla_response_deadline" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldSLAResponseDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSLAResponseDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSLAResponseDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSLAResponseDeadline: %w", err)
	}
	return oldValue.SLAResponseDeadline, nil
}

// ClearSLAResponseDeadline clears the value of the "sla_response_deadline" field.
func (m *TicketMutation) ClearSLAResponseDeadline() {
	m.sla_response_deadline = nil
	m.clearedFields[ticket.FieldSLAResponseDeadline] = struct{}{}
}

// SLAResponseDeadlineCleared returns if the "sla_response_deadline" field was cleared in this mutation.
func (m *TicketMutation) SLAResponseDeadlineCleared() bool {
	_, ok := m.clearedFields[ticket.FieldSLAResponseDeadline]
	return ok
}

// ResetSLAResponseDeadline resets all changes to the "sla_response_deadline" field.
func (m *TicketMutation) ResetSLAResponseDeadline() {
	m.sla_response_deadline = nil
	delete(m.clearedFields, ticket.FieldSLAResponseDeadline)
}

// SetSLAResolutionDeadline sets the "sla_resolution_deadline" field.
func (m *TicketMutation) SetSLAResolutionDeadline(t time.Time) {
	m.sla_resolution_deadline = &t
}

// SLAResolutionDeadline returns the value of the "sla_resolution_deadline" field in the mutation.
func (m *TicketMutation) SLAResolutionDeadline() (r time.Time, exists bool) {
	v := m.sla_resolution_deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldSLAResolutionDeadline returns the old "sla_resolution_deadline" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldSLAResolutionDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSLAResolutionDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSLAResolutionDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSLAResolutionDeadline: %w", err)
	}
	return oldValue.SLAResolutionDeadline, nil
}

// ClearSLAResolutionDeadline clears the value of the "sla_resolution_deadline" field.
func (m *TicketMutation) ClearSLAResolutionDeadline() {
	m.sla_resolution_deadline = nil
	m.clearedFields[ticket.FieldSLAResolutionDeadline] = struct{}{}
}

// SLAResolutionDeadlineCleared returns if the "sla_resolution_deadline" field was cleared in this mutation.
func (m *TicketMutation) SLAResolutionDeadlineCleared() bool {
	_, ok := m.clearedFields[ticket.FieldSLAResolutionDeadline]
	return ok
}

// ResetSLAResolutionDeadline resets all changes to the "sla_resolution_deadline" field.
func (m *TicketMutation) ResetSLAResolutionDeadline() {
	m.sla_resolution_deadline = nil
	delete(m.clearedFields, ticket.FieldSLAResolutionDeadline)
}

// SetFirstResponseAt sets the "first_response_at" field.
func (m *TicketMutation) SetFirstResponseAt(t time.Time) {
	m.first_response_at = &t
}

// FirstResponseAt returns the value of the "first_response_at" field in the mutation.
func (m *TicketMutation) FirstResponseAt() (r time.Time, exists bool) {
	v := m.first_response_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstResponseAt returns the old "first_response_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldFirstResponseAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstResponseAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstResponseAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstResponseAt: %w", err)
	}
	return oldValue.FirstResponseAt, nil
}

// ClearFirstResponseAt clears the value of the "first_response_at" field.
func (m *TicketMutation) ClearFirstResponseAt() {
	m.first_response_at = nil
	m.clearedFields[ticket.FieldFirstResponseAt] = struct{}{}
}

// FirstResponseAtCleared returns if the "first_response_at" field was cleared in this mutation.
func (m *TicketMutation) FirstResponseAtCleared() bool {
	_, ok := m.clearedFields[ticket.FieldFirstResponseAt]
	return ok
}

// ResetFirstResponseAt resets all changes to the "first_response_at" field.
func (m *TicketMutation) ResetFirstResponseAt() {
	m.first_response_at = nil
	delete(m.clearedFields, ticket.FieldFirstResponseAt)
}

// SetResolvedAt sets the "resolved_at" field.
func (m *TicketMutation) SetResolvedAt(t time.Time) {
	m.resolved_at = &t
}

// ResolvedAt returns the value of the "resolved_at" field in the mutation.
func (m *TicketMutation) ResolvedAt() (r time.Time, exists bool) {
	v := m.resolved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedAt returns the old "resolved_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldResolvedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedAt: %w", err)
	}
	return oldValue.ResolvedAt, nil
}

// ClearResolvedAt clears the value of the "resolved_at" field.
func (m *TicketMutation) ClearResolvedAt() {
	m.resolved_at = nil
	m.clearedFields[ticket.FieldResolvedAt] = struct{}{}
}

// ResolvedAtCleared returns if the "resolved_at" field was cleared in this mutation.
func (m *TicketMutation) ResolvedAtCleared() bool {
	_, ok := m.clearedFields[ticket.FieldResolvedAt]
	return ok
}

// ResetResolvedAt resets all changes to the "resolved_at" field.
func (m *TicketMutation) ResetResolvedAt() {
	m.resolved_at = nil
	delete(m.clearedFields, ticket.FieldResolvedAt)
}

// SetRating sets the "rating" field.
func (m *TicketMutation) SetRating(i int) {
	m.rating = &i
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *TicketMutation) Rating() (r int, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldRating(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds i to the "rating" field.
func (m *TicketMutation) AddRating(i int) {
	if m.addrating != nil {
		*m.addrating += i
	} else {
		m.addrating = &i
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *TicketMutation) AddedRating() (r int, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ClearRating clears the value of the "rating" field.
func (m *TicketMutation) ClearRating() {
	m.rating = nil
	m.addrating = nil
	m.clearedFields[ticket.FieldRating] = struct{}{}
}

// RatingCleared returns if the "rating" field was cleared in this mutation.
func (m *TicketMutation) RatingCleared() bool {
	_, ok := m.clearedFields[ticket.FieldRating]
	return ok
}

// ResetRating resets all changes to the "rating" field.
func (m *TicketMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
	delete(m.clearedFields, ticket.FieldRating)
}

// SetRatingComment sets the "rating_comment" field.
func (m *TicketMutation) SetRatingComment(s string) {
	m.rating_comment = &s
}

// RatingComment returns the value of the "rating_comment" field in the mutation.
func (m *TicketMutation) RatingComment() (r string, exists bool) {
	v := m.rating_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldRatingComment returns the old "rating_comment" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldRatingComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatingComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatingComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatingComment: %w", err)
	}
	return oldValue.RatingComment, nil
}

// ClearRatingComment clears the value of the "rating_comment" field.
func (m *TicketMutation) ClearRatingComment() {
	m.rating_comment = nil
	m.clearedFields[ticket.FieldRatingComment] = struct{}{}
}

// RatingCommentCleared returns if the "rating_comment" field was cleared in this mutation.
func (m *TicketMutation) RatingCommentCleared() bool {
	_, ok := m.clearedFields[ticket.FieldRatingComment]
	return ok
}

// ResetRatingComment resets all changes to the "rating_comment" field.
func (m *TicketMutation) ResetRatingComment() {
	m.rating_comment = nil
	delete(m.clearedFields, ticket.FieldRatingComment)
}

// SetRatedAt sets the "rated_at" field.
func (m *TicketMutation) SetRatedAt(t time.Time) {
	m.rated_at = &t
}

// RatedAt returns the value of the "rated_at" field in the mutation.
func (m *TicketMutation) RatedAt() (r time.Time, exists bool) {
	v := m.rated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRatedAt returns the old "rated_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldRatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatedAt: %w", err)
	}
	return oldValue.RatedAt, nil
}

// ClearRatedAt clears the value of the "rated_at" field.
func (m *TicketMutation) ClearRatedAt() {
	m.rated_at = nil
	m.clearedFields[ticket.FieldRatedAt] = struct{}{}
}

// RatedAtCleared returns if the "rated_at" field was cleared in this mutation.
func (m *TicketMutation) RatedAtCleared() bool {
	_, ok := m.clearedFields[ticket.FieldRatedAt]
	return ok
}

// ResetRatedAt resets all changes to the "rated_at" field.
func (m *TicketMutation) ResetRatedAt() {
	m.rated_at = nil
	delete(m.clearedFields, ticket.FieldRatedAt)
}

// SetRatedBy sets the "rated_by" field.
func (m *TicketMutation) SetRatedBy(i int) {
	m.rated_by = &i
	m.addrated_by = nil
}

// RatedBy returns the value of the "rated_by" field in the mutation.
func (m *TicketMutation) RatedBy() (r int, exists bool) {
	v := m.rated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldRatedBy returns the old "rated_by" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldRatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatedBy: %w", err)
	}
	return oldValue.RatedBy, nil
}

// AddRatedBy adds i to the "rated_by" field.
func (m *TicketMutation) AddRatedBy(i int) {
	if m.addrated_by != nil {
		*m.addrated_by += i
	} else {
		m.addrated_by = &i
	}
}

// AddedRatedBy returns the value that was added to the "rated_by" field in this mutation.
func (m *TicketMutation) AddedRatedBy() (r int, exists bool) {
	v := m.addrated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearRatedBy clears the value of the "rated_by" field.
func (m *TicketMutation) ClearRatedBy() {
	m.rated_by = nil
	m.addrated_by = nil
	m.clearedFields[ticket.FieldRatedBy] = struct{}{}
}

// RatedByCleared returns if the "rated_by" field was cleared in this mutation.
func (m *TicketMutation) RatedByCleared() bool {
	_, ok := m.clearedFields[ticket.FieldRatedBy]
	return ok
}

// ResetRatedBy resets all changes to the "rated_by" field.
func (m *TicketMutation) ResetRatedBy() {
	m.rated_by = nil
	m.addrated_by = nil
	delete(m.clearedFields, ticket.FieldRatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTemplate clears the "template" edge to the TicketTemplate entity.
func (m *TicketMutation) ClearTemplate() {
	m.clearedtemplate = true
	m.clearedFields[ticket.FieldTemplateID] = struct{}{}
}

// TemplateCleared reports if the "template" edge to the TicketTemplate entity was cleared.
func (m *TicketMutation) TemplateCleared() bool {
	return m.TemplateIDCleared() || m.clearedtemplate
}

// TemplateIDs returns the "template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) TemplateIDs() (ids []int) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate resets all changes to the "template" edge.
func (m *TicketMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// ClearCategory clears the "category" edge to the TicketCategory entity.
func (m *TicketMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[ticket.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the TicketCategory entity was cleared.
func (m *TicketMutation) CategoryCleared() bool {
	return m.CategoryIDCleared() || m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *TicketMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *TicketMutation) ClearDepartment() {
	m.cleareddepartment = true
	m.clearedFields[ticket.FieldDepartmentID] = struct{}{}
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *TicketMutation) DepartmentCleared() bool {
	return m.DepartmentIDCleared() || m.cleareddepartment
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *TicketMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// AddTagIDs adds the "tags" edge to the TicketTag entity by ids.
func (m *TicketMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the TicketTag entity.
func (m *TicketMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the TicketTag entity was cleared.
func (m *TicketMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the TicketTag entity by IDs.
func (m *TicketMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the TicketTag entity.
func (m *TicketMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *TicketMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *TicketMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddRelatedTicketIDs adds the "related_tickets" edge to the Ticket entity by ids.
func (m *TicketMutation) AddRelatedTicketIDs(ids ...int) {
	if m.related_tickets == nil {
		m.related_tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.related_tickets[ids[i]] = struct{}{}
	}
}

// ClearRelatedTickets clears the "related_tickets" edge to the Ticket entity.
func (m *TicketMutation) ClearRelatedTickets() {
	m.clearedrelated_tickets = true
}

// RelatedTicketsCleared reports if the "related_tickets" edge to the Ticket entity was cleared.
func (m *TicketMutation) RelatedTicketsCleared() bool {
	return m.clearedrelated_tickets
}

// RemoveRelatedTicketIDs removes the "related_tickets" edge to the Ticket entity by IDs.
func (m *TicketMutation) RemoveRelatedTicketIDs(ids ...int) {
	if m.removedrelated_tickets == nil {
		m.removedrelated_tickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.related_tickets, ids[i])
		m.removedrelated_tickets[ids[i]] = struct{}{}
	}
}

// RemovedRelatedTickets returns the removed IDs of the "related_tickets" edge to the Ticket entity.
func (m *TicketMutation) RemovedRelatedTicketsIDs() (ids []int) {
	for id := range m.removedrelated_tickets {
		ids = append(ids, id)
	}
	return
}

// RelatedTicketsIDs returns the "related_tickets" edge IDs in the mutation.
func (m *TicketMutation) RelatedTicketsIDs() (ids []int) {
	for id := range m.related_tickets {
		ids = append(ids, id)
	}
	return
}

// ResetRelatedTickets resets all changes to the "related_tickets" edge.
func (m *TicketMutation) ResetRelatedTickets() {
	m.related_tickets = nil
	m.clearedrelated_tickets = false
	m.removedrelated_tickets = nil
}

// ClearParentTicket clears the "parent_ticket" edge to the Ticket entity.
func (m *TicketMutation) ClearParentTicket() {
	m.clearedparent_ticket = true
	m.clearedFields[ticket.FieldParentTicketID] = struct{}{}
}

// ParentTicketCleared reports if the "parent_ticket" edge to the Ticket entity was cleared.
func (m *TicketMutation) ParentTicketCleared() bool {
	return m.ParentTicketIDCleared() || m.clearedparent_ticket
}

// ParentTicketIDs returns the "parent_ticket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentTicketID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) ParentTicketIDs() (ids []int) {
	if id := m.parent_ticket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentTicket resets all changes to the "parent_ticket" edge.
func (m *TicketMutation) ResetParentTicket() {
	m.parent_ticket = nil
	m.clearedparent_ticket = false
}

// AddWorkflowInstanceIDs adds the "workflow_instances" edge to the WorkflowInstance entity by ids.
func (m *TicketMutation) AddWorkflowInstanceIDs(ids ...int) {
	if m.workflow_instances == nil {
		m.workflow_instances = make(map[int]struct{})
	}
	for i := range ids {
		m.workflow_instances[ids[i]] = struct{}{}
	}
}

// ClearWorkflowInstances clears the "workflow_instances" edge to the WorkflowInstance entity.
func (m *TicketMutation) ClearWorkflowInstances() {
	m.clearedworkflow_instances = true
}

// WorkflowInstancesCleared reports if the "workflow_instances" edge to the WorkflowInstance entity was cleared.
func (m *TicketMutation) WorkflowInstancesCleared() bool {
	return m.clearedworkflow_instances
}

// RemoveWorkflowInstanceIDs removes the "workflow_instances" edge to the WorkflowInstance entity by IDs.
func (m *TicketMutation) RemoveWorkflowInstanceIDs(ids ...int) {
	if m.removedworkflow_instances == nil {
		m.removedworkflow_instances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workflow_instances, ids[i])
		m.removedworkflow_instances[ids[i]] = struct{}{}
	}
}

// RemovedWorkflowInstances returns the removed IDs of the "workflow_instances" edge to the WorkflowInstance entity.
func (m *TicketMutation) RemovedWorkflowInstancesIDs() (ids []int) {
	for id := range m.removedworkflow_instances {
		ids = append(ids, id)
	}
	return
}

// WorkflowInstancesIDs returns the "workflow_instances" edge IDs in the mutation.
func (m *TicketMutation) WorkflowInstancesIDs() (ids []int) {
	for id := range m.workflow_instances {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflowInstances resets all changes to the "workflow_instances" edge.
func (m *TicketMutation) ResetWorkflowInstances() {
	m.workflow_instances = nil
	m.clearedworkflow_instances = false
	m.removedworkflow_instances = nil
}

// ClearSLADefinition clears the "sla_definition" edge to the SLADefinition entity.
func (m *TicketMutation) ClearSLADefinition() {
	m.clearedsla_definition = true
	m.clearedFields[ticket.FieldSLADefinitionID] = struct{}{}
}

// SLADefinitionCleared reports if the "sla_definition" edge to the SLADefinition entity was cleared.
func (m *TicketMutation) SLADefinitionCleared() bool {
	return m.SLADefinitionIDCleared() || m.clearedsla_definition
}

// SLADefinitionIDs returns the "sla_definition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SLADefinitionID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) SLADefinitionIDs() (ids []int) {
	if id := m.sla_definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSLADefinition resets all changes to the "sla_definition" edge.
func (m *TicketMutation) ResetSLADefinition() {
	m.sla_definition = nil
	m.clearedsla_definition = false
}

// AddSLAViolationIDs adds the "sla_violations" edge to the SLAViolation entity by ids.
func (m *TicketMutation) AddSLAViolationIDs(ids ...int) {
	if m.sla_violations == nil {
		m.sla_violations = make(map[int]struct{})
	}
	for i := range ids {
		m.sla_violations[ids[i]] = struct{}{}
	}
}

// ClearSLAViolations clears the "sla_violations" edge to the SLAViolation entity.
func (m *TicketMutation) ClearSLAViolations() {
	m.clearedsla_violations = true
}

// SLAViolationsCleared reports if the "sla_violations" edge to the SLAViolation entity was cleared.
func (m *TicketMutation) SLAViolationsCleared() bool {
	return m.clearedsla_violations
}

// RemoveSLAViolationIDs removes the "sla_violations" edge to the SLAViolation entity by IDs.
func (m *TicketMutation) RemoveSLAViolationIDs(ids ...int) {
	if m.removedsla_violations == nil {
		m.removedsla_violations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sla_violations, ids[i])
		m.removedsla_violations[ids[i]] = struct{}{}
	}
}

// RemovedSLAViolations returns the removed IDs of the "sla_violations" edge to the SLAViolation entity.
func (m *TicketMutation) RemovedSLAViolationsIDs() (ids []int) {
	for id := range m.removedsla_violations {
		ids = append(ids, id)
	}
	return
}

// SLAViolationsIDs returns the "sla_violations" edge IDs in the mutation.
func (m *TicketMutation) SLAViolationsIDs() (ids []int) {
	for id := range m.sla_violations {
		ids = append(ids, id)
	}
	return
}

// ResetSLAViolations resets all changes to the "sla_violations" edge.
func (m *TicketMutation) ResetSLAViolations() {
	m.sla_violations = nil
	m.clearedsla_violations = false
	m.removedsla_violations = nil
}

// AddCommentIDs adds the "comments" edge to the TicketComment entity by ids.
func (m *TicketMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the TicketComment entity.
func (m *TicketMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the TicketComment entity was cleared.
func (m *TicketMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the TicketComment entity by IDs.
func (m *TicketMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the TicketComment entity.
func (m *TicketMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *TicketMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *TicketMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddAttachmentIDs adds the "attachments" edge to the TicketAttachment entity by ids.
func (m *TicketMutation) AddAttachmentIDs(ids ...int) {
	if m.attachments == nil {
		m.attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the TicketAttachment entity.
func (m *TicketMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the TicketAttachment entity was cleared.
func (m *TicketMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the TicketAttachment entity by IDs.
func (m *TicketMutation) RemoveAttachmentIDs(ids ...int) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the TicketAttachment entity.
func (m *TicketMutation) RemovedAttachmentsIDs() (ids []int) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *TicketMutation) AttachmentsIDs() (ids []int) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *TicketMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// AddNotificationIDs adds the "notifications" edge to the TicketNotification entity by ids.
func (m *TicketMutation) AddNotificationIDs(ids ...int) {
	if m.notifications == nil {
		m.notifications = make(map[int]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the TicketNotification entity.
func (m *TicketMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the TicketNotification entity was cleared.
func (m *TicketMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the TicketNotification entity by IDs.
func (m *TicketMutation) RemoveNotificationIDs(ids ...int) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the TicketNotification entity.
func (m *TicketMutation) RemovedNotificationsIDs() (ids []int) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *TicketMutation) NotificationsIDs() (ids []int) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *TicketMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// AddSLAAlertHistoryIDs adds the "sla_alert_history" edge to the SLAAlertHistory entity by ids.
func (m *TicketMutation) AddSLAAlertHistoryIDs(ids ...int) {
	if m.sla_alert_history == nil {
		m.sla_alert_history = make(map[int]struct{})
	}
	for i := range ids {
		m.sla_alert_history[ids[i]] = struct{}{}
	}
}

// ClearSLAAlertHistory clears the "sla_alert_history" edge to the SLAAlertHistory entity.
func (m *TicketMutation) ClearSLAAlertHistory() {
	m.clearedsla_alert_history = true
}

// SLAAlertHistoryCleared reports if the "sla_alert_history" edge to the SLAAlertHistory entity was cleared.
func (m *TicketMutation) SLAAlertHistoryCleared() bool {
	return m.clearedsla_alert_history
}

// RemoveSLAAlertHistoryIDs removes the "sla_alert_history" edge to the SLAAlertHistory entity by IDs.
func (m *TicketMutation) RemoveSLAAlertHistoryIDs(ids ...int) {
	if m.removedsla_alert_history == nil {
		m.removedsla_alert_history = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sla_alert_history, ids[i])
		m.removedsla_alert_history[ids[i]] = struct{}{}
	}
}

// RemovedSLAAlertHistory returns the removed IDs of the "sla_alert_history" edge to the SLAAlertHistory entity.
func (m *TicketMutation) RemovedSLAAlertHistoryIDs() (ids []int) {
	for id := range m.removedsla_alert_history {
		ids = append(ids, id)
	}
	return
}

// SLAAlertHistoryIDs returns the "sla_alert_history" edge IDs in the mutation.
func (m *TicketMutation) SLAAlertHistoryIDs() (ids []int) {
	for id := range m.sla_alert_history {
		ids = append(ids, id)
	}
	return
}

// ResetSLAAlertHistory resets all changes to the "sla_alert_history" edge.
func (m *TicketMutation) ResetSLAAlertHistory() {
	m.sla_alert_history = nil
	m.clearedsla_alert_history = false
	m.removedsla_alert_history = nil
}

// AddApprovalRecordIDs adds the "approval_records" edge to the ApprovalRecord entity by ids.
func (m *TicketMutation) AddApprovalRecordIDs(ids ...int) {
	if m.approval_records == nil {
		m.approval_records = make(map[int]struct{})
	}
	for i := range ids {
		m.approval_records[ids[i]] = struct{}{}
	}
}

// ClearApprovalRecords clears the "approval_records" edge to the ApprovalRecord entity.
func (m *TicketMutation) ClearApprovalRecords() {
	m.clearedapproval_records = true
}

// ApprovalRecordsCleared reports if the "approval_records" edge to the ApprovalRecord entity was cleared.
func (m *TicketMutation) ApprovalRecordsCleared() bool {
	return m.clearedapproval_records
}

// RemoveApprovalRecordIDs removes the "approval_records" edge to the ApprovalRecord entity by IDs.
func (m *TicketMutation) RemoveApprovalRecordIDs(ids ...int) {
	if m.removedapproval_records == nil {
		m.removedapproval_records = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.approval_records, ids[i])
		m.removedapproval_records[ids[i]] = struct{}{}
	}
}

// RemovedApprovalRecords returns the removed IDs of the "approval_records" edge to the ApprovalRecord entity.
func (m *TicketMutation) RemovedApprovalRecordsIDs() (ids []int) {
	for id := range m.removedapproval_records {
		ids = append(ids, id)
	}
	return
}

// ApprovalRecordsIDs returns the "approval_records" edge IDs in the mutation.
func (m *TicketMutation) ApprovalRecordsIDs() (ids []int) {
	for id := range m.approval_records {
		ids = append(ids, id)
	}
	return
}

// ResetApprovalRecords resets all changes to the "approval_records" edge.
func (m *TicketMutation) ResetApprovalRecords() {
	m.approval_records = nil
	m.clearedapproval_records = false
	m.removedapproval_records = nil
}

// AddRootCauseAnalysisIDs adds the "root_cause_analyses" edge to the RootCauseAnalysis entity by ids.
func (m *TicketMutation) AddRootCauseAnalysisIDs(ids ...int) {
	if m.root_cause_analyses == nil {
		m.root_cause_analyses = make(map[int]struct{})
	}
	for i := range ids {
		m.root_cause_analyses[ids[i]] = struct{}{}
	}
}

// ClearRootCauseAnalyses clears the "root_cause_analyses" edge to the RootCauseAnalysis entity.
func (m *TicketMutation) ClearRootCauseAnalyses() {
	m.clearedroot_cause_analyses = true
}

// RootCauseAnalysesCleared reports if the "root_cause_analyses" edge to the RootCauseAnalysis entity was cleared.
func (m *TicketMutation) RootCauseAnalysesCleared() bool {
	return m.clearedroot_cause_analyses
}

// RemoveRootCauseAnalysisIDs removes the "root_cause_analyses" edge to the RootCauseAnalysis entity by IDs.
func (m *TicketMutation) RemoveRootCauseAnalysisIDs(ids ...int) {
	if m.removedroot_cause_analyses == nil {
		m.removedroot_cause_analyses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.root_cause_analyses, ids[i])
		m.removedroot_cause_analyses[ids[i]] = struct{}{}
	}
}

// RemovedRootCauseAnalyses returns the removed IDs of the "root_cause_analyses" edge to the RootCauseAnalysis entity.
func (m *TicketMutation) RemovedRootCauseAnalysesIDs() (ids []int) {
	for id := range m.removedroot_cause_analyses {
		ids = append(ids, id)
	}
	return
}

// RootCauseAnalysesIDs returns the "root_cause_analyses" edge IDs in the mutation.
func (m *TicketMutation) RootCauseAnalysesIDs() (ids []int) {
	for id := range m.root_cause_analyses {
		ids = append(ids, id)
	}
	return
}

// ResetRootCauseAnalyses resets all changes to the "root_cause_analyses" edge.
func (m *TicketMutation) ResetRootCauseAnalyses() {
	m.root_cause_analyses = nil
	m.clearedroot_cause_analyses = false
	m.removedroot_cause_analyses = nil
}

// Where appends a list predicates to the TicketMutation builder.
func (m *TicketMutation) Where(ps ...predicate.Ticket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ticket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ticket).
func (m *TicketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.title != nil {
		fields = append(fields, ticket.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, ticket.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, ticket.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, ticket.FieldPriority)
	}
	if m.ticket_number != nil {
		fields = append(fields, ticket.FieldTicketNumber)
	}
	if m.requester_id != nil {
		fields = append(fields, ticket.FieldRequesterID)
	}
	if m.assignee_id != nil {
		fields = append(fields, ticket.FieldAssigneeID)
	}
	if m.tenant_id != nil {
		fields = append(fields, ticket.FieldTenantID)
	}
	if m.template != nil {
		fields = append(fields, ticket.FieldTemplateID)
	}
	if m.category != nil {
		fields = append(fields, ticket.FieldCategoryID)
	}
	if m.department != nil {
		fields = append(fields, ticket.FieldDepartmentID)
	}
	if m.parent_ticket != nil {
		fields = append(fields, ticket.FieldParentTicketID)
	}
	if m.sla_definition != nil {
		fields = append(fields, ticket.FieldSLADefinitionID)
	}
	if m.sla_response_deadline != nil {
		fields = append(fields, ticket.FieldSLAResponseDeadline)
	}
	if m.sla_resolution_deadline != nil {
		fields = append(fields, ticket.FieldSLAResolutionDeadline)
	}
	if m.first_response_at != nil {
		fields = append(fields, ticket.FieldFirstResponseAt)
	}
	if m.resolved_at != nil {
		fields = append(fields, ticket.FieldResolvedAt)
	}
	if m.rating != nil {
		fields = append(fields, ticket.FieldRating)
	}
	if m.rating_comment != nil {
		fields = append(fields, ticket.FieldRatingComment)
	}
	if m.rated_at != nil {
		fields = append(fields, ticket.FieldRatedAt)
	}
	if m.rated_by != nil {
		fields = append(fields, ticket.FieldRatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, ticket.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ticket.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldTitle:
		return m.Title()
	case ticket.FieldDescription:
		return m.Description()
	case ticket.FieldStatus:
		return m.Status()
	case ticket.FieldPriority:
		return m.Priority()
	case ticket.FieldTicketNumber:
		return m.TicketNumber()
	case ticket.FieldRequesterID:
		return m.RequesterID()
	case ticket.FieldAssigneeID:
		return m.AssigneeID()
	case ticket.FieldTenantID:
		return m.TenantID()
	case ticket.FieldTemplateID:
		return m.TemplateID()
	case ticket.FieldCategoryID:
		return m.CategoryID()
	case ticket.FieldDepartmentID:
		return m.DepartmentID()
	case ticket.FieldParentTicketID:
		return m.ParentTicketID()
	case ticket.FieldSLADefinitionID:
		return m.SLADefinitionID()
	case ticket.FieldSLAResponseDeadline:
		return m.SLAResponseDeadline()
	case ticket.FieldSLAResolutionDeadline:
		return m.SLAResolutionDeadline()
	case ticket.FieldFirstResponseAt:
		return m.FirstResponseAt()
	case ticket.FieldResolvedAt:
		return m.ResolvedAt()
	case ticket.FieldRating:
		return m.Rating()
	case ticket.FieldRatingComment:
		return m.RatingComment()
	case ticket.FieldRatedAt:
		return m.RatedAt()
	case ticket.FieldRatedBy:
		return m.RatedBy()
	case ticket.FieldCreatedAt:
		return m.CreatedAt()
	case ticket.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticket.FieldTitle:
		return m.OldTitle(ctx)
	case ticket.FieldDescription:
		return m.OldDescription(ctx)
	case ticket.FieldStatus:
		return m.OldStatus(ctx)
	case ticket.FieldPriority:
		return m.OldPriority(ctx)
	case ticket.FieldTicketNumber:
		return m.OldTicketNumber(ctx)
	case ticket.FieldRequesterID:
		return m.OldRequesterID(ctx)
	case ticket.FieldAssigneeID:
		return m.OldAssigneeID(ctx)
	case ticket.FieldTenantID:
		return m.OldTenantID(ctx)
	case ticket.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case ticket.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case ticket.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case ticket.FieldParentTicketID:
		return m.OldParentTicketID(ctx)
	case ticket.FieldSLADefinitionID:
		return m.OldSLADefinitionID(ctx)
	case ticket.FieldSLAResponseDeadline:
		return m.OldSLAResponseDeadline(ctx)
	case ticket.FieldSLAResolutionDeadline:
		return m.OldSLAResolutionDeadline(ctx)
	case ticket.FieldFirstResponseAt:
		return m.OldFirstResponseAt(ctx)
	case ticket.FieldResolvedAt:
		return m.OldResolvedAt(ctx)
	case ticket.FieldRating:
		return m.OldRating(ctx)
	case ticket.FieldRatingComment:
		return m.OldRatingComment(ctx)
	case ticket.FieldRatedAt:
		return m.OldRatedAt(ctx)
	case ticket.FieldRatedBy:
		return m.OldRatedBy(ctx)
	case ticket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ticket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case ticket.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ticket.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ticket.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case ticket.FieldTicketNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketNumber(v)
		return nil
	case ticket.FieldRequesterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequesterID(v)
		return nil
	case ticket.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeID(v)
		return nil
	case ticket.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ticket.FieldTemplateID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case ticket.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case ticket.FieldDepartmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case ticket.FieldParentTicketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentTicketID(v)
		return nil
	case ticket.FieldSLADefinitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSLADefinitionID(v)
		return nil
	case ticket.FieldSLAResponseDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSLAResponseDeadline(v)
		return nil
	case ticket.FieldSLAResolutionDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSLAResolutionDeadline(v)
		return nil
	case ticket.FieldFirstResponseAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstResponseAt(v)
		return nil
	case ticket.FieldResolvedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedAt(v)
		return nil
	case ticket.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case ticket.FieldRatingComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatingComment(v)
		return nil
	case ticket.FieldRatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatedAt(v)
		return nil
	case ticket.FieldRatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatedBy(v)
		return nil
	case ticket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketMutation) AddedFields() []string {
	var fields []string
	if m.addrequester_id != nil {
		fields = append(fields, ticket.FieldRequesterID)
	}
	if m.addassignee_id != nil {
		fields = append(fields, ticket.FieldAssigneeID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, ticket.FieldTenantID)
	}
	if m.addrating != nil {
		fields = append(fields, ticket.FieldRating)
	}
	if m.addrated_by != nil {
		fields = append(fields, ticket.FieldRatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldRequesterID:
		return m.AddedRequesterID()
	case ticket.FieldAssigneeID:
		return m.AddedAssigneeID()
	case ticket.FieldTenantID:
		return m.AddedTenantID()
	case ticket.FieldRating:
		return m.AddedRating()
	case ticket.FieldRatedBy:
		return m.AddedRatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldRequesterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequesterID(v)
		return nil
	case ticket.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssigneeID(v)
		return nil
	case ticket.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case ticket.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	case ticket.FieldRatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticket.FieldDescription) {
		fields = append(fields, ticket.FieldDescription)
	}
	if m.FieldCleared(ticket.FieldAssigneeID) {
		fields = append(fields, ticket.FieldAssigneeID)
	}
	if m.FieldCleared(ticket.FieldTemplateID) {
		fields = append(fields, ticket.FieldTemplateID)
	}
	if m.FieldCleared(ticket.FieldCategoryID) {
		fields = append(fields, ticket.FieldCategoryID)
	}
	if m.FieldCleared(ticket.FieldDepartmentID) {
		fields = append(fields, ticket.FieldDepartmentID)
	}
	if m.FieldCleared(ticket.FieldParentTicketID) {
		fields = append(fields, ticket.FieldParentTicketID)
	}
	if m.FieldCleared(ticket.FieldSLADefinitionID) {
		fields = append(fields, ticket.FieldSLADefinitionID)
	}
	if m.FieldCleared(ticket.FieldSLAResponseDeadline) {
		fields = append(fields, ticket.FieldSLAResponseDeadline)
	}
	if m.FieldCleared(ticket.FieldSLAResolutionDeadline) {
		fields = append(fields, ticket.FieldSLAResolutionDeadline)
	}
	if m.FieldCleared(ticket.FieldFirstResponseAt) {
		fields = append(fields, ticket.FieldFirstResponseAt)
	}
	if m.FieldCleared(ticket.FieldResolvedAt) {
		fields = append(fields, ticket.FieldResolvedAt)
	}
	if m.FieldCleared(ticket.FieldRating) {
		fields = append(fields, ticket.FieldRating)
	}
	if m.FieldCleared(ticket.FieldRatingComment) {
		fields = append(fields, ticket.FieldRatingComment)
	}
	if m.FieldCleared(ticket.FieldRatedAt) {
		fields = append(fields, ticket.FieldRatedAt)
	}
	if m.FieldCleared(ticket.FieldRatedBy) {
		fields = append(fields, ticket.FieldRatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketMutation) ClearField(name string) error {
	switch name {
	case ticket.FieldDescription:
		m.ClearDescription()
		return nil
	case ticket.FieldAssigneeID:
		m.ClearAssigneeID()
		return nil
	case ticket.FieldTemplateID:
		m.ClearTemplateID()
		return nil
	case ticket.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case ticket.FieldDepartmentID:
		m.ClearDepartmentID()
		return nil
	case ticket.FieldParentTicketID:
		m.ClearParentTicketID()
		return nil
	case ticket.FieldSLADefinitionID:
		m.ClearSLADefinitionID()
		return nil
	case ticket.FieldSLAResponseDeadline:
		m.ClearSLAResponseDeadline()
		return nil
	case ticket.FieldSLAResolutionDeadline:
		m.ClearSLAResolutionDeadline()
		return nil
	case ticket.FieldFirstResponseAt:
		m.ClearFirstResponseAt()
		return nil
	case ticket.FieldResolvedAt:
		m.ClearResolvedAt()
		return nil
	case ticket.FieldRating:
		m.ClearRating()
		return nil
	case ticket.FieldRatingComment:
		m.ClearRatingComment()
		return nil
	case ticket.FieldRatedAt:
		m.ClearRatedAt()
		return nil
	case ticket.FieldRatedBy:
		m.ClearRatedBy()
		return nil
	}
	return fmt.Errorf("unknown Ticket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketMutation) ResetField(name string) error {
	switch name {
	case ticket.FieldTitle:
		m.ResetTitle()
		return nil
	case ticket.FieldDescription:
		m.ResetDescription()
		return nil
	case ticket.FieldStatus:
		m.ResetStatus()
		return nil
	case ticket.FieldPriority:
		m.ResetPriority()
		return nil
	case ticket.FieldTicketNumber:
		m.ResetTicketNumber()
		return nil
	case ticket.FieldRequesterID:
		m.ResetRequesterID()
		return nil
	case ticket.FieldAssigneeID:
		m.ResetAssigneeID()
		return nil
	case ticket.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ticket.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case ticket.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case ticket.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case ticket.FieldParentTicketID:
		m.ResetParentTicketID()
		return nil
	case ticket.FieldSLADefinitionID:
		m.ResetSLADefinitionID()
		return nil
	case ticket.FieldSLAResponseDeadline:
		m.ResetSLAResponseDeadline()
		return nil
	case ticket.FieldSLAResolutionDeadline:
		m.ResetSLAResolutionDeadline()
		return nil
	case ticket.FieldFirstResponseAt:
		m.ResetFirstResponseAt()
		return nil
	case ticket.FieldResolvedAt:
		m.ResetResolvedAt()
		return nil
	case ticket.FieldRating:
		m.ResetRating()
		return nil
	case ticket.FieldRatingComment:
		m.ResetRatingComment()
		return nil
	case ticket.FieldRatedAt:
		m.ResetRatedAt()
		return nil
	case ticket.FieldRatedBy:
		m.ResetRatedBy()
		return nil
	case ticket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.template != nil {
		edges = append(edges, ticket.EdgeTemplate)
	}
	if m.category != nil {
		edges = append(edges, ticket.EdgeCategory)
	}
	if m.department != nil {
		edges = append(edges, ticket.EdgeDepartment)
	}
	if m.tags != nil {
		edges = append(edges, ticket.EdgeTags)
	}
	if m.related_tickets != nil {
		edges = append(edges, ticket.EdgeRelatedTickets)
	}
	if m.parent_ticket != nil {
		edges = append(edges, ticket.EdgeParentTicket)
	}
	if m.workflow_instances != nil {
		edges = append(edges, ticket.EdgeWorkflowInstances)
	}
	if m.sla_definition != nil {
		edges = append(edges, ticket.EdgeSLADefinition)
	}
	if m.sla_violations != nil {
		edges = append(edges, ticket.EdgeSLAViolations)
	}
	if m.comments != nil {
		edges = append(edges, ticket.EdgeComments)
	}
	if m.attachments != nil {
		edges = append(edges, ticket.EdgeAttachments)
	}
	if m.notifications != nil {
		edges = append(edges, ticket.EdgeNotifications)
	}
	if m.sla_alert_history != nil {
		edges = append(edges, ticket.EdgeSLAAlertHistory)
	}
	if m.approval_records != nil {
		edges = append(edges, ticket.EdgeApprovalRecords)
	}
	if m.root_cause_analyses != nil {
		edges = append(edges, ticket.EdgeRootCauseAnalyses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticket.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeRelatedTickets:
		ids := make([]ent.Value, 0, len(m.related_tickets))
		for id := range m.related_tickets {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeParentTicket:
		if id := m.parent_ticket; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeWorkflowInstances:
		ids := make([]ent.Value, 0, len(m.workflow_instances))
		for id := range m.workflow_instances {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeSLADefinition:
		if id := m.sla_definition; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeSLAViolations:
		ids := make([]ent.Value, 0, len(m.sla_violations))
		for id := range m.sla_violations {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeSLAAlertHistory:
		ids := make([]ent.Value, 0, len(m.sla_alert_history))
		for id := range m.sla_alert_history {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeApprovalRecords:
		ids := make([]ent.Value, 0, len(m.approval_records))
		for id := range m.approval_records {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeRootCauseAnalyses:
		ids := make([]ent.Value, 0, len(m.root_cause_analyses))
		for id := range m.root_cause_analyses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removedtags != nil {
		edges = append(edges, ticket.EdgeTags)
	}
	if m.removedrelated_tickets != nil {
		edges = append(edges, ticket.EdgeRelatedTickets)
	}
	if m.removedworkflow_instances != nil {
		edges = append(edges, ticket.EdgeWorkflowInstances)
	}
	if m.removedsla_violations != nil {
		edges = append(edges, ticket.EdgeSLAViolations)
	}
	if m.removedcomments != nil {
		edges = append(edges, ticket.EdgeComments)
	}
	if m.removedattachments != nil {
		edges = append(edges, ticket.EdgeAttachments)
	}
	if m.removednotifications != nil {
		edges = append(edges, ticket.EdgeNotifications)
	}
	if m.removedsla_alert_history != nil {
		edges = append(edges, ticket.EdgeSLAAlertHistory)
	}
	if m.removedapproval_records != nil {
		edges = append(edges, ticket.EdgeApprovalRecords)
	}
	if m.removedroot_cause_analyses != nil {
		edges = append(edges, ticket.EdgeRootCauseAnalyses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ticket.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeRelatedTickets:
		ids := make([]ent.Value, 0, len(m.removedrelated_tickets))
		for id := range m.removedrelated_tickets {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeWorkflowInstances:
		ids := make([]ent.Value, 0, len(m.removedworkflow_instances))
		for id := range m.removedworkflow_instances {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeSLAViolations:
		ids := make([]ent.Value, 0, len(m.removedsla_violations))
		for id := range m.removedsla_violations {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeSLAAlertHistory:
		ids := make([]ent.Value, 0, len(m.removedsla_alert_history))
		for id := range m.removedsla_alert_history {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeApprovalRecords:
		ids := make([]ent.Value, 0, len(m.removedapproval_records))
		for id := range m.removedapproval_records {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeRootCauseAnalyses:
		ids := make([]ent.Value, 0, len(m.removedroot_cause_analyses))
		for id := range m.removedroot_cause_analyses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedtemplate {
		edges = append(edges, ticket.EdgeTemplate)
	}
	if m.clearedcategory {
		edges = append(edges, ticket.EdgeCategory)
	}
	if m.cleareddepartment {
		edges = append(edges, ticket.EdgeDepartment)
	}
	if m.clearedtags {
		edges = append(edges, ticket.EdgeTags)
	}
	if m.clearedrelated_tickets {
		edges = append(edges, ticket.EdgeRelatedTickets)
	}
	if m.clearedparent_ticket {
		edges = append(edges, ticket.EdgeParentTicket)
	}
	if m.clearedworkflow_instances {
		edges = append(edges, ticket.EdgeWorkflowInstances)
	}
	if m.clearedsla_definition {
		edges = append(edges, ticket.EdgeSLADefinition)
	}
	if m.clearedsla_violations {
		edges = append(edges, ticket.EdgeSLAViolations)
	}
	if m.clearedcomments {
		edges = append(edges, ticket.EdgeComments)
	}
	if m.clearedattachments {
		edges = append(edges, ticket.EdgeAttachments)
	}
	if m.clearednotifications {
		edges = append(edges, ticket.EdgeNotifications)
	}
	if m.clearedsla_alert_history {
		edges = append(edges, ticket.EdgeSLAAlertHistory)
	}
	if m.clearedapproval_records {
		edges = append(edges, ticket.EdgeApprovalRecords)
	}
	if m.clearedroot_cause_analyses {
		edges = append(edges, ticket.EdgeRootCauseAnalyses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketMutation) EdgeCleared(name string) bool {
	switch name {
	case ticket.EdgeTemplate:
		return m.clearedtemplate
	case ticket.EdgeCategory:
		return m.clearedcategory
	case ticket.EdgeDepartment:
		return m.cleareddepartment
	case ticket.EdgeTags:
		return m.clearedtags
	case ticket.EdgeRelatedTickets:
		return m.clearedrelated_tickets
	case ticket.EdgeParentTicket:
		return m.clearedparent_ticket
	case ticket.EdgeWorkflowInstances:
		return m.clearedworkflow_instances
	case ticket.EdgeSLADefinition:
		return m.clearedsla_definition
	case ticket.EdgeSLAViolations:
		return m.clearedsla_violations
	case ticket.EdgeComments:
		return m.clearedcomments
	case ticket.EdgeAttachments:
		return m.clearedattachments
	case ticket.EdgeNotifications:
		return m.clearednotifications
	case ticket.EdgeSLAAlertHistory:
		return m.clearedsla_alert_history
	case ticket.EdgeApprovalRecords:
		return m.clearedapproval_records
	case ticket.EdgeRootCauseAnalyses:
		return m.clearedroot_cause_analyses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketMutation) ClearEdge(name string) error {
	switch name {
	case ticket.EdgeTemplate:
		m.ClearTemplate()
		return nil
	case ticket.EdgeCategory:
		m.ClearCategory()
		return nil
	case ticket.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case ticket.EdgeParentTicket:
		m.ClearParentTicket()
		return nil
	case ticket.EdgeSLADefinition:
		m.ClearSLADefinition()
		return nil
	}
	return fmt.Errorf("unknown Ticket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketMutation) ResetEdge(name string) error {
	switch name {
	case ticket.EdgeTemplate:
		m.ResetTemplate()
		return nil
	case ticket.EdgeCategory:
		m.ResetCategory()
		return nil
	case ticket.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case ticket.EdgeTags:
		m.ResetTags()
		return nil
	case ticket.EdgeRelatedTickets:
		m.ResetRelatedTickets()
		return nil
	case ticket.EdgeParentTicket:
		m.ResetParentTicket()
		return nil
	case ticket.EdgeWorkflowInstances:
		m.ResetWorkflowInstances()
		return nil
	case ticket.EdgeSLADefinition:
		m.ResetSLADefinition()
		return nil
	case ticket.EdgeSLAViolations:
		m.ResetSLAViolations()
		return nil
	case ticket.EdgeComments:
		m.ResetComments()
		return nil
	case ticket.EdgeAttachments:
		m.ResetAttachments()
		return nil
	case ticket.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case ticket.EdgeSLAAlertHistory:
		m.ResetSLAAlertHistory()
		return nil
	case ticket.EdgeApprovalRecords:
		m.ResetApprovalRecords()
		return nil
	case ticket.EdgeRootCauseAnalyses:
		m.ResetRootCauseAnalyses()
		return nil
	}
	return fmt.Errorf("unknown Ticket edge %s", name)
}

// TicketAssignmentRuleMutation represents an operation that mutates the TicketAssignmentRule nodes in the graph.
type TicketAssignmentRuleMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	description        *string
	priority           *int
	addpriority        *int
	conditions         *[]map[string]interface{}
	appendconditions   []map[string]interface{}
	actions            *map[string]interface{}
	is_active          *bool
	execution_count    *int
	addexecution_count *int
	last_executed_at   *time.Time
	tenant_id          *int
	addtenant_id       *int
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*TicketAssignmentRule, error)
	predicates         []predicate.TicketAssignmentRule
}

var _ ent.Mutation = (*TicketAssignmentRuleMutation)(nil)

// ticketassignmentruleOption allows management of the mutation configuration using functional options.
type ticketassignmentruleOption func(*TicketAssignmentRuleMutation)

// newTicketAssignmentRuleMutation creates new mutation for the TicketAssignmentRule entity.
func newTicketAssignmentRuleMutation(c config, op Op, opts ...ticketassignmentruleOption) *TicketAssignmentRuleMutation {
	m := &TicketAssignmentRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeTicketAssignmentRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketAssignmentRuleID sets the ID field of the mutation.
func withTicketAssignmentRuleID(id int) ticketassignmentruleOption {
	return func(m *TicketAssignmentRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *TicketAssignmentRule
		)
		m.oldValue = func(ctx context.Context) (*TicketAssignmentRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TicketAssignmentRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicketAssignmentRule sets the old TicketAssignmentRule of the mutation.
func withTicketAssignmentRule(node *TicketAssignmentRule) ticketassignmentruleOption {
	return func(m *TicketAssignmentRuleMutation) {
		m.oldValue = func(context.Context) (*TicketAssignmentRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketAssignmentRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketAssignmentRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketAssignmentRuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketAssignmentRuleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TicketAssignmentRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TicketAssignmentRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TicketAssignmentRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TicketAssignmentRule entity.
// If the TicketAssignmentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAssignmentRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TicketAssignmentRuleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TicketAssignmentRuleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TicketAssignmentRuleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TicketAssignmentRule entity.
// If the TicketAssignmentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAssignmentRuleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TicketAssignmentRuleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ticketassignmentrule.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TicketAssignmentRuleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ticketassignmentrule.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TicketAssignmentRuleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ticketassignmentrule.FieldDescription)
}

// SetPriority sets the "priority" field.
func (m *TicketAssignmentRuleMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TicketAssignmentRuleMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the TicketAssignmentRule entity.
// If the TicketAssignmentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAssignmentRuleMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *TicketAssignmentRuleMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *TicketAssignmentRuleMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *TicketAssignmentRuleMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetConditions sets the "conditions" field.
func (m *TicketAssignmentRuleMutation) SetConditions(value []map[string]interface{}) {
	m.conditions = &value
	m.appendconditions = nil
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *TicketAssignmentRuleMutation) Conditions() (r []map[string]interface{}, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the TicketAssignmentRule entity.
// If the TicketAssignmentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAssignmentRuleMutation) OldConditions(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// AppendConditions adds value to the "conditions" field.
func (m *TicketAssignmentRuleMutation) AppendConditions(value []map[string]interface{}) {
	m.appendconditions = append(m.appendconditions, value...)
}

// AppendedConditions returns the list of values that were appended to the "conditions" field in this mutation.
func (m *TicketAssignmentRuleMutation) AppendedConditions() ([]map[string]interface{}, bool) {
	if len(m.appendconditions) == 0 {
		return nil, false
	}
	return m.appendconditions, true
}

// ClearConditions clears the value of the "conditions" field.
func (m *TicketAssignmentRuleMutation) ClearConditions() {
	m.conditions = nil
	m.appendconditions = nil
	m.clearedFields[ticketassignmentrule.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *TicketAssignmentRuleMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[ticketassignmentrule.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *TicketAssignmentRuleMutation) ResetConditions() {
	m.conditions = nil
	m.appendconditions = nil
	delete(m.clearedFields, ticketassignmentrule.FieldConditions)
}

// SetActions sets the "actions" field.
func (m *TicketAssignmentRuleMutation) SetActions(value map[string]interface{}) {
	m.actions = &value
}

// Actions returns the value of the "actions" field in the mutation.
func (m *TicketAssignmentRuleMutation) Actions() (r map[string]interface{}, exists bool) {
	v := m.actions
	if v == nil {
		return
	}
	return *v, true
}

// OldActions returns the old "actions" field's value of the TicketAssignmentRule entity.
// If the TicketAssignmentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAssignmentRuleMutation) OldActions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActions: %w", err)
	}
	return oldValue.Actions, nil
}

// ClearActions clears the value of the "actions" field.
func (m *TicketAssignmentRuleMutation) ClearActions() {
	m.actions = nil
	m.clearedFields[ticketassignmentrule.FieldActions] = struct{}{}
}

// ActionsCleared returns if the "actions" field was cleared in this mutation.
func (m *TicketAssignmentRuleMutation) ActionsCleared() bool {
	_, ok := m.clearedFields[ticketassignmentrule.FieldActions]
	return ok
}

// ResetActions resets all changes to the "actions" field.
func (m *TicketAssignmentRuleMutation) ResetActions() {
	m.actions = nil
	delete(m.clearedFields, ticketassignmentrule.FieldActions)
}

// SetIsActive sets the "is_active" field.
func (m *TicketAssignmentRuleMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *TicketAssignmentRuleMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the TicketAssignmentRule entity.
// If the TicketAssignmentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAssignmentRuleMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *TicketAssignmentRuleMutation) ResetIsActive() {
	m.is_active = nil
}

// SetExecutionCount sets the "execution_count" field.
func (m *TicketAssignmentRuleMutation) SetExecutionCount(i int) {
	m.execution_count = &i
	m.addexecution_count = nil
}

// ExecutionCount returns the value of the "execution_count" field in the mutation.
func (m *TicketAssignmentRuleMutation) ExecutionCount() (r int, exists bool) {
	v := m.execution_count
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionCount returns the old "execution_count" field's value of the TicketAssignmentRule entity.
// If the TicketAssignmentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAssignmentRuleMutation) OldExecutionCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionCount: %w", err)
	}
	return oldValue.ExecutionCount, nil
}

// AddExecutionCount adds i to the "execution_count" field.
func (m *TicketAssignmentRuleMutation) AddExecutionCount(i int) {
	if m.addexecution_count != nil {
		*m.addexecution_count += i
	} else {
		m.addexecution_count = &i
	}
}

// AddedExecutionCount returns the value that was added to the "execution_count" field in this mutation.
func (m *TicketAssignmentRuleMutation) AddedExecutionCount() (r int, exists bool) {
	v := m.addexecution_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetExecutionCount resets all changes to the "execution_count" field.
func (m *TicketAssignmentRuleMutation) ResetExecutionCount() {
	m.execution_count = nil
	m.addexecution_count = nil
}

// SetLastExecutedAt sets the "last_executed_at" field.
func (m *TicketAssignmentRuleMutation) SetLastExecutedAt(t time.Time) {
	m.last_executed_at = &t
}

// LastExecutedAt returns the value of the "last_executed_at" field in the mutation.
func (m *TicketAssignmentRuleMutation) LastExecutedAt() (r time.Time, exists bool) {
	v := m.last_executed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastExecutedAt returns the old "last_executed_at" field's value of the TicketAssignmentRule entity.
// If the TicketAssignmentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAssignmentRuleMutation) OldLastExecutedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastExecutedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastExecutedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastExecutedAt: %w", err)
	}
	return oldValue.LastExecutedAt, nil
}

// ClearLastExecutedAt clears the value of the "last_executed_at" field.
func (m *TicketAssignmentRuleMutation) ClearLastExecutedAt() {
	m.last_executed_at = nil
	m.clearedFields[ticketassignmentrule.FieldLastExecutedAt] = struct{}{}
}

// LastExecutedAtCleared returns if the "last_executed_at" field was cleared in this mutation.
func (m *TicketAssignmentRuleMutation) LastExecutedAtCleared() bool {
	_, ok := m.clearedFields[ticketassignmentrule.FieldLastExecutedAt]
	return ok
}

// ResetLastExecutedAt resets all changes to the "last_executed_at" field.
func (m *TicketAssignmentRuleMutation) ResetLastExecutedAt() {
	m.last_executed_at = nil
	delete(m.clearedFields, ticketassignmentrule.FieldLastExecutedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketAssignmentRuleMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketAssignmentRuleMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TicketAssignmentRule entity.
// If the TicketAssignmentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAssignmentRuleMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TicketAssignmentRuleMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TicketAssignmentRuleMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketAssignmentRuleMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketAssignmentRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketAssignmentRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TicketAssignmentRule entity.
// If the TicketAssignmentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAssignmentRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketAssignmentRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketAssignmentRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketAssignmentRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TicketAssignmentRule entity.
// If the TicketAssignmentRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAssignmentRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketAssignmentRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the TicketAssignmentRuleMutation builder.
func (m *TicketAssignmentRuleMutation) Where(ps ...predicate.TicketAssignmentRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketAssignmentRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketAssignmentRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TicketAssignmentRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketAssignmentRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketAssignmentRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TicketAssignmentRule).
func (m *TicketAssignmentRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketAssignmentRuleMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, ticketassignmentrule.FieldName)
	}
	if m.description != nil {
		fields = append(fields, ticketassignmentrule.FieldDescription)
	}
	if m.priority != nil {
		fields = append(fields, ticketassignmentrule.FieldPriority)
	}
	if m.conditions != nil {
		fields = append(fields, ticketassignmentrule.FieldConditions)
	}
	if m.actions != nil {
		fields = append(fields, ticketassignmentrule.FieldActions)
	}
	if m.is_active != nil {
		fields = append(fields, ticketassignmentrule.FieldIsActive)
	}
	if m.execution_count != nil {
		fields = append(fields, ticketassignmentrule.FieldExecutionCount)
	}
	if m.last_executed_at != nil {
		fields = append(fields, ticketassignmentrule.FieldLastExecutedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, ticketassignmentrule.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, ticketassignmentrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ticketassignmentrule.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketAssignmentRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticketassignmentrule.FieldName:
		return m.Name()
	case ticketassignmentrule.FieldDescription:
		return m.Description()
	case ticketassignmentrule.FieldPriority:
		return m.Priority()
	case ticketassignmentrule.FieldConditions:
		return m.Conditions()
	case ticketassignmentrule.FieldActions:
		return m.Actions()
	case ticketassignmentrule.FieldIsActive:
		return m.IsActive()
	case ticketassignmentrule.FieldExecutionCount:
		return m.ExecutionCount()
	case ticketassignmentrule.FieldLastExecutedAt:
		return m.LastExecutedAt()
	case ticketassignmentrule.FieldTenantID:
		return m.TenantID()
	case ticketassignmentrule.FieldCreatedAt:
		return m.CreatedAt()
	case ticketassignmentrule.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketAssignmentRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticketassignmentrule.FieldName:
		return m.OldName(ctx)
	case ticketassignmentrule.FieldDescription:
		return m.OldDescription(ctx)
	case ticketassignmentrule.FieldPriority:
		return m.OldPriority(ctx)
	case ticketassignmentrule.FieldConditions:
		return m.OldConditions(ctx)
	case ticketassignmentrule.FieldActions:
		return m.OldActions(ctx)
	case ticketassignmentrule.FieldIsActive:
		return m.OldIsActive(ctx)
	case ticketassignmentrule.FieldExecutionCount:
		return m.OldExecutionCount(ctx)
	case ticketassignmentrule.FieldLastExecutedAt:
		return m.OldLastExecutedAt(ctx)
	case ticketassignmentrule.FieldTenantID:
		return m.OldTenantID(ctx)
	case ticketassignmentrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticketassignmentrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TicketAssignmentRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketAssignmentRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticketassignmentrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ticketassignmentrule.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ticketassignmentrule.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case ticketassignmentrule.FieldConditions:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case ticketassignmentrule.FieldActions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActions(v)
		return nil
	case ticketassignmentrule.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case ticketassignmentrule.FieldExecutionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionCount(v)
		return nil
	case ticketassignmentrule.FieldLastExecutedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastExecutedAt(v)
		return nil
	case ticketassignmentrule.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ticketassignmentrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticketassignmentrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TicketAssignmentRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketAssignmentRuleMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, ticketassignmentrule.FieldPriority)
	}
	if m.addexecution_count != nil {
		fields = append(fields, ticketassignmentrule.FieldExecutionCount)
	}
	if m.addtenant_id != nil {
		fields = append(fields, ticketassignmentrule.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketAssignmentRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ticketassignmentrule.FieldPriority:
		return m.AddedPriority()
	case ticketassignmentrule.FieldExecutionCount:
		return m.AddedExecutionCount()
	case ticketassignmentrule.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketAssignmentRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ticketassignmentrule.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case ticketassignmentrule.FieldExecutionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutionCount(v)
		return nil
	case ticketassignmentrule.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown TicketAssignmentRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketAssignmentRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticketassignmentrule.FieldDescription) {
		fields = append(fields, ticketassignmentrule.FieldDescription)
	}
	if m.FieldCleared(ticketassignmentrule.FieldConditions) {
		fields = append(fields, ticketassignmentrule.FieldConditions)
	}
	if m.FieldCleared(ticketassignmentrule.FieldActions) {
		fields = append(fields, ticketassignmentrule.FieldActions)
	}
	if m.FieldCleared(ticketassignmentrule.FieldLastExecutedAt) {
		fields = append(fields, ticketassignmentrule.FieldLastExecutedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketAssignmentRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketAssignmentRuleMutation) ClearField(name string) error {
	switch name {
	case ticketassignmentrule.FieldDescription:
		m.ClearDescription()
		return nil
	case ticketassignmentrule.FieldConditions:
		m.ClearConditions()
		return nil
	case ticketassignmentrule.FieldActions:
		m.ClearActions()
		return nil
	case ticketassignmentrule.FieldLastExecutedAt:
		m.ClearLastExecutedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketAssignmentRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketAssignmentRuleMutation) ResetField(name string) error {
	switch name {
	case ticketassignmentrule.FieldName:
		m.ResetName()
		return nil
	case ticketassignmentrule.FieldDescription:
		m.ResetDescription()
		return nil
	case ticketassignmentrule.FieldPriority:
		m.ResetPriority()
		return nil
	case ticketassignmentrule.FieldConditions:
		m.ResetConditions()
		return nil
	case ticketassignmentrule.FieldActions:
		m.ResetActions()
		return nil
	case ticketassignmentrule.FieldIsActive:
		m.ResetIsActive()
		return nil
	case ticketassignmentrule.FieldExecutionCount:
		m.ResetExecutionCount()
		return nil
	case ticketassignmentrule.FieldLastExecutedAt:
		m.ResetLastExecutedAt()
		return nil
	case ticketassignmentrule.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ticketassignmentrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticketassignmentrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketAssignmentRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketAssignmentRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketAssignmentRuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketAssignmentRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketAssignmentRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketAssignmentRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketAssignmentRuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketAssignmentRuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TicketAssignmentRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketAssignmentRuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TicketAssignmentRule edge %s", name)
}

// TicketAttachmentMutation represents an operation that mutates the TicketAttachment nodes in the graph.
type TicketAttachmentMutation struct {
	config
	op              Op
	typ             string
	id              *int
	file_name       *string
	file_path       *string
	file_url        *string
	file_size       *int
	addfile_size    *int
	file_type       *string
	mime_type       *string
	tenant_id       *int
	addtenant_id    *int
	created_at      *time.Time
	clearedFields   map[string]struct{}
	ticket          *int
	clearedticket   bool
	uploader        *int
	cleareduploader bool
	done            bool
	oldValue        func(context.Context) (*TicketAttachment, error)
	predicates      []predicate.TicketAttachment
}

var _ ent.Mutation = (*TicketAttachmentMutation)(nil)

// ticketattachmentOption allows management of the mutation configuration using functional options.
type ticketattachmentOption func(*TicketAttachmentMutation)

// newTicketAttachmentMutation creates new mutation for the TicketAttachment entity.
func newTicketAttachmentMutation(c config, op Op, opts ...ticketattachmentOption) *TicketAttachmentMutation {
	m := &TicketAttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeTicketAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketAttachmentID sets the ID field of the mutation.
func withTicketAttachmentID(id int) ticketattachmentOption {
	return func(m *TicketAttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *TicketAttachment
		)
		m.oldValue = func(ctx context.Context) (*TicketAttachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TicketAttachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicketAttachment sets the old TicketAttachment of the mutation.
func withTicketAttachment(node *TicketAttachment) ticketattachmentOption {
	return func(m *TicketAttachmentMutation) {
		m.oldValue = func(context.Context) (*TicketAttachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketAttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketAttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketAttachmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketAttachmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TicketAttachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTicketID sets the "ticket_id" field.
func (m *TicketAttachmentMutation) SetTicketID(i int) {
	m.ticket = &i
}

// TicketID returns the value of the "ticket_id" field in the mutation.
func (m *TicketAttachmentMutation) TicketID() (r int, exists bool) {
	v := m.ticket
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketID returns the old "ticket_id" field's value of the TicketAttachment entity.
// If the TicketAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAttachmentMutation) OldTicketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketID: %w", err)
	}
	return oldValue.TicketID, nil
}

// ResetTicketID resets all changes to the "ticket_id" field.
func (m *TicketAttachmentMutation) ResetTicketID() {
	m.ticket = nil
}

// SetFileName sets the "file_name" field.
func (m *TicketAttachmentMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *TicketAttachmentMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the TicketAttachment entity.
// If the TicketAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAttachmentMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *TicketAttachmentMutation) ResetFileName() {
	m.file_name = nil
}

// SetFilePath sets the "file_path" field.
func (m *TicketAttachmentMutation) SetFilePath(s string) {
	m.file_path = &s
}

// FilePath returns the value of the "file_path" field in the mutation.
func (m *TicketAttachmentMutation) FilePath() (r string, exists bool) {
	v := m.file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "file_path" field's value of the TicketAttachment entity.
// If the TicketAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAttachmentMutation) OldFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ResetFilePath resets all changes to the "file_path" field.
func (m *TicketAttachmentMutation) ResetFilePath() {
	m.file_path = nil
}

// SetFileURL sets the "file_url" field.
func (m *TicketAttachmentMutation) SetFileURL(s string) {
	m.file_url = &s
}

// FileURL returns the value of the "file_url" field in the mutation.
func (m *TicketAttachmentMutation) FileURL() (r string, exists bool) {
	v := m.file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFileURL returns the old "file_url" field's value of the TicketAttachment entity.
// If the TicketAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAttachmentMutation) OldFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileURL: %w", err)
	}
	return oldValue.FileURL, nil
}

// ClearFileURL clears the value of the "file_url" field.
func (m *TicketAttachmentMutation) ClearFileURL() {
	m.file_url = nil
	m.clearedFields[ticketattachment.FieldFileURL] = struct{}{}
}

// FileURLCleared returns if the "file_url" field was cleared in this mutation.
func (m *TicketAttachmentMutation) FileURLCleared() bool {
	_, ok := m.clearedFields[ticketattachment.FieldFileURL]
	return ok
}

// ResetFileURL resets all changes to the "file_url" field.
func (m *TicketAttachmentMutation) ResetFileURL() {
	m.file_url = nil
	delete(m.clearedFields, ticketattachment.FieldFileURL)
}

// SetFileSize sets the "file_size" field.
func (m *TicketAttachmentMutation) SetFileSize(i int) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *TicketAttachmentMutation) FileSize() (r int, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the TicketAttachment entity.
// If the TicketAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAttachmentMutation) OldFileSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *TicketAttachmentMutation) AddFileSize(i int) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *TicketAttachmentMutation) AddedFileSize() (r int, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *TicketAttachmentMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
}

// SetFileType sets the "file_type" field.
func (m *TicketAttachmentMutation) SetFileType(s string) {
	m.file_type = &s
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *TicketAttachmentMutation) FileType() (r string, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the TicketAttachment entity.
// If the TicketAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAttachmentMutation) OldFileType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// ResetFileType resets all changes to the "file_type" field.
func (m *TicketAttachmentMutation) ResetFileType() {
	m.file_type = nil
}

// SetMimeType sets the "mime_type" field.
func (m *TicketAttachmentMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *TicketAttachmentMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the TicketAttachment entity.
// If the TicketAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAttachmentMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *TicketAttachmentMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[ticketattachment.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *TicketAttachmentMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[ticketattachment.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *TicketAttachmentMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, ticketattachment.FieldMimeType)
}

// SetUploadedBy sets the "uploaded_by" field.
func (m *TicketAttachmentMutation) SetUploadedBy(i int) {
	m.uploader = &i
}

// UploadedBy returns the value of the "uploaded_by" field in the mutation.
func (m *TicketAttachmentMutation) UploadedBy() (r int, exists bool) {
	v := m.uploader
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedBy returns the old "uploaded_by" field's value of the TicketAttachment entity.
// If the TicketAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAttachmentMutation) OldUploadedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedBy: %w", err)
	}
	return oldValue.UploadedBy, nil
}

// ResetUploadedBy resets all changes to the "uploaded_by" field.
func (m *TicketAttachmentMutation) ResetUploadedBy() {
	m.uploader = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketAttachmentMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketAttachmentMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TicketAttachment entity.
// If the TicketAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAttachmentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TicketAttachmentMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TicketAttachmentMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketAttachmentMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketAttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketAttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TicketAttachment entity.
// If the TicketAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketAttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTicket clears the "ticket" edge to the Ticket entity.
func (m *TicketAttachmentMutation) ClearTicket() {
	m.clearedticket = true
	m.clearedFields[ticketattachment.FieldTicketID] = struct{}{}
}

// TicketCleared reports if the "ticket" edge to the Ticket entity was cleared.
func (m *TicketAttachmentMutation) TicketCleared() bool {
	return m.clearedticket
}

// TicketIDs returns the "ticket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TicketID instead. It exists only for internal usage by the builders.
func (m *TicketAttachmentMutation) TicketIDs() (ids []int) {
	if id := m.ticket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicket resets all changes to the "ticket" edge.
func (m *TicketAttachmentMutation) ResetTicket() {
	m.ticket = nil
	m.clearedticket = false
}

// SetUploaderID sets the "uploader" edge to the User entity by id.
func (m *TicketAttachmentMutation) SetUploaderID(id int) {
	m.uploader = &id
}

// ClearUploader clears the "uploader" edge to the User entity.
func (m *TicketAttachmentMutation) ClearUploader() {
	m.cleareduploader = true
	m.clearedFields[ticketattachment.FieldUploadedBy] = struct{}{}
}

// UploaderCleared reports if the "uploader" edge to the User entity was cleared.
func (m *TicketAttachmentMutation) UploaderCleared() bool {
	return m.cleareduploader
}

// UploaderID returns the "uploader" edge ID in the mutation.
func (m *TicketAttachmentMutation) UploaderID() (id int, exists bool) {
	if m.uploader != nil {
		return *m.uploader, true
	}
	return
}

// UploaderIDs returns the "uploader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UploaderID instead. It exists only for internal usage by the builders.
func (m *TicketAttachmentMutation) UploaderIDs() (ids []int) {
	if id := m.uploader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUploader resets all changes to the "uploader" edge.
func (m *TicketAttachmentMutation) ResetUploader() {
	m.uploader = nil
	m.cleareduploader = false
}

// Where appends a list predicates to the TicketAttachmentMutation builder.
func (m *TicketAttachmentMutation) Where(ps ...predicate.TicketAttachment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketAttachmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketAttachmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TicketAttachment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketAttachmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketAttachmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TicketAttachment).
func (m *TicketAttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketAttachmentMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.ticket != nil {
		fields = append(fields, ticketattachment.FieldTicketID)
	}
	if m.file_name != nil {
		fields = append(fields, ticketattachment.FieldFileName)
	}
	if m.file_path != nil {
		fields = append(fields, ticketattachment.FieldFilePath)
	}
	if m.file_url != nil {
		fields = append(fields, ticketattachment.FieldFileURL)
	}
	if m.file_size != nil {
		fields = append(fields, ticketattachment.FieldFileSize)
	}
	if m.file_type != nil {
		fields = append(fields, ticketattachment.FieldFileType)
	}
	if m.mime_type != nil {
		fields = append(fields, ticketattachment.FieldMimeType)
	}
	if m.uploader != nil {
		fields = append(fields, ticketattachment.FieldUploadedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, ticketattachment.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, ticketattachment.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketAttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticketattachment.FieldTicketID:
		return m.TicketID()
	case ticketattachment.FieldFileName:
		return m.FileName()
	case ticketattachment.FieldFilePath:
		return m.FilePath()
	case ticketattachment.FieldFileURL:
		return m.FileURL()
	case ticketattachment.FieldFileSize:
		return m.FileSize()
	case ticketattachment.FieldFileType:
		return m.FileType()
	case ticketattachment.FieldMimeType:
		return m.MimeType()
	case ticketattachment.FieldUploadedBy:
		return m.UploadedBy()
	case ticketattachment.FieldTenantID:
		return m.TenantID()
	case ticketattachment.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketAttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticketattachment.FieldTicketID:
		return m.OldTicketID(ctx)
	case ticketattachment.FieldFileName:
		return m.OldFileName(ctx)
	case ticketattachment.FieldFilePath:
		return m.OldFilePath(ctx)
	case ticketattachment.FieldFileURL:
		return m.OldFileURL(ctx)
	case ticketattachment.FieldFileSize:
		return m.OldFileSize(ctx)
	case ticketattachment.FieldFileType:
		return m.OldFileType(ctx)
	case ticketattachment.FieldMimeType:
		return m.OldMimeType(ctx)
	case ticketattachment.FieldUploadedBy:
		return m.OldUploadedBy(ctx)
	case ticketattachment.FieldTenantID:
		return m.OldTenantID(ctx)
	case ticketattachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TicketAttachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketAttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticketattachment.FieldTicketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketID(v)
		return nil
	case ticketattachment.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case ticketattachment.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case ticketattachment.FieldFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileURL(v)
		return nil
	case ticketattachment.FieldFileSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case ticketattachment.FieldFileType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case ticketattachment.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case ticketattachment.FieldUploadedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedBy(v)
		return nil
	case ticketattachment.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ticketattachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TicketAttachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketAttachmentMutation) AddedFields() []string {
	var fields []string
	if m.addfile_size != nil {
		fields = append(fields, ticketattachment.FieldFileSize)
	}
	if m.addtenant_id != nil {
		fields = append(fields, ticketattachment.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketAttachmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ticketattachment.FieldFileSize:
		return m.AddedFileSize()
	case ticketattachment.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketAttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ticketattachment.FieldFileSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	case ticketattachment.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown TicketAttachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketAttachmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticketattachment.FieldFileURL) {
		fields = append(fields, ticketattachment.FieldFileURL)
	}
	if m.FieldCleared(ticketattachment.FieldMimeType) {
		fields = append(fields, ticketattachment.FieldMimeType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketAttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketAttachmentMutation) ClearField(name string) error {
	switch name {
	case ticketattachment.FieldFileURL:
		m.ClearFileURL()
		return nil
	case ticketattachment.FieldMimeType:
		m.ClearMimeType()
		return nil
	}
	return fmt.Errorf("unknown TicketAttachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketAttachmentMutation) ResetField(name string) error {
	switch name {
	case ticketattachment.FieldTicketID:
		m.ResetTicketID()
		return nil
	case ticketattachment.FieldFileName:
		m.ResetFileName()
		return nil
	case ticketattachment.FieldFilePath:
		m.ResetFilePath()
		return nil
	case ticketattachment.FieldFileURL:
		m.ResetFileURL()
		return nil
	case ticketattachment.FieldFileSize:
		m.ResetFileSize()
		return nil
	case ticketattachment.FieldFileType:
		m.ResetFileType()
		return nil
	case ticketattachment.FieldMimeType:
		m.ResetMimeType()
		return nil
	case ticketattachment.FieldUploadedBy:
		m.ResetUploadedBy()
		return nil
	case ticketattachment.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ticketattachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketAttachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketAttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.ticket != nil {
		edges = append(edges, ticketattachment.EdgeTicket)
	}
	if m.uploader != nil {
		edges = append(edges, ticketattachment.EdgeUploader)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketAttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticketattachment.EdgeTicket:
		if id := m.ticket; id != nil {
			return []ent.Value{*id}
		}
	case ticketattachment.EdgeUploader:
		if id := m.uploader; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketAttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketAttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketAttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedticket {
		edges = append(edges, ticketattachment.EdgeTicket)
	}
	if m.cleareduploader {
		edges = append(edges, ticketattachment.EdgeUploader)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketAttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case ticketattachment.EdgeTicket:
		return m.clearedticket
	case ticketattachment.EdgeUploader:
		return m.cleareduploader
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketAttachmentMutation) ClearEdge(name string) error {
	switch name {
	case ticketattachment.EdgeTicket:
		m.ClearTicket()
		return nil
	case ticketattachment.EdgeUploader:
		m.ClearUploader()
		return nil
	}
	return fmt.Errorf("unknown TicketAttachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketAttachmentMutation) ResetEdge(name string) error {
	switch name {
	case ticketattachment.EdgeTicket:
		m.ResetTicket()
		return nil
	case ticketattachment.EdgeUploader:
		m.ResetUploader()
		return nil
	}
	return fmt.Errorf("unknown TicketAttachment edge %s", name)
}

// TicketAutomationRuleMutation represents an operation that mutates the TicketAutomationRule nodes in the graph.
type TicketAutomationRuleMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	description        *string
	priority           *int
	addpriority        *int
	conditions         *[]map[string]interface{}
	appendconditions   []map[string]interface{}
	actions            *[]map[string]interface{}
	appendactions      []map[string]interface{}
	is_active          *bool
	execution_count    *int
	addexecution_count *int
	last_executed_at   *time.Time
	tenant_id          *int
	addtenant_id       *int
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	creator            *int
	clearedcreator     bool
	done               bool
	oldValue           func(context.Context) (*TicketAutomationRule, error)
	predicates         []predicate.TicketAutomationRule
}

var _ ent.Mutation = (*TicketAutomationRuleMutation)(nil)

// ticketautomationruleOption allows management of the mutation configuration using functional options.
type ticketautomationruleOption func(*TicketAutomationRuleMutation)

// newTicketAutomationRuleMutation creates new mutation for the TicketAutomationRule entity.
func newTicketAutomationRuleMutation(c config, op Op, opts ...ticketautomationruleOption) *TicketAutomationRuleMutation {
	m := &TicketAutomationRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeTicketAutomationRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketAutomationRuleID sets the ID field of the mutation.
func withTicketAutomationRuleID(id int) ticketautomationruleOption {
	return func(m *TicketAutomationRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *TicketAutomationRule
		)
		m.oldValue = func(ctx context.Context) (*TicketAutomationRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TicketAutomationRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicketAutomationRule sets the old TicketAutomationRule of the mutation.
func withTicketAutomationRule(node *TicketAutomationRule) ticketautomationruleOption {
	return func(m *TicketAutomationRuleMutation) {
		m.oldValue = func(context.Context) (*TicketAutomationRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketAutomationRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketAutomationRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketAutomationRuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketAutomationRuleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TicketAutomationRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TicketAutomationRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TicketAutomationRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TicketAutomationRule entity.
// If the TicketAutomationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAutomationRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TicketAutomationRuleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TicketAutomationRuleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TicketAutomationRuleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TicketAutomationRule entity.
// If the TicketAutomationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAutomationRuleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TicketAutomationRuleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ticketautomationrule.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TicketAutomationRuleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ticketautomationrule.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TicketAutomationRuleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ticketautomationrule.FieldDescription)
}

// SetPriority sets the "priority" field.
func (m *TicketAutomationRuleMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TicketAutomationRuleMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the TicketAutomationRule entity.
// If the TicketAutomationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAutomationRuleMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *TicketAutomationRuleMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *TicketAutomationRuleMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *TicketAutomationRuleMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetConditions sets the "conditions" field.
func (m *TicketAutomationRuleMutation) SetConditions(value []map[string]interface{}) {
	m.conditions = &value
	m.appendconditions = nil
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *TicketAutomationRuleMutation) Conditions() (r []map[string]interface{}, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the TicketAutomationRule entity.
// If the TicketAutomationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAutomationRuleMutation) OldConditions(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// AppendConditions adds value to the "conditions" field.
func (m *TicketAutomationRuleMutation) AppendConditions(value []map[string]interface{}) {
	m.appendconditions = append(m.appendconditions, value...)
}

// AppendedConditions returns the list of values that were appended to the "conditions" field in this mutation.
func (m *TicketAutomationRuleMutation) AppendedConditions() ([]map[string]interface{}, bool) {
	if len(m.appendconditions) == 0 {
		return nil, false
	}
	return m.appendconditions, true
}

// ClearConditions clears the value of the "conditions" field.
func (m *TicketAutomationRuleMutation) ClearConditions() {
	m.conditions = nil
	m.appendconditions = nil
	m.clearedFields[ticketautomationrule.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *TicketAutomationRuleMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[ticketautomationrule.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *TicketAutomationRuleMutation) ResetConditions() {
	m.conditions = nil
	m.appendconditions = nil
	delete(m.clearedFields, ticketautomationrule.FieldConditions)
}

// SetActions sets the "actions" field.
func (m *TicketAutomationRuleMutation) SetActions(value []map[string]interface{}) {
	m.actions = &value
	m.appendactions = nil
}

// Actions returns the value of the "actions" field in the mutation.
func (m *TicketAutomationRuleMutation) Actions() (r []map[string]interface{}, exists bool) {
	v := m.actions
	if v == nil {
		return
	}
	return *v, true
}

// OldActions returns the old "actions" field's value of the TicketAutomationRule entity.
// If the TicketAutomationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAutomationRuleMutation) OldActions(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActions: %w", err)
	}
	return oldValue.Actions, nil
}

// AppendActions adds value to the "actions" field.
func (m *TicketAutomationRuleMutation) AppendActions(value []map[string]interface{}) {
	m.appendactions = append(m.appendactions, value...)
}

// AppendedActions returns the list of values that were appended to the "actions" field in this mutation.
func (m *TicketAutomationRuleMutation) AppendedActions() ([]map[string]interface{}, bool) {
	if len(m.appendactions) == 0 {
		return nil, false
	}
	return m.appendactions, true
}

// ClearActions clears the value of the "actions" field.
func (m *TicketAutomationRuleMutation) ClearActions() {
	m.actions = nil
	m.appendactions = nil
	m.clearedFields[ticketautomationrule.FieldActions] = struct{}{}
}

// ActionsCleared returns if the "actions" field was cleared in this mutation.
func (m *TicketAutomationRuleMutation) ActionsCleared() bool {
	_, ok := m.clearedFields[ticketautomationrule.FieldActions]
	return ok
}

// ResetActions resets all changes to the "actions" field.
func (m *TicketAutomationRuleMutation) ResetActions() {
	m.actions = nil
	m.appendactions = nil
	delete(m.clearedFields, ticketautomationrule.FieldActions)
}

// SetIsActive sets the "is_active" field.
func (m *TicketAutomationRuleMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *TicketAutomationRuleMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the TicketAutomationRule entity.
// If the TicketAutomationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAutomationRuleMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *TicketAutomationRuleMutation) ResetIsActive() {
	m.is_active = nil
}

// SetExecutionCount sets the "execution_count" field.
func (m *TicketAutomationRuleMutation) SetExecutionCount(i int) {
	m.execution_count = &i
	m.addexecution_count = nil
}

// ExecutionCount returns the value of the "execution_count" field in the mutation.
func (m *TicketAutomationRuleMutation) ExecutionCount() (r int, exists bool) {
	v := m.execution_count
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionCount returns the old "execution_count" field's value of the TicketAutomationRule entity.
// If the TicketAutomationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAutomationRuleMutation) OldExecutionCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionCount: %w", err)
	}
	return oldValue.ExecutionCount, nil
}

// AddExecutionCount adds i to the "execution_count" field.
func (m *TicketAutomationRuleMutation) AddExecutionCount(i int) {
	if m.addexecution_count != nil {
		*m.addexecution_count += i
	} else {
		m.addexecution_count = &i
	}
}

// AddedExecutionCount returns the value that was added to the "execution_count" field in this mutation.
func (m *TicketAutomationRuleMutation) AddedExecutionCount() (r int, exists bool) {
	v := m.addexecution_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetExecutionCount resets all changes to the "execution_count" field.
func (m *TicketAutomationRuleMutation) ResetExecutionCount() {
	m.execution_count = nil
	m.addexecution_count = nil
}

// SetLastExecutedAt sets the "last_executed_at" field.
func (m *TicketAutomationRuleMutation) SetLastExecutedAt(t time.Time) {
	m.last_executed_at = &t
}

// LastExecutedAt returns the value of the "last_executed_at" field in the mutation.
func (m *TicketAutomationRuleMutation) LastExecutedAt() (r time.Time, exists bool) {
	v := m.last_executed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastExecutedAt returns the old "last_executed_at" field's value of the TicketAutomationRule entity.
// If the TicketAutomationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAutomationRuleMutation) OldLastExecutedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastExecutedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastExecutedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastExecutedAt: %w", err)
	}
	return oldValue.LastExecutedAt, nil
}

// ClearLastExecutedAt clears the value of the "last_executed_at" field.
func (m *TicketAutomationRuleMutation) ClearLastExecutedAt() {
	m.last_executed_at = nil
	m.clearedFields[ticketautomationrule.FieldLastExecutedAt] = struct{}{}
}

// LastExecutedAtCleared returns if the "last_executed_at" field was cleared in this mutation.
func (m *TicketAutomationRuleMutation) LastExecutedAtCleared() bool {
	_, ok := m.clearedFields[ticketautomationrule.FieldLastExecutedAt]
	return ok
}

// ResetLastExecutedAt resets all changes to the "last_executed_at" field.
func (m *TicketAutomationRuleMutation) ResetLastExecutedAt() {
	m.last_executed_at = nil
	delete(m.clearedFields, ticketautomationrule.FieldLastExecutedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TicketAutomationRuleMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TicketAutomationRuleMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TicketAutomationRule entity.
// If the TicketAutomationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAutomationRuleMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TicketAutomationRuleMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketAutomationRuleMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketAutomationRuleMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TicketAutomationRule entity.
// If the TicketAutomationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAutomationRuleMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TicketAutomationRuleMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TicketAutomationRuleMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketAutomationRuleMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketAutomationRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketAutomationRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TicketAutomationRule entity.
// If the TicketAutomationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAutomationRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketAutomationRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketAutomationRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketAutomationRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TicketAutomationRule entity.
// If the TicketAutomationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketAutomationRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketAutomationRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *TicketAutomationRuleMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *TicketAutomationRuleMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[ticketautomationrule.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *TicketAutomationRuleMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *TicketAutomationRuleMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *TicketAutomationRuleMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *TicketAutomationRuleMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// Where appends a list predicates to the TicketAutomationRuleMutation builder.
func (m *TicketAutomationRuleMutation) Where(ps ...predicate.TicketAutomationRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketAutomationRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketAutomationRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TicketAutomationRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketAutomationRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketAutomationRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TicketAutomationRule).
func (m *TicketAutomationRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketAutomationRuleMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, ticketautomationrule.FieldName)
	}
	if m.description != nil {
		fields = append(fields, ticketautomationrule.FieldDescription)
	}
	if m.priority != nil {
		fields = append(fields, ticketautomationrule.FieldPriority)
	}
	if m.conditions != nil {
		fields = append(fields, ticketautomationrule.FieldConditions)
	}
	if m.actions != nil {
		fields = append(fields, ticketautomationrule.FieldActions)
	}
	if m.is_active != nil {
		fields = append(fields, ticketautomationrule.FieldIsActive)
	}
	if m.execution_count != nil {
		fields = append(fields, ticketautomationrule.FieldExecutionCount)
	}
	if m.last_executed_at != nil {
		fields = append(fields, ticketautomationrule.FieldLastExecutedAt)
	}
	if m.creator != nil {
		fields = append(fields, ticketautomationrule.FieldCreatedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, ticketautomationrule.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, ticketautomationrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ticketautomationrule.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketAutomationRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticketautomationrule.FieldName:
		return m.Name()
	case ticketautomationrule.FieldDescription:
		return m.Description()
	case ticketautomationrule.FieldPriority:
		return m.Priority()
	case ticketautomationrule.FieldConditions:
		return m.Conditions()
	case ticketautomationrule.FieldActions:
		return m.Actions()
	case ticketautomationrule.FieldIsActive:
		return m.IsActive()
	case ticketautomationrule.FieldExecutionCount:
		return m.ExecutionCount()
	case ticketautomationrule.FieldLastExecutedAt:
		return m.LastExecutedAt()
	case ticketautomationrule.FieldCreatedBy:
		return m.CreatedBy()
	case ticketautomationrule.FieldTenantID:
		return m.TenantID()
	case ticketautomationrule.FieldCreatedAt:
		return m.CreatedAt()
	case ticketautomationrule.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketAutomationRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticketautomationrule.FieldName:
		return m.OldName(ctx)
	case ticketautomationrule.FieldDescription:
		return m.OldDescription(ctx)
	case ticketautomationrule.FieldPriority:
		return m.OldPriority(ctx)
	case ticketautomationrule.FieldConditions:
		return m.OldConditions(ctx)
	case ticketautomationrule.FieldActions:
		return m.OldActions(ctx)
	case ticketautomationrule.FieldIsActive:
		return m.OldIsActive(ctx)
	case ticketautomationrule.FieldExecutionCount:
		return m.OldExecutionCount(ctx)
	case ticketautomationrule.FieldLastExecutedAt:
		return m.OldLastExecutedAt(ctx)
	case ticketautomationrule.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case ticketautomationrule.FieldTenantID:
		return m.OldTenantID(ctx)
	case ticketautomationrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticketautomationrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TicketAutomationRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketAutomationRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticketautomationrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ticketautomationrule.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ticketautomationrule.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case ticketautomationrule.FieldConditions:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case ticketautomationrule.FieldActions:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActions(v)
		return nil
	case ticketautomationrule.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case ticketautomationrule.FieldExecutionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionCount(v)
		return nil
	case ticketautomationrule.FieldLastExecutedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastExecutedAt(v)
		return nil
	case ticketautomationrule.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case ticketautomationrule.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ticketautomationrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticketautomationrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TicketAutomationRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketAutomationRuleMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, ticketautomationrule.FieldPriority)
	}
	if m.addexecution_count != nil {
		fields = append(fields, ticketautomationrule.FieldExecutionCount)
	}
	if m.addtenant_id != nil {
		fields = append(fields, ticketautomationrule.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketAutomationRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ticketautomationrule.FieldPriority:
		return m.AddedPriority()
	case ticketautomationrule.FieldExecutionCount:
		return m.AddedExecutionCount()
	case ticketautomationrule.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketAutomationRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ticketautomationrule.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case ticketautomationrule.FieldExecutionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutionCount(v)
		return nil
	case ticketautomationrule.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown TicketAutomationRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketAutomationRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticketautomationrule.FieldDescription) {
		fields = append(fields, ticketautomationrule.FieldDescription)
	}
	if m.FieldCleared(ticketautomationrule.FieldConditions) {
		fields = append(fields, ticketautomationrule.FieldConditions)
	}
	if m.FieldCleared(ticketautomationrule.FieldActions) {
		fields = append(fields, ticketautomationrule.FieldActions)
	}
	if m.FieldCleared(ticketautomationrule.FieldLastExecutedAt) {
		fields = append(fields, ticketautomationrule.FieldLastExecutedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketAutomationRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketAutomationRuleMutation) ClearField(name string) error {
	switch name {
	case ticketautomationrule.FieldDescription:
		m.ClearDescription()
		return nil
	case ticketautomationrule.FieldConditions:
		m.ClearConditions()
		return nil
	case ticketautomationrule.FieldActions:
		m.ClearActions()
		return nil
	case ticketautomationrule.FieldLastExecutedAt:
		m.ClearLastExecutedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketAutomationRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketAutomationRuleMutation) ResetField(name string) error {
	switch name {
	case ticketautomationrule.FieldName:
		m.ResetName()
		return nil
	case ticketautomationrule.FieldDescription:
		m.ResetDescription()
		return nil
	case ticketautomationrule.FieldPriority:
		m.ResetPriority()
		return nil
	case ticketautomationrule.FieldConditions:
		m.ResetConditions()
		return nil
	case ticketautomationrule.FieldActions:
		m.ResetActions()
		return nil
	case ticketautomationrule.FieldIsActive:
		m.ResetIsActive()
		return nil
	case ticketautomationrule.FieldExecutionCount:
		m.ResetExecutionCount()
		return nil
	case ticketautomationrule.FieldLastExecutedAt:
		m.ResetLastExecutedAt()
		return nil
	case ticketautomationrule.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case ticketautomationrule.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ticketautomationrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticketautomationrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketAutomationRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketAutomationRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.creator != nil {
		edges = append(edges, ticketautomationrule.EdgeCreator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketAutomationRuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticketautomationrule.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketAutomationRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketAutomationRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketAutomationRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcreator {
		edges = append(edges, ticketautomationrule.EdgeCreator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketAutomationRuleMutation) EdgeCleared(name string) bool {
	switch name {
	case ticketautomationrule.EdgeCreator:
		return m.clearedcreator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketAutomationRuleMutation) ClearEdge(name string) error {
	switch name {
	case ticketautomationrule.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown TicketAutomationRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketAutomationRuleMutation) ResetEdge(name string) error {
	switch name {
	case ticketautomationrule.EdgeCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown TicketAutomationRule edge %s", name)
}

// TicketCategoryMutation represents an operation that mutates the TicketCategory nodes in the graph.
type TicketCategoryMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	description       *string
	code              *string
	level             *int
	addlevel          *int
	sort_order        *int
	addsort_order     *int
	is_active         *bool
	tenant_id         *int
	addtenant_id      *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	tickets           map[int]struct{}
	removedtickets    map[int]struct{}
	clearedtickets    bool
	children          map[int]struct{}
	removedchildren   map[int]struct{}
	clearedchildren   bool
	parent            *int
	clearedparent     bool
	department        *int
	cleareddepartment bool
	workflow          *int
	clearedworkflow   bool
	done              bool
	oldValue          func(context.Context) (*TicketCategory, error)
	predicates        []predicate.TicketCategory
}

var _ ent.Mutation = (*TicketCategoryMutation)(nil)

// ticketcategoryOption allows management of the mutation configuration using functional options.
type ticketcategoryOption func(*TicketCategoryMutation)

// newTicketCategoryMutation creates new mutation for the TicketCategory entity.
func newTicketCategoryMutation(c config, op Op, opts ...ticketcategoryOption) *TicketCategoryMutation {
	m := &TicketCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTicketCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketCategoryID sets the ID field of the mutation.
func withTicketCategoryID(id int) ticketcategoryOption {
	return func(m *TicketCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TicketCategory
		)
		m.oldValue = func(ctx context.Context) (*TicketCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TicketCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicketCategory sets the old TicketCategory of the mutation.
func withTicketCategory(node *TicketCategory) ticketcategoryOption {
	return func(m *TicketCategoryMutation) {
		m.oldValue = func(context.Context) (*TicketCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TicketCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TicketCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TicketCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TicketCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TicketCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TicketCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TicketCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ticketcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TicketCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ticketcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TicketCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ticketcategory.FieldDescription)
}

// SetCode sets the "code" field.
func (m *TicketCategoryMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TicketCategoryMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TicketCategoryMutation) ResetCode() {
	m.code = nil
}

// SetParentID sets the "parent_id" field.
func (m *TicketCategoryMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *TicketCategoryMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *TicketCategoryMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[ticketcategory.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *TicketCategoryMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[ticketcategory.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *TicketCategoryMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, ticketcategory.FieldParentID)
}

// SetLevel sets the "level" field.
func (m *TicketCategoryMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *TicketCategoryMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *TicketCategoryMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *TicketCategoryMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *TicketCategoryMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *TicketCategoryMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *TicketCategoryMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *TicketCategoryMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *TicketCategoryMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *TicketCategoryMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetIsActive sets the "is_active" field.
func (m *TicketCategoryMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *TicketCategoryMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *TicketCategoryMutation) ResetIsActive() {
	m.is_active = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketCategoryMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketCategoryMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TicketCategoryMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TicketCategoryMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketCategoryMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetDepartmentID sets the "department_id" field.
func (m *TicketCategoryMutation) SetDepartmentID(i int) {
	m.department = &i
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *TicketCategoryMutation) DepartmentID() (r int, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldDepartmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ClearDepartmentID clears the value of the "department_id" field.
func (m *TicketCategoryMutation) ClearDepartmentID() {
	m.department = nil
	m.clearedFields[ticketcategory.FieldDepartmentID] = struct{}{}
}

// DepartmentIDCleared returns if the "department_id" field was cleared in this mutation.
func (m *TicketCategoryMutation) DepartmentIDCleared() bool {
	_, ok := m.clearedFields[ticketcategory.FieldDepartmentID]
	return ok
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *TicketCategoryMutation) ResetDepartmentID() {
	m.department = nil
	delete(m.clearedFields, ticketcategory.FieldDepartmentID)
}

// SetWorkflowID sets the "workflow_id" field.
func (m *TicketCategoryMutation) SetWorkflowID(i int) {
	m.workflow = &i
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *TicketCategoryMutation) WorkflowID() (r int, exists bool) {
	v := m.workflow
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldWorkflowID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ClearWorkflowID clears the value of the "workflow_id" field.
func (m *TicketCategoryMutation) ClearWorkflowID() {
	m.workflow = nil
	m.clearedFields[ticketcategory.FieldWorkflowID] = struct{}{}
}

// WorkflowIDCleared returns if the "workflow_id" field was cleared in this mutation.
func (m *TicketCategoryMutation) WorkflowIDCleared() bool {
	_, ok := m.clearedFields[ticketcategory.FieldWorkflowID]
	return ok
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *TicketCategoryMutation) ResetWorkflowID() {
	m.workflow = nil
	delete(m.clearedFields, ticketcategory.FieldWorkflowID)
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by ids.
func (m *TicketCategoryMutation) AddTicketIDs(ids ...int) {
	if m.tickets == nil {
		m.tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.tickets[ids[i]] = struct{}{}
	}
}

// ClearTickets clears the "tickets" edge to the Ticket entity.
func (m *TicketCategoryMutation) ClearTickets() {
	m.clearedtickets = true
}

// TicketsCleared reports if the "tickets" edge to the Ticket entity was cleared.
func (m *TicketCategoryMutation) TicketsCleared() bool {
	return m.clearedtickets
}

// RemoveTicketIDs removes the "tickets" edge to the Ticket entity by IDs.
func (m *TicketCategoryMutation) RemoveTicketIDs(ids ...int) {
	if m.removedtickets == nil {
		m.removedtickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tickets, ids[i])
		m.removedtickets[ids[i]] = struct{}{}
	}
}

// RemovedTickets returns the removed IDs of the "tickets" edge to the Ticket entity.
func (m *TicketCategoryMutation) RemovedTicketsIDs() (ids []int) {
	for id := range m.removedtickets {
		ids = append(ids, id)
	}
	return
}

// TicketsIDs returns the "tickets" edge IDs in the mutation.
func (m *TicketCategoryMutation) TicketsIDs() (ids []int) {
	for id := range m.tickets {
		ids = append(ids, id)
	}
	return
}

// ResetTickets resets all changes to the "tickets" edge.
func (m *TicketCategoryMutation) ResetTickets() {
	m.tickets = nil
	m.clearedtickets = false
	m.removedtickets = nil
}

// AddChildIDs adds the "children" edge to the TicketCategory entity by ids.
func (m *TicketCategoryMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the TicketCategory entity.
func (m *TicketCategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the TicketCategory entity was cleared.
func (m *TicketCategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the TicketCategory entity by IDs.
func (m *TicketCategoryMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the TicketCategory entity.
func (m *TicketCategoryMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TicketCategoryMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *TicketCategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// ClearParent clears the "parent" edge to the TicketCategory entity.
func (m *TicketCategoryMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[ticketcategory.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the TicketCategory entity was cleared.
func (m *TicketCategoryMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TicketCategoryMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *TicketCategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *TicketCategoryMutation) ClearDepartment() {
	m.cleareddepartment = true
	m.clearedFields[ticketcategory.FieldDepartmentID] = struct{}{}
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *TicketCategoryMutation) DepartmentCleared() bool {
	return m.DepartmentIDCleared() || m.cleareddepartment
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *TicketCategoryMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *TicketCategoryMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *TicketCategoryMutation) ClearWorkflow() {
	m.clearedworkflow = true
	m.clearedFields[ticketcategory.FieldWorkflowID] = struct{}{}
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *TicketCategoryMutation) WorkflowCleared() bool {
	return m.WorkflowIDCleared() || m.clearedworkflow
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *TicketCategoryMutation) WorkflowIDs() (ids []int) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *TicketCategoryMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// Where appends a list predicates to the TicketCategoryMutation builder.
func (m *TicketCategoryMutation) Where(ps ...predicate.TicketCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TicketCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TicketCategory).
func (m *TicketCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketCategoryMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, ticketcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, ticketcategory.FieldDescription)
	}
	if m.code != nil {
		fields = append(fields, ticketcategory.FieldCode)
	}
	if m.parent != nil {
		fields = append(fields, ticketcategory.FieldParentID)
	}
	if m.level != nil {
		fields = append(fields, ticketcategory.FieldLevel)
	}
	if m.sort_order != nil {
		fields = append(fields, ticketcategory.FieldSortOrder)
	}
	if m.is_active != nil {
		fields = append(fields, ticketcategory.FieldIsActive)
	}
	if m.tenant_id != nil {
		fields = append(fields, ticketcategory.FieldTenantID)
	}
	if m.department != nil {
		fields = append(fields, ticketcategory.FieldDepartmentID)
	}
	if m.workflow != nil {
		fields = append(fields, ticketcategory.FieldWorkflowID)
	}
	if m.created_at != nil {
		fields = append(fields, ticketcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ticketcategory.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticketcategory.FieldName:
		return m.Name()
	case ticketcategory.FieldDescription:
		return m.Description()
	case ticketcategory.FieldCode:
		return m.Code()
	case ticketcategory.FieldParentID:
		return m.ParentID()
	case ticketcategory.FieldLevel:
		return m.Level()
	case ticketcategory.FieldSortOrder:
		return m.SortOrder()
	case ticketcategory.FieldIsActive:
		return m.IsActive()
	case ticketcategory.FieldTenantID:
		return m.TenantID()
	case ticketcategory.FieldDepartmentID:
		return m.DepartmentID()
	case ticketcategory.FieldWorkflowID:
		return m.WorkflowID()
	case ticketcategory.FieldCreatedAt:
		return m.CreatedAt()
	case ticketcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticketcategory.FieldName:
		return m.OldName(ctx)
	case ticketcategory.FieldDescription:
		return m.OldDescription(ctx)
	case ticketcategory.FieldCode:
		return m.OldCode(ctx)
	case ticketcategory.FieldParentID:
		return m.OldParentID(ctx)
	case ticketcategory.FieldLevel:
		return m.OldLevel(ctx)
	case ticketcategory.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case ticketcategory.FieldIsActive:
		return m.OldIsActive(ctx)
	case ticketcategory.FieldTenantID:
		return m.OldTenantID(ctx)
	case ticketcategory.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case ticketcategory.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case ticketcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticketcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TicketCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticketcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ticketcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ticketcategory.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case ticketcategory.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case ticketcategory.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case ticketcategory.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case ticketcategory.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case ticketcategory.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ticketcategory.FieldDepartmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case ticketcategory.FieldWorkflowID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case ticketcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticketcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TicketCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, ticketcategory.FieldLevel)
	}
	if m.addsort_order != nil {
		fields = append(fields, ticketcategory.FieldSortOrder)
	}
	if m.addtenant_id != nil {
		fields = append(fields, ticketcategory.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ticketcategory.FieldLevel:
		return m.AddedLevel()
	case ticketcategory.FieldSortOrder:
		return m.AddedSortOrder()
	case ticketcategory.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ticketcategory.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case ticketcategory.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	case ticketcategory.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown TicketCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticketcategory.FieldDescription) {
		fields = append(fields, ticketcategory.FieldDescription)
	}
	if m.FieldCleared(ticketcategory.FieldParentID) {
		fields = append(fields, ticketcategory.FieldParentID)
	}
	if m.FieldCleared(ticketcategory.FieldDepartmentID) {
		fields = append(fields, ticketcategory.FieldDepartmentID)
	}
	if m.FieldCleared(ticketcategory.FieldWorkflowID) {
		fields = append(fields, ticketcategory.FieldWorkflowID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketCategoryMutation) ClearField(name string) error {
	switch name {
	case ticketcategory.FieldDescription:
		m.ClearDescription()
		return nil
	case ticketcategory.FieldParentID:
		m.ClearParentID()
		return nil
	case ticketcategory.FieldDepartmentID:
		m.ClearDepartmentID()
		return nil
	case ticketcategory.FieldWorkflowID:
		m.ClearWorkflowID()
		return nil
	}
	return fmt.Errorf("unknown TicketCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketCategoryMutation) ResetField(name string) error {
	switch name {
	case ticketcategory.FieldName:
		m.ResetName()
		return nil
	case ticketcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case ticketcategory.FieldCode:
		m.ResetCode()
		return nil
	case ticketcategory.FieldParentID:
		m.ResetParentID()
		return nil
	case ticketcategory.FieldLevel:
		m.ResetLevel()
		return nil
	case ticketcategory.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case ticketcategory.FieldIsActive:
		m.ResetIsActive()
		return nil
	case ticketcategory.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ticketcategory.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case ticketcategory.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case ticketcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticketcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tickets != nil {
		edges = append(edges, ticketcategory.EdgeTickets)
	}
	if m.children != nil {
		edges = append(edges, ticketcategory.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, ticketcategory.EdgeParent)
	}
	if m.department != nil {
		edges = append(edges, ticketcategory.EdgeDepartment)
	}
	if m.workflow != nil {
		edges = append(edges, ticketcategory.EdgeWorkflow)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticketcategory.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.tickets))
		for id := range m.tickets {
			ids = append(ids, id)
		}
		return ids
	case ticketcategory.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case ticketcategory.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case ticketcategory.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case ticketcategory.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtickets != nil {
		edges = append(edges, ticketcategory.EdgeTickets)
	}
	if m.removedchildren != nil {
		edges = append(edges, ticketcategory.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ticketcategory.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.removedtickets))
		for id := range m.removedtickets {
			ids = append(ids, id)
		}
		return ids
	case ticketcategory.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtickets {
		edges = append(edges, ticketcategory.EdgeTickets)
	}
	if m.clearedchildren {
		edges = append(edges, ticketcategory.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, ticketcategory.EdgeParent)
	}
	if m.cleareddepartment {
		edges = append(edges, ticketcategory.EdgeDepartment)
	}
	if m.clearedworkflow {
		edges = append(edges, ticketcategory.EdgeWorkflow)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case ticketcategory.EdgeTickets:
		return m.clearedtickets
	case ticketcategory.EdgeChildren:
		return m.clearedchildren
	case ticketcategory.EdgeParent:
		return m.clearedparent
	case ticketcategory.EdgeDepartment:
		return m.cleareddepartment
	case ticketcategory.EdgeWorkflow:
		return m.clearedworkflow
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketCategoryMutation) ClearEdge(name string) error {
	switch name {
	case ticketcategory.EdgeParent:
		m.ClearParent()
		return nil
	case ticketcategory.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case ticketcategory.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown TicketCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketCategoryMutation) ResetEdge(name string) error {
	switch name {
	case ticketcategory.EdgeTickets:
		m.ResetTickets()
		return nil
	case ticketcategory.EdgeChildren:
		m.ResetChildren()
		return nil
	case ticketcategory.EdgeParent:
		m.ResetParent()
		return nil
	case ticketcategory.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case ticketcategory.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	}
	return fmt.Errorf("unknown TicketCategory edge %s", name)
}

// TicketCommentMutation represents an operation that mutates the TicketComment nodes in the graph.
type TicketCommentMutation struct {
	config
	op                Op
	typ               string
	id                *int
	content           *string
	is_internal       *bool
	mentions          *[]int
	appendmentions    []int
	attachments       *[]int
	appendattachments []int
	tenant_id         *int
	addtenant_id      *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	ticket            *int
	clearedticket     bool
	user              *int
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*TicketComment, error)
	predicates        []predicate.TicketComment
}

var _ ent.Mutation = (*TicketCommentMutation)(nil)

// ticketcommentOption allows management of the mutation configuration using functional options.
type ticketcommentOption func(*TicketCommentMutation)

// newTicketCommentMutation creates new mutation for the TicketComment entity.
func newTicketCommentMutation(c config, op Op, opts ...ticketcommentOption) *TicketCommentMutation {
	m := &TicketCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeTicketComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketCommentID sets the ID field of the mutation.
func withTicketCommentID(id int) ticketcommentOption {
	return func(m *TicketCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *TicketComment
		)
		m.oldValue = func(ctx context.Context) (*TicketComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TicketComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicketComment sets the old TicketComment of the mutation.
func withTicketComment(node *TicketComment) ticketcommentOption {
	return func(m *TicketCommentMutation) {
		m.oldValue = func(context.Context) (*TicketComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketCommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketCommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TicketComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTicketID sets the "ticket_id" field.
func (m *TicketCommentMutation) SetTicketID(i int) {
	m.ticket = &i
}

// TicketID returns the value of the "ticket_id" field in the mutation.
func (m *TicketCommentMutation) TicketID() (r int, exists bool) {
	v := m.ticket
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketID returns the old "ticket_id" field's value of the TicketComment entity.
// If the TicketComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCommentMutation) OldTicketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketID: %w", err)
	}
	return oldValue.TicketID, nil
}

// ResetTicketID resets all changes to the "ticket_id" field.
func (m *TicketCommentMutation) ResetTicketID() {
	m.ticket = nil
}

// SetUserID sets the "user_id" field.
func (m *TicketCommentMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TicketCommentMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TicketComment entity.
// If the TicketComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCommentMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TicketCommentMutation) ResetUserID() {
	m.user = nil
}

// SetContent sets the "content" field.
func (m *TicketCommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *TicketCommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the TicketComment entity.
// If the TicketComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *TicketCommentMutation) ResetContent() {
	m.content = nil
}

// SetIsInternal sets the "is_internal" field.
func (m *TicketCommentMutation) SetIsInternal(b bool) {
	m.is_internal = &b
}

// IsInternal returns the value of the "is_internal" field in the mutation.
func (m *TicketCommentMutation) IsInternal() (r bool, exists bool) {
	v := m.is_internal
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInternal returns the old "is_internal" field's value of the TicketComment entity.
// If the TicketComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCommentMutation) OldIsInternal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsInternal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsInternal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInternal: %w", err)
	}
	return oldValue.IsInternal, nil
}

// ResetIsInternal resets all changes to the "is_internal" field.
func (m *TicketCommentMutation) ResetIsInternal() {
	m.is_internal = nil
}

// SetMentions sets the "mentions" field.
func (m *TicketCommentMutation) SetMentions(i []int) {
	m.mentions = &i
	m.appendmentions = nil
}

// Mentions returns the value of the "mentions" field in the mutation.
func (m *TicketCommentMutation) Mentions() (r []int, exists bool) {
	v := m.mentions
	if v == nil {
		return
	}
	return *v, true
}

// OldMentions returns the old "mentions" field's value of the TicketComment entity.
// If the TicketComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCommentMutation) OldMentions(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMentions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMentions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMentions: %w", err)
	}
	return oldValue.Mentions, nil
}

// AppendMentions adds i to the "mentions" field.
func (m *TicketCommentMutation) AppendMentions(i []int) {
	m.appendmentions = append(m.appendmentions, i...)
}

// AppendedMentions returns the list of values that were appended to the "mentions" field in this mutation.
func (m *TicketCommentMutation) AppendedMentions() ([]int, bool) {
	if len(m.appendmentions) == 0 {
		return nil, false
	}
	return m.appendmentions, true
}

// ClearMentions clears the value of the "mentions" field.
func (m *TicketCommentMutation) ClearMentions() {
	m.mentions = nil
	m.appendmentions = nil
	m.clearedFields[ticketcomment.FieldMentions] = struct{}{}
}

// MentionsCleared returns if the "mentions" field was cleared in this mutation.
func (m *TicketCommentMutation) MentionsCleared() bool {
	_, ok := m.clearedFields[ticketcomment.FieldMentions]
	return ok
}

// ResetMentions resets all changes to the "mentions" field.
func (m *TicketCommentMutation) ResetMentions() {
	m.mentions = nil
	m.appendmentions = nil
	delete(m.clearedFields, ticketcomment.FieldMentions)
}

// SetAttachments sets the "attachments" field.
func (m *TicketCommentMutation) SetAttachments(i []int) {
	m.attachments = &i
	m.appendattachments = nil
}

// Attachments returns the value of the "attachments" field in the mutation.
func (m *TicketCommentMutation) Attachments() (r []int, exists bool) {
	v := m.attachments
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachments returns the old "attachments" field's value of the TicketComment entity.
// If the TicketComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCommentMutation) OldAttachments(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachments: %w", err)
	}
	return oldValue.Attachments, nil
}

// AppendAttachments adds i to the "attachments" field.
func (m *TicketCommentMutation) AppendAttachments(i []int) {
	m.appendattachments = append(m.appendattachments, i...)
}

// AppendedAttachments returns the list of values that were appended to the "attachments" field in this mutation.
func (m *TicketCommentMutation) AppendedAttachments() ([]int, bool) {
	if len(m.appendattachments) == 0 {
		return nil, false
	}
	return m.appendattachments, true
}

// ClearAttachments clears the value of the "attachments" field.
func (m *TicketCommentMutation) ClearAttachments() {
	m.attachments = nil
	m.appendattachments = nil
	m.clearedFields[ticketcomment.FieldAttachments] = struct{}{}
}

// AttachmentsCleared returns if the "attachments" field was cleared in this mutation.
func (m *TicketCommentMutation) AttachmentsCleared() bool {
	_, ok := m.clearedFields[ticketcomment.FieldAttachments]
	return ok
}

// ResetAttachments resets all changes to the "attachments" field.
func (m *TicketCommentMutation) ResetAttachments() {
	m.attachments = nil
	m.appendattachments = nil
	delete(m.clearedFields, ticketcomment.FieldAttachments)
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketCommentMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketCommentMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TicketComment entity.
// If the TicketComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCommentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TicketCommentMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TicketCommentMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketCommentMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketCommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketCommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TicketComment entity.
// If the TicketComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketCommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketCommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketCommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TicketComment entity.
// If the TicketComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketCommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTicket clears the "ticket" edge to the Ticket entity.
func (m *TicketCommentMutation) ClearTicket() {
	m.clearedticket = true
	m.clearedFields[ticketcomment.FieldTicketID] = struct{}{}
}

// TicketCleared reports if the "ticket" edge to the Ticket entity was cleared.
func (m *TicketCommentMutation) TicketCleared() bool {
	return m.clearedticket
}

// TicketIDs returns the "ticket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TicketID instead. It exists only for internal usage by the builders.
func (m *TicketCommentMutation) TicketIDs() (ids []int) {
	if id := m.ticket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicket resets all changes to the "ticket" edge.
func (m *TicketCommentMutation) ResetTicket() {
	m.ticket = nil
	m.clearedticket = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *TicketCommentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[ticketcomment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TicketCommentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TicketCommentMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TicketCommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TicketCommentMutation builder.
func (m *TicketCommentMutation) Where(ps ...predicate.TicketComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TicketComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TicketComment).
func (m *TicketCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketCommentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.ticket != nil {
		fields = append(fields, ticketcomment.FieldTicketID)
	}
	if m.user != nil {
		fields = append(fields, ticketcomment.FieldUserID)
	}
	if m.content != nil {
		fields = append(fields, ticketcomment.FieldContent)
	}
	if m.is_internal != nil {
		fields = append(fields, ticketcomment.FieldIsInternal)
	}
	if m.mentions != nil {
		fields = append(fields, ticketcomment.FieldMentions)
	}
	if m.attachments != nil {
		fields = append(fields, ticketcomment.FieldAttachments)
	}
	if m.tenant_id != nil {
		fields = append(fields, ticketcomment.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, ticketcomment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ticketcomment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticketcomment.FieldTicketID:
		return m.TicketID()
	case ticketcomment.FieldUserID:
		return m.UserID()
	case ticketcomment.FieldContent:
		return m.Content()
	case ticketcomment.FieldIsInternal:
		return m.IsInternal()
	case ticketcomment.FieldMentions:
		return m.Mentions()
	case ticketcomment.FieldAttachments:
		return m.Attachments()
	case ticketcomment.FieldTenantID:
		return m.TenantID()
	case ticketcomment.FieldCreatedAt:
		return m.CreatedAt()
	case ticketcomment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticketcomment.FieldTicketID:
		return m.OldTicketID(ctx)
	case ticketcomment.FieldUserID:
		return m.OldUserID(ctx)
	case ticketcomment.FieldContent:
		return m.OldContent(ctx)
	case ticketcomment.FieldIsInternal:
		return m.OldIsInternal(ctx)
	case ticketcomment.FieldMentions:
		return m.OldMentions(ctx)
	case ticketcomment.FieldAttachments:
		return m.OldAttachments(ctx)
	case ticketcomment.FieldTenantID:
		return m.OldTenantID(ctx)
	case ticketcomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticketcomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TicketComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticketcomment.FieldTicketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketID(v)
		return nil
	case ticketcomment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case ticketcomment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case ticketcomment.FieldIsInternal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInternal(v)
		return nil
	case ticketcomment.FieldMentions:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMentions(v)
		return nil
	case ticketcomment.FieldAttachments:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachments(v)
		return nil
	case ticketcomment.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ticketcomment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticketcomment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TicketComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketCommentMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, ticketcomment.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketCommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ticketcomment.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ticketcomment.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown TicketComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketCommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticketcomment.FieldMentions) {
		fields = append(fields, ticketcomment.FieldMentions)
	}
	if m.FieldCleared(ticketcomment.FieldAttachments) {
		fields = append(fields, ticketcomment.FieldAttachments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketCommentMutation) ClearField(name string) error {
	switch name {
	case ticketcomment.FieldMentions:
		m.ClearMentions()
		return nil
	case ticketcomment.FieldAttachments:
		m.ClearAttachments()
		return nil
	}
	return fmt.Errorf("unknown TicketComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketCommentMutation) ResetField(name string) error {
	switch name {
	case ticketcomment.FieldTicketID:
		m.ResetTicketID()
		return nil
	case ticketcomment.FieldUserID:
		m.ResetUserID()
		return nil
	case ticketcomment.FieldContent:
		m.ResetContent()
		return nil
	case ticketcomment.FieldIsInternal:
		m.ResetIsInternal()
		return nil
	case ticketcomment.FieldMentions:
		m.ResetMentions()
		return nil
	case ticketcomment.FieldAttachments:
		m.ResetAttachments()
		return nil
	case ticketcomment.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ticketcomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticketcomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.ticket != nil {
		edges = append(edges, ticketcomment.EdgeTicket)
	}
	if m.user != nil {
		edges = append(edges, ticketcomment.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketCommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticketcomment.EdgeTicket:
		if id := m.ticket; id != nil {
			return []ent.Value{*id}
		}
	case ticketcomment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketCommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedticket {
		edges = append(edges, ticketcomment.EdgeTicket)
	}
	if m.cleareduser {
		edges = append(edges, ticketcomment.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketCommentMutation) EdgeCleared(name string) bool {
	switch name {
	case ticketcomment.EdgeTicket:
		return m.clearedticket
	case ticketcomment.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketCommentMutation) ClearEdge(name string) error {
	switch name {
	case ticketcomment.EdgeTicket:
		m.ClearTicket()
		return nil
	case ticketcomment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TicketComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketCommentMutation) ResetEdge(name string) error {
	switch name {
	case ticketcomment.EdgeTicket:
		m.ResetTicket()
		return nil
	case ticketcomment.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown TicketComment edge %s", name)
}

// TicketNotificationMutation represents an operation that mutates the TicketNotification nodes in the graph.
type TicketNotificationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_type         *string
	channel       *string
	content       *string
	sent_at       *time.Time
	read_at       *time.Time
	status        *string
	tenant_id     *int
	addtenant_id  *int
	created_at    *time.Time
	clearedFields map[string]struct{}
	ticket        *int
	clearedticket bool
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*TicketNotification, error)
	predicates    []predicate.TicketNotification
}

var _ ent.Mutation = (*TicketNotificationMutation)(nil)

// ticketnotificationOption allows management of the mutation configuration using functional options.
type ticketnotificationOption func(*TicketNotificationMutation)

// newTicketNotificationMutation creates new mutation for the TicketNotification entity.
func newTicketNotificationMutation(c config, op Op, opts ...ticketnotificationOption) *TicketNotificationMutation {
	m := &TicketNotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeTicketNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketNotificationID sets the ID field of the mutation.
func withTicketNotificationID(id int) ticketnotificationOption {
	return func(m *TicketNotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *TicketNotification
		)
		m.oldValue = func(ctx context.Context) (*TicketNotification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TicketNotification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicketNotification sets the old TicketNotification of the mutation.
func withTicketNotification(node *TicketNotification) ticketnotificationOption {
	return func(m *TicketNotificationMutation) {
		m.oldValue = func(context.Context) (*TicketNotification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketNotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketNotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketNotificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketNotificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TicketNotification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTicketID sets the "ticket_id" field.
func (m *TicketNotificationMutation) SetTicketID(i int) {
	m.ticket = &i
}

// TicketID returns the value of the "ticket_id" field in the mutation.
func (m *TicketNotificationMutation) TicketID() (r int, exists bool) {
	v := m.ticket
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketID returns the old "ticket_id" field's value of the TicketNotification entity.
// If the TicketNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketNotificationMutation) OldTicketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketID: %w", err)
	}
	return oldValue.TicketID, nil
}

// ResetTicketID resets all changes to the "ticket_id" field.
func (m *TicketNotificationMutation) ResetTicketID() {
	m.ticket = nil
}

// SetUserID sets the "user_id" field.
func (m *TicketNotificationMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TicketNotificationMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TicketNotification entity.
// If the TicketNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketNotificationMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TicketNotificationMutation) ResetUserID() {
	m.user = nil
}

// SetType sets the "type" field.
func (m *TicketNotificationMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TicketNotificationMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the TicketNotification entity.
// If the TicketNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketNotificationMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TicketNotificationMutation) ResetType() {
	m._type = nil
}

// SetChannel sets the "channel" field.
func (m *TicketNotificationMutation) SetChannel(s string) {
	m.channel = &s
}

// Channel returns the value of the "channel" field in the mutation.
func (m *TicketNotificationMutation) Channel() (r string, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the TicketNotification entity.
// If the TicketNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketNotificationMutation) OldChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *TicketNotificationMutation) ResetChannel() {
	m.channel = nil
}

// SetContent sets the "content" field.
func (m *TicketNotificationMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *TicketNotificationMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the TicketNotification entity.
// If the TicketNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketNotificationMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *TicketNotificationMutation) ResetContent() {
	m.content = nil
}

// SetSentAt sets the "sent_at" field.
func (m *TicketNotificationMutation) SetSentAt(t time.Time) {
	m.sent_at = &t
}

// SentAt returns the value of the "sent_at" field in the mutation.
func (m *TicketNotificationMutation) SentAt() (r time.Time, exists bool) {
	v := m.sent_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSentAt returns the old "sent_at" field's value of the TicketNotification entity.
// If the TicketNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketNotificationMutation) OldSentAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentAt: %w", err)
	}
	return oldValue.SentAt, nil
}

// ClearSentAt clears the value of the "sent_at" field.
func (m *TicketNotificationMutation) ClearSentAt() {
	m.sent_at = nil
	m.clearedFields[ticketnotification.FieldSentAt] = struct{}{}
}

// SentAtCleared returns if the "sent_at" field was cleared in this mutation.
func (m *TicketNotificationMutation) SentAtCleared() bool {
	_, ok := m.clearedFields[ticketnotification.FieldSentAt]
	return ok
}

// ResetSentAt resets all changes to the "sent_at" field.
func (m *TicketNotificationMutation) ResetSentAt() {
	m.sent_at = nil
	delete(m.clearedFields, ticketnotification.FieldSentAt)
}

// SetReadAt sets the "read_at" field.
func (m *TicketNotificationMutation) SetReadAt(t time.Time) {
	m.read_at = &t
}

// ReadAt returns the value of the "read_at" field in the mutation.
func (m *TicketNotificationMutation) ReadAt() (r time.Time, exists bool) {
	v := m.read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReadAt returns the old "read_at" field's value of the TicketNotification entity.
// If the TicketNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketNotificationMutation) OldReadAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadAt: %w", err)
	}
	return oldValue.ReadAt, nil
}

// ClearReadAt clears the value of the "read_at" field.
func (m *TicketNotificationMutation) ClearReadAt() {
	m.read_at = nil
	m.clearedFields[ticketnotification.FieldReadAt] = struct{}{}
}

// ReadAtCleared returns if the "read_at" field was cleared in this mutation.
func (m *TicketNotificationMutation) ReadAtCleared() bool {
	_, ok := m.clearedFields[ticketnotification.FieldReadAt]
	return ok
}

// ResetReadAt resets all changes to the "read_at" field.
func (m *TicketNotificationMutation) ResetReadAt() {
	m.read_at = nil
	delete(m.clearedFields, ticketnotification.FieldReadAt)
}

// SetStatus sets the "status" field.
func (m *TicketNotificationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TicketNotificationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TicketNotification entity.
// If the TicketNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketNotificationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TicketNotificationMutation) ResetStatus() {
	m.status = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketNotificationMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketNotificationMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TicketNotification entity.
// If the TicketNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketNotificationMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TicketNotificationMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TicketNotificationMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketNotificationMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketNotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketNotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TicketNotification entity.
// If the TicketNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketNotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketNotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTicket clears the "ticket" edge to the Ticket entity.
func (m *TicketNotificationMutation) ClearTicket() {
	m.clearedticket = true
	m.clearedFields[ticketnotification.FieldTicketID] = struct{}{}
}

// TicketCleared reports if the "ticket" edge to the Ticket entity was cleared.
func (m *TicketNotificationMutation) TicketCleared() bool {
	return m.clearedticket
}

// TicketIDs returns the "ticket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TicketID instead. It exists only for internal usage by the builders.
func (m *TicketNotificationMutation) TicketIDs() (ids []int) {
	if id := m.ticket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicket resets all changes to the "ticket" edge.
func (m *TicketNotificationMutation) ResetTicket() {
	m.ticket = nil
	m.clearedticket = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *TicketNotificationMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[ticketnotification.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TicketNotificationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TicketNotificationMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TicketNotificationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TicketNotificationMutation builder.
func (m *TicketNotificationMutation) Where(ps ...predicate.TicketNotification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketNotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketNotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TicketNotification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketNotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketNotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TicketNotification).
func (m *TicketNotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketNotificationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.ticket != nil {
		fields = append(fields, ticketnotification.FieldTicketID)
	}
	if m.user != nil {
		fields = append(fields, ticketnotification.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, ticketnotification.FieldType)
	}
	if m.channel != nil {
		fields = append(fields, ticketnotification.FieldChannel)
	}
	if m.content != nil {
		fields = append(fields, ticketnotification.FieldContent)
	}
	if m.sent_at != nil {
		fields = append(fields, ticketnotification.FieldSentAt)
	}
	if m.read_at != nil {
		fields = append(fields, ticketnotification.FieldReadAt)
	}
	if m.status != nil {
		fields = append(fields, ticketnotification.FieldStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, ticketnotification.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, ticketnotification.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketNotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticketnotification.FieldTicketID:
		return m.TicketID()
	case ticketnotification.FieldUserID:
		return m.UserID()
	case ticketnotification.FieldType:
		return m.GetType()
	case ticketnotification.FieldChannel:
		return m.Channel()
	case ticketnotification.FieldContent:
		return m.Content()
	case ticketnotification.FieldSentAt:
		return m.SentAt()
	case ticketnotification.FieldReadAt:
		return m.ReadAt()
	case ticketnotification.FieldStatus:
		return m.Status()
	case ticketnotification.FieldTenantID:
		return m.TenantID()
	case ticketnotification.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketNotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticketnotification.FieldTicketID:
		return m.OldTicketID(ctx)
	case ticketnotification.FieldUserID:
		return m.OldUserID(ctx)
	case ticketnotification.FieldType:
		return m.OldType(ctx)
	case ticketnotification.FieldChannel:
		return m.OldChannel(ctx)
	case ticketnotification.FieldContent:
		return m.OldContent(ctx)
	case ticketnotification.FieldSentAt:
		return m.OldSentAt(ctx)
	case ticketnotification.FieldReadAt:
		return m.OldReadAt(ctx)
	case ticketnotification.FieldStatus:
		return m.OldStatus(ctx)
	case ticketnotification.FieldTenantID:
		return m.OldTenantID(ctx)
	case ticketnotification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TicketNotification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketNotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticketnotification.FieldTicketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketID(v)
		return nil
	case ticketnotification.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case ticketnotification.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case ticketnotification.FieldChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case ticketnotification.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case ticketnotification.FieldSentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentAt(v)
		return nil
	case ticketnotification.FieldReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadAt(v)
		return nil
	case ticketnotification.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ticketnotification.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ticketnotification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TicketNotification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketNotificationMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, ticketnotification.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketNotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ticketnotification.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketNotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ticketnotification.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown TicketNotification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketNotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticketnotification.FieldSentAt) {
		fields = append(fields, ticketnotification.FieldSentAt)
	}
	if m.FieldCleared(ticketnotification.FieldReadAt) {
		fields = append(fields, ticketnotification.FieldReadAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketNotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketNotificationMutation) ClearField(name string) error {
	switch name {
	case ticketnotification.FieldSentAt:
		m.ClearSentAt()
		return nil
	case ticketnotification.FieldReadAt:
		m.ClearReadAt()
		return nil
	}
	return fmt.Errorf("unknown TicketNotification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketNotificationMutation) ResetField(name string) error {
	switch name {
	case ticketnotification.FieldTicketID:
		m.ResetTicketID()
		return nil
	case ticketnotification.FieldUserID:
		m.ResetUserID()
		return nil
	case ticketnotification.FieldType:
		m.ResetType()
		return nil
	case ticketnotification.FieldChannel:
		m.ResetChannel()
		return nil
	case ticketnotification.FieldContent:
		m.ResetContent()
		return nil
	case ticketnotification.FieldSentAt:
		m.ResetSentAt()
		return nil
	case ticketnotification.FieldReadAt:
		m.ResetReadAt()
		return nil
	case ticketnotification.FieldStatus:
		m.ResetStatus()
		return nil
	case ticketnotification.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ticketnotification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketNotification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketNotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.ticket != nil {
		edges = append(edges, ticketnotification.EdgeTicket)
	}
	if m.user != nil {
		edges = append(edges, ticketnotification.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketNotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticketnotification.EdgeTicket:
		if id := m.ticket; id != nil {
			return []ent.Value{*id}
		}
	case ticketnotification.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketNotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketNotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketNotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedticket {
		edges = append(edges, ticketnotification.EdgeTicket)
	}
	if m.cleareduser {
		edges = append(edges, ticketnotification.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketNotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case ticketnotification.EdgeTicket:
		return m.clearedticket
	case ticketnotification.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketNotificationMutation) ClearEdge(name string) error {
	switch name {
	case ticketnotification.EdgeTicket:
		m.ClearTicket()
		return nil
	case ticketnotification.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TicketNotification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketNotificationMutation) ResetEdge(name string) error {
	switch name {
	case ticketnotification.EdgeTicket:
		m.ResetTicket()
		return nil
	case ticketnotification.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown TicketNotification edge %s", name)
}

// TicketTagMutation represents an operation that mutates the TicketTag nodes in the graph.
type TicketTagMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	color          *string
	description    *string
	is_active      *bool
	tenant_id      *int
	addtenant_id   *int
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	tickets        map[int]struct{}
	removedtickets map[int]struct{}
	clearedtickets bool
	done           bool
	oldValue       func(context.Context) (*TicketTag, error)
	predicates     []predicate.TicketTag
}

var _ ent.Mutation = (*TicketTagMutation)(nil)

// tickettagOption allows management of the mutation configuration using functional options.
type tickettagOption func(*TicketTagMutation)

// newTicketTagMutation creates new mutation for the TicketTag entity.
func newTicketTagMutation(c config, op Op, opts ...tickettagOption) *TicketTagMutation {
	m := &TicketTagMutation{
		config:        c,
		op:            op,
		typ:           TypeTicketTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketTagID sets the ID field of the mutation.
func withTicketTagID(id int) tickettagOption {
	return func(m *TicketTagMutation) {
		var (
			err   error
			once  sync.Once
			value *TicketTag
		)
		m.oldValue = func(ctx context.Context) (*TicketTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TicketTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicketTag sets the old TicketTag of the mutation.
func withTicketTag(node *TicketTag) tickettagOption {
	return func(m *TicketTagMutation) {
		m.oldValue = func(context.Context) (*TicketTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketTagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketTagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TicketTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TicketTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TicketTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TicketTag entity.
// If the TicketTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TicketTagMutation) ResetName() {
	m.name = nil
}

// SetColor sets the "color" field.
func (m *TicketTagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *TicketTagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the TicketTag entity.
// If the TicketTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *TicketTagMutation) ResetColor() {
	m.color = nil
}

// SetDescription sets the "description" field.
func (m *TicketTagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TicketTagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TicketTag entity.
// If the TicketTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TicketTagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tickettag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TicketTagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tickettag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TicketTagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tickettag.FieldDescription)
}

// SetIsActive sets the "is_active" field.
func (m *TicketTagMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *TicketTagMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the TicketTag entity.
// If the TicketTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTagMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *TicketTagMutation) ResetIsActive() {
	m.is_active = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketTagMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketTagMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TicketTag entity.
// If the TicketTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTagMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TicketTagMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TicketTagMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketTagMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TicketTag entity.
// If the TicketTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TicketTag entity.
// If the TicketTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by ids.
func (m *TicketTagMutation) AddTicketIDs(ids ...int) {
	if m.tickets == nil {
		m.tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.tickets[ids[i]] = struct{}{}
	}
}

// ClearTickets clears the "tickets" edge to the Ticket entity.
func (m *TicketTagMutation) ClearTickets() {
	m.clearedtickets = true
}

// TicketsCleared reports if the "tickets" edge to the Ticket entity was cleared.
func (m *TicketTagMutation) TicketsCleared() bool {
	return m.clearedtickets
}

// RemoveTicketIDs removes the "tickets" edge to the Ticket entity by IDs.
func (m *TicketTagMutation) RemoveTicketIDs(ids ...int) {
	if m.removedtickets == nil {
		m.removedtickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tickets, ids[i])
		m.removedtickets[ids[i]] = struct{}{}
	}
}

// RemovedTickets returns the removed IDs of the "tickets" edge to the Ticket entity.
func (m *TicketTagMutation) RemovedTicketsIDs() (ids []int) {
	for id := range m.removedtickets {
		ids = append(ids, id)
	}
	return
}

// TicketsIDs returns the "tickets" edge IDs in the mutation.
func (m *TicketTagMutation) TicketsIDs() (ids []int) {
	for id := range m.tickets {
		ids = append(ids, id)
	}
	return
}

// ResetTickets resets all changes to the "tickets" edge.
func (m *TicketTagMutation) ResetTickets() {
	m.tickets = nil
	m.clearedtickets = false
	m.removedtickets = nil
}

// Where appends a list predicates to the TicketTagMutation builder.
func (m *TicketTagMutation) Where(ps ...predicate.TicketTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TicketTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TicketTag).
func (m *TicketTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketTagMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, tickettag.FieldName)
	}
	if m.color != nil {
		fields = append(fields, tickettag.FieldColor)
	}
	if m.description != nil {
		fields = append(fields, tickettag.FieldDescription)
	}
	if m.is_active != nil {
		fields = append(fields, tickettag.FieldIsActive)
	}
	if m.tenant_id != nil {
		fields = append(fields, tickettag.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, tickettag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tickettag.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tickettag.FieldName:
		return m.Name()
	case tickettag.FieldColor:
		return m.Color()
	case tickettag.FieldDescription:
		return m.Description()
	case tickettag.FieldIsActive:
		return m.IsActive()
	case tickettag.FieldTenantID:
		return m.TenantID()
	case tickettag.FieldCreatedAt:
		return m.CreatedAt()
	case tickettag.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tickettag.FieldName:
		return m.OldName(ctx)
	case tickettag.FieldColor:
		return m.OldColor(ctx)
	case tickettag.FieldDescription:
		return m.OldDescription(ctx)
	case tickettag.FieldIsActive:
		return m.OldIsActive(ctx)
	case tickettag.FieldTenantID:
		return m.OldTenantID(ctx)
	case tickettag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tickettag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TicketTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tickettag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tickettag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case tickettag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tickettag.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case tickettag.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case tickettag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tickettag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TicketTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketTagMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, tickettag.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tickettag.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tickettag.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown TicketTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tickettag.FieldDescription) {
		fields = append(fields, tickettag.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketTagMutation) ClearField(name string) error {
	switch name {
	case tickettag.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown TicketTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketTagMutation) ResetField(name string) error {
	switch name {
	case tickettag.FieldName:
		m.ResetName()
		return nil
	case tickettag.FieldColor:
		m.ResetColor()
		return nil
	case tickettag.FieldDescription:
		m.ResetDescription()
		return nil
	case tickettag.FieldIsActive:
		m.ResetIsActive()
		return nil
	case tickettag.FieldTenantID:
		m.ResetTenantID()
		return nil
	case tickettag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tickettag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tickets != nil {
		edges = append(edges, tickettag.EdgeTickets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tickettag.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.tickets))
		for id := range m.tickets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtickets != nil {
		edges = append(edges, tickettag.EdgeTickets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tickettag.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.removedtickets))
		for id := range m.removedtickets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtickets {
		edges = append(edges, tickettag.EdgeTickets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketTagMutation) EdgeCleared(name string) bool {
	switch name {
	case tickettag.EdgeTickets:
		return m.clearedtickets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TicketTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketTagMutation) ResetEdge(name string) error {
	switch name {
	case tickettag.EdgeTickets:
		m.ResetTickets()
		return nil
	}
	return fmt.Errorf("unknown TicketTag edge %s", name)
}

// TicketTemplateMutation represents an operation that mutates the TicketTemplate nodes in the graph.
type TicketTemplateMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	description          *string
	category             *string
	priority             *string
	form_fields          *[]uint8
	appendform_fields    []uint8
	workflow_steps       *[]uint8
	appendworkflow_steps []uint8
	is_active            *bool
	tenant_id            *int
	addtenant_id         *int
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	tickets              map[int]struct{}
	removedtickets       map[int]struct{}
	clearedtickets       bool
	done                 bool
	oldValue             func(context.Context) (*TicketTemplate, error)
	predicates           []predicate.TicketTemplate
}

var _ ent.Mutation = (*TicketTemplateMutation)(nil)

// tickettemplateOption allows management of the mutation configuration using functional options.
type tickettemplateOption func(*TicketTemplateMutation)

// newTicketTemplateMutation creates new mutation for the TicketTemplate entity.
func newTicketTemplateMutation(c config, op Op, opts ...tickettemplateOption) *TicketTemplateMutation {
	m := &TicketTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeTicketTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketTemplateID sets the ID field of the mutation.
func withTicketTemplateID(id int) tickettemplateOption {
	return func(m *TicketTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *TicketTemplate
		)
		m.oldValue = func(ctx context.Context) (*TicketTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TicketTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicketTemplate sets the old TicketTemplate of the mutation.
func withTicketTemplate(node *TicketTemplate) tickettemplateOption {
	return func(m *TicketTemplateMutation) {
		m.oldValue = func(context.Context) (*TicketTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketTemplateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketTemplateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TicketTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TicketTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TicketTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TicketTemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TicketTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TicketTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TicketTemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tickettemplate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TicketTemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tickettemplate.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TicketTemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tickettemplate.FieldDescription)
}

// SetCategory sets the "category" field.
func (m *TicketTemplateMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *TicketTemplateMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *TicketTemplateMutation) ResetCategory() {
	m.category = nil
}

// SetPriority sets the "priority" field.
func (m *TicketTemplateMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TicketTemplateMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *TicketTemplateMutation) ResetPriority() {
	m.priority = nil
}

// SetFormFields sets the "form_fields" field.
func (m *TicketTemplateMutation) SetFormFields(u []uint8) {
	m.form_fields = &u
	m.appendform_fields = nil
}

// FormFields returns the value of the "form_fields" field in the mutation.
func (m *TicketTemplateMutation) FormFields() (r []uint8, exists bool) {
	v := m.form_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldFormFields returns the old "form_fields" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldFormFields(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormFields: %w", err)
	}
	return oldValue.FormFields, nil
}

// AppendFormFields adds u to the "form_fields" field.
func (m *TicketTemplateMutation) AppendFormFields(u []uint8) {
	m.appendform_fields = append(m.appendform_fields, u...)
}

// AppendedFormFields returns the list of values that were appended to the "form_fields" field in this mutation.
func (m *TicketTemplateMutation) AppendedFormFields() ([]uint8, bool) {
	if len(m.appendform_fields) == 0 {
		return nil, false
	}
	return m.appendform_fields, true
}

// ClearFormFields clears the value of the "form_fields" field.
func (m *TicketTemplateMutation) ClearFormFields() {
	m.form_fields = nil
	m.appendform_fields = nil
	m.clearedFields[tickettemplate.FieldFormFields] = struct{}{}
}

// FormFieldsCleared returns if the "form_fields" field was cleared in this mutation.
func (m *TicketTemplateMutation) FormFieldsCleared() bool {
	_, ok := m.clearedFields[tickettemplate.FieldFormFields]
	return ok
}

// ResetFormFields resets all changes to the "form_fields" field.
func (m *TicketTemplateMutation) ResetFormFields() {
	m.form_fields = nil
	m.appendform_fields = nil
	delete(m.clearedFields, tickettemplate.FieldFormFields)
}

// SetWorkflowSteps sets the "workflow_steps" field.
func (m *TicketTemplateMutation) SetWorkflowSteps(u []uint8) {
	m.workflow_steps = &u
	m.appendworkflow_steps = nil
}

// WorkflowSteps returns the value of the "workflow_steps" field in the mutation.
func (m *TicketTemplateMutation) WorkflowSteps() (r []uint8, exists bool) {
	v := m.workflow_steps
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowSteps returns the old "workflow_steps" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldWorkflowSteps(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowSteps: %w", err)
	}
	return oldValue.WorkflowSteps, nil
}

// AppendWorkflowSteps adds u to the "workflow_steps" field.
func (m *TicketTemplateMutation) AppendWorkflowSteps(u []uint8) {
	m.appendworkflow_steps = append(m.appendworkflow_steps, u...)
}

// AppendedWorkflowSteps returns the list of values that were appended to the "workflow_steps" field in this mutation.
func (m *TicketTemplateMutation) AppendedWorkflowSteps() ([]uint8, bool) {
	if len(m.appendworkflow_steps) == 0 {
		return nil, false
	}
	return m.appendworkflow_steps, true
}

// ClearWorkflowSteps clears the value of the "workflow_steps" field.
func (m *TicketTemplateMutation) ClearWorkflowSteps() {
	m.workflow_steps = nil
	m.appendworkflow_steps = nil
	m.clearedFields[tickettemplate.FieldWorkflowSteps] = struct{}{}
}

// WorkflowStepsCleared returns if the "workflow_steps" field was cleared in this mutation.
func (m *TicketTemplateMutation) WorkflowStepsCleared() bool {
	_, ok := m.clearedFields[tickettemplate.FieldWorkflowSteps]
	return ok
}

// ResetWorkflowSteps resets all changes to the "workflow_steps" field.
func (m *TicketTemplateMutation) ResetWorkflowSteps() {
	m.workflow_steps = nil
	m.appendworkflow_steps = nil
	delete(m.clearedFields, tickettemplate.FieldWorkflowSteps)
}

// SetIsActive sets the "is_active" field.
func (m *TicketTemplateMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *TicketTemplateMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *TicketTemplateMutation) ResetIsActive() {
	m.is_active = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketTemplateMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketTemplateMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TicketTemplateMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TicketTemplateMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketTemplateMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by ids.
func (m *TicketTemplateMutation) AddTicketIDs(ids ...int) {
	if m.tickets == nil {
		m.tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.tickets[ids[i]] = struct{}{}
	}
}

// ClearTickets clears the "tickets" edge to the Ticket entity.
func (m *TicketTemplateMutation) ClearTickets() {
	m.clearedtickets = true
}

// TicketsCleared reports if the "tickets" edge to the Ticket entity was cleared.
func (m *TicketTemplateMutation) TicketsCleared() bool {
	return m.clearedtickets
}

// RemoveTicketIDs removes the "tickets" edge to the Ticket entity by IDs.
func (m *TicketTemplateMutation) RemoveTicketIDs(ids ...int) {
	if m.removedtickets == nil {
		m.removedtickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tickets, ids[i])
		m.removedtickets[ids[i]] = struct{}{}
	}
}

// RemovedTickets returns the removed IDs of the "tickets" edge to the Ticket entity.
func (m *TicketTemplateMutation) RemovedTicketsIDs() (ids []int) {
	for id := range m.removedtickets {
		ids = append(ids, id)
	}
	return
}

// TicketsIDs returns the "tickets" edge IDs in the mutation.
func (m *TicketTemplateMutation) TicketsIDs() (ids []int) {
	for id := range m.tickets {
		ids = append(ids, id)
	}
	return
}

// ResetTickets resets all changes to the "tickets" edge.
func (m *TicketTemplateMutation) ResetTickets() {
	m.tickets = nil
	m.clearedtickets = false
	m.removedtickets = nil
}

// Where appends a list predicates to the TicketTemplateMutation builder.
func (m *TicketTemplateMutation) Where(ps ...predicate.TicketTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TicketTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TicketTemplate).
func (m *TicketTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketTemplateMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, tickettemplate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tickettemplate.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, tickettemplate.FieldCategory)
	}
	if m.priority != nil {
		fields = append(fields, tickettemplate.FieldPriority)
	}
	if m.form_fields != nil {
		fields = append(fields, tickettemplate.FieldFormFields)
	}
	if m.workflow_steps != nil {
		fields = append(fields, tickettemplate.FieldWorkflowSteps)
	}
	if m.is_active != nil {
		fields = append(fields, tickettemplate.FieldIsActive)
	}
	if m.tenant_id != nil {
		fields = append(fields, tickettemplate.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, tickettemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tickettemplate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tickettemplate.FieldName:
		return m.Name()
	case tickettemplate.FieldDescription:
		return m.Description()
	case tickettemplate.FieldCategory:
		return m.Category()
	case tickettemplate.FieldPriority:
		return m.Priority()
	case tickettemplate.FieldFormFields:
		return m.FormFields()
	case tickettemplate.FieldWorkflowSteps:
		return m.WorkflowSteps()
	case tickettemplate.FieldIsActive:
		return m.IsActive()
	case tickettemplate.FieldTenantID:
		return m.TenantID()
	case tickettemplate.FieldCreatedAt:
		return m.CreatedAt()
	case tickettemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tickettemplate.FieldName:
		return m.OldName(ctx)
	case tickettemplate.FieldDescription:
		return m.OldDescription(ctx)
	case tickettemplate.FieldCategory:
		return m.OldCategory(ctx)
	case tickettemplate.FieldPriority:
		return m.OldPriority(ctx)
	case tickettemplate.FieldFormFields:
		return m.OldFormFields(ctx)
	case tickettemplate.FieldWorkflowSteps:
		return m.OldWorkflowSteps(ctx)
	case tickettemplate.FieldIsActive:
		return m.OldIsActive(ctx)
	case tickettemplate.FieldTenantID:
		return m.OldTenantID(ctx)
	case tickettemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tickettemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TicketTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tickettemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tickettemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tickettemplate.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case tickettemplate.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case tickettemplate.FieldFormFields:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormFields(v)
		return nil
	case tickettemplate.FieldWorkflowSteps:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowSteps(v)
		return nil
	case tickettemplate.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case tickettemplate.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case tickettemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tickettemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TicketTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketTemplateMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, tickettemplate.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tickettemplate.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tickettemplate.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown TicketTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tickettemplate.FieldDescription) {
		fields = append(fields, tickettemplate.FieldDescription)
	}
	if m.FieldCleared(tickettemplate.FieldFormFields) {
		fields = append(fields, tickettemplate.FieldFormFields)
	}
	if m.FieldCleared(tickettemplate.FieldWorkflowSteps) {
		fields = append(fields, tickettemplate.FieldWorkflowSteps)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketTemplateMutation) ClearField(name string) error {
	switch name {
	case tickettemplate.FieldDescription:
		m.ClearDescription()
		return nil
	case tickettemplate.FieldFormFields:
		m.ClearFormFields()
		return nil
	case tickettemplate.FieldWorkflowSteps:
		m.ClearWorkflowSteps()
		return nil
	}
	return fmt.Errorf("unknown TicketTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketTemplateMutation) ResetField(name string) error {
	switch name {
	case tickettemplate.FieldName:
		m.ResetName()
		return nil
	case tickettemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case tickettemplate.FieldCategory:
		m.ResetCategory()
		return nil
	case tickettemplate.FieldPriority:
		m.ResetPriority()
		return nil
	case tickettemplate.FieldFormFields:
		m.ResetFormFields()
		return nil
	case tickettemplate.FieldWorkflowSteps:
		m.ResetWorkflowSteps()
		return nil
	case tickettemplate.FieldIsActive:
		m.ResetIsActive()
		return nil
	case tickettemplate.FieldTenantID:
		m.ResetTenantID()
		return nil
	case tickettemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tickettemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tickets != nil {
		edges = append(edges, tickettemplate.EdgeTickets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tickettemplate.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.tickets))
		for id := range m.tickets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtickets != nil {
		edges = append(edges, tickettemplate.EdgeTickets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tickettemplate.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.removedtickets))
		for id := range m.removedtickets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtickets {
		edges = append(edges, tickettemplate.EdgeTickets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case tickettemplate.EdgeTickets:
		return m.clearedtickets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketTemplateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TicketTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketTemplateMutation) ResetEdge(name string) error {
	switch name {
	case tickettemplate.EdgeTickets:
		m.ResetTickets()
		return nil
	}
	return fmt.Errorf("unknown TicketTemplate edge %s", name)
}

// TicketViewMutation represents an operation that mutates the TicketView nodes in the graph.
type TicketViewMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	description    *string
	filters        *map[string]interface{}
	columns        *[]string
	appendcolumns  []string
	sort_config    *map[string]interface{}
	group_config   *map[string]interface{}
	is_shared      *bool
	tenant_id      *int
	addtenant_id   *int
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	done           bool
	oldValue       func(context.Context) (*TicketView, error)
	predicates     []predicate.TicketView
}

var _ ent.Mutation = (*TicketViewMutation)(nil)

// ticketviewOption allows management of the mutation configuration using functional options.
type ticketviewOption func(*TicketViewMutation)

// newTicketViewMutation creates new mutation for the TicketView entity.
func newTicketViewMutation(c config, op Op, opts ...ticketviewOption) *TicketViewMutation {
	m := &TicketViewMutation{
		config:        c,
		op:            op,
		typ:           TypeTicketView,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketViewID sets the ID field of the mutation.
func withTicketViewID(id int) ticketviewOption {
	return func(m *TicketViewMutation) {
		var (
			err   error
			once  sync.Once
			value *TicketView
		)
		m.oldValue = func(ctx context.Context) (*TicketView, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TicketView.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicketView sets the old TicketView of the mutation.
func withTicketView(node *TicketView) ticketviewOption {
	return func(m *TicketViewMutation) {
		m.oldValue = func(context.Context) (*TicketView, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketViewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketViewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketViewMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketViewMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TicketView.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TicketViewMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TicketViewMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TicketView entity.
// If the TicketView object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketViewMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TicketViewMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TicketViewMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TicketViewMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TicketView entity.
// If the TicketView object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketViewMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TicketViewMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ticketview.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TicketViewMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ticketview.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TicketViewMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ticketview.FieldDescription)
}

// SetFilters sets the "filters" field.
func (m *TicketViewMutation) SetFilters(value map[string]interface{}) {
	m.filters = &value
}

// Filters returns the value of the "filters" field in the mutation.
func (m *TicketViewMutation) Filters() (r map[string]interface{}, exists bool) {
	v := m.filters
	if v == nil {
		return
	}
	return *v, true
}

// OldFilters returns the old "filters" field's value of the TicketView entity.
// If the TicketView object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketViewMutation) OldFilters(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilters: %w", err)
	}
	return oldValue.Filters, nil
}

// ClearFilters clears the value of the "filters" field.
func (m *TicketViewMutation) ClearFilters() {
	m.filters = nil
	m.clearedFields[ticketview.FieldFilters] = struct{}{}
}

// FiltersCleared returns if the "filters" field was cleared in this mutation.
func (m *TicketViewMutation) FiltersCleared() bool {
	_, ok := m.clearedFields[ticketview.FieldFilters]
	return ok
}

// ResetFilters resets all changes to the "filters" field.
func (m *TicketViewMutation) ResetFilters() {
	m.filters = nil
	delete(m.clearedFields, ticketview.FieldFilters)
}

// SetColumns sets the "columns" field.
func (m *TicketViewMutation) SetColumns(s []string) {
	m.columns = &s
	m.appendcolumns = nil
}

// Columns returns the value of the "columns" field in the mutation.
func (m *TicketViewMutation) Columns() (r []string, exists bool) {
	v := m.columns
	if v == nil {
		return
	}
	return *v, true
}

// OldColumns returns the old "columns" field's value of the TicketView entity.
// If the TicketView object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketViewMutation) OldColumns(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColumns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColumns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColumns: %w", err)
	}
	return oldValue.Columns, nil
}

// AppendColumns adds s to the "columns" field.
func (m *TicketViewMutation) AppendColumns(s []string) {
	m.appendcolumns = append(m.appendcolumns, s...)
}

// AppendedColumns returns the list of values that were appended to the "columns" field in this mutation.
func (m *TicketViewMutation) AppendedColumns() ([]string, bool) {
	if len(m.appendcolumns) == 0 {
		return nil, false
	}
	return m.appendcolumns, true
}

// ClearColumns clears the value of the "columns" field.
func (m *TicketViewMutation) ClearColumns() {
	m.columns = nil
	m.appendcolumns = nil
	m.clearedFields[ticketview.FieldColumns] = struct{}{}
}

// ColumnsCleared returns if the "columns" field was cleared in this mutation.
func (m *TicketViewMutation) ColumnsCleared() bool {
	_, ok := m.clearedFields[ticketview.FieldColumns]
	return ok
}

// ResetColumns resets all changes to the "columns" field.
func (m *TicketViewMutation) ResetColumns() {
	m.columns = nil
	m.appendcolumns = nil
	delete(m.clearedFields, ticketview.FieldColumns)
}

// SetSortConfig sets the "sort_config" field.
func (m *TicketViewMutation) SetSortConfig(value map[string]interface{}) {
	m.sort_config = &value
}

// SortConfig returns the value of the "sort_config" field in the mutation.
func (m *TicketViewMutation) SortConfig() (r map[string]interface{}, exists bool) {
	v := m.sort_config
	if v == nil {
		return
	}
	return *v, true
}

// OldSortConfig returns the old "sort_config" field's value of the TicketView entity.
// If the TicketView object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketViewMutation) OldSortConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortConfig: %w", err)
	}
	return oldValue.SortConfig, nil
}

// ClearSortConfig clears the value of the "sort_config" field.
func (m *TicketViewMutation) ClearSortConfig() {
	m.sort_config = nil
	m.clearedFields[ticketview.FieldSortConfig] = struct{}{}
}

// SortConfigCleared returns if the "sort_config" field was cleared in this mutation.
func (m *TicketViewMutation) SortConfigCleared() bool {
	_, ok := m.clearedFields[ticketview.FieldSortConfig]
	return ok
}

// ResetSortConfig resets all changes to the "sort_config" field.
func (m *TicketViewMutation) ResetSortConfig() {
	m.sort_config = nil
	delete(m.clearedFields, ticketview.FieldSortConfig)
}

// SetGroupConfig sets the "group_config" field.
func (m *TicketViewMutation) SetGroupConfig(value map[string]interface{}) {
	m.group_config = &value
}

// GroupConfig returns the value of the "group_config" field in the mutation.
func (m *TicketViewMutation) GroupConfig() (r map[string]interface{}, exists bool) {
	v := m.group_config
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupConfig returns the old "group_config" field's value of the TicketView entity.
// If the TicketView object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketViewMutation) OldGroupConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupConfig: %w", err)
	}
	return oldValue.GroupConfig, nil
}

// ClearGroupConfig clears the value of the "group_config" field.
func (m *TicketViewMutation) ClearGroupConfig() {
	m.group_config = nil
	m.clearedFields[ticketview.FieldGroupConfig] = struct{}{}
}

// GroupConfigCleared returns if the "group_config" field was cleared in this mutation.
func (m *TicketViewMutation) GroupConfigCleared() bool {
	_, ok := m.clearedFields[ticketview.FieldGroupConfig]
	return ok
}

// ResetGroupConfig resets all changes to the "group_config" field.
func (m *TicketViewMutation) ResetGroupConfig() {
	m.group_config = nil
	delete(m.clearedFields, ticketview.FieldGroupConfig)
}

// SetIsShared sets the "is_shared" field.
func (m *TicketViewMutation) SetIsShared(b bool) {
	m.is_shared = &b
}

// IsShared returns the value of the "is_shared" field in the mutation.
func (m *TicketViewMutation) IsShared() (r bool, exists bool) {
	v := m.is_shared
	if v == nil {
		return
	}
	return *v, true
}

// OldIsShared returns the old "is_shared" field's value of the TicketView entity.
// If the TicketView object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketViewMutation) OldIsShared(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsShared is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsShared requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsShared: %w", err)
	}
	return oldValue.IsShared, nil
}

// ResetIsShared resets all changes to the "is_shared" field.
func (m *TicketViewMutation) ResetIsShared() {
	m.is_shared = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TicketViewMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TicketViewMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TicketView entity.
// If the TicketView object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketViewMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TicketViewMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketViewMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketViewMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TicketView entity.
// If the TicketView object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketViewMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TicketViewMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TicketViewMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketViewMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketViewMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketViewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TicketView entity.
// If the TicketView object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketViewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketViewMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketViewMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketViewMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TicketView entity.
// If the TicketView object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketViewMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketViewMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *TicketViewMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *TicketViewMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[ticketview.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *TicketViewMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *TicketViewMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *TicketViewMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *TicketViewMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// Where appends a list predicates to the TicketViewMutation builder.
func (m *TicketViewMutation) Where(ps ...predicate.TicketView) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketViewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketViewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TicketView, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketViewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketViewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TicketView).
func (m *TicketViewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketViewMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, ticketview.FieldName)
	}
	if m.description != nil {
		fields = append(fields, ticketview.FieldDescription)
	}
	if m.filters != nil {
		fields = append(fields, ticketview.FieldFilters)
	}
	if m.columns != nil {
		fields = append(fields, ticketview.FieldColumns)
	}
	if m.sort_config != nil {
		fields = append(fields, ticketview.FieldSortConfig)
	}
	if m.group_config != nil {
		fields = append(fields, ticketview.FieldGroupConfig)
	}
	if m.is_shared != nil {
		fields = append(fields, ticketview.FieldIsShared)
	}
	if m.creator != nil {
		fields = append(fields, ticketview.FieldCreatedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, ticketview.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, ticketview.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ticketview.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketViewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticketview.FieldName:
		return m.Name()
	case ticketview.FieldDescription:
		return m.Description()
	case ticketview.FieldFilters:
		return m.Filters()
	case ticketview.FieldColumns:
		return m.Columns()
	case ticketview.FieldSortConfig:
		return m.SortConfig()
	case ticketview.FieldGroupConfig:
		return m.GroupConfig()
	case ticketview.FieldIsShared:
		return m.IsShared()
	case ticketview.FieldCreatedBy:
		return m.CreatedBy()
	case ticketview.FieldTenantID:
		return m.TenantID()
	case ticketview.FieldCreatedAt:
		return m.CreatedAt()
	case ticketview.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketViewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticketview.FieldName:
		return m.OldName(ctx)
	case ticketview.FieldDescription:
		return m.OldDescription(ctx)
	case ticketview.FieldFilters:
		return m.OldFilters(ctx)
	case ticketview.FieldColumns:
		return m.OldColumns(ctx)
	case ticketview.FieldSortConfig:
		return m.OldSortConfig(ctx)
	case ticketview.FieldGroupConfig:
		return m.OldGroupConfig(ctx)
	case ticketview.FieldIsShared:
		return m.OldIsShared(ctx)
	case ticketview.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case ticketview.FieldTenantID:
		return m.OldTenantID(ctx)
	case ticketview.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticketview.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TicketView field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketViewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticketview.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ticketview.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ticketview.FieldFilters:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilters(v)
		return nil
	case ticketview.FieldColumns:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColumns(v)
		return nil
	case ticketview.FieldSortConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortConfig(v)
		return nil
	case ticketview.FieldGroupConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupConfig(v)
		return nil
	case ticketview.FieldIsShared:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsShared(v)
		return nil
	case ticketview.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case ticketview.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ticketview.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticketview.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TicketView field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketViewMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, ticketview.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketViewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ticketview.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketViewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ticketview.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown TicketView numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketViewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticketview.FieldDescription) {
		fields = append(fields, ticketview.FieldDescription)
	}
	if m.FieldCleared(ticketview.FieldFilters) {
		fields = append(fields, ticketview.FieldFilters)
	}
	if m.FieldCleared(ticketview.FieldColumns) {
		fields = append(fields, ticketview.FieldColumns)
	}
	if m.FieldCleared(ticketview.FieldSortConfig) {
		fields = append(fields, ticketview.FieldSortConfig)
	}
	if m.FieldCleared(ticketview.FieldGroupConfig) {
		fields = append(fields, ticketview.FieldGroupConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketViewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketViewMutation) ClearField(name string) error {
	switch name {
	case ticketview.FieldDescription:
		m.ClearDescription()
		return nil
	case ticketview.FieldFilters:
		m.ClearFilters()
		return nil
	case ticketview.FieldColumns:
		m.ClearColumns()
		return nil
	case ticketview.FieldSortConfig:
		m.ClearSortConfig()
		return nil
	case ticketview.FieldGroupConfig:
		m.ClearGroupConfig()
		return nil
	}
	return fmt.Errorf("unknown TicketView nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketViewMutation) ResetField(name string) error {
	switch name {
	case ticketview.FieldName:
		m.ResetName()
		return nil
	case ticketview.FieldDescription:
		m.ResetDescription()
		return nil
	case ticketview.FieldFilters:
		m.ResetFilters()
		return nil
	case ticketview.FieldColumns:
		m.ResetColumns()
		return nil
	case ticketview.FieldSortConfig:
		m.ResetSortConfig()
		return nil
	case ticketview.FieldGroupConfig:
		m.ResetGroupConfig()
		return nil
	case ticketview.FieldIsShared:
		m.ResetIsShared()
		return nil
	case ticketview.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case ticketview.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ticketview.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticketview.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketView field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketViewMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.creator != nil {
		edges = append(edges, ticketview.EdgeCreator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketViewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticketview.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketViewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketViewMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketViewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcreator {
		edges = append(edges, ticketview.EdgeCreator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketViewMutation) EdgeCleared(name string) bool {
	switch name {
	case ticketview.EdgeCreator:
		return m.clearedcreator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketViewMutation) ClearEdge(name string) error {
	switch name {
	case ticketview.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown TicketView unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketViewMutation) ResetEdge(name string) error {
	switch name {
	case ticketview.EdgeCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown TicketView edge %s", name)
}

// ToolInvocationMutation represents an operation that mutates the ToolInvocation nodes in the graph.
type ToolInvocationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	tool_name           *string
	arguments           *string
	result              *string
	status              *string
	request_id          *string
	needs_approval      *bool
	approval_state      *string
	approval_reason     *string
	approved_by         *int
	addapproved_by      *int
	approved_at         *time.Time
	dry_run             *bool
	error               *string
	clearedFields       map[string]struct{}
	conversation        *int
	clearedconversation bool
	done                bool
	oldValue            func(context.Context) (*ToolInvocation, error)
	predicates          []predicate.ToolInvocation
}

var _ ent.Mutation = (*ToolInvocationMutation)(nil)

// toolinvocationOption allows management of the mutation configuration using functional options.
type toolinvocationOption func(*ToolInvocationMutation)

// newToolInvocationMutation creates new mutation for the ToolInvocation entity.
func newToolInvocationMutation(c config, op Op, opts ...toolinvocationOption) *ToolInvocationMutation {
	m := &ToolInvocationMutation{
		config:        c,
		op:            op,
		typ:           TypeToolInvocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolInvocationID sets the ID field of the mutation.
func withToolInvocationID(id int) toolinvocationOption {
	return func(m *ToolInvocationMutation) {
		var (
			err   error
			once  sync.Once
			value *ToolInvocation
		)
		m.oldValue = func(ctx context.Context) (*ToolInvocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ToolInvocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToolInvocation sets the old ToolInvocation of the mutation.
func withToolInvocation(node *ToolInvocation) toolinvocationOption {
	return func(m *ToolInvocationMutation) {
		m.oldValue = func(context.Context) (*ToolInvocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolInvocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolInvocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToolInvocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToolInvocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ToolInvocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ToolInvocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ToolInvocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ToolInvocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetConversationID sets the "conversation_id" field.
func (m *ToolInvocationMutation) SetConversationID(i int) {
	m.conversation = &i
}

// ConversationID returns the value of the "conversation_id" field in the mutation.
func (m *ToolInvocationMutation) ConversationID() (r int, exists bool) {
	v := m.conversation
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationID returns the old "conversation_id" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldConversationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationID: %w", err)
	}
	return oldValue.ConversationID, nil
}

// ResetConversationID resets all changes to the "conversation_id" field.
func (m *ToolInvocationMutation) ResetConversationID() {
	m.conversation = nil
}

// SetToolName sets the "tool_name" field.
func (m *ToolInvocationMutation) SetToolName(s string) {
	m.tool_name = &s
}

// ToolName returns the value of the "tool_name" field in the mutation.
func (m *ToolInvocationMutation) ToolName() (r string, exists bool) {
	v := m.tool_name
	if v == nil {
		return
	}
	return *v, true
}

// OldToolName returns the old "tool_name" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldToolName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToolName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToolName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolName: %w", err)
	}
	return oldValue.ToolName, nil
}

// ResetToolName resets all changes to the "tool_name" field.
func (m *ToolInvocationMutation) ResetToolName() {
	m.tool_name = nil
}

// SetArguments sets the "arguments" field.
func (m *ToolInvocationMutation) SetArguments(s string) {
	m.arguments = &s
}

// Arguments returns the value of the "arguments" field in the mutation.
func (m *ToolInvocationMutation) Arguments() (r string, exists bool) {
	v := m.arguments
	if v == nil {
		return
	}
	return *v, true
}

// OldArguments returns the old "arguments" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldArguments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArguments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArguments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArguments: %w", err)
	}
	return oldValue.Arguments, nil
}

// ResetArguments resets all changes to the "arguments" field.
func (m *ToolInvocationMutation) ResetArguments() {
	m.arguments = nil
}

// SetResult sets the "result" field.
func (m *ToolInvocationMutation) SetResult(s string) {
	m.result = &s
}

// Result returns the value of the "result" field in the mutation.
func (m *ToolInvocationMutation) Result() (r string, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldResult(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ClearResult clears the value of the "result" field.
func (m *ToolInvocationMutation) ClearResult() {
	m.result = nil
	m.clearedFields[toolinvocation.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *ToolInvocationMutation) ResultCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *ToolInvocationMutation) ResetResult() {
	m.result = nil
	delete(m.clearedFields, toolinvocation.FieldResult)
}

// SetStatus sets the "status" field.
func (m *ToolInvocationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ToolInvocationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ToolInvocationMutation) ResetStatus() {
	m.status = nil
}

// SetRequestID sets the "request_id" field.
func (m *ToolInvocationMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *ToolInvocationMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *ToolInvocationMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[toolinvocation.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *ToolInvocationMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *ToolInvocationMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, toolinvocation.FieldRequestID)
}

// SetNeedsApproval sets the "needs_approval" field.
func (m *ToolInvocationMutation) SetNeedsApproval(b bool) {
	m.needs_approval = &b
}

// NeedsApproval returns the value of the "needs_approval" field in the mutation.
func (m *ToolInvocationMutation) NeedsApproval() (r bool, exists bool) {
	v := m.needs_approval
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedsApproval returns the old "needs_approval" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldNeedsApproval(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNeedsApproval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNeedsApproval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedsApproval: %w", err)
	}
	return oldValue.NeedsApproval, nil
}

// ResetNeedsApproval resets all changes to the "needs_approval" field.
func (m *ToolInvocationMutation) ResetNeedsApproval() {
	m.needs_approval = nil
}

// SetApprovalState sets the "approval_state" field.
func (m *ToolInvocationMutation) SetApprovalState(s string) {
	m.approval_state = &s
}

// ApprovalState returns the value of the "approval_state" field in the mutation.
func (m *ToolInvocationMutation) ApprovalState() (r string, exists bool) {
	v := m.approval_state
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalState returns the old "approval_state" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldApprovalState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalState: %w", err)
	}
	return oldValue.ApprovalState, nil
}

// ResetApprovalState resets all changes to the "approval_state" field.
func (m *ToolInvocationMutation) ResetApprovalState() {
	m.approval_state = nil
}

// SetApprovalReason sets the "approval_reason" field.
func (m *ToolInvocationMutation) SetApprovalReason(s string) {
	m.approval_reason = &s
}

// ApprovalReason returns the value of the "approval_reason" field in the mutation.
func (m *ToolInvocationMutation) ApprovalReason() (r string, exists bool) {
	v := m.approval_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalReason returns the old "approval_reason" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldApprovalReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalReason: %w", err)
	}
	return oldValue.ApprovalReason, nil
}

// ResetApprovalReason resets all changes to the "approval_reason" field.
func (m *ToolInvocationMutation) ResetApprovalReason() {
	m.approval_reason = nil
}

// SetApprovedBy sets the "approved_by" field.
func (m *ToolInvocationMutation) SetApprovedBy(i int) {
	m.approved_by = &i
	m.addapproved_by = nil
}

// ApprovedBy returns the value of the "approved_by" field in the mutation.
func (m *ToolInvocationMutation) ApprovedBy() (r int, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedBy returns the old "approved_by" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldApprovedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedBy: %w", err)
	}
	return oldValue.ApprovedBy, nil
}

// AddApprovedBy adds i to the "approved_by" field.
func (m *ToolInvocationMutation) AddApprovedBy(i int) {
	if m.addapproved_by != nil {
		*m.addapproved_by += i
	} else {
		m.addapproved_by = &i
	}
}

// AddedApprovedBy returns the value that was added to the "approved_by" field in this mutation.
func (m *ToolInvocationMutation) AddedApprovedBy() (r int, exists bool) {
	v := m.addapproved_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearApprovedBy clears the value of the "approved_by" field.
func (m *ToolInvocationMutation) ClearApprovedBy() {
	m.approved_by = nil
	m.addapproved_by = nil
	m.clearedFields[toolinvocation.FieldApprovedBy] = struct{}{}
}

// ApprovedByCleared returns if the "approved_by" field was cleared in this mutation.
func (m *ToolInvocationMutation) ApprovedByCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldApprovedBy]
	return ok
}

// ResetApprovedBy resets all changes to the "approved_by" field.
func (m *ToolInvocationMutation) ResetApprovedBy() {
	m.approved_by = nil
	m.addapproved_by = nil
	delete(m.clearedFields, toolinvocation.FieldApprovedBy)
}

// SetApprovedAt sets the "approved_at" field.
func (m *ToolInvocationMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *ToolInvocationMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldApprovedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *ToolInvocationMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[toolinvocation.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *ToolInvocationMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *ToolInvocationMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, toolinvocation.FieldApprovedAt)
}

// SetDryRun sets the "dry_run" field.
func (m *ToolInvocationMutation) SetDryRun(b bool) {
	m.dry_run = &b
}

// DryRun returns the value of the "dry_run" field in the mutation.
func (m *ToolInvocationMutation) DryRun() (r bool, exists bool) {
	v := m.dry_run
	if v == nil {
		return
	}
	return *v, true
}

// OldDryRun returns the old "dry_run" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldDryRun(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDryRun is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDryRun requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDryRun: %w", err)
	}
	return oldValue.DryRun, nil
}

// ResetDryRun resets all changes to the "dry_run" field.
func (m *ToolInvocationMutation) ResetDryRun() {
	m.dry_run = nil
}

// SetError sets the "error" field.
func (m *ToolInvocationMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *ToolInvocationMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldError(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *ToolInvocationMutation) ClearError() {
	m.error = nil
	m.clearedFields[toolinvocation.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *ToolInvocationMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *ToolInvocationMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, toolinvocation.FieldError)
}

// ClearConversation clears the "conversation" edge to the Conversation entity.
func (m *ToolInvocationMutation) ClearConversation() {
	m.clearedconversation = true
	m.clearedFields[toolinvocation.FieldConversationID] = struct{}{}
}

// ConversationCleared reports if the "conversation" edge to the Conversation entity was cleared.
func (m *ToolInvocationMutation) ConversationCleared() bool {
	return m.clearedconversation
}

// ConversationIDs returns the "conversation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConversationID instead. It exists only for internal usage by the builders.
func (m *ToolInvocationMutation) ConversationIDs() (ids []int) {
	if id := m.conversation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConversation resets all changes to the "conversation" edge.
func (m *ToolInvocationMutation) ResetConversation() {
	m.conversation = nil
	m.clearedconversation = false
}

// Where appends a list predicates to the ToolInvocationMutation builder.
func (m *ToolInvocationMutation) Where(ps ...predicate.ToolInvocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToolInvocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToolInvocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ToolInvocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToolInvocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToolInvocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ToolInvocation).
func (m *ToolInvocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToolInvocationMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, toolinvocation.FieldCreatedAt)
	}
	if m.conversation != nil {
		fields = append(fields, toolinvocation.FieldConversationID)
	}
	if m.tool_name != nil {
		fields = append(fields, toolinvocation.FieldToolName)
	}
	if m.arguments != nil {
		fields = append(fields, toolinvocation.FieldArguments)
	}
	if m.result != nil {
		fields = append(fields, toolinvocation.FieldResult)
	}
	if m.status != nil {
		fields = append(fields, toolinvocation.FieldStatus)
	}
	if m.request_id != nil {
		fields = append(fields, toolinvocation.FieldRequestID)
	}
	if m.needs_approval != nil {
		fields = append(fields, toolinvocation.FieldNeedsApproval)
	}
	if m.approval_state != nil {
		fields = append(fields, toolinvocation.FieldApprovalState)
	}
	if m.approval_reason != nil {
		fields = append(fields, toolinvocation.FieldApprovalReason)
	}
	if m.approved_by != nil {
		fields = append(fields, toolinvocation.FieldApprovedBy)
	}
	if m.approved_at != nil {
		fields = append(fields, toolinvocation.FieldApprovedAt)
	}
	if m.dry_run != nil {
		fields = append(fields, toolinvocation.FieldDryRun)
	}
	if m.error != nil {
		fields = append(fields, toolinvocation.FieldError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToolInvocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case toolinvocation.FieldCreatedAt:
		return m.CreatedAt()
	case toolinvocation.FieldConversationID:
		return m.ConversationID()
	case toolinvocation.FieldToolName:
		return m.ToolName()
	case toolinvocation.FieldArguments:
		return m.Arguments()
	case toolinvocation.FieldResult:
		return m.Result()
	case toolinvocation.FieldStatus:
		return m.Status()
	case toolinvocation.FieldRequestID:
		return m.RequestID()
	case toolinvocation.FieldNeedsApproval:
		return m.NeedsApproval()
	case toolinvocation.FieldApprovalState:
		return m.ApprovalState()
	case toolinvocation.FieldApprovalReason:
		return m.ApprovalReason()
	case toolinvocation.FieldApprovedBy:
		return m.ApprovedBy()
	case toolinvocation.FieldApprovedAt:
		return m.ApprovedAt()
	case toolinvocation.FieldDryRun:
		return m.DryRun()
	case toolinvocation.FieldError:
		return m.Error()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToolInvocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case toolinvocation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case toolinvocation.FieldConversationID:
		return m.OldConversationID(ctx)
	case toolinvocation.FieldToolName:
		return m.OldToolName(ctx)
	case toolinvocation.FieldArguments:
		return m.OldArguments(ctx)
	case toolinvocation.FieldResult:
		return m.OldResult(ctx)
	case toolinvocation.FieldStatus:
		return m.OldStatus(ctx)
	case toolinvocation.FieldRequestID:
		return m.OldRequestID(ctx)
	case toolinvocation.FieldNeedsApproval:
		return m.OldNeedsApproval(ctx)
	case toolinvocation.FieldApprovalState:
		return m.OldApprovalState(ctx)
	case toolinvocation.FieldApprovalReason:
		return m.OldApprovalReason(ctx)
	case toolinvocation.FieldApprovedBy:
		return m.OldApprovedBy(ctx)
	case toolinvocation.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case toolinvocation.FieldDryRun:
		return m.OldDryRun(ctx)
	case toolinvocation.FieldError:
		return m.OldError(ctx)
	}
	return nil, fmt.Errorf("unknown ToolInvocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolInvocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case toolinvocation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case toolinvocation.FieldConversationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationID(v)
		return nil
	case toolinvocation.FieldToolName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolName(v)
		return nil
	case toolinvocation.FieldArguments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArguments(v)
		return nil
	case toolinvocation.FieldResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case toolinvocation.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case toolinvocation.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case toolinvocation.FieldNeedsApproval:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedsApproval(v)
		return nil
	case toolinvocation.FieldApprovalState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalState(v)
		return nil
	case toolinvocation.FieldApprovalReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalReason(v)
		return nil
	case toolinvocation.FieldApprovedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedBy(v)
		return nil
	case toolinvocation.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case toolinvocation.FieldDryRun:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDryRun(v)
		return nil
	case toolinvocation.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToolInvocationMutation) AddedFields() []string {
	var fields []string
	if m.addapproved_by != nil {
		fields = append(fields, toolinvocation.FieldApprovedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToolInvocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case toolinvocation.FieldApprovedBy:
		return m.AddedApprovedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolInvocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case toolinvocation.FieldApprovedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApprovedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToolInvocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(toolinvocation.FieldResult) {
		fields = append(fields, toolinvocation.FieldResult)
	}
	if m.FieldCleared(toolinvocation.FieldRequestID) {
		fields = append(fields, toolinvocation.FieldRequestID)
	}
	if m.FieldCleared(toolinvocation.FieldApprovedBy) {
		fields = append(fields, toolinvocation.FieldApprovedBy)
	}
	if m.FieldCleared(toolinvocation.FieldApprovedAt) {
		fields = append(fields, toolinvocation.FieldApprovedAt)
	}
	if m.FieldCleared(toolinvocation.FieldError) {
		fields = append(fields, toolinvocation.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToolInvocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolInvocationMutation) ClearField(name string) error {
	switch name {
	case toolinvocation.FieldResult:
		m.ClearResult()
		return nil
	case toolinvocation.FieldRequestID:
		m.ClearRequestID()
		return nil
	case toolinvocation.FieldApprovedBy:
		m.ClearApprovedBy()
		return nil
	case toolinvocation.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case toolinvocation.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToolInvocationMutation) ResetField(name string) error {
	switch name {
	case toolinvocation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case toolinvocation.FieldConversationID:
		m.ResetConversationID()
		return nil
	case toolinvocation.FieldToolName:
		m.ResetToolName()
		return nil
	case toolinvocation.FieldArguments:
		m.ResetArguments()
		return nil
	case toolinvocation.FieldResult:
		m.ResetResult()
		return nil
	case toolinvocation.FieldStatus:
		m.ResetStatus()
		return nil
	case toolinvocation.FieldRequestID:
		m.ResetRequestID()
		return nil
	case toolinvocation.FieldNeedsApproval:
		m.ResetNeedsApproval()
		return nil
	case toolinvocation.FieldApprovalState:
		m.ResetApprovalState()
		return nil
	case toolinvocation.FieldApprovalReason:
		m.ResetApprovalReason()
		return nil
	case toolinvocation.FieldApprovedBy:
		m.ResetApprovedBy()
		return nil
	case toolinvocation.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case toolinvocation.FieldDryRun:
		m.ResetDryRun()
		return nil
	case toolinvocation.FieldError:
		m.ResetError()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToolInvocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.conversation != nil {
		edges = append(edges, toolinvocation.EdgeConversation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToolInvocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case toolinvocation.EdgeConversation:
		if id := m.conversation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToolInvocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToolInvocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToolInvocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconversation {
		edges = append(edges, toolinvocation.EdgeConversation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToolInvocationMutation) EdgeCleared(name string) bool {
	switch name {
	case toolinvocation.EdgeConversation:
		return m.clearedconversation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToolInvocationMutation) ClearEdge(name string) error {
	switch name {
	case toolinvocation.EdgeConversation:
		m.ClearConversation()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToolInvocationMutation) ResetEdge(name string) error {
	switch name {
	case toolinvocation.EdgeConversation:
		m.ResetConversation()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	username                    *string
	email                       *string
	name                        *string
	role                        *user.Role
	department                  *string
	phone                       *string
	password_hash               *string
	active                      *bool
	tenant_id                   *int
	addtenant_id                *int
	created_at                  *time.Time
	updated_at                  *time.Time
	clearedFields               map[string]struct{}
	department_ref              *int
	cleareddepartment_ref       bool
	ticket_comments             map[int]struct{}
	removedticket_comments      map[int]struct{}
	clearedticket_comments      bool
	ticket_attachments          map[int]struct{}
	removedticket_attachments   map[int]struct{}
	clearedticket_attachments   bool
	ticket_notifications        map[int]struct{}
	removedticket_notifications map[int]struct{}
	clearedticket_notifications bool
	done                        bool
	oldValue                    func(context.Context) (*User, error)
	predicates                  []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetDepartment sets the "department" field.
func (m *UserMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the value of the "department" field in the mutation.
func (m *UserMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old "department" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ClearDepartment clears the value of the "department" field.
func (m *UserMutation) ClearDepartment() {
	m.department = nil
	m.clearedFields[user.FieldDepartment] = struct{}{}
}

// DepartmentCleared returns if the "department" field was cleared in this mutation.
func (m *UserMutation) DepartmentCleared() bool {
	_, ok := m.clearedFields[user.FieldDepartment]
	return ok
}

// ResetDepartment resets all changes to the "department" field.
func (m *UserMutation) ResetDepartment() {
	m.department = nil
	delete(m.clearedFields, user.FieldDepartment)
}

// SetDepartmentID sets the "department_id" field.
func (m *UserMutation) SetDepartmentID(i int) {
	m.department_ref = &i
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *UserMutation) DepartmentID() (r int, exists bool) {
	v := m.department_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDepartmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ClearDepartmentID clears the value of the "department_id" field.
func (m *UserMutation) ClearDepartmentID() {
	m.department_ref = nil
	m.clearedFields[user.FieldDepartmentID] = struct{}{}
}

// DepartmentIDCleared returns if the "department_id" field was cleared in this mutation.
func (m *UserMutation) DepartmentIDCleared() bool {
	_, ok := m.clearedFields[user.FieldDepartmentID]
	return ok
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *UserMutation) ResetDepartmentID() {
	m.department_ref = nil
	delete(m.clearedFields, user.FieldDepartmentID)
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *UserMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *UserMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *UserMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDepartmentRefID sets the "department_ref" edge to the Department entity by id.
func (m *UserMutation) SetDepartmentRefID(id int) {
	m.department_ref = &id
}

// ClearDepartmentRef clears the "department_ref" edge to the Department entity.
func (m *UserMutation) ClearDepartmentRef() {
	m.cleareddepartment_ref = true
	m.clearedFields[user.FieldDepartmentID] = struct{}{}
}

// DepartmentRefCleared reports if the "department_ref" edge to the Department entity was cleared.
func (m *UserMutation) DepartmentRefCleared() bool {
	return m.DepartmentIDCleared() || m.cleareddepartment_ref
}

// DepartmentRefID returns the "department_ref" edge ID in the mutation.
func (m *UserMutation) DepartmentRefID() (id int, exists bool) {
	if m.department_ref != nil {
		return *m.department_ref, true
	}
	return
}

// DepartmentRefIDs returns the "department_ref" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentRefID instead. It exists only for internal usage by the builders.
func (m *UserMutation) DepartmentRefIDs() (ids []int) {
	if id := m.department_ref; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartmentRef resets all changes to the "department_ref" edge.
func (m *UserMutation) ResetDepartmentRef() {
	m.department_ref = nil
	m.cleareddepartment_ref = false
}

// AddTicketCommentIDs adds the "ticket_comments" edge to the TicketComment entity by ids.
func (m *UserMutation) AddTicketCommentIDs(ids ...int) {
	if m.ticket_comments == nil {
		m.ticket_comments = make(map[int]struct{})
	}
	for i := range ids {
		m.ticket_comments[ids[i]] = struct{}{}
	}
}

// ClearTicketComments clears the "ticket_comments" edge to the TicketComment entity.
func (m *UserMutation) ClearTicketComments() {
	m.clearedticket_comments = true
}

// TicketCommentsCleared reports if the "ticket_comments" edge to the TicketComment entity was cleared.
func (m *UserMutation) TicketCommentsCleared() bool {
	return m.clearedticket_comments
}

// RemoveTicketCommentIDs removes the "ticket_comments" edge to the TicketComment entity by IDs.
func (m *UserMutation) RemoveTicketCommentIDs(ids ...int) {
	if m.removedticket_comments == nil {
		m.removedticket_comments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ticket_comments, ids[i])
		m.removedticket_comments[ids[i]] = struct{}{}
	}
}

// RemovedTicketComments returns the removed IDs of the "ticket_comments" edge to the TicketComment entity.
func (m *UserMutation) RemovedTicketCommentsIDs() (ids []int) {
	for id := range m.removedticket_comments {
		ids = append(ids, id)
	}
	return
}

// TicketCommentsIDs returns the "ticket_comments" edge IDs in the mutation.
func (m *UserMutation) TicketCommentsIDs() (ids []int) {
	for id := range m.ticket_comments {
		ids = append(ids, id)
	}
	return
}

// ResetTicketComments resets all changes to the "ticket_comments" edge.
func (m *UserMutation) ResetTicketComments() {
	m.ticket_comments = nil
	m.clearedticket_comments = false
	m.removedticket_comments = nil
}

// AddTicketAttachmentIDs adds the "ticket_attachments" edge to the TicketAttachment entity by ids.
func (m *UserMutation) AddTicketAttachmentIDs(ids ...int) {
	if m.ticket_attachments == nil {
		m.ticket_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.ticket_attachments[ids[i]] = struct{}{}
	}
}

// ClearTicketAttachments clears the "ticket_attachments" edge to the TicketAttachment entity.
func (m *UserMutation) ClearTicketAttachments() {
	m.clearedticket_attachments = true
}

// TicketAttachmentsCleared reports if the "ticket_attachments" edge to the TicketAttachment entity was cleared.
func (m *UserMutation) TicketAttachmentsCleared() bool {
	return m.clearedticket_attachments
}

// RemoveTicketAttachmentIDs removes the "ticket_attachments" edge to the TicketAttachment entity by IDs.
func (m *UserMutation) RemoveTicketAttachmentIDs(ids ...int) {
	if m.removedticket_attachments == nil {
		m.removedticket_attachments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ticket_attachments, ids[i])
		m.removedticket_attachments[ids[i]] = struct{}{}
	}
}

// RemovedTicketAttachments returns the removed IDs of the "ticket_attachments" edge to the TicketAttachment entity.
func (m *UserMutation) RemovedTicketAttachmentsIDs() (ids []int) {
	for id := range m.removedticket_attachments {
		ids = append(ids, id)
	}
	return
}

// TicketAttachmentsIDs returns the "ticket_attachments" edge IDs in the mutation.
func (m *UserMutation) TicketAttachmentsIDs() (ids []int) {
	for id := range m.ticket_attachments {
		ids = append(ids, id)
	}
	return
}

// ResetTicketAttachments resets all changes to the "ticket_attachments" edge.
func (m *UserMutation) ResetTicketAttachments() {
	m.ticket_attachments = nil
	m.clearedticket_attachments = false
	m.removedticket_attachments = nil
}

// AddTicketNotificationIDs adds the "ticket_notifications" edge to the TicketNotification entity by ids.
func (m *UserMutation) AddTicketNotificationIDs(ids ...int) {
	if m.ticket_notifications == nil {
		m.ticket_notifications = make(map[int]struct{})
	}
	for i := range ids {
		m.ticket_notifications[ids[i]] = struct{}{}
	}
}

// ClearTicketNotifications clears the "ticket_notifications" edge to the TicketNotification entity.
func (m *UserMutation) ClearTicketNotifications() {
	m.clearedticket_notifications = true
}

// TicketNotificationsCleared reports if the "ticket_notifications" edge to the TicketNotification entity was cleared.
func (m *UserMutation) TicketNotificationsCleared() bool {
	return m.clearedticket_notifications
}

// RemoveTicketNotificationIDs removes the "ticket_notifications" edge to the TicketNotification entity by IDs.
func (m *UserMutation) RemoveTicketNotificationIDs(ids ...int) {
	if m.removedticket_notifications == nil {
		m.removedticket_notifications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ticket_notifications, ids[i])
		m.removedticket_notifications[ids[i]] = struct{}{}
	}
}

// RemovedTicketNotifications returns the removed IDs of the "ticket_notifications" edge to the TicketNotification entity.
func (m *UserMutation) RemovedTicketNotificationsIDs() (ids []int) {
	for id := range m.removedticket_notifications {
		ids = append(ids, id)
	}
	return
}

// TicketNotificationsIDs returns the "ticket_notifications" edge IDs in the mutation.
func (m *UserMutation) TicketNotificationsIDs() (ids []int) {
	for id := range m.ticket_notifications {
		ids = append(ids, id)
	}
	return
}

// ResetTicketNotifications resets all changes to the "ticket_notifications" edge.
func (m *UserMutation) ResetTicketNotifications() {
	m.ticket_notifications = nil
	m.clearedticket_notifications = false
	m.removedticket_notifications = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.department != nil {
		fields = append(fields, user.FieldDepartment)
	}
	if m.department_ref != nil {
		fields = append(fields, user.FieldDepartmentID)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	if m.tenant_id != nil {
		fields = append(fields, user.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldRole:
		return m.Role()
	case user.FieldDepartment:
		return m.Department()
	case user.FieldDepartmentID:
		return m.DepartmentID()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldActive:
		return m.Active()
	case user.FieldTenantID:
		return m.TenantID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldDepartment:
		return m.OldDepartment(ctx)
	case user.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	case user.FieldTenantID:
		return m.OldTenantID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	case user.FieldDepartmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case user.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, user.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDepartment) {
		fields = append(fields, user.FieldDepartment)
	}
	if m.FieldCleared(user.FieldDepartmentID) {
		fields = append(fields, user.FieldDepartmentID)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDepartment:
		m.ClearDepartment()
		return nil
	case user.FieldDepartmentID:
		m.ClearDepartmentID()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldDepartment:
		m.ResetDepartment()
		return nil
	case user.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	case user.FieldTenantID:
		m.ResetTenantID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.department_ref != nil {
		edges = append(edges, user.EdgeDepartmentRef)
	}
	if m.ticket_comments != nil {
		edges = append(edges, user.EdgeTicketComments)
	}
	if m.ticket_attachments != nil {
		edges = append(edges, user.EdgeTicketAttachments)
	}
	if m.ticket_notifications != nil {
		edges = append(edges, user.EdgeTicketNotifications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDepartmentRef:
		if id := m.department_ref; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeTicketComments:
		ids := make([]ent.Value, 0, len(m.ticket_comments))
		for id := range m.ticket_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTicketAttachments:
		ids := make([]ent.Value, 0, len(m.ticket_attachments))
		for id := range m.ticket_attachments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTicketNotifications:
		ids := make([]ent.Value, 0, len(m.ticket_notifications))
		for id := range m.ticket_notifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedticket_comments != nil {
		edges = append(edges, user.EdgeTicketComments)
	}
	if m.removedticket_attachments != nil {
		edges = append(edges, user.EdgeTicketAttachments)
	}
	if m.removedticket_notifications != nil {
		edges = append(edges, user.EdgeTicketNotifications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTicketComments:
		ids := make([]ent.Value, 0, len(m.removedticket_comments))
		for id := range m.removedticket_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTicketAttachments:
		ids := make([]ent.Value, 0, len(m.removedticket_attachments))
		for id := range m.removedticket_attachments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTicketNotifications:
		ids := make([]ent.Value, 0, len(m.removedticket_notifications))
		for id := range m.removedticket_notifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddepartment_ref {
		edges = append(edges, user.EdgeDepartmentRef)
	}
	if m.clearedticket_comments {
		edges = append(edges, user.EdgeTicketComments)
	}
	if m.clearedticket_attachments {
		edges = append(edges, user.EdgeTicketAttachments)
	}
	if m.clearedticket_notifications {
		edges = append(edges, user.EdgeTicketNotifications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeDepartmentRef:
		return m.cleareddepartment_ref
	case user.EdgeTicketComments:
		return m.clearedticket_comments
	case user.EdgeTicketAttachments:
		return m.clearedticket_attachments
	case user.EdgeTicketNotifications:
		return m.clearedticket_notifications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeDepartmentRef:
		m.ClearDepartmentRef()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeDepartmentRef:
		m.ResetDepartmentRef()
		return nil
	case user.EdgeTicketComments:
		m.ResetTicketComments()
		return nil
	case user.EdgeTicketAttachments:
		m.ResetTicketAttachments()
		return nil
	case user.EdgeTicketNotifications:
		m.ResetTicketNotifications()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WorkflowMutation represents an operation that mutates the Workflow nodes in the graph.
type WorkflowMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	description               *string
	_type                     *string
	definition                *[]uint8
	appenddefinition          []uint8
	version                   *string
	is_active                 *bool
	tenant_id                 *int
	addtenant_id              *int
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	workflow_instances        map[int]struct{}
	removedworkflow_instances map[int]struct{}
	clearedworkflow_instances bool
	department                *int
	cleareddepartment         bool
	done                      bool
	oldValue                  func(context.Context) (*Workflow, error)
	predicates                []predicate.Workflow
}

var _ ent.Mutation = (*WorkflowMutation)(nil)

// workflowOption allows management of the mutation configuration using functional options.
type workflowOption func(*WorkflowMutation)

// newWorkflowMutation creates new mutation for the Workflow entity.
func newWorkflowMutation(c config, op Op, opts ...workflowOption) *WorkflowMutation {
	m := &WorkflowMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowID sets the ID field of the mutation.
func withWorkflowID(id int) workflowOption {
	return func(m *WorkflowMutation) {
		var (
			err   error
			once  sync.Once
			value *Workflow
		)
		m.oldValue = func(ctx context.Context) (*Workflow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workflow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflow sets the old Workflow of the mutation.
func withWorkflow(node *Workflow) workflowOption {
	return func(m *WorkflowMutation) {
		m.oldValue = func(context.Context) (*Workflow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workflow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WorkflowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkflowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkflowMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *WorkflowMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkflowMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkflowMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workflow.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkflowMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workflow.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkflowMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workflow.FieldDescription)
}

// SetType sets the "type" field.
func (m *WorkflowMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *WorkflowMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *WorkflowMutation) ResetType() {
	m._type = nil
}

// SetDefinition sets the "definition" field.
func (m *WorkflowMutation) SetDefinition(u []uint8) {
	m.definition = &u
	m.appenddefinition = nil
}

// Definition returns the value of the "definition" field in the mutation.
func (m *WorkflowMutation) Definition() (r []uint8, exists bool) {
	v := m.definition
	if v == nil {
		return
	}
	return *v, true
}

// OldDefinition returns the old "definition" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldDefinition(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefinition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefinition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefinition: %w", err)
	}
	return oldValue.Definition, nil
}

// AppendDefinition adds u to the "definition" field.
func (m *WorkflowMutation) AppendDefinition(u []uint8) {
	m.appenddefinition = append(m.appenddefinition, u...)
}

// AppendedDefinition returns the list of values that were appended to the "definition" field in this mutation.
func (m *WorkflowMutation) AppendedDefinition() ([]uint8, bool) {
	if len(m.appenddefinition) == 0 {
		return nil, false
	}
	return m.appenddefinition, true
}

// ResetDefinition resets all changes to the "definition" field.
func (m *WorkflowMutation) ResetDefinition() {
	m.definition = nil
	m.appenddefinition = nil
}

// SetVersion sets the "version" field.
func (m *WorkflowMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *WorkflowMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *WorkflowMutation) ResetVersion() {
	m.version = nil
}

// SetIsActive sets the "is_active" field.
func (m *WorkflowMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *WorkflowMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *WorkflowMutation) ResetIsActive() {
	m.is_active = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *WorkflowMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *WorkflowMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *WorkflowMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *WorkflowMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *WorkflowMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetDepartmentID sets the "department_id" field.
func (m *WorkflowMutation) SetDepartmentID(i int) {
	m.department = &i
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *WorkflowMutation) DepartmentID() (r int, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldDepartmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ClearDepartmentID clears the value of the "department_id" field.
func (m *WorkflowMutation) ClearDepartmentID() {
	m.department = nil
	m.clearedFields[workflow.FieldDepartmentID] = struct{}{}
}

// DepartmentIDCleared returns if the "department_id" field was cleared in this mutation.
func (m *WorkflowMutation) DepartmentIDCleared() bool {
	_, ok := m.clearedFields[workflow.FieldDepartmentID]
	return ok
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *WorkflowMutation) ResetDepartmentID() {
	m.department = nil
	delete(m.clearedFields, workflow.FieldDepartmentID)
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddWorkflowInstanceIDs adds the "workflow_instances" edge to the WorkflowInstance entity by ids.
func (m *WorkflowMutation) AddWorkflowInstanceIDs(ids ...int) {
	if m.workflow_instances == nil {
		m.workflow_instances = make(map[int]struct{})
	}
	for i := range ids {
		m.workflow_instances[ids[i]] = struct{}{}
	}
}

// ClearWorkflowInstances clears the "workflow_instances" edge to the WorkflowInstance entity.
func (m *WorkflowMutation) ClearWorkflowInstances() {
	m.clearedworkflow_instances = true
}

// WorkflowInstancesCleared reports if the "workflow_instances" edge to the WorkflowInstance entity was cleared.
func (m *WorkflowMutation) WorkflowInstancesCleared() bool {
	return m.clearedworkflow_instances
}

// RemoveWorkflowInstanceIDs removes the "workflow_instances" edge to the WorkflowInstance entity by IDs.
func (m *WorkflowMutation) RemoveWorkflowInstanceIDs(ids ...int) {
	if m.removedworkflow_instances == nil {
		m.removedworkflow_instances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workflow_instances, ids[i])
		m.removedworkflow_instances[ids[i]] = struct{}{}
	}
}

// RemovedWorkflowInstances returns the removed IDs of the "workflow_instances" edge to the WorkflowInstance entity.
func (m *WorkflowMutation) RemovedWorkflowInstancesIDs() (ids []int) {
	for id := range m.removedworkflow_instances {
		ids = append(ids, id)
	}
	return
}

// WorkflowInstancesIDs returns the "workflow_instances" edge IDs in the mutation.
func (m *WorkflowMutation) WorkflowInstancesIDs() (ids []int) {
	for id := range m.workflow_instances {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflowInstances resets all changes to the "workflow_instances" edge.
func (m *WorkflowMutation) ResetWorkflowInstances() {
	m.workflow_instances = nil
	m.clearedworkflow_instances = false
	m.removedworkflow_instances = nil
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *WorkflowMutation) ClearDepartment() {
	m.cleareddepartment = true
	m.clearedFields[workflow.FieldDepartmentID] = struct{}{}
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *WorkflowMutation) DepartmentCleared() bool {
	return m.DepartmentIDCleared() || m.cleareddepartment
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *WorkflowMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *WorkflowMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// Where appends a list predicates to the WorkflowMutation builder.
func (m *WorkflowMutation) Where(ps ...predicate.Workflow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workflow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workflow).
func (m *WorkflowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, workflow.FieldName)
	}
	if m.description != nil {
		fields = append(fields, workflow.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, workflow.FieldType)
	}
	if m.definition != nil {
		fields = append(fields, workflow.FieldDefinition)
	}
	if m.version != nil {
		fields = append(fields, workflow.FieldVersion)
	}
	if m.is_active != nil {
		fields = append(fields, workflow.FieldIsActive)
	}
	if m.tenant_id != nil {
		fields = append(fields, workflow.FieldTenantID)
	}
	if m.department != nil {
		fields = append(fields, workflow.FieldDepartmentID)
	}
	if m.created_at != nil {
		fields = append(fields, workflow.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflow.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldName:
		return m.Name()
	case workflow.FieldDescription:
		return m.Description()
	case workflow.FieldType:
		return m.GetType()
	case workflow.FieldDefinition:
		return m.Definition()
	case workflow.FieldVersion:
		return m.Version()
	case workflow.FieldIsActive:
		return m.IsActive()
	case workflow.FieldTenantID:
		return m.TenantID()
	case workflow.FieldDepartmentID:
		return m.DepartmentID()
	case workflow.FieldCreatedAt:
		return m.CreatedAt()
	case workflow.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflow.FieldName:
		return m.OldName(ctx)
	case workflow.FieldDescription:
		return m.OldDescription(ctx)
	case workflow.FieldType:
		return m.OldType(ctx)
	case workflow.FieldDefinition:
		return m.OldDefinition(ctx)
	case workflow.FieldVersion:
		return m.OldVersion(ctx)
	case workflow.FieldIsActive:
		return m.OldIsActive(ctx)
	case workflow.FieldTenantID:
		return m.OldTenantID(ctx)
	case workflow.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case workflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Workflow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workflow.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workflow.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case workflow.FieldDefinition:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefinition(v)
		return nil
	case workflow.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case workflow.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case workflow.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case workflow.FieldDepartmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case workflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, workflow.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflow.FieldDescription) {
		fields = append(fields, workflow.FieldDescription)
	}
	if m.FieldCleared(workflow.FieldDepartmentID) {
		fields = append(fields, workflow.FieldDepartmentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowMutation) ClearField(name string) error {
	switch name {
	case workflow.FieldDescription:
		m.ClearDescription()
		return nil
	case workflow.FieldDepartmentID:
		m.ClearDepartmentID()
		return nil
	}
	return fmt.Errorf("unknown Workflow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowMutation) ResetField(name string) error {
	switch name {
	case workflow.FieldName:
		m.ResetName()
		return nil
	case workflow.FieldDescription:
		m.ResetDescription()
		return nil
	case workflow.FieldType:
		m.ResetType()
		return nil
	case workflow.FieldDefinition:
		m.ResetDefinition()
		return nil
	case workflow.FieldVersion:
		m.ResetVersion()
		return nil
	case workflow.FieldIsActive:
		m.ResetIsActive()
		return nil
	case workflow.FieldTenantID:
		m.ResetTenantID()
		return nil
	case workflow.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case workflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workflow_instances != nil {
		edges = append(edges, workflow.EdgeWorkflowInstances)
	}
	if m.department != nil {
		edges = append(edges, workflow.EdgeDepartment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeWorkflowInstances:
		ids := make([]ent.Value, 0, len(m.workflow_instances))
		for id := range m.workflow_instances {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedworkflow_instances != nil {
		edges = append(edges, workflow.EdgeWorkflowInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeWorkflowInstances:
		ids := make([]ent.Value, 0, len(m.removedworkflow_instances))
		for id := range m.removedworkflow_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkflow_instances {
		edges = append(edges, workflow.EdgeWorkflowInstances)
	}
	if m.cleareddepartment {
		edges = append(edges, workflow.EdgeDepartment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowMutation) EdgeCleared(name string) bool {
	switch name {
	case workflow.EdgeWorkflowInstances:
		return m.clearedworkflow_instances
	case workflow.EdgeDepartment:
		return m.cleareddepartment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowMutation) ClearEdge(name string) error {
	switch name {
	case workflow.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown Workflow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowMutation) ResetEdge(name string) error {
	switch name {
	case workflow.EdgeWorkflowInstances:
		m.ResetWorkflowInstances()
		return nil
	case workflow.EdgeDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown Workflow edge %s", name)
}

// WorkflowInstanceMutation represents an operation that mutates the WorkflowInstance nodes in the graph.
type WorkflowInstanceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	status          *string
	current_step    *string
	context         *[]uint8
	appendcontext   []uint8
	entity_id       *int
	addentity_id    *int
	entity_type     *string
	tenant_id       *int
	addtenant_id    *int
	started_at      *time.Time
	completed_at    *time.Time
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	workflow        *int
	clearedworkflow bool
	done            bool
	oldValue        func(context.Context) (*WorkflowInstance, error)
	predicates      []predicate.WorkflowInstance
}

var _ ent.Mutation = (*WorkflowInstanceMutation)(nil)

// workflowinstanceOption allows management of the mutation configuration using functional options.
type workflowinstanceOption func(*WorkflowInstanceMutation)

// newWorkflowInstanceMutation creates new mutation for the WorkflowInstance entity.
func newWorkflowInstanceMutation(c config, op Op, opts ...workflowinstanceOption) *WorkflowInstanceMutation {
	m := &WorkflowInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowInstanceID sets the ID field of the mutation.
func withWorkflowInstanceID(id int) workflowinstanceOption {
	return func(m *WorkflowInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowInstance
		)
		m.oldValue = func(ctx context.Context) (*WorkflowInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowInstance sets the old WorkflowInstance of the mutation.
func withWorkflowInstance(node *WorkflowInstance) workflowinstanceOption {
	return func(m *WorkflowInstanceMutation) {
		m.oldValue = func(context.Context) (*WorkflowInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowInstanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowInstanceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *WorkflowInstanceMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkflowInstanceMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkflowInstanceMutation) ResetStatus() {
	m.status = nil
}

// SetCurrentStep sets the "current_step" field.
func (m *WorkflowInstanceMutation) SetCurrentStep(s string) {
	m.current_step = &s
}

// CurrentStep returns the value of the "current_step" field in the mutation.
func (m *WorkflowInstanceMutation) CurrentStep() (r string, exists bool) {
	v := m.current_step
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentStep returns the old "current_step" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldCurrentStep(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentStep: %w", err)
	}
	return oldValue.CurrentStep, nil
}

// ClearCurrentStep clears the value of the "current_step" field.
func (m *WorkflowInstanceMutation) ClearCurrentStep() {
	m.current_step = nil
	m.clearedFields[workflowinstance.FieldCurrentStep] = struct{}{}
}

// CurrentStepCleared returns if the "current_step" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) CurrentStepCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldCurrentStep]
	return ok
}

// ResetCurrentStep resets all changes to the "current_step" field.
func (m *WorkflowInstanceMutation) ResetCurrentStep() {
	m.current_step = nil
	delete(m.clearedFields, workflowinstance.FieldCurrentStep)
}

// SetContext sets the "context" field.
func (m *WorkflowInstanceMutation) SetContext(u []uint8) {
	m.context = &u
	m.appendcontext = nil
}

// Context returns the value of the "context" field in the mutation.
func (m *WorkflowInstanceMutation) Context() (r []uint8, exists bool) {
	v := m.context
	if v == nil {
		return
	}
	return *v, true
}

// OldContext returns the old "context" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldContext(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContext: %w", err)
	}
	return oldValue.Context, nil
}

// AppendContext adds u to the "context" field.
func (m *WorkflowInstanceMutation) AppendContext(u []uint8) {
	m.appendcontext = append(m.appendcontext, u...)
}

// AppendedContext returns the list of values that were appended to the "context" field in this mutation.
func (m *WorkflowInstanceMutation) AppendedContext() ([]uint8, bool) {
	if len(m.appendcontext) == 0 {
		return nil, false
	}
	return m.appendcontext, true
}

// ClearContext clears the value of the "context" field.
func (m *WorkflowInstanceMutation) ClearContext() {
	m.context = nil
	m.appendcontext = nil
	m.clearedFields[workflowinstance.FieldContext] = struct{}{}
}

// ContextCleared returns if the "context" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) ContextCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldContext]
	return ok
}

// ResetContext resets all changes to the "context" field.
func (m *WorkflowInstanceMutation) ResetContext() {
	m.context = nil
	m.appendcontext = nil
	delete(m.clearedFields, workflowinstance.FieldContext)
}

// SetWorkflowID sets the "workflow_id" field.
func (m *WorkflowInstanceMutation) SetWorkflowID(i int) {
	m.workflow = &i
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *WorkflowInstanceMutation) WorkflowID() (r int, exists bool) {
	v := m.workflow
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldWorkflowID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *WorkflowInstanceMutation) ResetWorkflowID() {
	m.workflow = nil
}

// SetEntityID sets the "entity_id" field.
func (m *WorkflowInstanceMutation) SetEntityID(i int) {
	m.entity_id = &i
	m.addentity_id = nil
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *WorkflowInstanceMutation) EntityID() (r int, exists bool) {
	v := m.entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldEntityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// AddEntityID adds i to the "entity_id" field.
func (m *WorkflowInstanceMutation) AddEntityID(i int) {
	if m.addentity_id != nil {
		*m.addentity_id += i
	} else {
		m.addentity_id = &i
	}
}

// AddedEntityID returns the value that was added to the "entity_id" field in this mutation.
func (m *WorkflowInstanceMutation) AddedEntityID() (r int, exists bool) {
	v := m.addentity_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *WorkflowInstanceMutation) ResetEntityID() {
	m.entity_id = nil
	m.addentity_id = nil
}

// SetEntityType sets the "entity_type" field.
func (m *WorkflowInstanceMutation) SetEntityType(s string) {
	m.entity_type = &s
}

// EntityType returns the value of the "entity_type" field in the mutation.
func (m *WorkflowInstanceMutation) EntityType() (r string, exists bool) {
	v := m.entity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityType returns the old "entity_type" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldEntityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityType: %w", err)
	}
	return oldValue.EntityType, nil
}

// ResetEntityType resets all changes to the "entity_type" field.
func (m *WorkflowInstanceMutation) ResetEntityType() {
	m.entity_type = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *WorkflowInstanceMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *WorkflowInstanceMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *WorkflowInstanceMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *WorkflowInstanceMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *WorkflowInstanceMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetStartedAt sets the "started_at" field.
func (m *WorkflowInstanceMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *WorkflowInstanceMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *WorkflowInstanceMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *WorkflowInstanceMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *WorkflowInstanceMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *WorkflowInstanceMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[workflowinstance.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *WorkflowInstanceMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, workflowinstance.FieldCompletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowInstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowInstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowInstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowInstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowInstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *WorkflowInstanceMutation) ClearWorkflow() {
	m.clearedworkflow = true
	m.clearedFields[workflowinstance.FieldWorkflowID] = struct{}{}
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *WorkflowInstanceMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *WorkflowInstanceMutation) WorkflowIDs() (ids []int) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *WorkflowInstanceMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// Where appends a list predicates to the WorkflowInstanceMutation builder.
func (m *WorkflowInstanceMutation) Where(ps ...predicate.WorkflowInstance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowInstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowInstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowInstance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowInstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowInstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowInstance).
func (m *WorkflowInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowInstanceMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.status != nil {
		fields = append(fields, workflowinstance.FieldStatus)
	}
	if m.current_step != nil {
		fields = append(fields, workflowinstance.FieldCurrentStep)
	}
	if m.context != nil {
		fields = append(fields, workflowinstance.FieldContext)
	}
	if m.workflow != nil {
		fields = append(fields, workflowinstance.FieldWorkflowID)
	}
	if m.entity_id != nil {
		fields = append(fields, workflowinstance.FieldEntityID)
	}
	if m.entity_type != nil {
		fields = append(fields, workflowinstance.FieldEntityType)
	}
	if m.tenant_id != nil {
		fields = append(fields, workflowinstance.FieldTenantID)
	}
	if m.started_at != nil {
		fields = append(fields, workflowinstance.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, workflowinstance.FieldCompletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, workflowinstance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflowinstance.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowinstance.FieldStatus:
		return m.Status()
	case workflowinstance.FieldCurrentStep:
		return m.CurrentStep()
	case workflowinstance.FieldContext:
		return m.Context()
	case workflowinstance.FieldWorkflowID:
		return m.WorkflowID()
	case workflowinstance.FieldEntityID:
		return m.EntityID()
	case workflowinstance.FieldEntityType:
		return m.EntityType()
	case workflowinstance.FieldTenantID:
		return m.TenantID()
	case workflowinstance.FieldStartedAt:
		return m.StartedAt()
	case workflowinstance.FieldCompletedAt:
		return m.CompletedAt()
	case workflowinstance.FieldCreatedAt:
		return m.CreatedAt()
	case workflowinstance.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowinstance.FieldStatus:
		return m.OldStatus(ctx)
	case workflowinstance.FieldCurrentStep:
		return m.OldCurrentStep(ctx)
	case workflowinstance.FieldContext:
		return m.OldContext(ctx)
	case workflowinstance.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case workflowinstance.FieldEntityID:
		return m.OldEntityID(ctx)
	case workflowinstance.FieldEntityType:
		return m.OldEntityType(ctx)
	case workflowinstance.FieldTenantID:
		return m.OldTenantID(ctx)
	case workflowinstance.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case workflowinstance.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case workflowinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflowinstance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowinstance.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workflowinstance.FieldCurrentStep:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentStep(v)
		return nil
	case workflowinstance.FieldContext:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContext(v)
		return nil
	case workflowinstance.FieldWorkflowID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case workflowinstance.FieldEntityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case workflowinstance.FieldEntityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityType(v)
		return nil
	case workflowinstance.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case workflowinstance.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case workflowinstance.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case workflowinstance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflowinstance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowInstanceMutation) AddedFields() []string {
	var fields []string
	if m.addentity_id != nil {
		fields = append(fields, workflowinstance.FieldEntityID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, workflowinstance.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflowinstance.FieldEntityID:
		return m.AddedEntityID()
	case workflowinstance.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflowinstance.FieldEntityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntityID(v)
		return nil
	case workflowinstance.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowinstance.FieldCurrentStep) {
		fields = append(fields, workflowinstance.FieldCurrentStep)
	}
	if m.FieldCleared(workflowinstance.FieldContext) {
		fields = append(fields, workflowinstance.FieldContext)
	}
	if m.FieldCleared(workflowinstance.FieldCompletedAt) {
		fields = append(fields, workflowinstance.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowInstanceMutation) ClearField(name string) error {
	switch name {
	case workflowinstance.FieldCurrentStep:
		m.ClearCurrentStep()
		return nil
	case workflowinstance.FieldContext:
		m.ClearContext()
		return nil
	case workflowinstance.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowInstanceMutation) ResetField(name string) error {
	switch name {
	case workflowinstance.FieldStatus:
		m.ResetStatus()
		return nil
	case workflowinstance.FieldCurrentStep:
		m.ResetCurrentStep()
		return nil
	case workflowinstance.FieldContext:
		m.ResetContext()
		return nil
	case workflowinstance.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case workflowinstance.FieldEntityID:
		m.ResetEntityID()
		return nil
	case workflowinstance.FieldEntityType:
		m.ResetEntityType()
		return nil
	case workflowinstance.FieldTenantID:
		m.ResetTenantID()
		return nil
	case workflowinstance.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case workflowinstance.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case workflowinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflowinstance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflow != nil {
		edges = append(edges, workflowinstance.EdgeWorkflow)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowinstance.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowInstanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflow {
		edges = append(edges, workflowinstance.EdgeWorkflow)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowinstance.EdgeWorkflow:
		return m.clearedworkflow
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowInstanceMutation) ClearEdge(name string) error {
	switch name {
	case workflowinstance.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowInstanceMutation) ResetEdge(name string) error {
	switch name {
	case workflowinstance.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance edge %s", name)
}
