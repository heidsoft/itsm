// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"itsm-backend/ent/auditlog"
	"itsm-backend/ent/change"
	"itsm-backend/ent/ciattributedefinition"
	"itsm-backend/ent/cirelationship"
	"itsm-backend/ent/citype"
	"itsm-backend/ent/configurationitem"
	"itsm-backend/ent/conversation"
	"itsm-backend/ent/incident"
	"itsm-backend/ent/knowledgearticle"
	"itsm-backend/ent/message"
	"itsm-backend/ent/notification"
	"itsm-backend/ent/predicate"
	"itsm-backend/ent/problem"
	"itsm-backend/ent/processdefinition"
	"itsm-backend/ent/processdeployment"
	"itsm-backend/ent/processexecutionhistory"
	"itsm-backend/ent/processinstance"
	"itsm-backend/ent/processtask"
	"itsm-backend/ent/processvariable"
	"itsm-backend/ent/prompttemplate"
	"itsm-backend/ent/servicecatalog"
	"itsm-backend/ent/servicerequest"
	"itsm-backend/ent/sladefinition"
	"itsm-backend/ent/slaviolation"
	"itsm-backend/ent/tenant"
	"itsm-backend/ent/ticket"
	"itsm-backend/ent/ticketcategory"
	"itsm-backend/ent/tickettag"
	"itsm-backend/ent/tickettemplate"
	"itsm-backend/ent/toolinvocation"
	"itsm-backend/ent/user"
	"itsm-backend/ent/workflow"
	"itsm-backend/ent/workflowinstance"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuditLog                = "AuditLog"
	TypeCIAttributeDefinition   = "CIAttributeDefinition"
	TypeCIRelationship          = "CIRelationship"
	TypeCIType                  = "CIType"
	TypeChange                  = "Change"
	TypeConfigurationItem       = "ConfigurationItem"
	TypeConversation            = "Conversation"
	TypeIncident                = "Incident"
	TypeKnowledgeArticle        = "KnowledgeArticle"
	TypeMessage                 = "Message"
	TypeNotification            = "Notification"
	TypeProblem                 = "Problem"
	TypeProcessDefinition       = "ProcessDefinition"
	TypeProcessDeployment       = "ProcessDeployment"
	TypeProcessExecutionHistory = "ProcessExecutionHistory"
	TypeProcessInstance         = "ProcessInstance"
	TypeProcessTask             = "ProcessTask"
	TypeProcessVariable         = "ProcessVariable"
	TypePromptTemplate          = "PromptTemplate"
	TypeSLADefinition           = "SLADefinition"
	TypeSLAViolation            = "SLAViolation"
	TypeServiceCatalog          = "ServiceCatalog"
	TypeServiceRequest          = "ServiceRequest"
	TypeTenant                  = "Tenant"
	TypeTicket                  = "Ticket"
	TypeTicketCategory          = "TicketCategory"
	TypeTicketTag               = "TicketTag"
	TypeTicketTemplate          = "TicketTemplate"
	TypeToolInvocation          = "ToolInvocation"
	TypeUser                    = "User"
	TypeWorkflow                = "Workflow"
	TypeWorkflowInstance        = "WorkflowInstance"
)

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	tenant_id      *int
	addtenant_id   *int
	user_id        *int
	adduser_id     *int
	request_id     *string
	ip             *string
	resource       *string
	action         *string
	_path          *string
	method         *string
	status_code    *int
	addstatus_code *int
	request_body   *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AuditLog, error)
	predicates     []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id int) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *AuditLogMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AuditLogMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *AuditLogMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *AuditLogMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AuditLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[auditlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AuditLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, auditlog.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *AuditLogMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuditLogMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *AuditLogMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AuditLogMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *AuditLogMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[auditlog.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AuditLogMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuditLogMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, auditlog.FieldUserID)
}

// SetRequestID sets the "request_id" field.
func (m *AuditLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *AuditLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *AuditLogMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[auditlog.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *AuditLogMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *AuditLogMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, auditlog.FieldRequestID)
}

// SetIP sets the "ip" field.
func (m *AuditLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AuditLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AuditLogMutation) ResetIP() {
	m.ip = nil
}

// SetResource sets the "resource" field.
func (m *AuditLogMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the value of the "resource" field in the mutation.
func (m *AuditLogMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old "resource" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ResetResource resets all changes to the "resource" field.
func (m *AuditLogMutation) ResetResource() {
	m.resource = nil
}

// SetAction sets the "action" field.
func (m *AuditLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *AuditLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *AuditLogMutation) ResetAction() {
	m.action = nil
}

// SetPath sets the "path" field.
func (m *AuditLogMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *AuditLogMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *AuditLogMutation) ResetPath() {
	m._path = nil
}

// SetMethod sets the "method" field.
func (m *AuditLogMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *AuditLogMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *AuditLogMutation) ResetMethod() {
	m.method = nil
}

// SetStatusCode sets the "status_code" field.
func (m *AuditLogMutation) SetStatusCode(i int) {
	m.status_code = &i
	m.addstatus_code = nil
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *AuditLogMutation) StatusCode() (r int, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldStatusCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// AddStatusCode adds i to the "status_code" field.
func (m *AuditLogMutation) AddStatusCode(i int) {
	if m.addstatus_code != nil {
		*m.addstatus_code += i
	} else {
		m.addstatus_code = &i
	}
}

// AddedStatusCode returns the value that was added to the "status_code" field in this mutation.
func (m *AuditLogMutation) AddedStatusCode() (r int, exists bool) {
	v := m.addstatus_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *AuditLogMutation) ResetStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
}

// SetRequestBody sets the "request_body" field.
func (m *AuditLogMutation) SetRequestBody(s string) {
	m.request_body = &s
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *AuditLogMutation) RequestBody() (r string, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestBody(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// ClearRequestBody clears the value of the "request_body" field.
func (m *AuditLogMutation) ClearRequestBody() {
	m.request_body = nil
	m.clearedFields[auditlog.FieldRequestBody] = struct{}{}
}

// RequestBodyCleared returns if the "request_body" field was cleared in this mutation.
func (m *AuditLogMutation) RequestBodyCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRequestBody]
	return ok
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *AuditLogMutation) ResetRequestBody() {
	m.request_body = nil
	delete(m.clearedFields, auditlog.FieldRequestBody)
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, auditlog.FieldCreatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.request_id != nil {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.ip != nil {
		fields = append(fields, auditlog.FieldIP)
	}
	if m.resource != nil {
		fields = append(fields, auditlog.FieldResource)
	}
	if m.action != nil {
		fields = append(fields, auditlog.FieldAction)
	}
	if m._path != nil {
		fields = append(fields, auditlog.FieldPath)
	}
	if m.method != nil {
		fields = append(fields, auditlog.FieldMethod)
	}
	if m.status_code != nil {
		fields = append(fields, auditlog.FieldStatusCode)
	}
	if m.request_body != nil {
		fields = append(fields, auditlog.FieldRequestBody)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldCreatedAt:
		return m.CreatedAt()
	case auditlog.FieldTenantID:
		return m.TenantID()
	case auditlog.FieldUserID:
		return m.UserID()
	case auditlog.FieldRequestID:
		return m.RequestID()
	case auditlog.FieldIP:
		return m.IP()
	case auditlog.FieldResource:
		return m.Resource()
	case auditlog.FieldAction:
		return m.Action()
	case auditlog.FieldPath:
		return m.Path()
	case auditlog.FieldMethod:
		return m.Method()
	case auditlog.FieldStatusCode:
		return m.StatusCode()
	case auditlog.FieldRequestBody:
		return m.RequestBody()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case auditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case auditlog.FieldUserID:
		return m.OldUserID(ctx)
	case auditlog.FieldRequestID:
		return m.OldRequestID(ctx)
	case auditlog.FieldIP:
		return m.OldIP(ctx)
	case auditlog.FieldResource:
		return m.OldResource(ctx)
	case auditlog.FieldAction:
		return m.OldAction(ctx)
	case auditlog.FieldPath:
		return m.OldPath(ctx)
	case auditlog.FieldMethod:
		return m.OldMethod(ctx)
	case auditlog.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case auditlog.FieldRequestBody:
		return m.OldRequestBody(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case auditlog.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case auditlog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case auditlog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case auditlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case auditlog.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case auditlog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case auditlog.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case auditlog.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case auditlog.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case auditlog.FieldRequestBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.addstatus_code != nil {
		fields = append(fields, auditlog.FieldStatusCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldTenantID:
		return m.AddedTenantID()
	case auditlog.FieldUserID:
		return m.AddedUserID()
	case auditlog.FieldStatusCode:
		return m.AddedStatusCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case auditlog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case auditlog.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusCode(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldTenantID) {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.FieldCleared(auditlog.FieldUserID) {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.FieldCleared(auditlog.FieldRequestID) {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.FieldCleared(auditlog.FieldRequestBody) {
		fields = append(fields, auditlog.FieldRequestBody)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case auditlog.FieldUserID:
		m.ClearUserID()
		return nil
	case auditlog.FieldRequestID:
		m.ClearRequestID()
		return nil
	case auditlog.FieldRequestBody:
		m.ClearRequestBody()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case auditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case auditlog.FieldUserID:
		m.ResetUserID()
		return nil
	case auditlog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case auditlog.FieldIP:
		m.ResetIP()
		return nil
	case auditlog.FieldResource:
		m.ResetResource()
		return nil
	case auditlog.FieldAction:
		m.ResetAction()
		return nil
	case auditlog.FieldPath:
		m.ResetPath()
		return nil
	case auditlog.FieldMethod:
		m.ResetMethod()
		return nil
	case auditlog.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case auditlog.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// CIAttributeDefinitionMutation represents an operation that mutates the CIAttributeDefinition nodes in the graph.
type CIAttributeDefinitionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	display_name     *string
	_type            *string
	required         *bool
	_unique          *bool
	default_value    *string
	validation_rules *string
	ci_type_id       *int
	addci_type_id    *int
	tenant_id        *int
	addtenant_id     *int
	is_active        *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*CIAttributeDefinition, error)
	predicates       []predicate.CIAttributeDefinition
}

var _ ent.Mutation = (*CIAttributeDefinitionMutation)(nil)

// ciattributedefinitionOption allows management of the mutation configuration using functional options.
type ciattributedefinitionOption func(*CIAttributeDefinitionMutation)

// newCIAttributeDefinitionMutation creates new mutation for the CIAttributeDefinition entity.
func newCIAttributeDefinitionMutation(c config, op Op, opts ...ciattributedefinitionOption) *CIAttributeDefinitionMutation {
	m := &CIAttributeDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeCIAttributeDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCIAttributeDefinitionID sets the ID field of the mutation.
func withCIAttributeDefinitionID(id int) ciattributedefinitionOption {
	return func(m *CIAttributeDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *CIAttributeDefinition
		)
		m.oldValue = func(ctx context.Context) (*CIAttributeDefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CIAttributeDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCIAttributeDefinition sets the old CIAttributeDefinition of the mutation.
func withCIAttributeDefinition(node *CIAttributeDefinition) ciattributedefinitionOption {
	return func(m *CIAttributeDefinitionMutation) {
		m.oldValue = func(context.Context) (*CIAttributeDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CIAttributeDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CIAttributeDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CIAttributeDefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CIAttributeDefinitionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CIAttributeDefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CIAttributeDefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CIAttributeDefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CIAttributeDefinitionMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *CIAttributeDefinitionMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *CIAttributeDefinitionMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *CIAttributeDefinitionMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetType sets the "type" field.
func (m *CIAttributeDefinitionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CIAttributeDefinitionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CIAttributeDefinitionMutation) ResetType() {
	m._type = nil
}

// SetRequired sets the "required" field.
func (m *CIAttributeDefinitionMutation) SetRequired(b bool) {
	m.required = &b
}

// Required returns the value of the "required" field in the mutation.
func (m *CIAttributeDefinitionMutation) Required() (r bool, exists bool) {
	v := m.required
	if v == nil {
		return
	}
	return *v, true
}

// OldRequired returns the old "required" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequired: %w", err)
	}
	return oldValue.Required, nil
}

// ResetRequired resets all changes to the "required" field.
func (m *CIAttributeDefinitionMutation) ResetRequired() {
	m.required = nil
}

// SetUnique sets the "unique" field.
func (m *CIAttributeDefinitionMutation) SetUnique(b bool) {
	m._unique = &b
}

// Unique returns the value of the "unique" field in the mutation.
func (m *CIAttributeDefinitionMutation) Unique() (r bool, exists bool) {
	v := m._unique
	if v == nil {
		return
	}
	return *v, true
}

// OldUnique returns the old "unique" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldUnique(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnique is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnique requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnique: %w", err)
	}
	return oldValue.Unique, nil
}

// ResetUnique resets all changes to the "unique" field.
func (m *CIAttributeDefinitionMutation) ResetUnique() {
	m._unique = nil
}

// SetDefaultValue sets the "default_value" field.
func (m *CIAttributeDefinitionMutation) SetDefaultValue(s string) {
	m.default_value = &s
}

// DefaultValue returns the value of the "default_value" field in the mutation.
func (m *CIAttributeDefinitionMutation) DefaultValue() (r string, exists bool) {
	v := m.default_value
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultValue returns the old "default_value" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldDefaultValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultValue: %w", err)
	}
	return oldValue.DefaultValue, nil
}

// ClearDefaultValue clears the value of the "default_value" field.
func (m *CIAttributeDefinitionMutation) ClearDefaultValue() {
	m.default_value = nil
	m.clearedFields[ciattributedefinition.FieldDefaultValue] = struct{}{}
}

// DefaultValueCleared returns if the "default_value" field was cleared in this mutation.
func (m *CIAttributeDefinitionMutation) DefaultValueCleared() bool {
	_, ok := m.clearedFields[ciattributedefinition.FieldDefaultValue]
	return ok
}

// ResetDefaultValue resets all changes to the "default_value" field.
func (m *CIAttributeDefinitionMutation) ResetDefaultValue() {
	m.default_value = nil
	delete(m.clearedFields, ciattributedefinition.FieldDefaultValue)
}

// SetValidationRules sets the "validation_rules" field.
func (m *CIAttributeDefinitionMutation) SetValidationRules(s string) {
	m.validation_rules = &s
}

// ValidationRules returns the value of the "validation_rules" field in the mutation.
func (m *CIAttributeDefinitionMutation) ValidationRules() (r string, exists bool) {
	v := m.validation_rules
	if v == nil {
		return
	}
	return *v, true
}

// OldValidationRules returns the old "validation_rules" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldValidationRules(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidationRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidationRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidationRules: %w", err)
	}
	return oldValue.ValidationRules, nil
}

// ClearValidationRules clears the value of the "validation_rules" field.
func (m *CIAttributeDefinitionMutation) ClearValidationRules() {
	m.validation_rules = nil
	m.clearedFields[ciattributedefinition.FieldValidationRules] = struct{}{}
}

// ValidationRulesCleared returns if the "validation_rules" field was cleared in this mutation.
func (m *CIAttributeDefinitionMutation) ValidationRulesCleared() bool {
	_, ok := m.clearedFields[ciattributedefinition.FieldValidationRules]
	return ok
}

// ResetValidationRules resets all changes to the "validation_rules" field.
func (m *CIAttributeDefinitionMutation) ResetValidationRules() {
	m.validation_rules = nil
	delete(m.clearedFields, ciattributedefinition.FieldValidationRules)
}

// SetCiTypeID sets the "ci_type_id" field.
func (m *CIAttributeDefinitionMutation) SetCiTypeID(i int) {
	m.ci_type_id = &i
	m.addci_type_id = nil
}

// CiTypeID returns the value of the "ci_type_id" field in the mutation.
func (m *CIAttributeDefinitionMutation) CiTypeID() (r int, exists bool) {
	v := m.ci_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCiTypeID returns the old "ci_type_id" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldCiTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCiTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCiTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCiTypeID: %w", err)
	}
	return oldValue.CiTypeID, nil
}

// AddCiTypeID adds i to the "ci_type_id" field.
func (m *CIAttributeDefinitionMutation) AddCiTypeID(i int) {
	if m.addci_type_id != nil {
		*m.addci_type_id += i
	} else {
		m.addci_type_id = &i
	}
}

// AddedCiTypeID returns the value that was added to the "ci_type_id" field in this mutation.
func (m *CIAttributeDefinitionMutation) AddedCiTypeID() (r int, exists bool) {
	v := m.addci_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCiTypeID resets all changes to the "ci_type_id" field.
func (m *CIAttributeDefinitionMutation) ResetCiTypeID() {
	m.ci_type_id = nil
	m.addci_type_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *CIAttributeDefinitionMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CIAttributeDefinitionMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *CIAttributeDefinitionMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *CIAttributeDefinitionMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CIAttributeDefinitionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetIsActive sets the "is_active" field.
func (m *CIAttributeDefinitionMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *CIAttributeDefinitionMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *CIAttributeDefinitionMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CIAttributeDefinitionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CIAttributeDefinitionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CIAttributeDefinitionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CIAttributeDefinitionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CIAttributeDefinitionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CIAttributeDefinition entity.
// If the CIAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIAttributeDefinitionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CIAttributeDefinitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the CIAttributeDefinitionMutation builder.
func (m *CIAttributeDefinitionMutation) Where(ps ...predicate.CIAttributeDefinition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CIAttributeDefinitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CIAttributeDefinitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CIAttributeDefinition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CIAttributeDefinitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CIAttributeDefinitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CIAttributeDefinition).
func (m *CIAttributeDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CIAttributeDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, ciattributedefinition.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, ciattributedefinition.FieldDisplayName)
	}
	if m._type != nil {
		fields = append(fields, ciattributedefinition.FieldType)
	}
	if m.required != nil {
		fields = append(fields, ciattributedefinition.FieldRequired)
	}
	if m._unique != nil {
		fields = append(fields, ciattributedefinition.FieldUnique)
	}
	if m.default_value != nil {
		fields = append(fields, ciattributedefinition.FieldDefaultValue)
	}
	if m.validation_rules != nil {
		fields = append(fields, ciattributedefinition.FieldValidationRules)
	}
	if m.ci_type_id != nil {
		fields = append(fields, ciattributedefinition.FieldCiTypeID)
	}
	if m.tenant_id != nil {
		fields = append(fields, ciattributedefinition.FieldTenantID)
	}
	if m.is_active != nil {
		fields = append(fields, ciattributedefinition.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, ciattributedefinition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ciattributedefinition.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CIAttributeDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ciattributedefinition.FieldName:
		return m.Name()
	case ciattributedefinition.FieldDisplayName:
		return m.DisplayName()
	case ciattributedefinition.FieldType:
		return m.GetType()
	case ciattributedefinition.FieldRequired:
		return m.Required()
	case ciattributedefinition.FieldUnique:
		return m.Unique()
	case ciattributedefinition.FieldDefaultValue:
		return m.DefaultValue()
	case ciattributedefinition.FieldValidationRules:
		return m.ValidationRules()
	case ciattributedefinition.FieldCiTypeID:
		return m.CiTypeID()
	case ciattributedefinition.FieldTenantID:
		return m.TenantID()
	case ciattributedefinition.FieldIsActive:
		return m.IsActive()
	case ciattributedefinition.FieldCreatedAt:
		return m.CreatedAt()
	case ciattributedefinition.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CIAttributeDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ciattributedefinition.FieldName:
		return m.OldName(ctx)
	case ciattributedefinition.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case ciattributedefinition.FieldType:
		return m.OldType(ctx)
	case ciattributedefinition.FieldRequired:
		return m.OldRequired(ctx)
	case ciattributedefinition.FieldUnique:
		return m.OldUnique(ctx)
	case ciattributedefinition.FieldDefaultValue:
		return m.OldDefaultValue(ctx)
	case ciattributedefinition.FieldValidationRules:
		return m.OldValidationRules(ctx)
	case ciattributedefinition.FieldCiTypeID:
		return m.OldCiTypeID(ctx)
	case ciattributedefinition.FieldTenantID:
		return m.OldTenantID(ctx)
	case ciattributedefinition.FieldIsActive:
		return m.OldIsActive(ctx)
	case ciattributedefinition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ciattributedefinition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CIAttributeDefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CIAttributeDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ciattributedefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ciattributedefinition.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case ciattributedefinition.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case ciattributedefinition.FieldRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequired(v)
		return nil
	case ciattributedefinition.FieldUnique:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnique(v)
		return nil
	case ciattributedefinition.FieldDefaultValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultValue(v)
		return nil
	case ciattributedefinition.FieldValidationRules:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidationRules(v)
		return nil
	case ciattributedefinition.FieldCiTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCiTypeID(v)
		return nil
	case ciattributedefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ciattributedefinition.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case ciattributedefinition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ciattributedefinition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CIAttributeDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CIAttributeDefinitionMutation) AddedFields() []string {
	var fields []string
	if m.addci_type_id != nil {
		fields = append(fields, ciattributedefinition.FieldCiTypeID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, ciattributedefinition.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CIAttributeDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ciattributedefinition.FieldCiTypeID:
		return m.AddedCiTypeID()
	case ciattributedefinition.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CIAttributeDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ciattributedefinition.FieldCiTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCiTypeID(v)
		return nil
	case ciattributedefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown CIAttributeDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CIAttributeDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ciattributedefinition.FieldDefaultValue) {
		fields = append(fields, ciattributedefinition.FieldDefaultValue)
	}
	if m.FieldCleared(ciattributedefinition.FieldValidationRules) {
		fields = append(fields, ciattributedefinition.FieldValidationRules)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CIAttributeDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CIAttributeDefinitionMutation) ClearField(name string) error {
	switch name {
	case ciattributedefinition.FieldDefaultValue:
		m.ClearDefaultValue()
		return nil
	case ciattributedefinition.FieldValidationRules:
		m.ClearValidationRules()
		return nil
	}
	return fmt.Errorf("unknown CIAttributeDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CIAttributeDefinitionMutation) ResetField(name string) error {
	switch name {
	case ciattributedefinition.FieldName:
		m.ResetName()
		return nil
	case ciattributedefinition.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case ciattributedefinition.FieldType:
		m.ResetType()
		return nil
	case ciattributedefinition.FieldRequired:
		m.ResetRequired()
		return nil
	case ciattributedefinition.FieldUnique:
		m.ResetUnique()
		return nil
	case ciattributedefinition.FieldDefaultValue:
		m.ResetDefaultValue()
		return nil
	case ciattributedefinition.FieldValidationRules:
		m.ResetValidationRules()
		return nil
	case ciattributedefinition.FieldCiTypeID:
		m.ResetCiTypeID()
		return nil
	case ciattributedefinition.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ciattributedefinition.FieldIsActive:
		m.ResetIsActive()
		return nil
	case ciattributedefinition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ciattributedefinition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CIAttributeDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CIAttributeDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CIAttributeDefinitionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CIAttributeDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CIAttributeDefinitionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CIAttributeDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CIAttributeDefinitionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CIAttributeDefinitionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CIAttributeDefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CIAttributeDefinitionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CIAttributeDefinition edge %s", name)
}

// CIRelationshipMutation represents an operation that mutates the CIRelationship nodes in the graph.
type CIRelationshipMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	source_ci_id            *int
	addsource_ci_id         *int
	target_ci_id            *int
	addtarget_ci_id         *int
	relationship_type_id    *int
	addrelationship_type_id *int
	description             *string
	tenant_id               *int
	addtenant_id            *int
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*CIRelationship, error)
	predicates              []predicate.CIRelationship
}

var _ ent.Mutation = (*CIRelationshipMutation)(nil)

// cirelationshipOption allows management of the mutation configuration using functional options.
type cirelationshipOption func(*CIRelationshipMutation)

// newCIRelationshipMutation creates new mutation for the CIRelationship entity.
func newCIRelationshipMutation(c config, op Op, opts ...cirelationshipOption) *CIRelationshipMutation {
	m := &CIRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeCIRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCIRelationshipID sets the ID field of the mutation.
func withCIRelationshipID(id int) cirelationshipOption {
	return func(m *CIRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *CIRelationship
		)
		m.oldValue = func(ctx context.Context) (*CIRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CIRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCIRelationship sets the old CIRelationship of the mutation.
func withCIRelationship(node *CIRelationship) cirelationshipOption {
	return func(m *CIRelationshipMutation) {
		m.oldValue = func(context.Context) (*CIRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CIRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CIRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CIRelationshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CIRelationshipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CIRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceCiID sets the "source_ci_id" field.
func (m *CIRelationshipMutation) SetSourceCiID(i int) {
	m.source_ci_id = &i
	m.addsource_ci_id = nil
}

// SourceCiID returns the value of the "source_ci_id" field in the mutation.
func (m *CIRelationshipMutation) SourceCiID() (r int, exists bool) {
	v := m.source_ci_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceCiID returns the old "source_ci_id" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldSourceCiID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceCiID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceCiID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceCiID: %w", err)
	}
	return oldValue.SourceCiID, nil
}

// AddSourceCiID adds i to the "source_ci_id" field.
func (m *CIRelationshipMutation) AddSourceCiID(i int) {
	if m.addsource_ci_id != nil {
		*m.addsource_ci_id += i
	} else {
		m.addsource_ci_id = &i
	}
}

// AddedSourceCiID returns the value that was added to the "source_ci_id" field in this mutation.
func (m *CIRelationshipMutation) AddedSourceCiID() (r int, exists bool) {
	v := m.addsource_ci_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSourceCiID resets all changes to the "source_ci_id" field.
func (m *CIRelationshipMutation) ResetSourceCiID() {
	m.source_ci_id = nil
	m.addsource_ci_id = nil
}

// SetTargetCiID sets the "target_ci_id" field.
func (m *CIRelationshipMutation) SetTargetCiID(i int) {
	m.target_ci_id = &i
	m.addtarget_ci_id = nil
}

// TargetCiID returns the value of the "target_ci_id" field in the mutation.
func (m *CIRelationshipMutation) TargetCiID() (r int, exists bool) {
	v := m.target_ci_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetCiID returns the old "target_ci_id" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldTargetCiID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetCiID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetCiID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetCiID: %w", err)
	}
	return oldValue.TargetCiID, nil
}

// AddTargetCiID adds i to the "target_ci_id" field.
func (m *CIRelationshipMutation) AddTargetCiID(i int) {
	if m.addtarget_ci_id != nil {
		*m.addtarget_ci_id += i
	} else {
		m.addtarget_ci_id = &i
	}
}

// AddedTargetCiID returns the value that was added to the "target_ci_id" field in this mutation.
func (m *CIRelationshipMutation) AddedTargetCiID() (r int, exists bool) {
	v := m.addtarget_ci_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTargetCiID resets all changes to the "target_ci_id" field.
func (m *CIRelationshipMutation) ResetTargetCiID() {
	m.target_ci_id = nil
	m.addtarget_ci_id = nil
}

// SetRelationshipTypeID sets the "relationship_type_id" field.
func (m *CIRelationshipMutation) SetRelationshipTypeID(i int) {
	m.relationship_type_id = &i
	m.addrelationship_type_id = nil
}

// RelationshipTypeID returns the value of the "relationship_type_id" field in the mutation.
func (m *CIRelationshipMutation) RelationshipTypeID() (r int, exists bool) {
	v := m.relationship_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationshipTypeID returns the old "relationship_type_id" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldRelationshipTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationshipTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationshipTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationshipTypeID: %w", err)
	}
	return oldValue.RelationshipTypeID, nil
}

// AddRelationshipTypeID adds i to the "relationship_type_id" field.
func (m *CIRelationshipMutation) AddRelationshipTypeID(i int) {
	if m.addrelationship_type_id != nil {
		*m.addrelationship_type_id += i
	} else {
		m.addrelationship_type_id = &i
	}
}

// AddedRelationshipTypeID returns the value that was added to the "relationship_type_id" field in this mutation.
func (m *CIRelationshipMutation) AddedRelationshipTypeID() (r int, exists bool) {
	v := m.addrelationship_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRelationshipTypeID resets all changes to the "relationship_type_id" field.
func (m *CIRelationshipMutation) ResetRelationshipTypeID() {
	m.relationship_type_id = nil
	m.addrelationship_type_id = nil
}

// SetDescription sets the "description" field.
func (m *CIRelationshipMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CIRelationshipMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CIRelationshipMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[cirelationship.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CIRelationshipMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[cirelationship.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CIRelationshipMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, cirelationship.FieldDescription)
}

// SetTenantID sets the "tenant_id" field.
func (m *CIRelationshipMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CIRelationshipMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *CIRelationshipMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *CIRelationshipMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CIRelationshipMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CIRelationshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CIRelationshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CIRelationshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CIRelationshipMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CIRelationshipMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CIRelationship entity.
// If the CIRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIRelationshipMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CIRelationshipMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the CIRelationshipMutation builder.
func (m *CIRelationshipMutation) Where(ps ...predicate.CIRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CIRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CIRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CIRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CIRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CIRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CIRelationship).
func (m *CIRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CIRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.source_ci_id != nil {
		fields = append(fields, cirelationship.FieldSourceCiID)
	}
	if m.target_ci_id != nil {
		fields = append(fields, cirelationship.FieldTargetCiID)
	}
	if m.relationship_type_id != nil {
		fields = append(fields, cirelationship.FieldRelationshipTypeID)
	}
	if m.description != nil {
		fields = append(fields, cirelationship.FieldDescription)
	}
	if m.tenant_id != nil {
		fields = append(fields, cirelationship.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, cirelationship.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cirelationship.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CIRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cirelationship.FieldSourceCiID:
		return m.SourceCiID()
	case cirelationship.FieldTargetCiID:
		return m.TargetCiID()
	case cirelationship.FieldRelationshipTypeID:
		return m.RelationshipTypeID()
	case cirelationship.FieldDescription:
		return m.Description()
	case cirelationship.FieldTenantID:
		return m.TenantID()
	case cirelationship.FieldCreatedAt:
		return m.CreatedAt()
	case cirelationship.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CIRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cirelationship.FieldSourceCiID:
		return m.OldSourceCiID(ctx)
	case cirelationship.FieldTargetCiID:
		return m.OldTargetCiID(ctx)
	case cirelationship.FieldRelationshipTypeID:
		return m.OldRelationshipTypeID(ctx)
	case cirelationship.FieldDescription:
		return m.OldDescription(ctx)
	case cirelationship.FieldTenantID:
		return m.OldTenantID(ctx)
	case cirelationship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cirelationship.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CIRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CIRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cirelationship.FieldSourceCiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceCiID(v)
		return nil
	case cirelationship.FieldTargetCiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetCiID(v)
		return nil
	case cirelationship.FieldRelationshipTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationshipTypeID(v)
		return nil
	case cirelationship.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case cirelationship.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case cirelationship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cirelationship.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CIRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CIRelationshipMutation) AddedFields() []string {
	var fields []string
	if m.addsource_ci_id != nil {
		fields = append(fields, cirelationship.FieldSourceCiID)
	}
	if m.addtarget_ci_id != nil {
		fields = append(fields, cirelationship.FieldTargetCiID)
	}
	if m.addrelationship_type_id != nil {
		fields = append(fields, cirelationship.FieldRelationshipTypeID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, cirelationship.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CIRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cirelationship.FieldSourceCiID:
		return m.AddedSourceCiID()
	case cirelationship.FieldTargetCiID:
		return m.AddedTargetCiID()
	case cirelationship.FieldRelationshipTypeID:
		return m.AddedRelationshipTypeID()
	case cirelationship.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CIRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cirelationship.FieldSourceCiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSourceCiID(v)
		return nil
	case cirelationship.FieldTargetCiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetCiID(v)
		return nil
	case cirelationship.FieldRelationshipTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelationshipTypeID(v)
		return nil
	case cirelationship.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown CIRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CIRelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cirelationship.FieldDescription) {
		fields = append(fields, cirelationship.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CIRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CIRelationshipMutation) ClearField(name string) error {
	switch name {
	case cirelationship.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CIRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CIRelationshipMutation) ResetField(name string) error {
	switch name {
	case cirelationship.FieldSourceCiID:
		m.ResetSourceCiID()
		return nil
	case cirelationship.FieldTargetCiID:
		m.ResetTargetCiID()
		return nil
	case cirelationship.FieldRelationshipTypeID:
		m.ResetRelationshipTypeID()
		return nil
	case cirelationship.FieldDescription:
		m.ResetDescription()
		return nil
	case cirelationship.FieldTenantID:
		m.ResetTenantID()
		return nil
	case cirelationship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cirelationship.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CIRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CIRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CIRelationshipMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CIRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CIRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CIRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CIRelationshipMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CIRelationshipMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CIRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CIRelationshipMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CIRelationship edge %s", name)
}

// CITypeMutation represents an operation that mutates the CIType nodes in the graph.
type CITypeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	description      *string
	icon             *string
	color            *string
	attribute_schema *string
	tenant_id        *int
	addtenant_id     *int
	is_active        *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*CIType, error)
	predicates       []predicate.CIType
}

var _ ent.Mutation = (*CITypeMutation)(nil)

// citypeOption allows management of the mutation configuration using functional options.
type citypeOption func(*CITypeMutation)

// newCITypeMutation creates new mutation for the CIType entity.
func newCITypeMutation(c config, op Op, opts ...citypeOption) *CITypeMutation {
	m := &CITypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCIType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCITypeID sets the ID field of the mutation.
func withCITypeID(id int) citypeOption {
	return func(m *CITypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CIType
		)
		m.oldValue = func(ctx context.Context) (*CIType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CIType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCIType sets the old CIType of the mutation.
func withCIType(node *CIType) citypeOption {
	return func(m *CITypeMutation) {
		m.oldValue = func(context.Context) (*CIType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CITypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CITypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CITypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CITypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CIType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CITypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CITypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CITypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CITypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CITypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CITypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[citype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CITypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[citype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CITypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, citype.FieldDescription)
}

// SetIcon sets the "icon" field.
func (m *CITypeMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *CITypeMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *CITypeMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[citype.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *CITypeMutation) IconCleared() bool {
	_, ok := m.clearedFields[citype.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *CITypeMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, citype.FieldIcon)
}

// SetColor sets the "color" field.
func (m *CITypeMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *CITypeMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *CITypeMutation) ClearColor() {
	m.color = nil
	m.clearedFields[citype.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *CITypeMutation) ColorCleared() bool {
	_, ok := m.clearedFields[citype.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *CITypeMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, citype.FieldColor)
}

// SetAttributeSchema sets the "attribute_schema" field.
func (m *CITypeMutation) SetAttributeSchema(s string) {
	m.attribute_schema = &s
}

// AttributeSchema returns the value of the "attribute_schema" field in the mutation.
func (m *CITypeMutation) AttributeSchema() (r string, exists bool) {
	v := m.attribute_schema
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributeSchema returns the old "attribute_schema" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldAttributeSchema(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributeSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributeSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributeSchema: %w", err)
	}
	return oldValue.AttributeSchema, nil
}

// ClearAttributeSchema clears the value of the "attribute_schema" field.
func (m *CITypeMutation) ClearAttributeSchema() {
	m.attribute_schema = nil
	m.clearedFields[citype.FieldAttributeSchema] = struct{}{}
}

// AttributeSchemaCleared returns if the "attribute_schema" field was cleared in this mutation.
func (m *CITypeMutation) AttributeSchemaCleared() bool {
	_, ok := m.clearedFields[citype.FieldAttributeSchema]
	return ok
}

// ResetAttributeSchema resets all changes to the "attribute_schema" field.
func (m *CITypeMutation) ResetAttributeSchema() {
	m.attribute_schema = nil
	delete(m.clearedFields, citype.FieldAttributeSchema)
}

// SetTenantID sets the "tenant_id" field.
func (m *CITypeMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CITypeMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *CITypeMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *CITypeMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CITypeMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetIsActive sets the "is_active" field.
func (m *CITypeMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *CITypeMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *CITypeMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CITypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CITypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CITypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CITypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CITypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CIType entity.
// If the CIType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CITypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CITypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the CITypeMutation builder.
func (m *CITypeMutation) Where(ps ...predicate.CIType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CITypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CITypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CIType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CITypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CITypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CIType).
func (m *CITypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CITypeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, citype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, citype.FieldDescription)
	}
	if m.icon != nil {
		fields = append(fields, citype.FieldIcon)
	}
	if m.color != nil {
		fields = append(fields, citype.FieldColor)
	}
	if m.attribute_schema != nil {
		fields = append(fields, citype.FieldAttributeSchema)
	}
	if m.tenant_id != nil {
		fields = append(fields, citype.FieldTenantID)
	}
	if m.is_active != nil {
		fields = append(fields, citype.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, citype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, citype.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CITypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case citype.FieldName:
		return m.Name()
	case citype.FieldDescription:
		return m.Description()
	case citype.FieldIcon:
		return m.Icon()
	case citype.FieldColor:
		return m.Color()
	case citype.FieldAttributeSchema:
		return m.AttributeSchema()
	case citype.FieldTenantID:
		return m.TenantID()
	case citype.FieldIsActive:
		return m.IsActive()
	case citype.FieldCreatedAt:
		return m.CreatedAt()
	case citype.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CITypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case citype.FieldName:
		return m.OldName(ctx)
	case citype.FieldDescription:
		return m.OldDescription(ctx)
	case citype.FieldIcon:
		return m.OldIcon(ctx)
	case citype.FieldColor:
		return m.OldColor(ctx)
	case citype.FieldAttributeSchema:
		return m.OldAttributeSchema(ctx)
	case citype.FieldTenantID:
		return m.OldTenantID(ctx)
	case citype.FieldIsActive:
		return m.OldIsActive(ctx)
	case citype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case citype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CIType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CITypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case citype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case citype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case citype.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case citype.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case citype.FieldAttributeSchema:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributeSchema(v)
		return nil
	case citype.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case citype.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case citype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case citype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CIType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CITypeMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, citype.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CITypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case citype.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CITypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case citype.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown CIType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CITypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(citype.FieldDescription) {
		fields = append(fields, citype.FieldDescription)
	}
	if m.FieldCleared(citype.FieldIcon) {
		fields = append(fields, citype.FieldIcon)
	}
	if m.FieldCleared(citype.FieldColor) {
		fields = append(fields, citype.FieldColor)
	}
	if m.FieldCleared(citype.FieldAttributeSchema) {
		fields = append(fields, citype.FieldAttributeSchema)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CITypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CITypeMutation) ClearField(name string) error {
	switch name {
	case citype.FieldDescription:
		m.ClearDescription()
		return nil
	case citype.FieldIcon:
		m.ClearIcon()
		return nil
	case citype.FieldColor:
		m.ClearColor()
		return nil
	case citype.FieldAttributeSchema:
		m.ClearAttributeSchema()
		return nil
	}
	return fmt.Errorf("unknown CIType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CITypeMutation) ResetField(name string) error {
	switch name {
	case citype.FieldName:
		m.ResetName()
		return nil
	case citype.FieldDescription:
		m.ResetDescription()
		return nil
	case citype.FieldIcon:
		m.ResetIcon()
		return nil
	case citype.FieldColor:
		m.ResetColor()
		return nil
	case citype.FieldAttributeSchema:
		m.ResetAttributeSchema()
		return nil
	case citype.FieldTenantID:
		m.ResetTenantID()
		return nil
	case citype.FieldIsActive:
		m.ResetIsActive()
		return nil
	case citype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case citype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CIType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CITypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CITypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CITypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CITypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CITypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CITypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CITypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CIType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CITypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CIType edge %s", name)
}

// ChangeMutation represents an operation that mutates the Change nodes in the graph.
type ChangeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	title                 *string
	description           *string
	justification         *string
	_type                 *string
	status                *string
	priority              *string
	impact_scope          *string
	risk_level            *string
	assignee_id           *int
	addassignee_id        *int
	created_by            *int
	addcreated_by         *int
	tenant_id             *int
	addtenant_id          *int
	planned_start_date    *time.Time
	planned_end_date      *time.Time
	actual_start_date     *time.Time
	actual_end_date       *time.Time
	implementation_plan   *string
	rollback_plan         *string
	affected_cis          *[]string
	appendaffected_cis    []string
	related_tickets       *[]string
	appendrelated_tickets []string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*Change, error)
	predicates            []predicate.Change
}

var _ ent.Mutation = (*ChangeMutation)(nil)

// changeOption allows management of the mutation configuration using functional options.
type changeOption func(*ChangeMutation)

// newChangeMutation creates new mutation for the Change entity.
func newChangeMutation(c config, op Op, opts ...changeOption) *ChangeMutation {
	m := &ChangeMutation{
		config:        c,
		op:            op,
		typ:           TypeChange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChangeID sets the ID field of the mutation.
func withChangeID(id int) changeOption {
	return func(m *ChangeMutation) {
		var (
			err   error
			once  sync.Once
			value *Change
		)
		m.oldValue = func(ctx context.Context) (*Change, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Change.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChange sets the old Change of the mutation.
func withChange(node *Change) changeOption {
	return func(m *ChangeMutation) {
		m.oldValue = func(context.Context) (*Change, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChangeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChangeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Change.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ChangeMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ChangeMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ChangeMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ChangeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ChangeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ChangeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[change.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ChangeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[change.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ChangeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, change.FieldDescription)
}

// SetJustification sets the "justification" field.
func (m *ChangeMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *ChangeMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ClearJustification clears the value of the "justification" field.
func (m *ChangeMutation) ClearJustification() {
	m.justification = nil
	m.clearedFields[change.FieldJustification] = struct{}{}
}

// JustificationCleared returns if the "justification" field was cleared in this mutation.
func (m *ChangeMutation) JustificationCleared() bool {
	_, ok := m.clearedFields[change.FieldJustification]
	return ok
}

// ResetJustification resets all changes to the "justification" field.
func (m *ChangeMutation) ResetJustification() {
	m.justification = nil
	delete(m.clearedFields, change.FieldJustification)
}

// SetType sets the "type" field.
func (m *ChangeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ChangeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ChangeMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *ChangeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ChangeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ChangeMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *ChangeMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ChangeMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *ChangeMutation) ResetPriority() {
	m.priority = nil
}

// SetImpactScope sets the "impact_scope" field.
func (m *ChangeMutation) SetImpactScope(s string) {
	m.impact_scope = &s
}

// ImpactScope returns the value of the "impact_scope" field in the mutation.
func (m *ChangeMutation) ImpactScope() (r string, exists bool) {
	v := m.impact_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldImpactScope returns the old "impact_scope" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldImpactScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpactScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpactScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpactScope: %w", err)
	}
	return oldValue.ImpactScope, nil
}

// ResetImpactScope resets all changes to the "impact_scope" field.
func (m *ChangeMutation) ResetImpactScope() {
	m.impact_scope = nil
}

// SetRiskLevel sets the "risk_level" field.
func (m *ChangeMutation) SetRiskLevel(s string) {
	m.risk_level = &s
}

// RiskLevel returns the value of the "risk_level" field in the mutation.
func (m *ChangeMutation) RiskLevel() (r string, exists bool) {
	v := m.risk_level
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskLevel returns the old "risk_level" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldRiskLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskLevel: %w", err)
	}
	return oldValue.RiskLevel, nil
}

// ResetRiskLevel resets all changes to the "risk_level" field.
func (m *ChangeMutation) ResetRiskLevel() {
	m.risk_level = nil
}

// SetAssigneeID sets the "assignee_id" field.
func (m *ChangeMutation) SetAssigneeID(i int) {
	m.assignee_id = &i
	m.addassignee_id = nil
}

// AssigneeID returns the value of the "assignee_id" field in the mutation.
func (m *ChangeMutation) AssigneeID() (r int, exists bool) {
	v := m.assignee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeID returns the old "assignee_id" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldAssigneeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeID: %w", err)
	}
	return oldValue.AssigneeID, nil
}

// AddAssigneeID adds i to the "assignee_id" field.
func (m *ChangeMutation) AddAssigneeID(i int) {
	if m.addassignee_id != nil {
		*m.addassignee_id += i
	} else {
		m.addassignee_id = &i
	}
}

// AddedAssigneeID returns the value that was added to the "assignee_id" field in this mutation.
func (m *ChangeMutation) AddedAssigneeID() (r int, exists bool) {
	v := m.addassignee_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssigneeID clears the value of the "assignee_id" field.
func (m *ChangeMutation) ClearAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	m.clearedFields[change.FieldAssigneeID] = struct{}{}
}

// AssigneeIDCleared returns if the "assignee_id" field was cleared in this mutation.
func (m *ChangeMutation) AssigneeIDCleared() bool {
	_, ok := m.clearedFields[change.FieldAssigneeID]
	return ok
}

// ResetAssigneeID resets all changes to the "assignee_id" field.
func (m *ChangeMutation) ResetAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	delete(m.clearedFields, change.FieldAssigneeID)
}

// SetCreatedBy sets the "created_by" field.
func (m *ChangeMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ChangeMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ChangeMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ChangeMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ChangeMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ChangeMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ChangeMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ChangeMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ChangeMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ChangeMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetPlannedStartDate sets the "planned_start_date" field.
func (m *ChangeMutation) SetPlannedStartDate(t time.Time) {
	m.planned_start_date = &t
}

// PlannedStartDate returns the value of the "planned_start_date" field in the mutation.
func (m *ChangeMutation) PlannedStartDate() (r time.Time, exists bool) {
	v := m.planned_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPlannedStartDate returns the old "planned_start_date" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldPlannedStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlannedStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlannedStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlannedStartDate: %w", err)
	}
	return oldValue.PlannedStartDate, nil
}

// ClearPlannedStartDate clears the value of the "planned_start_date" field.
func (m *ChangeMutation) ClearPlannedStartDate() {
	m.planned_start_date = nil
	m.clearedFields[change.FieldPlannedStartDate] = struct{}{}
}

// PlannedStartDateCleared returns if the "planned_start_date" field was cleared in this mutation.
func (m *ChangeMutation) PlannedStartDateCleared() bool {
	_, ok := m.clearedFields[change.FieldPlannedStartDate]
	return ok
}

// ResetPlannedStartDate resets all changes to the "planned_start_date" field.
func (m *ChangeMutation) ResetPlannedStartDate() {
	m.planned_start_date = nil
	delete(m.clearedFields, change.FieldPlannedStartDate)
}

// SetPlannedEndDate sets the "planned_end_date" field.
func (m *ChangeMutation) SetPlannedEndDate(t time.Time) {
	m.planned_end_date = &t
}

// PlannedEndDate returns the value of the "planned_end_date" field in the mutation.
func (m *ChangeMutation) PlannedEndDate() (r time.Time, exists bool) {
	v := m.planned_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPlannedEndDate returns the old "planned_end_date" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldPlannedEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlannedEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlannedEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlannedEndDate: %w", err)
	}
	return oldValue.PlannedEndDate, nil
}

// ClearPlannedEndDate clears the value of the "planned_end_date" field.
func (m *ChangeMutation) ClearPlannedEndDate() {
	m.planned_end_date = nil
	m.clearedFields[change.FieldPlannedEndDate] = struct{}{}
}

// PlannedEndDateCleared returns if the "planned_end_date" field was cleared in this mutation.
func (m *ChangeMutation) PlannedEndDateCleared() bool {
	_, ok := m.clearedFields[change.FieldPlannedEndDate]
	return ok
}

// ResetPlannedEndDate resets all changes to the "planned_end_date" field.
func (m *ChangeMutation) ResetPlannedEndDate() {
	m.planned_end_date = nil
	delete(m.clearedFields, change.FieldPlannedEndDate)
}

// SetActualStartDate sets the "actual_start_date" field.
func (m *ChangeMutation) SetActualStartDate(t time.Time) {
	m.actual_start_date = &t
}

// ActualStartDate returns the value of the "actual_start_date" field in the mutation.
func (m *ChangeMutation) ActualStartDate() (r time.Time, exists bool) {
	v := m.actual_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldActualStartDate returns the old "actual_start_date" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldActualStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualStartDate: %w", err)
	}
	return oldValue.ActualStartDate, nil
}

// ClearActualStartDate clears the value of the "actual_start_date" field.
func (m *ChangeMutation) ClearActualStartDate() {
	m.actual_start_date = nil
	m.clearedFields[change.FieldActualStartDate] = struct{}{}
}

// ActualStartDateCleared returns if the "actual_start_date" field was cleared in this mutation.
func (m *ChangeMutation) ActualStartDateCleared() bool {
	_, ok := m.clearedFields[change.FieldActualStartDate]
	return ok
}

// ResetActualStartDate resets all changes to the "actual_start_date" field.
func (m *ChangeMutation) ResetActualStartDate() {
	m.actual_start_date = nil
	delete(m.clearedFields, change.FieldActualStartDate)
}

// SetActualEndDate sets the "actual_end_date" field.
func (m *ChangeMutation) SetActualEndDate(t time.Time) {
	m.actual_end_date = &t
}

// ActualEndDate returns the value of the "actual_end_date" field in the mutation.
func (m *ChangeMutation) ActualEndDate() (r time.Time, exists bool) {
	v := m.actual_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldActualEndDate returns the old "actual_end_date" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldActualEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualEndDate: %w", err)
	}
	return oldValue.ActualEndDate, nil
}

// ClearActualEndDate clears the value of the "actual_end_date" field.
func (m *ChangeMutation) ClearActualEndDate() {
	m.actual_end_date = nil
	m.clearedFields[change.FieldActualEndDate] = struct{}{}
}

// ActualEndDateCleared returns if the "actual_end_date" field was cleared in this mutation.
func (m *ChangeMutation) ActualEndDateCleared() bool {
	_, ok := m.clearedFields[change.FieldActualEndDate]
	return ok
}

// ResetActualEndDate resets all changes to the "actual_end_date" field.
func (m *ChangeMutation) ResetActualEndDate() {
	m.actual_end_date = nil
	delete(m.clearedFields, change.FieldActualEndDate)
}

// SetImplementationPlan sets the "implementation_plan" field.
func (m *ChangeMutation) SetImplementationPlan(s string) {
	m.implementation_plan = &s
}

// ImplementationPlan returns the value of the "implementation_plan" field in the mutation.
func (m *ChangeMutation) ImplementationPlan() (r string, exists bool) {
	v := m.implementation_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementationPlan returns the old "implementation_plan" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldImplementationPlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementationPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementationPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementationPlan: %w", err)
	}
	return oldValue.ImplementationPlan, nil
}

// ClearImplementationPlan clears the value of the "implementation_plan" field.
func (m *ChangeMutation) ClearImplementationPlan() {
	m.implementation_plan = nil
	m.clearedFields[change.FieldImplementationPlan] = struct{}{}
}

// ImplementationPlanCleared returns if the "implementation_plan" field was cleared in this mutation.
func (m *ChangeMutation) ImplementationPlanCleared() bool {
	_, ok := m.clearedFields[change.FieldImplementationPlan]
	return ok
}

// ResetImplementationPlan resets all changes to the "implementation_plan" field.
func (m *ChangeMutation) ResetImplementationPlan() {
	m.implementation_plan = nil
	delete(m.clearedFields, change.FieldImplementationPlan)
}

// SetRollbackPlan sets the "rollback_plan" field.
func (m *ChangeMutation) SetRollbackPlan(s string) {
	m.rollback_plan = &s
}

// RollbackPlan returns the value of the "rollback_plan" field in the mutation.
func (m *ChangeMutation) RollbackPlan() (r string, exists bool) {
	v := m.rollback_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldRollbackPlan returns the old "rollback_plan" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldRollbackPlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRollbackPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRollbackPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRollbackPlan: %w", err)
	}
	return oldValue.RollbackPlan, nil
}

// ClearRollbackPlan clears the value of the "rollback_plan" field.
func (m *ChangeMutation) ClearRollbackPlan() {
	m.rollback_plan = nil
	m.clearedFields[change.FieldRollbackPlan] = struct{}{}
}

// RollbackPlanCleared returns if the "rollback_plan" field was cleared in this mutation.
func (m *ChangeMutation) RollbackPlanCleared() bool {
	_, ok := m.clearedFields[change.FieldRollbackPlan]
	return ok
}

// ResetRollbackPlan resets all changes to the "rollback_plan" field.
func (m *ChangeMutation) ResetRollbackPlan() {
	m.rollback_plan = nil
	delete(m.clearedFields, change.FieldRollbackPlan)
}

// SetAffectedCis sets the "affected_cis" field.
func (m *ChangeMutation) SetAffectedCis(s []string) {
	m.affected_cis = &s
	m.appendaffected_cis = nil
}

// AffectedCis returns the value of the "affected_cis" field in the mutation.
func (m *ChangeMutation) AffectedCis() (r []string, exists bool) {
	v := m.affected_cis
	if v == nil {
		return
	}
	return *v, true
}

// OldAffectedCis returns the old "affected_cis" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldAffectedCis(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffectedCis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffectedCis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffectedCis: %w", err)
	}
	return oldValue.AffectedCis, nil
}

// AppendAffectedCis adds s to the "affected_cis" field.
func (m *ChangeMutation) AppendAffectedCis(s []string) {
	m.appendaffected_cis = append(m.appendaffected_cis, s...)
}

// AppendedAffectedCis returns the list of values that were appended to the "affected_cis" field in this mutation.
func (m *ChangeMutation) AppendedAffectedCis() ([]string, bool) {
	if len(m.appendaffected_cis) == 0 {
		return nil, false
	}
	return m.appendaffected_cis, true
}

// ClearAffectedCis clears the value of the "affected_cis" field.
func (m *ChangeMutation) ClearAffectedCis() {
	m.affected_cis = nil
	m.appendaffected_cis = nil
	m.clearedFields[change.FieldAffectedCis] = struct{}{}
}

// AffectedCisCleared returns if the "affected_cis" field was cleared in this mutation.
func (m *ChangeMutation) AffectedCisCleared() bool {
	_, ok := m.clearedFields[change.FieldAffectedCis]
	return ok
}

// ResetAffectedCis resets all changes to the "affected_cis" field.
func (m *ChangeMutation) ResetAffectedCis() {
	m.affected_cis = nil
	m.appendaffected_cis = nil
	delete(m.clearedFields, change.FieldAffectedCis)
}

// SetRelatedTickets sets the "related_tickets" field.
func (m *ChangeMutation) SetRelatedTickets(s []string) {
	m.related_tickets = &s
	m.appendrelated_tickets = nil
}

// RelatedTickets returns the value of the "related_tickets" field in the mutation.
func (m *ChangeMutation) RelatedTickets() (r []string, exists bool) {
	v := m.related_tickets
	if v == nil {
		return
	}
	return *v, true
}

// OldRelatedTickets returns the old "related_tickets" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldRelatedTickets(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelatedTickets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelatedTickets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelatedTickets: %w", err)
	}
	return oldValue.RelatedTickets, nil
}

// AppendRelatedTickets adds s to the "related_tickets" field.
func (m *ChangeMutation) AppendRelatedTickets(s []string) {
	m.appendrelated_tickets = append(m.appendrelated_tickets, s...)
}

// AppendedRelatedTickets returns the list of values that were appended to the "related_tickets" field in this mutation.
func (m *ChangeMutation) AppendedRelatedTickets() ([]string, bool) {
	if len(m.appendrelated_tickets) == 0 {
		return nil, false
	}
	return m.appendrelated_tickets, true
}

// ClearRelatedTickets clears the value of the "related_tickets" field.
func (m *ChangeMutation) ClearRelatedTickets() {
	m.related_tickets = nil
	m.appendrelated_tickets = nil
	m.clearedFields[change.FieldRelatedTickets] = struct{}{}
}

// RelatedTicketsCleared returns if the "related_tickets" field was cleared in this mutation.
func (m *ChangeMutation) RelatedTicketsCleared() bool {
	_, ok := m.clearedFields[change.FieldRelatedTickets]
	return ok
}

// ResetRelatedTickets resets all changes to the "related_tickets" field.
func (m *ChangeMutation) ResetRelatedTickets() {
	m.related_tickets = nil
	m.appendrelated_tickets = nil
	delete(m.clearedFields, change.FieldRelatedTickets)
}

// SetCreatedAt sets the "created_at" field.
func (m *ChangeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChangeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChangeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChangeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChangeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Change entity.
// If the Change object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChangeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ChangeMutation builder.
func (m *ChangeMutation) Where(ps ...predicate.Change) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChangeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChangeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Change, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChangeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChangeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Change).
func (m *ChangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChangeMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.title != nil {
		fields = append(fields, change.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, change.FieldDescription)
	}
	if m.justification != nil {
		fields = append(fields, change.FieldJustification)
	}
	if m._type != nil {
		fields = append(fields, change.FieldType)
	}
	if m.status != nil {
		fields = append(fields, change.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, change.FieldPriority)
	}
	if m.impact_scope != nil {
		fields = append(fields, change.FieldImpactScope)
	}
	if m.risk_level != nil {
		fields = append(fields, change.FieldRiskLevel)
	}
	if m.assignee_id != nil {
		fields = append(fields, change.FieldAssigneeID)
	}
	if m.created_by != nil {
		fields = append(fields, change.FieldCreatedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, change.FieldTenantID)
	}
	if m.planned_start_date != nil {
		fields = append(fields, change.FieldPlannedStartDate)
	}
	if m.planned_end_date != nil {
		fields = append(fields, change.FieldPlannedEndDate)
	}
	if m.actual_start_date != nil {
		fields = append(fields, change.FieldActualStartDate)
	}
	if m.actual_end_date != nil {
		fields = append(fields, change.FieldActualEndDate)
	}
	if m.implementation_plan != nil {
		fields = append(fields, change.FieldImplementationPlan)
	}
	if m.rollback_plan != nil {
		fields = append(fields, change.FieldRollbackPlan)
	}
	if m.affected_cis != nil {
		fields = append(fields, change.FieldAffectedCis)
	}
	if m.related_tickets != nil {
		fields = append(fields, change.FieldRelatedTickets)
	}
	if m.created_at != nil {
		fields = append(fields, change.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, change.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case change.FieldTitle:
		return m.Title()
	case change.FieldDescription:
		return m.Description()
	case change.FieldJustification:
		return m.Justification()
	case change.FieldType:
		return m.GetType()
	case change.FieldStatus:
		return m.Status()
	case change.FieldPriority:
		return m.Priority()
	case change.FieldImpactScope:
		return m.ImpactScope()
	case change.FieldRiskLevel:
		return m.RiskLevel()
	case change.FieldAssigneeID:
		return m.AssigneeID()
	case change.FieldCreatedBy:
		return m.CreatedBy()
	case change.FieldTenantID:
		return m.TenantID()
	case change.FieldPlannedStartDate:
		return m.PlannedStartDate()
	case change.FieldPlannedEndDate:
		return m.PlannedEndDate()
	case change.FieldActualStartDate:
		return m.ActualStartDate()
	case change.FieldActualEndDate:
		return m.ActualEndDate()
	case change.FieldImplementationPlan:
		return m.ImplementationPlan()
	case change.FieldRollbackPlan:
		return m.RollbackPlan()
	case change.FieldAffectedCis:
		return m.AffectedCis()
	case change.FieldRelatedTickets:
		return m.RelatedTickets()
	case change.FieldCreatedAt:
		return m.CreatedAt()
	case change.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case change.FieldTitle:
		return m.OldTitle(ctx)
	case change.FieldDescription:
		return m.OldDescription(ctx)
	case change.FieldJustification:
		return m.OldJustification(ctx)
	case change.FieldType:
		return m.OldType(ctx)
	case change.FieldStatus:
		return m.OldStatus(ctx)
	case change.FieldPriority:
		return m.OldPriority(ctx)
	case change.FieldImpactScope:
		return m.OldImpactScope(ctx)
	case change.FieldRiskLevel:
		return m.OldRiskLevel(ctx)
	case change.FieldAssigneeID:
		return m.OldAssigneeID(ctx)
	case change.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case change.FieldTenantID:
		return m.OldTenantID(ctx)
	case change.FieldPlannedStartDate:
		return m.OldPlannedStartDate(ctx)
	case change.FieldPlannedEndDate:
		return m.OldPlannedEndDate(ctx)
	case change.FieldActualStartDate:
		return m.OldActualStartDate(ctx)
	case change.FieldActualEndDate:
		return m.OldActualEndDate(ctx)
	case change.FieldImplementationPlan:
		return m.OldImplementationPlan(ctx)
	case change.FieldRollbackPlan:
		return m.OldRollbackPlan(ctx)
	case change.FieldAffectedCis:
		return m.OldAffectedCis(ctx)
	case change.FieldRelatedTickets:
		return m.OldRelatedTickets(ctx)
	case change.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case change.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Change field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case change.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case change.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case change.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case change.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case change.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case change.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case change.FieldImpactScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpactScope(v)
		return nil
	case change.FieldRiskLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskLevel(v)
		return nil
	case change.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeID(v)
		return nil
	case change.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case change.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case change.FieldPlannedStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlannedStartDate(v)
		return nil
	case change.FieldPlannedEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlannedEndDate(v)
		return nil
	case change.FieldActualStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualStartDate(v)
		return nil
	case change.FieldActualEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualEndDate(v)
		return nil
	case change.FieldImplementationPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementationPlan(v)
		return nil
	case change.FieldRollbackPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRollbackPlan(v)
		return nil
	case change.FieldAffectedCis:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffectedCis(v)
		return nil
	case change.FieldRelatedTickets:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelatedTickets(v)
		return nil
	case change.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case change.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Change field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChangeMutation) AddedFields() []string {
	var fields []string
	if m.addassignee_id != nil {
		fields = append(fields, change.FieldAssigneeID)
	}
	if m.addcreated_by != nil {
		fields = append(fields, change.FieldCreatedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, change.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChangeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case change.FieldAssigneeID:
		return m.AddedAssigneeID()
	case change.FieldCreatedBy:
		return m.AddedCreatedBy()
	case change.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case change.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssigneeID(v)
		return nil
	case change.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case change.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Change numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChangeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(change.FieldDescription) {
		fields = append(fields, change.FieldDescription)
	}
	if m.FieldCleared(change.FieldJustification) {
		fields = append(fields, change.FieldJustification)
	}
	if m.FieldCleared(change.FieldAssigneeID) {
		fields = append(fields, change.FieldAssigneeID)
	}
	if m.FieldCleared(change.FieldPlannedStartDate) {
		fields = append(fields, change.FieldPlannedStartDate)
	}
	if m.FieldCleared(change.FieldPlannedEndDate) {
		fields = append(fields, change.FieldPlannedEndDate)
	}
	if m.FieldCleared(change.FieldActualStartDate) {
		fields = append(fields, change.FieldActualStartDate)
	}
	if m.FieldCleared(change.FieldActualEndDate) {
		fields = append(fields, change.FieldActualEndDate)
	}
	if m.FieldCleared(change.FieldImplementationPlan) {
		fields = append(fields, change.FieldImplementationPlan)
	}
	if m.FieldCleared(change.FieldRollbackPlan) {
		fields = append(fields, change.FieldRollbackPlan)
	}
	if m.FieldCleared(change.FieldAffectedCis) {
		fields = append(fields, change.FieldAffectedCis)
	}
	if m.FieldCleared(change.FieldRelatedTickets) {
		fields = append(fields, change.FieldRelatedTickets)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChangeMutation) ClearField(name string) error {
	switch name {
	case change.FieldDescription:
		m.ClearDescription()
		return nil
	case change.FieldJustification:
		m.ClearJustification()
		return nil
	case change.FieldAssigneeID:
		m.ClearAssigneeID()
		return nil
	case change.FieldPlannedStartDate:
		m.ClearPlannedStartDate()
		return nil
	case change.FieldPlannedEndDate:
		m.ClearPlannedEndDate()
		return nil
	case change.FieldActualStartDate:
		m.ClearActualStartDate()
		return nil
	case change.FieldActualEndDate:
		m.ClearActualEndDate()
		return nil
	case change.FieldImplementationPlan:
		m.ClearImplementationPlan()
		return nil
	case change.FieldRollbackPlan:
		m.ClearRollbackPlan()
		return nil
	case change.FieldAffectedCis:
		m.ClearAffectedCis()
		return nil
	case change.FieldRelatedTickets:
		m.ClearRelatedTickets()
		return nil
	}
	return fmt.Errorf("unknown Change nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChangeMutation) ResetField(name string) error {
	switch name {
	case change.FieldTitle:
		m.ResetTitle()
		return nil
	case change.FieldDescription:
		m.ResetDescription()
		return nil
	case change.FieldJustification:
		m.ResetJustification()
		return nil
	case change.FieldType:
		m.ResetType()
		return nil
	case change.FieldStatus:
		m.ResetStatus()
		return nil
	case change.FieldPriority:
		m.ResetPriority()
		return nil
	case change.FieldImpactScope:
		m.ResetImpactScope()
		return nil
	case change.FieldRiskLevel:
		m.ResetRiskLevel()
		return nil
	case change.FieldAssigneeID:
		m.ResetAssigneeID()
		return nil
	case change.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case change.FieldTenantID:
		m.ResetTenantID()
		return nil
	case change.FieldPlannedStartDate:
		m.ResetPlannedStartDate()
		return nil
	case change.FieldPlannedEndDate:
		m.ResetPlannedEndDate()
		return nil
	case change.FieldActualStartDate:
		m.ResetActualStartDate()
		return nil
	case change.FieldActualEndDate:
		m.ResetActualEndDate()
		return nil
	case change.FieldImplementationPlan:
		m.ResetImplementationPlan()
		return nil
	case change.FieldRollbackPlan:
		m.ResetRollbackPlan()
		return nil
	case change.FieldAffectedCis:
		m.ResetAffectedCis()
		return nil
	case change.FieldRelatedTickets:
		m.ResetRelatedTickets()
		return nil
	case change.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case change.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Change field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChangeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChangeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChangeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChangeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Change unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChangeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Change edge %s", name)
}

// ConfigurationItemMutation represents an operation that mutates the ConfigurationItem nodes in the graph.
type ConfigurationItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	_type         *string
	status        *string
	location      *string
	serial_number *string
	model         *string
	vendor        *string
	ci_type_id    *int
	addci_type_id *int
	tenant_id     *int
	addtenant_id  *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ConfigurationItem, error)
	predicates    []predicate.ConfigurationItem
}

var _ ent.Mutation = (*ConfigurationItemMutation)(nil)

// configurationitemOption allows management of the mutation configuration using functional options.
type configurationitemOption func(*ConfigurationItemMutation)

// newConfigurationItemMutation creates new mutation for the ConfigurationItem entity.
func newConfigurationItemMutation(c config, op Op, opts ...configurationitemOption) *ConfigurationItemMutation {
	m := &ConfigurationItemMutation{
		config:        c,
		op:            op,
		typ:           TypeConfigurationItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigurationItemID sets the ID field of the mutation.
func withConfigurationItemID(id int) configurationitemOption {
	return func(m *ConfigurationItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ConfigurationItem
		)
		m.oldValue = func(ctx context.Context) (*ConfigurationItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConfigurationItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfigurationItem sets the old ConfigurationItem of the mutation.
func withConfigurationItem(node *ConfigurationItem) configurationitemOption {
	return func(m *ConfigurationItemMutation) {
		m.oldValue = func(context.Context) (*ConfigurationItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigurationItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigurationItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConfigurationItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConfigurationItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConfigurationItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ConfigurationItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConfigurationItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConfigurationItemMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ConfigurationItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ConfigurationItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ConfigurationItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[configurationitem.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ConfigurationItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ConfigurationItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, configurationitem.FieldDescription)
}

// SetType sets the "type" field.
func (m *ConfigurationItemMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ConfigurationItemMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ConfigurationItemMutation) ClearType() {
	m._type = nil
	m.clearedFields[configurationitem.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ConfigurationItemMutation) TypeCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ConfigurationItemMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, configurationitem.FieldType)
}

// SetStatus sets the "status" field.
func (m *ConfigurationItemMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ConfigurationItemMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ConfigurationItemMutation) ResetStatus() {
	m.status = nil
}

// SetLocation sets the "location" field.
func (m *ConfigurationItemMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *ConfigurationItemMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *ConfigurationItemMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[configurationitem.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *ConfigurationItemMutation) LocationCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *ConfigurationItemMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, configurationitem.FieldLocation)
}

// SetSerialNumber sets the "serial_number" field.
func (m *ConfigurationItemMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *ConfigurationItemMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ClearSerialNumber clears the value of the "serial_number" field.
func (m *ConfigurationItemMutation) ClearSerialNumber() {
	m.serial_number = nil
	m.clearedFields[configurationitem.FieldSerialNumber] = struct{}{}
}

// SerialNumberCleared returns if the "serial_number" field was cleared in this mutation.
func (m *ConfigurationItemMutation) SerialNumberCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldSerialNumber]
	return ok
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *ConfigurationItemMutation) ResetSerialNumber() {
	m.serial_number = nil
	delete(m.clearedFields, configurationitem.FieldSerialNumber)
}

// SetModel sets the "model" field.
func (m *ConfigurationItemMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ConfigurationItemMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *ConfigurationItemMutation) ClearModel() {
	m.model = nil
	m.clearedFields[configurationitem.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *ConfigurationItemMutation) ModelCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *ConfigurationItemMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, configurationitem.FieldModel)
}

// SetVendor sets the "vendor" field.
func (m *ConfigurationItemMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ConfigurationItemMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ClearVendor clears the value of the "vendor" field.
func (m *ConfigurationItemMutation) ClearVendor() {
	m.vendor = nil
	m.clearedFields[configurationitem.FieldVendor] = struct{}{}
}

// VendorCleared returns if the "vendor" field was cleared in this mutation.
func (m *ConfigurationItemMutation) VendorCleared() bool {
	_, ok := m.clearedFields[configurationitem.FieldVendor]
	return ok
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ConfigurationItemMutation) ResetVendor() {
	m.vendor = nil
	delete(m.clearedFields, configurationitem.FieldVendor)
}

// SetCiTypeID sets the "ci_type_id" field.
func (m *ConfigurationItemMutation) SetCiTypeID(i int) {
	m.ci_type_id = &i
	m.addci_type_id = nil
}

// CiTypeID returns the value of the "ci_type_id" field in the mutation.
func (m *ConfigurationItemMutation) CiTypeID() (r int, exists bool) {
	v := m.ci_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCiTypeID returns the old "ci_type_id" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldCiTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCiTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCiTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCiTypeID: %w", err)
	}
	return oldValue.CiTypeID, nil
}

// AddCiTypeID adds i to the "ci_type_id" field.
func (m *ConfigurationItemMutation) AddCiTypeID(i int) {
	if m.addci_type_id != nil {
		*m.addci_type_id += i
	} else {
		m.addci_type_id = &i
	}
}

// AddedCiTypeID returns the value that was added to the "ci_type_id" field in this mutation.
func (m *ConfigurationItemMutation) AddedCiTypeID() (r int, exists bool) {
	v := m.addci_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCiTypeID resets all changes to the "ci_type_id" field.
func (m *ConfigurationItemMutation) ResetCiTypeID() {
	m.ci_type_id = nil
	m.addci_type_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ConfigurationItemMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ConfigurationItemMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ConfigurationItemMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ConfigurationItemMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ConfigurationItemMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConfigurationItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConfigurationItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConfigurationItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConfigurationItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConfigurationItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ConfigurationItem entity.
// If the ConfigurationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConfigurationItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ConfigurationItemMutation builder.
func (m *ConfigurationItemMutation) Where(ps ...predicate.ConfigurationItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConfigurationItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConfigurationItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConfigurationItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConfigurationItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConfigurationItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConfigurationItem).
func (m *ConfigurationItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigurationItemMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, configurationitem.FieldName)
	}
	if m.description != nil {
		fields = append(fields, configurationitem.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, configurationitem.FieldType)
	}
	if m.status != nil {
		fields = append(fields, configurationitem.FieldStatus)
	}
	if m.location != nil {
		fields = append(fields, configurationitem.FieldLocation)
	}
	if m.serial_number != nil {
		fields = append(fields, configurationitem.FieldSerialNumber)
	}
	if m.model != nil {
		fields = append(fields, configurationitem.FieldModel)
	}
	if m.vendor != nil {
		fields = append(fields, configurationitem.FieldVendor)
	}
	if m.ci_type_id != nil {
		fields = append(fields, configurationitem.FieldCiTypeID)
	}
	if m.tenant_id != nil {
		fields = append(fields, configurationitem.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, configurationitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, configurationitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigurationItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configurationitem.FieldName:
		return m.Name()
	case configurationitem.FieldDescription:
		return m.Description()
	case configurationitem.FieldType:
		return m.GetType()
	case configurationitem.FieldStatus:
		return m.Status()
	case configurationitem.FieldLocation:
		return m.Location()
	case configurationitem.FieldSerialNumber:
		return m.SerialNumber()
	case configurationitem.FieldModel:
		return m.Model()
	case configurationitem.FieldVendor:
		return m.Vendor()
	case configurationitem.FieldCiTypeID:
		return m.CiTypeID()
	case configurationitem.FieldTenantID:
		return m.TenantID()
	case configurationitem.FieldCreatedAt:
		return m.CreatedAt()
	case configurationitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigurationItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configurationitem.FieldName:
		return m.OldName(ctx)
	case configurationitem.FieldDescription:
		return m.OldDescription(ctx)
	case configurationitem.FieldType:
		return m.OldType(ctx)
	case configurationitem.FieldStatus:
		return m.OldStatus(ctx)
	case configurationitem.FieldLocation:
		return m.OldLocation(ctx)
	case configurationitem.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case configurationitem.FieldModel:
		return m.OldModel(ctx)
	case configurationitem.FieldVendor:
		return m.OldVendor(ctx)
	case configurationitem.FieldCiTypeID:
		return m.OldCiTypeID(ctx)
	case configurationitem.FieldTenantID:
		return m.OldTenantID(ctx)
	case configurationitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case configurationitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ConfigurationItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configurationitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case configurationitem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case configurationitem.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case configurationitem.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case configurationitem.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case configurationitem.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case configurationitem.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case configurationitem.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case configurationitem.FieldCiTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCiTypeID(v)
		return nil
	case configurationitem.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case configurationitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case configurationitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigurationItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigurationItemMutation) AddedFields() []string {
	var fields []string
	if m.addci_type_id != nil {
		fields = append(fields, configurationitem.FieldCiTypeID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, configurationitem.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigurationItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case configurationitem.FieldCiTypeID:
		return m.AddedCiTypeID()
	case configurationitem.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case configurationitem.FieldCiTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCiTypeID(v)
		return nil
	case configurationitem.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigurationItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigurationItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configurationitem.FieldDescription) {
		fields = append(fields, configurationitem.FieldDescription)
	}
	if m.FieldCleared(configurationitem.FieldType) {
		fields = append(fields, configurationitem.FieldType)
	}
	if m.FieldCleared(configurationitem.FieldLocation) {
		fields = append(fields, configurationitem.FieldLocation)
	}
	if m.FieldCleared(configurationitem.FieldSerialNumber) {
		fields = append(fields, configurationitem.FieldSerialNumber)
	}
	if m.FieldCleared(configurationitem.FieldModel) {
		fields = append(fields, configurationitem.FieldModel)
	}
	if m.FieldCleared(configurationitem.FieldVendor) {
		fields = append(fields, configurationitem.FieldVendor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigurationItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigurationItemMutation) ClearField(name string) error {
	switch name {
	case configurationitem.FieldDescription:
		m.ClearDescription()
		return nil
	case configurationitem.FieldType:
		m.ClearType()
		return nil
	case configurationitem.FieldLocation:
		m.ClearLocation()
		return nil
	case configurationitem.FieldSerialNumber:
		m.ClearSerialNumber()
		return nil
	case configurationitem.FieldModel:
		m.ClearModel()
		return nil
	case configurationitem.FieldVendor:
		m.ClearVendor()
		return nil
	}
	return fmt.Errorf("unknown ConfigurationItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigurationItemMutation) ResetField(name string) error {
	switch name {
	case configurationitem.FieldName:
		m.ResetName()
		return nil
	case configurationitem.FieldDescription:
		m.ResetDescription()
		return nil
	case configurationitem.FieldType:
		m.ResetType()
		return nil
	case configurationitem.FieldStatus:
		m.ResetStatus()
		return nil
	case configurationitem.FieldLocation:
		m.ResetLocation()
		return nil
	case configurationitem.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case configurationitem.FieldModel:
		m.ResetModel()
		return nil
	case configurationitem.FieldVendor:
		m.ResetVendor()
		return nil
	case configurationitem.FieldCiTypeID:
		m.ResetCiTypeID()
		return nil
	case configurationitem.FieldTenantID:
		m.ResetTenantID()
		return nil
	case configurationitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case configurationitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ConfigurationItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigurationItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigurationItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigurationItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigurationItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigurationItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigurationItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigurationItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ConfigurationItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigurationItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ConfigurationItem edge %s", name)
}

// ConversationMutation represents an operation that mutates the Conversation nodes in the graph.
type ConversationMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	tenant_id               *int
	addtenant_id            *int
	user_id                 *int
	adduser_id              *int
	title                   *string
	clearedFields           map[string]struct{}
	messages                map[int]struct{}
	removedmessages         map[int]struct{}
	clearedmessages         bool
	tool_invocations        map[int]struct{}
	removedtool_invocations map[int]struct{}
	clearedtool_invocations bool
	done                    bool
	oldValue                func(context.Context) (*Conversation, error)
	predicates              []predicate.Conversation
}

var _ ent.Mutation = (*ConversationMutation)(nil)

// conversationOption allows management of the mutation configuration using functional options.
type conversationOption func(*ConversationMutation)

// newConversationMutation creates new mutation for the Conversation entity.
func newConversationMutation(c config, op Op, opts ...conversationOption) *ConversationMutation {
	m := &ConversationMutation{
		config:        c,
		op:            op,
		typ:           TypeConversation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConversationID sets the ID field of the mutation.
func withConversationID(id int) conversationOption {
	return func(m *ConversationMutation) {
		var (
			err   error
			once  sync.Once
			value *Conversation
		)
		m.oldValue = func(ctx context.Context) (*Conversation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Conversation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConversation sets the old Conversation of the mutation.
func withConversation(node *Conversation) conversationOption {
	return func(m *ConversationMutation) {
		m.oldValue = func(context.Context) (*Conversation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConversationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConversationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConversationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConversationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Conversation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ConversationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConversationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConversationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ConversationMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ConversationMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ConversationMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ConversationMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *ConversationMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[conversation.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *ConversationMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[conversation.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ConversationMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, conversation.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *ConversationMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ConversationMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *ConversationMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ConversationMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *ConversationMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[conversation.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ConversationMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[conversation.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ConversationMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, conversation.FieldUserID)
}

// SetTitle sets the "title" field.
func (m *ConversationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ConversationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ConversationMutation) ResetTitle() {
	m.title = nil
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *ConversationMutation) AddMessageIDs(ids ...int) {
	if m.messages == nil {
		m.messages = make(map[int]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *ConversationMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *ConversationMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *ConversationMutation) RemoveMessageIDs(ids ...int) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *ConversationMutation) RemovedMessagesIDs() (ids []int) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *ConversationMutation) MessagesIDs() (ids []int) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *ConversationMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddToolInvocationIDs adds the "tool_invocations" edge to the ToolInvocation entity by ids.
func (m *ConversationMutation) AddToolInvocationIDs(ids ...int) {
	if m.tool_invocations == nil {
		m.tool_invocations = make(map[int]struct{})
	}
	for i := range ids {
		m.tool_invocations[ids[i]] = struct{}{}
	}
}

// ClearToolInvocations clears the "tool_invocations" edge to the ToolInvocation entity.
func (m *ConversationMutation) ClearToolInvocations() {
	m.clearedtool_invocations = true
}

// ToolInvocationsCleared reports if the "tool_invocations" edge to the ToolInvocation entity was cleared.
func (m *ConversationMutation) ToolInvocationsCleared() bool {
	return m.clearedtool_invocations
}

// RemoveToolInvocationIDs removes the "tool_invocations" edge to the ToolInvocation entity by IDs.
func (m *ConversationMutation) RemoveToolInvocationIDs(ids ...int) {
	if m.removedtool_invocations == nil {
		m.removedtool_invocations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tool_invocations, ids[i])
		m.removedtool_invocations[ids[i]] = struct{}{}
	}
}

// RemovedToolInvocations returns the removed IDs of the "tool_invocations" edge to the ToolInvocation entity.
func (m *ConversationMutation) RemovedToolInvocationsIDs() (ids []int) {
	for id := range m.removedtool_invocations {
		ids = append(ids, id)
	}
	return
}

// ToolInvocationsIDs returns the "tool_invocations" edge IDs in the mutation.
func (m *ConversationMutation) ToolInvocationsIDs() (ids []int) {
	for id := range m.tool_invocations {
		ids = append(ids, id)
	}
	return
}

// ResetToolInvocations resets all changes to the "tool_invocations" edge.
func (m *ConversationMutation) ResetToolInvocations() {
	m.tool_invocations = nil
	m.clearedtool_invocations = false
	m.removedtool_invocations = nil
}

// Where appends a list predicates to the ConversationMutation builder.
func (m *ConversationMutation) Where(ps ...predicate.Conversation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConversationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConversationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Conversation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConversationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConversationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Conversation).
func (m *ConversationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConversationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, conversation.FieldCreatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, conversation.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, conversation.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, conversation.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConversationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case conversation.FieldCreatedAt:
		return m.CreatedAt()
	case conversation.FieldTenantID:
		return m.TenantID()
	case conversation.FieldUserID:
		return m.UserID()
	case conversation.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConversationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case conversation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case conversation.FieldTenantID:
		return m.OldTenantID(ctx)
	case conversation.FieldUserID:
		return m.OldUserID(ctx)
	case conversation.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown Conversation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case conversation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case conversation.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case conversation.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case conversation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConversationMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, conversation.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, conversation.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConversationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case conversation.FieldTenantID:
		return m.AddedTenantID()
	case conversation.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case conversation.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case conversation.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Conversation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConversationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(conversation.FieldTenantID) {
		fields = append(fields, conversation.FieldTenantID)
	}
	if m.FieldCleared(conversation.FieldUserID) {
		fields = append(fields, conversation.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConversationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConversationMutation) ClearField(name string) error {
	switch name {
	case conversation.FieldTenantID:
		m.ClearTenantID()
		return nil
	case conversation.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Conversation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConversationMutation) ResetField(name string) error {
	switch name {
	case conversation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case conversation.FieldTenantID:
		m.ResetTenantID()
		return nil
	case conversation.FieldUserID:
		m.ResetUserID()
		return nil
	case conversation.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConversationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.messages != nil {
		edges = append(edges, conversation.EdgeMessages)
	}
	if m.tool_invocations != nil {
		edges = append(edges, conversation.EdgeToolInvocations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConversationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case conversation.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case conversation.EdgeToolInvocations:
		ids := make([]ent.Value, 0, len(m.tool_invocations))
		for id := range m.tool_invocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConversationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmessages != nil {
		edges = append(edges, conversation.EdgeMessages)
	}
	if m.removedtool_invocations != nil {
		edges = append(edges, conversation.EdgeToolInvocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConversationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case conversation.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case conversation.EdgeToolInvocations:
		ids := make([]ent.Value, 0, len(m.removedtool_invocations))
		for id := range m.removedtool_invocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConversationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmessages {
		edges = append(edges, conversation.EdgeMessages)
	}
	if m.clearedtool_invocations {
		edges = append(edges, conversation.EdgeToolInvocations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConversationMutation) EdgeCleared(name string) bool {
	switch name {
	case conversation.EdgeMessages:
		return m.clearedmessages
	case conversation.EdgeToolInvocations:
		return m.clearedtool_invocations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConversationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Conversation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConversationMutation) ResetEdge(name string) error {
	switch name {
	case conversation.EdgeMessages:
		m.ResetMessages()
		return nil
	case conversation.EdgeToolInvocations:
		m.ResetToolInvocations()
		return nil
	}
	return fmt.Errorf("unknown Conversation edge %s", name)
}

// IncidentMutation represents an operation that mutates the Incident nodes in the graph.
type IncidentMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	title                    *string
	description              *string
	status                   *string
	priority                 *string
	incident_number          *string
	reporter_id              *int
	addreporter_id           *int
	assignee_id              *int
	addassignee_id           *int
	configuration_item_id    *int
	addconfiguration_item_id *int
	resolved_at              *time.Time
	closed_at                *time.Time
	tenant_id                *int
	addtenant_id             *int
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Incident, error)
	predicates               []predicate.Incident
}

var _ ent.Mutation = (*IncidentMutation)(nil)

// incidentOption allows management of the mutation configuration using functional options.
type incidentOption func(*IncidentMutation)

// newIncidentMutation creates new mutation for the Incident entity.
func newIncidentMutation(c config, op Op, opts ...incidentOption) *IncidentMutation {
	m := &IncidentMutation{
		config:        c,
		op:            op,
		typ:           TypeIncident,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentID sets the ID field of the mutation.
func withIncidentID(id int) incidentOption {
	return func(m *IncidentMutation) {
		var (
			err   error
			once  sync.Once
			value *Incident
		)
		m.oldValue = func(ctx context.Context) (*Incident, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Incident.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncident sets the old Incident of the mutation.
func withIncident(node *Incident) incidentOption {
	return func(m *IncidentMutation) {
		m.oldValue = func(context.Context) (*Incident, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Incident.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *IncidentMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IncidentMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IncidentMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *IncidentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incident.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incident.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incident.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *IncidentMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *IncidentMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *IncidentMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *IncidentMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *IncidentMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *IncidentMutation) ResetPriority() {
	m.priority = nil
}

// SetIncidentNumber sets the "incident_number" field.
func (m *IncidentMutation) SetIncidentNumber(s string) {
	m.incident_number = &s
}

// IncidentNumber returns the value of the "incident_number" field in the mutation.
func (m *IncidentMutation) IncidentNumber() (r string, exists bool) {
	v := m.incident_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentNumber returns the old "incident_number" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldIncidentNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentNumber: %w", err)
	}
	return oldValue.IncidentNumber, nil
}

// ResetIncidentNumber resets all changes to the "incident_number" field.
func (m *IncidentMutation) ResetIncidentNumber() {
	m.incident_number = nil
}

// SetReporterID sets the "reporter_id" field.
func (m *IncidentMutation) SetReporterID(i int) {
	m.reporter_id = &i
	m.addreporter_id = nil
}

// ReporterID returns the value of the "reporter_id" field in the mutation.
func (m *IncidentMutation) ReporterID() (r int, exists bool) {
	v := m.reporter_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReporterID returns the old "reporter_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldReporterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReporterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReporterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReporterID: %w", err)
	}
	return oldValue.ReporterID, nil
}

// AddReporterID adds i to the "reporter_id" field.
func (m *IncidentMutation) AddReporterID(i int) {
	if m.addreporter_id != nil {
		*m.addreporter_id += i
	} else {
		m.addreporter_id = &i
	}
}

// AddedReporterID returns the value that was added to the "reporter_id" field in this mutation.
func (m *IncidentMutation) AddedReporterID() (r int, exists bool) {
	v := m.addreporter_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetReporterID resets all changes to the "reporter_id" field.
func (m *IncidentMutation) ResetReporterID() {
	m.reporter_id = nil
	m.addreporter_id = nil
}

// SetAssigneeID sets the "assignee_id" field.
func (m *IncidentMutation) SetAssigneeID(i int) {
	m.assignee_id = &i
	m.addassignee_id = nil
}

// AssigneeID returns the value of the "assignee_id" field in the mutation.
func (m *IncidentMutation) AssigneeID() (r int, exists bool) {
	v := m.assignee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeID returns the old "assignee_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldAssigneeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeID: %w", err)
	}
	return oldValue.AssigneeID, nil
}

// AddAssigneeID adds i to the "assignee_id" field.
func (m *IncidentMutation) AddAssigneeID(i int) {
	if m.addassignee_id != nil {
		*m.addassignee_id += i
	} else {
		m.addassignee_id = &i
	}
}

// AddedAssigneeID returns the value that was added to the "assignee_id" field in this mutation.
func (m *IncidentMutation) AddedAssigneeID() (r int, exists bool) {
	v := m.addassignee_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssigneeID clears the value of the "assignee_id" field.
func (m *IncidentMutation) ClearAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	m.clearedFields[incident.FieldAssigneeID] = struct{}{}
}

// AssigneeIDCleared returns if the "assignee_id" field was cleared in this mutation.
func (m *IncidentMutation) AssigneeIDCleared() bool {
	_, ok := m.clearedFields[incident.FieldAssigneeID]
	return ok
}

// ResetAssigneeID resets all changes to the "assignee_id" field.
func (m *IncidentMutation) ResetAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	delete(m.clearedFields, incident.FieldAssigneeID)
}

// SetConfigurationItemID sets the "configuration_item_id" field.
func (m *IncidentMutation) SetConfigurationItemID(i int) {
	m.configuration_item_id = &i
	m.addconfiguration_item_id = nil
}

// ConfigurationItemID returns the value of the "configuration_item_id" field in the mutation.
func (m *IncidentMutation) ConfigurationItemID() (r int, exists bool) {
	v := m.configuration_item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigurationItemID returns the old "configuration_item_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldConfigurationItemID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigurationItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigurationItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigurationItemID: %w", err)
	}
	return oldValue.ConfigurationItemID, nil
}

// AddConfigurationItemID adds i to the "configuration_item_id" field.
func (m *IncidentMutation) AddConfigurationItemID(i int) {
	if m.addconfiguration_item_id != nil {
		*m.addconfiguration_item_id += i
	} else {
		m.addconfiguration_item_id = &i
	}
}

// AddedConfigurationItemID returns the value that was added to the "configuration_item_id" field in this mutation.
func (m *IncidentMutation) AddedConfigurationItemID() (r int, exists bool) {
	v := m.addconfiguration_item_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearConfigurationItemID clears the value of the "configuration_item_id" field.
func (m *IncidentMutation) ClearConfigurationItemID() {
	m.configuration_item_id = nil
	m.addconfiguration_item_id = nil
	m.clearedFields[incident.FieldConfigurationItemID] = struct{}{}
}

// ConfigurationItemIDCleared returns if the "configuration_item_id" field was cleared in this mutation.
func (m *IncidentMutation) ConfigurationItemIDCleared() bool {
	_, ok := m.clearedFields[incident.FieldConfigurationItemID]
	return ok
}

// ResetConfigurationItemID resets all changes to the "configuration_item_id" field.
func (m *IncidentMutation) ResetConfigurationItemID() {
	m.configuration_item_id = nil
	m.addconfiguration_item_id = nil
	delete(m.clearedFields, incident.FieldConfigurationItemID)
}

// SetResolvedAt sets the "resolved_at" field.
func (m *IncidentMutation) SetResolvedAt(t time.Time) {
	m.resolved_at = &t
}

// ResolvedAt returns the value of the "resolved_at" field in the mutation.
func (m *IncidentMutation) ResolvedAt() (r time.Time, exists bool) {
	v := m.resolved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedAt returns the old "resolved_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldResolvedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedAt: %w", err)
	}
	return oldValue.ResolvedAt, nil
}

// ClearResolvedAt clears the value of the "resolved_at" field.
func (m *IncidentMutation) ClearResolvedAt() {
	m.resolved_at = nil
	m.clearedFields[incident.FieldResolvedAt] = struct{}{}
}

// ResolvedAtCleared returns if the "resolved_at" field was cleared in this mutation.
func (m *IncidentMutation) ResolvedAtCleared() bool {
	_, ok := m.clearedFields[incident.FieldResolvedAt]
	return ok
}

// ResetResolvedAt resets all changes to the "resolved_at" field.
func (m *IncidentMutation) ResetResolvedAt() {
	m.resolved_at = nil
	delete(m.clearedFields, incident.FieldResolvedAt)
}

// SetClosedAt sets the "closed_at" field.
func (m *IncidentMutation) SetClosedAt(t time.Time) {
	m.closed_at = &t
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *IncidentMutation) ClosedAt() (r time.Time, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldClosedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ClearClosedAt clears the value of the "closed_at" field.
func (m *IncidentMutation) ClearClosedAt() {
	m.closed_at = nil
	m.clearedFields[incident.FieldClosedAt] = struct{}{}
}

// ClosedAtCleared returns if the "closed_at" field was cleared in this mutation.
func (m *IncidentMutation) ClosedAtCleared() bool {
	_, ok := m.clearedFields[incident.FieldClosedAt]
	return ok
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *IncidentMutation) ResetClosedAt() {
	m.closed_at = nil
	delete(m.clearedFields, incident.FieldClosedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *IncidentMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *IncidentMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IncidentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IncidentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IncidentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the IncidentMutation builder.
func (m *IncidentMutation) Where(ps ...predicate.Incident) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Incident, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Incident).
func (m *IncidentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.title != nil {
		fields = append(fields, incident.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, incident.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, incident.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, incident.FieldPriority)
	}
	if m.incident_number != nil {
		fields = append(fields, incident.FieldIncidentNumber)
	}
	if m.reporter_id != nil {
		fields = append(fields, incident.FieldReporterID)
	}
	if m.assignee_id != nil {
		fields = append(fields, incident.FieldAssigneeID)
	}
	if m.configuration_item_id != nil {
		fields = append(fields, incident.FieldConfigurationItemID)
	}
	if m.resolved_at != nil {
		fields = append(fields, incident.FieldResolvedAt)
	}
	if m.closed_at != nil {
		fields = append(fields, incident.FieldClosedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, incident.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, incident.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, incident.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incident.FieldTitle:
		return m.Title()
	case incident.FieldDescription:
		return m.Description()
	case incident.FieldStatus:
		return m.Status()
	case incident.FieldPriority:
		return m.Priority()
	case incident.FieldIncidentNumber:
		return m.IncidentNumber()
	case incident.FieldReporterID:
		return m.ReporterID()
	case incident.FieldAssigneeID:
		return m.AssigneeID()
	case incident.FieldConfigurationItemID:
		return m.ConfigurationItemID()
	case incident.FieldResolvedAt:
		return m.ResolvedAt()
	case incident.FieldClosedAt:
		return m.ClosedAt()
	case incident.FieldTenantID:
		return m.TenantID()
	case incident.FieldCreatedAt:
		return m.CreatedAt()
	case incident.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incident.FieldTitle:
		return m.OldTitle(ctx)
	case incident.FieldDescription:
		return m.OldDescription(ctx)
	case incident.FieldStatus:
		return m.OldStatus(ctx)
	case incident.FieldPriority:
		return m.OldPriority(ctx)
	case incident.FieldIncidentNumber:
		return m.OldIncidentNumber(ctx)
	case incident.FieldReporterID:
		return m.OldReporterID(ctx)
	case incident.FieldAssigneeID:
		return m.OldAssigneeID(ctx)
	case incident.FieldConfigurationItemID:
		return m.OldConfigurationItemID(ctx)
	case incident.FieldResolvedAt:
		return m.OldResolvedAt(ctx)
	case incident.FieldClosedAt:
		return m.OldClosedAt(ctx)
	case incident.FieldTenantID:
		return m.OldTenantID(ctx)
	case incident.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incident.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Incident field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incident.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case incident.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incident.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case incident.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case incident.FieldIncidentNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentNumber(v)
		return nil
	case incident.FieldReporterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReporterID(v)
		return nil
	case incident.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeID(v)
		return nil
	case incident.FieldConfigurationItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigurationItemID(v)
		return nil
	case incident.FieldResolvedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedAt(v)
		return nil
	case incident.FieldClosedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	case incident.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incident.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incident.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Incident field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentMutation) AddedFields() []string {
	var fields []string
	if m.addreporter_id != nil {
		fields = append(fields, incident.FieldReporterID)
	}
	if m.addassignee_id != nil {
		fields = append(fields, incident.FieldAssigneeID)
	}
	if m.addconfiguration_item_id != nil {
		fields = append(fields, incident.FieldConfigurationItemID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, incident.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case incident.FieldReporterID:
		return m.AddedReporterID()
	case incident.FieldAssigneeID:
		return m.AddedAssigneeID()
	case incident.FieldConfigurationItemID:
		return m.AddedConfigurationItemID()
	case incident.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case incident.FieldReporterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReporterID(v)
		return nil
	case incident.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssigneeID(v)
		return nil
	case incident.FieldConfigurationItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfigurationItemID(v)
		return nil
	case incident.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Incident numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incident.FieldDescription) {
		fields = append(fields, incident.FieldDescription)
	}
	if m.FieldCleared(incident.FieldAssigneeID) {
		fields = append(fields, incident.FieldAssigneeID)
	}
	if m.FieldCleared(incident.FieldConfigurationItemID) {
		fields = append(fields, incident.FieldConfigurationItemID)
	}
	if m.FieldCleared(incident.FieldResolvedAt) {
		fields = append(fields, incident.FieldResolvedAt)
	}
	if m.FieldCleared(incident.FieldClosedAt) {
		fields = append(fields, incident.FieldClosedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentMutation) ClearField(name string) error {
	switch name {
	case incident.FieldDescription:
		m.ClearDescription()
		return nil
	case incident.FieldAssigneeID:
		m.ClearAssigneeID()
		return nil
	case incident.FieldConfigurationItemID:
		m.ClearConfigurationItemID()
		return nil
	case incident.FieldResolvedAt:
		m.ClearResolvedAt()
		return nil
	case incident.FieldClosedAt:
		m.ClearClosedAt()
		return nil
	}
	return fmt.Errorf("unknown Incident nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentMutation) ResetField(name string) error {
	switch name {
	case incident.FieldTitle:
		m.ResetTitle()
		return nil
	case incident.FieldDescription:
		m.ResetDescription()
		return nil
	case incident.FieldStatus:
		m.ResetStatus()
		return nil
	case incident.FieldPriority:
		m.ResetPriority()
		return nil
	case incident.FieldIncidentNumber:
		m.ResetIncidentNumber()
		return nil
	case incident.FieldReporterID:
		m.ResetReporterID()
		return nil
	case incident.FieldAssigneeID:
		m.ResetAssigneeID()
		return nil
	case incident.FieldConfigurationItemID:
		m.ResetConfigurationItemID()
		return nil
	case incident.FieldResolvedAt:
		m.ResetResolvedAt()
		return nil
	case incident.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	case incident.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incident.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incident.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Incident field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Incident unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Incident edge %s", name)
}

// KnowledgeArticleMutation represents an operation that mutates the KnowledgeArticle nodes in the graph.
type KnowledgeArticleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	content       *string
	category      *string
	tags          *string
	author_id     *int
	addauthor_id  *int
	tenant_id     *int
	addtenant_id  *int
	is_published  *bool
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*KnowledgeArticle, error)
	predicates    []predicate.KnowledgeArticle
}

var _ ent.Mutation = (*KnowledgeArticleMutation)(nil)

// knowledgearticleOption allows management of the mutation configuration using functional options.
type knowledgearticleOption func(*KnowledgeArticleMutation)

// newKnowledgeArticleMutation creates new mutation for the KnowledgeArticle entity.
func newKnowledgeArticleMutation(c config, op Op, opts ...knowledgearticleOption) *KnowledgeArticleMutation {
	m := &KnowledgeArticleMutation{
		config:        c,
		op:            op,
		typ:           TypeKnowledgeArticle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKnowledgeArticleID sets the ID field of the mutation.
func withKnowledgeArticleID(id int) knowledgearticleOption {
	return func(m *KnowledgeArticleMutation) {
		var (
			err   error
			once  sync.Once
			value *KnowledgeArticle
		)
		m.oldValue = func(ctx context.Context) (*KnowledgeArticle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KnowledgeArticle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKnowledgeArticle sets the old KnowledgeArticle of the mutation.
func withKnowledgeArticle(node *KnowledgeArticle) knowledgearticleOption {
	return func(m *KnowledgeArticleMutation) {
		m.oldValue = func(context.Context) (*KnowledgeArticle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KnowledgeArticleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KnowledgeArticleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KnowledgeArticleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KnowledgeArticleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KnowledgeArticle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *KnowledgeArticleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *KnowledgeArticleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *KnowledgeArticleMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *KnowledgeArticleMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *KnowledgeArticleMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *KnowledgeArticleMutation) ClearContent() {
	m.content = nil
	m.clearedFields[knowledgearticle.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *KnowledgeArticleMutation) ContentCleared() bool {
	_, ok := m.clearedFields[knowledgearticle.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *KnowledgeArticleMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, knowledgearticle.FieldContent)
}

// SetCategory sets the "category" field.
func (m *KnowledgeArticleMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *KnowledgeArticleMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *KnowledgeArticleMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[knowledgearticle.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *KnowledgeArticleMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[knowledgearticle.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *KnowledgeArticleMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, knowledgearticle.FieldCategory)
}

// SetTags sets the "tags" field.
func (m *KnowledgeArticleMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *KnowledgeArticleMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *KnowledgeArticleMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[knowledgearticle.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *KnowledgeArticleMutation) TagsCleared() bool {
	_, ok := m.clearedFields[knowledgearticle.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *KnowledgeArticleMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, knowledgearticle.FieldTags)
}

// SetAuthorID sets the "author_id" field.
func (m *KnowledgeArticleMutation) SetAuthorID(i int) {
	m.author_id = &i
	m.addauthor_id = nil
}

// AuthorID returns the value of the "author_id" field in the mutation.
func (m *KnowledgeArticleMutation) AuthorID() (r int, exists bool) {
	v := m.author_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorID returns the old "author_id" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldAuthorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorID: %w", err)
	}
	return oldValue.AuthorID, nil
}

// AddAuthorID adds i to the "author_id" field.
func (m *KnowledgeArticleMutation) AddAuthorID(i int) {
	if m.addauthor_id != nil {
		*m.addauthor_id += i
	} else {
		m.addauthor_id = &i
	}
}

// AddedAuthorID returns the value that was added to the "author_id" field in this mutation.
func (m *KnowledgeArticleMutation) AddedAuthorID() (r int, exists bool) {
	v := m.addauthor_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthorID resets all changes to the "author_id" field.
func (m *KnowledgeArticleMutation) ResetAuthorID() {
	m.author_id = nil
	m.addauthor_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *KnowledgeArticleMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *KnowledgeArticleMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *KnowledgeArticleMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *KnowledgeArticleMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *KnowledgeArticleMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetIsPublished sets the "is_published" field.
func (m *KnowledgeArticleMutation) SetIsPublished(b bool) {
	m.is_published = &b
}

// IsPublished returns the value of the "is_published" field in the mutation.
func (m *KnowledgeArticleMutation) IsPublished() (r bool, exists bool) {
	v := m.is_published
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublished returns the old "is_published" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldIsPublished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublished: %w", err)
	}
	return oldValue.IsPublished, nil
}

// ResetIsPublished resets all changes to the "is_published" field.
func (m *KnowledgeArticleMutation) ResetIsPublished() {
	m.is_published = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *KnowledgeArticleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KnowledgeArticleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KnowledgeArticleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KnowledgeArticleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KnowledgeArticleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KnowledgeArticle entity.
// If the KnowledgeArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeArticleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KnowledgeArticleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the KnowledgeArticleMutation builder.
func (m *KnowledgeArticleMutation) Where(ps ...predicate.KnowledgeArticle) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KnowledgeArticleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KnowledgeArticleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.KnowledgeArticle, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KnowledgeArticleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KnowledgeArticleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (KnowledgeArticle).
func (m *KnowledgeArticleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KnowledgeArticleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.title != nil {
		fields = append(fields, knowledgearticle.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, knowledgearticle.FieldContent)
	}
	if m.category != nil {
		fields = append(fields, knowledgearticle.FieldCategory)
	}
	if m.tags != nil {
		fields = append(fields, knowledgearticle.FieldTags)
	}
	if m.author_id != nil {
		fields = append(fields, knowledgearticle.FieldAuthorID)
	}
	if m.tenant_id != nil {
		fields = append(fields, knowledgearticle.FieldTenantID)
	}
	if m.is_published != nil {
		fields = append(fields, knowledgearticle.FieldIsPublished)
	}
	if m.created_at != nil {
		fields = append(fields, knowledgearticle.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, knowledgearticle.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KnowledgeArticleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case knowledgearticle.FieldTitle:
		return m.Title()
	case knowledgearticle.FieldContent:
		return m.Content()
	case knowledgearticle.FieldCategory:
		return m.Category()
	case knowledgearticle.FieldTags:
		return m.Tags()
	case knowledgearticle.FieldAuthorID:
		return m.AuthorID()
	case knowledgearticle.FieldTenantID:
		return m.TenantID()
	case knowledgearticle.FieldIsPublished:
		return m.IsPublished()
	case knowledgearticle.FieldCreatedAt:
		return m.CreatedAt()
	case knowledgearticle.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KnowledgeArticleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case knowledgearticle.FieldTitle:
		return m.OldTitle(ctx)
	case knowledgearticle.FieldContent:
		return m.OldContent(ctx)
	case knowledgearticle.FieldCategory:
		return m.OldCategory(ctx)
	case knowledgearticle.FieldTags:
		return m.OldTags(ctx)
	case knowledgearticle.FieldAuthorID:
		return m.OldAuthorID(ctx)
	case knowledgearticle.FieldTenantID:
		return m.OldTenantID(ctx)
	case knowledgearticle.FieldIsPublished:
		return m.OldIsPublished(ctx)
	case knowledgearticle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case knowledgearticle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown KnowledgeArticle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KnowledgeArticleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case knowledgearticle.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case knowledgearticle.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case knowledgearticle.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case knowledgearticle.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case knowledgearticle.FieldAuthorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorID(v)
		return nil
	case knowledgearticle.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case knowledgearticle.FieldIsPublished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublished(v)
		return nil
	case knowledgearticle.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case knowledgearticle.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown KnowledgeArticle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KnowledgeArticleMutation) AddedFields() []string {
	var fields []string
	if m.addauthor_id != nil {
		fields = append(fields, knowledgearticle.FieldAuthorID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, knowledgearticle.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KnowledgeArticleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case knowledgearticle.FieldAuthorID:
		return m.AddedAuthorID()
	case knowledgearticle.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KnowledgeArticleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case knowledgearticle.FieldAuthorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthorID(v)
		return nil
	case knowledgearticle.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown KnowledgeArticle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KnowledgeArticleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(knowledgearticle.FieldContent) {
		fields = append(fields, knowledgearticle.FieldContent)
	}
	if m.FieldCleared(knowledgearticle.FieldCategory) {
		fields = append(fields, knowledgearticle.FieldCategory)
	}
	if m.FieldCleared(knowledgearticle.FieldTags) {
		fields = append(fields, knowledgearticle.FieldTags)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KnowledgeArticleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KnowledgeArticleMutation) ClearField(name string) error {
	switch name {
	case knowledgearticle.FieldContent:
		m.ClearContent()
		return nil
	case knowledgearticle.FieldCategory:
		m.ClearCategory()
		return nil
	case knowledgearticle.FieldTags:
		m.ClearTags()
		return nil
	}
	return fmt.Errorf("unknown KnowledgeArticle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KnowledgeArticleMutation) ResetField(name string) error {
	switch name {
	case knowledgearticle.FieldTitle:
		m.ResetTitle()
		return nil
	case knowledgearticle.FieldContent:
		m.ResetContent()
		return nil
	case knowledgearticle.FieldCategory:
		m.ResetCategory()
		return nil
	case knowledgearticle.FieldTags:
		m.ResetTags()
		return nil
	case knowledgearticle.FieldAuthorID:
		m.ResetAuthorID()
		return nil
	case knowledgearticle.FieldTenantID:
		m.ResetTenantID()
		return nil
	case knowledgearticle.FieldIsPublished:
		m.ResetIsPublished()
		return nil
	case knowledgearticle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case knowledgearticle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown KnowledgeArticle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KnowledgeArticleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KnowledgeArticleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KnowledgeArticleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KnowledgeArticleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KnowledgeArticleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KnowledgeArticleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KnowledgeArticleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown KnowledgeArticle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KnowledgeArticleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown KnowledgeArticle edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	role                *string
	content             *string
	request_id          *string
	clearedFields       map[string]struct{}
	conversation        *int
	clearedconversation bool
	done                bool
	oldValue            func(context.Context) (*Message, error)
	predicates          []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id int) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetConversationID sets the "conversation_id" field.
func (m *MessageMutation) SetConversationID(i int) {
	m.conversation = &i
}

// ConversationID returns the value of the "conversation_id" field in the mutation.
func (m *MessageMutation) ConversationID() (r int, exists bool) {
	v := m.conversation
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationID returns the old "conversation_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldConversationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationID: %w", err)
	}
	return oldValue.ConversationID, nil
}

// ResetConversationID resets all changes to the "conversation_id" field.
func (m *MessageMutation) ResetConversationID() {
	m.conversation = nil
}

// SetRole sets the "role" field.
func (m *MessageMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *MessageMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *MessageMutation) ResetRole() {
	m.role = nil
}

// SetContent sets the "content" field.
func (m *MessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MessageMutation) ResetContent() {
	m.content = nil
}

// SetRequestID sets the "request_id" field.
func (m *MessageMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *MessageMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *MessageMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[message.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *MessageMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[message.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *MessageMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, message.FieldRequestID)
}

// ClearConversation clears the "conversation" edge to the Conversation entity.
func (m *MessageMutation) ClearConversation() {
	m.clearedconversation = true
	m.clearedFields[message.FieldConversationID] = struct{}{}
}

// ConversationCleared reports if the "conversation" edge to the Conversation entity was cleared.
func (m *MessageMutation) ConversationCleared() bool {
	return m.clearedconversation
}

// ConversationIDs returns the "conversation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConversationID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) ConversationIDs() (ids []int) {
	if id := m.conversation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConversation resets all changes to the "conversation" edge.
func (m *MessageMutation) ResetConversation() {
	m.conversation = nil
	m.clearedconversation = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.conversation != nil {
		fields = append(fields, message.FieldConversationID)
	}
	if m.role != nil {
		fields = append(fields, message.FieldRole)
	}
	if m.content != nil {
		fields = append(fields, message.FieldContent)
	}
	if m.request_id != nil {
		fields = append(fields, message.FieldRequestID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldCreatedAt:
		return m.CreatedAt()
	case message.FieldConversationID:
		return m.ConversationID()
	case message.FieldRole:
		return m.Role()
	case message.FieldContent:
		return m.Content()
	case message.FieldRequestID:
		return m.RequestID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case message.FieldConversationID:
		return m.OldConversationID(ctx)
	case message.FieldRole:
		return m.OldRole(ctx)
	case message.FieldContent:
		return m.OldContent(ctx)
	case message.FieldRequestID:
		return m.OldRequestID(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case message.FieldConversationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationID(v)
		return nil
	case message.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case message.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case message.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldRequestID) {
		fields = append(fields, message.FieldRequestID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldRequestID:
		m.ClearRequestID()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case message.FieldConversationID:
		m.ResetConversationID()
		return nil
	case message.FieldRole:
		m.ResetRole()
		return nil
	case message.FieldContent:
		m.ResetContent()
		return nil
	case message.FieldRequestID:
		m.ResetRequestID()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.conversation != nil {
		edges = append(edges, message.EdgeConversation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeConversation:
		if id := m.conversation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconversation {
		edges = append(edges, message.EdgeConversation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeConversation:
		return m.clearedconversation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ClearConversation()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ResetConversation()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	message       *string
	_type         *string
	read          *bool
	action_url    *string
	action_text   *string
	user_id       *int
	adduser_id    *int
	tenant_id     *int
	addtenant_id  *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Notification, error)
	predicates    []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id int) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *NotificationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *NotificationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *NotificationMutation) ResetTitle() {
	m.title = nil
}

// SetMessage sets the "message" field.
func (m *NotificationMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *NotificationMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *NotificationMutation) ResetMessage() {
	m.message = nil
}

// SetType sets the "type" field.
func (m *NotificationMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationMutation) ResetType() {
	m._type = nil
}

// SetRead sets the "read" field.
func (m *NotificationMutation) SetRead(b bool) {
	m.read = &b
}

// Read returns the value of the "read" field in the mutation.
func (m *NotificationMutation) Read() (r bool, exists bool) {
	v := m.read
	if v == nil {
		return
	}
	return *v, true
}

// OldRead returns the old "read" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRead: %w", err)
	}
	return oldValue.Read, nil
}

// ResetRead resets all changes to the "read" field.
func (m *NotificationMutation) ResetRead() {
	m.read = nil
}

// SetActionURL sets the "action_url" field.
func (m *NotificationMutation) SetActionURL(s string) {
	m.action_url = &s
}

// ActionURL returns the value of the "action_url" field in the mutation.
func (m *NotificationMutation) ActionURL() (r string, exists bool) {
	v := m.action_url
	if v == nil {
		return
	}
	return *v, true
}

// OldActionURL returns the old "action_url" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldActionURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionURL: %w", err)
	}
	return oldValue.ActionURL, nil
}

// ClearActionURL clears the value of the "action_url" field.
func (m *NotificationMutation) ClearActionURL() {
	m.action_url = nil
	m.clearedFields[notification.FieldActionURL] = struct{}{}
}

// ActionURLCleared returns if the "action_url" field was cleared in this mutation.
func (m *NotificationMutation) ActionURLCleared() bool {
	_, ok := m.clearedFields[notification.FieldActionURL]
	return ok
}

// ResetActionURL resets all changes to the "action_url" field.
func (m *NotificationMutation) ResetActionURL() {
	m.action_url = nil
	delete(m.clearedFields, notification.FieldActionURL)
}

// SetActionText sets the "action_text" field.
func (m *NotificationMutation) SetActionText(s string) {
	m.action_text = &s
}

// ActionText returns the value of the "action_text" field in the mutation.
func (m *NotificationMutation) ActionText() (r string, exists bool) {
	v := m.action_text
	if v == nil {
		return
	}
	return *v, true
}

// OldActionText returns the old "action_text" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldActionText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionText: %w", err)
	}
	return oldValue.ActionText, nil
}

// ClearActionText clears the value of the "action_text" field.
func (m *NotificationMutation) ClearActionText() {
	m.action_text = nil
	m.clearedFields[notification.FieldActionText] = struct{}{}
}

// ActionTextCleared returns if the "action_text" field was cleared in this mutation.
func (m *NotificationMutation) ActionTextCleared() bool {
	_, ok := m.clearedFields[notification.FieldActionText]
	return ok
}

// ResetActionText resets all changes to the "action_text" field.
func (m *NotificationMutation) ResetActionText() {
	m.action_text = nil
	delete(m.clearedFields, notification.FieldActionText)
}

// SetUserID sets the "user_id" field.
func (m *NotificationMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *NotificationMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *NotificationMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *NotificationMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *NotificationMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *NotificationMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *NotificationMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *NotificationMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *NotificationMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *NotificationMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.title != nil {
		fields = append(fields, notification.FieldTitle)
	}
	if m.message != nil {
		fields = append(fields, notification.FieldMessage)
	}
	if m._type != nil {
		fields = append(fields, notification.FieldType)
	}
	if m.read != nil {
		fields = append(fields, notification.FieldRead)
	}
	if m.action_url != nil {
		fields = append(fields, notification.FieldActionURL)
	}
	if m.action_text != nil {
		fields = append(fields, notification.FieldActionText)
	}
	if m.user_id != nil {
		fields = append(fields, notification.FieldUserID)
	}
	if m.tenant_id != nil {
		fields = append(fields, notification.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notification.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldTitle:
		return m.Title()
	case notification.FieldMessage:
		return m.Message()
	case notification.FieldType:
		return m.GetType()
	case notification.FieldRead:
		return m.Read()
	case notification.FieldActionURL:
		return m.ActionURL()
	case notification.FieldActionText:
		return m.ActionText()
	case notification.FieldUserID:
		return m.UserID()
	case notification.FieldTenantID:
		return m.TenantID()
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	case notification.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldTitle:
		return m.OldTitle(ctx)
	case notification.FieldMessage:
		return m.OldMessage(ctx)
	case notification.FieldType:
		return m.OldType(ctx)
	case notification.FieldRead:
		return m.OldRead(ctx)
	case notification.FieldActionURL:
		return m.OldActionURL(ctx)
	case notification.FieldActionText:
		return m.OldActionText(ctx)
	case notification.FieldUserID:
		return m.OldUserID(ctx)
	case notification.FieldTenantID:
		return m.OldTenantID(ctx)
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case notification.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case notification.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notification.FieldRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRead(v)
		return nil
	case notification.FieldActionURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionURL(v)
		return nil
	case notification.FieldActionText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionText(v)
		return nil
	case notification.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case notification.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, notification.FieldUserID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, notification.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldUserID:
		return m.AddedUserID()
	case notification.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notification.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case notification.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldActionURL) {
		fields = append(fields, notification.FieldActionURL)
	}
	if m.FieldCleared(notification.FieldActionText) {
		fields = append(fields, notification.FieldActionText)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldActionURL:
		m.ClearActionURL()
		return nil
	case notification.FieldActionText:
		m.ClearActionText()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldTitle:
		m.ResetTitle()
		return nil
	case notification.FieldMessage:
		m.ResetMessage()
		return nil
	case notification.FieldType:
		m.ResetType()
		return nil
	case notification.FieldRead:
		m.ResetRead()
		return nil
	case notification.FieldActionURL:
		m.ResetActionURL()
		return nil
	case notification.FieldActionText:
		m.ResetActionText()
		return nil
	case notification.FieldUserID:
		m.ResetUserID()
		return nil
	case notification.FieldTenantID:
		m.ResetTenantID()
		return nil
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Notification edge %s", name)
}

// ProblemMutation represents an operation that mutates the Problem nodes in the graph.
type ProblemMutation struct {
	config
	op             Op
	typ            string
	id             *int
	title          *string
	description    *string
	status         *string
	priority       *string
	category       *string
	root_cause     *string
	impact         *string
	assignee_id    *int
	addassignee_id *int
	created_by     *int
	addcreated_by  *int
	tenant_id      *int
	addtenant_id   *int
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Problem, error)
	predicates     []predicate.Problem
}

var _ ent.Mutation = (*ProblemMutation)(nil)

// problemOption allows management of the mutation configuration using functional options.
type problemOption func(*ProblemMutation)

// newProblemMutation creates new mutation for the Problem entity.
func newProblemMutation(c config, op Op, opts ...problemOption) *ProblemMutation {
	m := &ProblemMutation{
		config:        c,
		op:            op,
		typ:           TypeProblem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProblemID sets the ID field of the mutation.
func withProblemID(id int) problemOption {
	return func(m *ProblemMutation) {
		var (
			err   error
			once  sync.Once
			value *Problem
		)
		m.oldValue = func(ctx context.Context) (*Problem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Problem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProblem sets the old Problem of the mutation.
func withProblem(node *Problem) problemOption {
	return func(m *ProblemMutation) {
		m.oldValue = func(context.Context) (*Problem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProblemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProblemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProblemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProblemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Problem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ProblemMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ProblemMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ProblemMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ProblemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProblemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProblemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[problem.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProblemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[problem.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProblemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, problem.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *ProblemMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProblemMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProblemMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *ProblemMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ProblemMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *ProblemMutation) ResetPriority() {
	m.priority = nil
}

// SetCategory sets the "category" field.
func (m *ProblemMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ProblemMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ProblemMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[problem.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ProblemMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[problem.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ProblemMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, problem.FieldCategory)
}

// SetRootCause sets the "root_cause" field.
func (m *ProblemMutation) SetRootCause(s string) {
	m.root_cause = &s
}

// RootCause returns the value of the "root_cause" field in the mutation.
func (m *ProblemMutation) RootCause() (r string, exists bool) {
	v := m.root_cause
	if v == nil {
		return
	}
	return *v, true
}

// OldRootCause returns the old "root_cause" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldRootCause(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootCause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootCause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootCause: %w", err)
	}
	return oldValue.RootCause, nil
}

// ClearRootCause clears the value of the "root_cause" field.
func (m *ProblemMutation) ClearRootCause() {
	m.root_cause = nil
	m.clearedFields[problem.FieldRootCause] = struct{}{}
}

// RootCauseCleared returns if the "root_cause" field was cleared in this mutation.
func (m *ProblemMutation) RootCauseCleared() bool {
	_, ok := m.clearedFields[problem.FieldRootCause]
	return ok
}

// ResetRootCause resets all changes to the "root_cause" field.
func (m *ProblemMutation) ResetRootCause() {
	m.root_cause = nil
	delete(m.clearedFields, problem.FieldRootCause)
}

// SetImpact sets the "impact" field.
func (m *ProblemMutation) SetImpact(s string) {
	m.impact = &s
}

// Impact returns the value of the "impact" field in the mutation.
func (m *ProblemMutation) Impact() (r string, exists bool) {
	v := m.impact
	if v == nil {
		return
	}
	return *v, true
}

// OldImpact returns the old "impact" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldImpact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpact: %w", err)
	}
	return oldValue.Impact, nil
}

// ClearImpact clears the value of the "impact" field.
func (m *ProblemMutation) ClearImpact() {
	m.impact = nil
	m.clearedFields[problem.FieldImpact] = struct{}{}
}

// ImpactCleared returns if the "impact" field was cleared in this mutation.
func (m *ProblemMutation) ImpactCleared() bool {
	_, ok := m.clearedFields[problem.FieldImpact]
	return ok
}

// ResetImpact resets all changes to the "impact" field.
func (m *ProblemMutation) ResetImpact() {
	m.impact = nil
	delete(m.clearedFields, problem.FieldImpact)
}

// SetAssigneeID sets the "assignee_id" field.
func (m *ProblemMutation) SetAssigneeID(i int) {
	m.assignee_id = &i
	m.addassignee_id = nil
}

// AssigneeID returns the value of the "assignee_id" field in the mutation.
func (m *ProblemMutation) AssigneeID() (r int, exists bool) {
	v := m.assignee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeID returns the old "assignee_id" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldAssigneeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeID: %w", err)
	}
	return oldValue.AssigneeID, nil
}

// AddAssigneeID adds i to the "assignee_id" field.
func (m *ProblemMutation) AddAssigneeID(i int) {
	if m.addassignee_id != nil {
		*m.addassignee_id += i
	} else {
		m.addassignee_id = &i
	}
}

// AddedAssigneeID returns the value that was added to the "assignee_id" field in this mutation.
func (m *ProblemMutation) AddedAssigneeID() (r int, exists bool) {
	v := m.addassignee_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssigneeID clears the value of the "assignee_id" field.
func (m *ProblemMutation) ClearAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	m.clearedFields[problem.FieldAssigneeID] = struct{}{}
}

// AssigneeIDCleared returns if the "assignee_id" field was cleared in this mutation.
func (m *ProblemMutation) AssigneeIDCleared() bool {
	_, ok := m.clearedFields[problem.FieldAssigneeID]
	return ok
}

// ResetAssigneeID resets all changes to the "assignee_id" field.
func (m *ProblemMutation) ResetAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	delete(m.clearedFields, problem.FieldAssigneeID)
}

// SetCreatedBy sets the "created_by" field.
func (m *ProblemMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProblemMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ProblemMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ProblemMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProblemMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ProblemMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProblemMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProblemMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProblemMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProblemMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProblemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProblemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProblemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProblemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProblemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProblemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProblemMutation builder.
func (m *ProblemMutation) Where(ps ...predicate.Problem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProblemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProblemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Problem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProblemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProblemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Problem).
func (m *ProblemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProblemMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.title != nil {
		fields = append(fields, problem.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, problem.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, problem.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, problem.FieldPriority)
	}
	if m.category != nil {
		fields = append(fields, problem.FieldCategory)
	}
	if m.root_cause != nil {
		fields = append(fields, problem.FieldRootCause)
	}
	if m.impact != nil {
		fields = append(fields, problem.FieldImpact)
	}
	if m.assignee_id != nil {
		fields = append(fields, problem.FieldAssigneeID)
	}
	if m.created_by != nil {
		fields = append(fields, problem.FieldCreatedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, problem.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, problem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, problem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProblemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case problem.FieldTitle:
		return m.Title()
	case problem.FieldDescription:
		return m.Description()
	case problem.FieldStatus:
		return m.Status()
	case problem.FieldPriority:
		return m.Priority()
	case problem.FieldCategory:
		return m.Category()
	case problem.FieldRootCause:
		return m.RootCause()
	case problem.FieldImpact:
		return m.Impact()
	case problem.FieldAssigneeID:
		return m.AssigneeID()
	case problem.FieldCreatedBy:
		return m.CreatedBy()
	case problem.FieldTenantID:
		return m.TenantID()
	case problem.FieldCreatedAt:
		return m.CreatedAt()
	case problem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProblemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case problem.FieldTitle:
		return m.OldTitle(ctx)
	case problem.FieldDescription:
		return m.OldDescription(ctx)
	case problem.FieldStatus:
		return m.OldStatus(ctx)
	case problem.FieldPriority:
		return m.OldPriority(ctx)
	case problem.FieldCategory:
		return m.OldCategory(ctx)
	case problem.FieldRootCause:
		return m.OldRootCause(ctx)
	case problem.FieldImpact:
		return m.OldImpact(ctx)
	case problem.FieldAssigneeID:
		return m.OldAssigneeID(ctx)
	case problem.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case problem.FieldTenantID:
		return m.OldTenantID(ctx)
	case problem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case problem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Problem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProblemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case problem.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case problem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case problem.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case problem.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case problem.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case problem.FieldRootCause:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootCause(v)
		return nil
	case problem.FieldImpact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpact(v)
		return nil
	case problem.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeID(v)
		return nil
	case problem.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case problem.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case problem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case problem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Problem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProblemMutation) AddedFields() []string {
	var fields []string
	if m.addassignee_id != nil {
		fields = append(fields, problem.FieldAssigneeID)
	}
	if m.addcreated_by != nil {
		fields = append(fields, problem.FieldCreatedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, problem.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProblemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case problem.FieldAssigneeID:
		return m.AddedAssigneeID()
	case problem.FieldCreatedBy:
		return m.AddedCreatedBy()
	case problem.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProblemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case problem.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssigneeID(v)
		return nil
	case problem.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case problem.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Problem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProblemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(problem.FieldDescription) {
		fields = append(fields, problem.FieldDescription)
	}
	if m.FieldCleared(problem.FieldCategory) {
		fields = append(fields, problem.FieldCategory)
	}
	if m.FieldCleared(problem.FieldRootCause) {
		fields = append(fields, problem.FieldRootCause)
	}
	if m.FieldCleared(problem.FieldImpact) {
		fields = append(fields, problem.FieldImpact)
	}
	if m.FieldCleared(problem.FieldAssigneeID) {
		fields = append(fields, problem.FieldAssigneeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProblemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProblemMutation) ClearField(name string) error {
	switch name {
	case problem.FieldDescription:
		m.ClearDescription()
		return nil
	case problem.FieldCategory:
		m.ClearCategory()
		return nil
	case problem.FieldRootCause:
		m.ClearRootCause()
		return nil
	case problem.FieldImpact:
		m.ClearImpact()
		return nil
	case problem.FieldAssigneeID:
		m.ClearAssigneeID()
		return nil
	}
	return fmt.Errorf("unknown Problem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProblemMutation) ResetField(name string) error {
	switch name {
	case problem.FieldTitle:
		m.ResetTitle()
		return nil
	case problem.FieldDescription:
		m.ResetDescription()
		return nil
	case problem.FieldStatus:
		m.ResetStatus()
		return nil
	case problem.FieldPriority:
		m.ResetPriority()
		return nil
	case problem.FieldCategory:
		m.ResetCategory()
		return nil
	case problem.FieldRootCause:
		m.ResetRootCause()
		return nil
	case problem.FieldImpact:
		m.ResetImpact()
		return nil
	case problem.FieldAssigneeID:
		m.ResetAssigneeID()
		return nil
	case problem.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case problem.FieldTenantID:
		m.ResetTenantID()
		return nil
	case problem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case problem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Problem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProblemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProblemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProblemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProblemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProblemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProblemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProblemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Problem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProblemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Problem edge %s", name)
}

// ProcessDefinitionMutation represents an operation that mutates the ProcessDefinition nodes in the graph.
type ProcessDefinitionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	key               *string
	name              *string
	description       *string
	version           *string
	category          *string
	bpmn_xml          *[]uint8
	appendbpmn_xml    []uint8
	process_variables *map[string]interface{}
	is_active         *bool
	is_latest         *bool
	deployment_id     *int
	adddeployment_id  *int
	deployment_name   *string
	deployed_at       *time.Time
	tenant_id         *int
	addtenant_id      *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*ProcessDefinition, error)
	predicates        []predicate.ProcessDefinition
}

var _ ent.Mutation = (*ProcessDefinitionMutation)(nil)

// processdefinitionOption allows management of the mutation configuration using functional options.
type processdefinitionOption func(*ProcessDefinitionMutation)

// newProcessDefinitionMutation creates new mutation for the ProcessDefinition entity.
func newProcessDefinitionMutation(c config, op Op, opts ...processdefinitionOption) *ProcessDefinitionMutation {
	m := &ProcessDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessDefinitionID sets the ID field of the mutation.
func withProcessDefinitionID(id int) processdefinitionOption {
	return func(m *ProcessDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessDefinition
		)
		m.oldValue = func(ctx context.Context) (*ProcessDefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessDefinition sets the old ProcessDefinition of the mutation.
func withProcessDefinition(node *ProcessDefinition) processdefinitionOption {
	return func(m *ProcessDefinitionMutation) {
		m.oldValue = func(context.Context) (*ProcessDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessDefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessDefinitionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessDefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *ProcessDefinitionMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *ProcessDefinitionMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *ProcessDefinitionMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *ProcessDefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProcessDefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProcessDefinitionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProcessDefinitionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProcessDefinitionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProcessDefinitionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[processdefinition.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProcessDefinitionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[processdefinition.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProcessDefinitionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, processdefinition.FieldDescription)
}

// SetVersion sets the "version" field.
func (m *ProcessDefinitionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ProcessDefinitionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ProcessDefinitionMutation) ResetVersion() {
	m.version = nil
}

// SetCategory sets the "category" field.
func (m *ProcessDefinitionMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ProcessDefinitionMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ProcessDefinitionMutation) ResetCategory() {
	m.category = nil
}

// SetBpmnXML sets the "bpmn_xml" field.
func (m *ProcessDefinitionMutation) SetBpmnXML(u []uint8) {
	m.bpmn_xml = &u
	m.appendbpmn_xml = nil
}

// BpmnXML returns the value of the "bpmn_xml" field in the mutation.
func (m *ProcessDefinitionMutation) BpmnXML() (r []uint8, exists bool) {
	v := m.bpmn_xml
	if v == nil {
		return
	}
	return *v, true
}

// OldBpmnXML returns the old "bpmn_xml" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldBpmnXML(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBpmnXML is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBpmnXML requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBpmnXML: %w", err)
	}
	return oldValue.BpmnXML, nil
}

// AppendBpmnXML adds u to the "bpmn_xml" field.
func (m *ProcessDefinitionMutation) AppendBpmnXML(u []uint8) {
	m.appendbpmn_xml = append(m.appendbpmn_xml, u...)
}

// AppendedBpmnXML returns the list of values that were appended to the "bpmn_xml" field in this mutation.
func (m *ProcessDefinitionMutation) AppendedBpmnXML() ([]uint8, bool) {
	if len(m.appendbpmn_xml) == 0 {
		return nil, false
	}
	return m.appendbpmn_xml, true
}

// ResetBpmnXML resets all changes to the "bpmn_xml" field.
func (m *ProcessDefinitionMutation) ResetBpmnXML() {
	m.bpmn_xml = nil
	m.appendbpmn_xml = nil
}

// SetProcessVariables sets the "process_variables" field.
func (m *ProcessDefinitionMutation) SetProcessVariables(value map[string]interface{}) {
	m.process_variables = &value
}

// ProcessVariables returns the value of the "process_variables" field in the mutation.
func (m *ProcessDefinitionMutation) ProcessVariables() (r map[string]interface{}, exists bool) {
	v := m.process_variables
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessVariables returns the old "process_variables" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldProcessVariables(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessVariables: %w", err)
	}
	return oldValue.ProcessVariables, nil
}

// ClearProcessVariables clears the value of the "process_variables" field.
func (m *ProcessDefinitionMutation) ClearProcessVariables() {
	m.process_variables = nil
	m.clearedFields[processdefinition.FieldProcessVariables] = struct{}{}
}

// ProcessVariablesCleared returns if the "process_variables" field was cleared in this mutation.
func (m *ProcessDefinitionMutation) ProcessVariablesCleared() bool {
	_, ok := m.clearedFields[processdefinition.FieldProcessVariables]
	return ok
}

// ResetProcessVariables resets all changes to the "process_variables" field.
func (m *ProcessDefinitionMutation) ResetProcessVariables() {
	m.process_variables = nil
	delete(m.clearedFields, processdefinition.FieldProcessVariables)
}

// SetIsActive sets the "is_active" field.
func (m *ProcessDefinitionMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ProcessDefinitionMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ProcessDefinitionMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsLatest sets the "is_latest" field.
func (m *ProcessDefinitionMutation) SetIsLatest(b bool) {
	m.is_latest = &b
}

// IsLatest returns the value of the "is_latest" field in the mutation.
func (m *ProcessDefinitionMutation) IsLatest() (r bool, exists bool) {
	v := m.is_latest
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLatest returns the old "is_latest" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldIsLatest(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLatest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLatest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLatest: %w", err)
	}
	return oldValue.IsLatest, nil
}

// ResetIsLatest resets all changes to the "is_latest" field.
func (m *ProcessDefinitionMutation) ResetIsLatest() {
	m.is_latest = nil
}

// SetDeploymentID sets the "deployment_id" field.
func (m *ProcessDefinitionMutation) SetDeploymentID(i int) {
	m.deployment_id = &i
	m.adddeployment_id = nil
}

// DeploymentID returns the value of the "deployment_id" field in the mutation.
func (m *ProcessDefinitionMutation) DeploymentID() (r int, exists bool) {
	v := m.deployment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentID returns the old "deployment_id" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldDeploymentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentID: %w", err)
	}
	return oldValue.DeploymentID, nil
}

// AddDeploymentID adds i to the "deployment_id" field.
func (m *ProcessDefinitionMutation) AddDeploymentID(i int) {
	if m.adddeployment_id != nil {
		*m.adddeployment_id += i
	} else {
		m.adddeployment_id = &i
	}
}

// AddedDeploymentID returns the value that was added to the "deployment_id" field in this mutation.
func (m *ProcessDefinitionMutation) AddedDeploymentID() (r int, exists bool) {
	v := m.adddeployment_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeploymentID resets all changes to the "deployment_id" field.
func (m *ProcessDefinitionMutation) ResetDeploymentID() {
	m.deployment_id = nil
	m.adddeployment_id = nil
}

// SetDeploymentName sets the "deployment_name" field.
func (m *ProcessDefinitionMutation) SetDeploymentName(s string) {
	m.deployment_name = &s
}

// DeploymentName returns the value of the "deployment_name" field in the mutation.
func (m *ProcessDefinitionMutation) DeploymentName() (r string, exists bool) {
	v := m.deployment_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentName returns the old "deployment_name" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldDeploymentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentName: %w", err)
	}
	return oldValue.DeploymentName, nil
}

// ClearDeploymentName clears the value of the "deployment_name" field.
func (m *ProcessDefinitionMutation) ClearDeploymentName() {
	m.deployment_name = nil
	m.clearedFields[processdefinition.FieldDeploymentName] = struct{}{}
}

// DeploymentNameCleared returns if the "deployment_name" field was cleared in this mutation.
func (m *ProcessDefinitionMutation) DeploymentNameCleared() bool {
	_, ok := m.clearedFields[processdefinition.FieldDeploymentName]
	return ok
}

// ResetDeploymentName resets all changes to the "deployment_name" field.
func (m *ProcessDefinitionMutation) ResetDeploymentName() {
	m.deployment_name = nil
	delete(m.clearedFields, processdefinition.FieldDeploymentName)
}

// SetDeployedAt sets the "deployed_at" field.
func (m *ProcessDefinitionMutation) SetDeployedAt(t time.Time) {
	m.deployed_at = &t
}

// DeployedAt returns the value of the "deployed_at" field in the mutation.
func (m *ProcessDefinitionMutation) DeployedAt() (r time.Time, exists bool) {
	v := m.deployed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployedAt returns the old "deployed_at" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldDeployedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployedAt: %w", err)
	}
	return oldValue.DeployedAt, nil
}

// ResetDeployedAt resets all changes to the "deployed_at" field.
func (m *ProcessDefinitionMutation) ResetDeployedAt() {
	m.deployed_at = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcessDefinitionMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcessDefinitionMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProcessDefinitionMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProcessDefinitionMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcessDefinitionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessDefinitionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessDefinitionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessDefinitionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessDefinitionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessDefinitionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcessDefinition entity.
// If the ProcessDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDefinitionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessDefinitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProcessDefinitionMutation builder.
func (m *ProcessDefinitionMutation) Where(ps ...predicate.ProcessDefinition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcessDefinitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcessDefinitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcessDefinition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcessDefinitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcessDefinitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcessDefinition).
func (m *ProcessDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.key != nil {
		fields = append(fields, processdefinition.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, processdefinition.FieldName)
	}
	if m.description != nil {
		fields = append(fields, processdefinition.FieldDescription)
	}
	if m.version != nil {
		fields = append(fields, processdefinition.FieldVersion)
	}
	if m.category != nil {
		fields = append(fields, processdefinition.FieldCategory)
	}
	if m.bpmn_xml != nil {
		fields = append(fields, processdefinition.FieldBpmnXML)
	}
	if m.process_variables != nil {
		fields = append(fields, processdefinition.FieldProcessVariables)
	}
	if m.is_active != nil {
		fields = append(fields, processdefinition.FieldIsActive)
	}
	if m.is_latest != nil {
		fields = append(fields, processdefinition.FieldIsLatest)
	}
	if m.deployment_id != nil {
		fields = append(fields, processdefinition.FieldDeploymentID)
	}
	if m.deployment_name != nil {
		fields = append(fields, processdefinition.FieldDeploymentName)
	}
	if m.deployed_at != nil {
		fields = append(fields, processdefinition.FieldDeployedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, processdefinition.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, processdefinition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, processdefinition.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processdefinition.FieldKey:
		return m.Key()
	case processdefinition.FieldName:
		return m.Name()
	case processdefinition.FieldDescription:
		return m.Description()
	case processdefinition.FieldVersion:
		return m.Version()
	case processdefinition.FieldCategory:
		return m.Category()
	case processdefinition.FieldBpmnXML:
		return m.BpmnXML()
	case processdefinition.FieldProcessVariables:
		return m.ProcessVariables()
	case processdefinition.FieldIsActive:
		return m.IsActive()
	case processdefinition.FieldIsLatest:
		return m.IsLatest()
	case processdefinition.FieldDeploymentID:
		return m.DeploymentID()
	case processdefinition.FieldDeploymentName:
		return m.DeploymentName()
	case processdefinition.FieldDeployedAt:
		return m.DeployedAt()
	case processdefinition.FieldTenantID:
		return m.TenantID()
	case processdefinition.FieldCreatedAt:
		return m.CreatedAt()
	case processdefinition.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processdefinition.FieldKey:
		return m.OldKey(ctx)
	case processdefinition.FieldName:
		return m.OldName(ctx)
	case processdefinition.FieldDescription:
		return m.OldDescription(ctx)
	case processdefinition.FieldVersion:
		return m.OldVersion(ctx)
	case processdefinition.FieldCategory:
		return m.OldCategory(ctx)
	case processdefinition.FieldBpmnXML:
		return m.OldBpmnXML(ctx)
	case processdefinition.FieldProcessVariables:
		return m.OldProcessVariables(ctx)
	case processdefinition.FieldIsActive:
		return m.OldIsActive(ctx)
	case processdefinition.FieldIsLatest:
		return m.OldIsLatest(ctx)
	case processdefinition.FieldDeploymentID:
		return m.OldDeploymentID(ctx)
	case processdefinition.FieldDeploymentName:
		return m.OldDeploymentName(ctx)
	case processdefinition.FieldDeployedAt:
		return m.OldDeployedAt(ctx)
	case processdefinition.FieldTenantID:
		return m.OldTenantID(ctx)
	case processdefinition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case processdefinition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessDefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processdefinition.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case processdefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case processdefinition.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case processdefinition.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case processdefinition.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case processdefinition.FieldBpmnXML:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBpmnXML(v)
		return nil
	case processdefinition.FieldProcessVariables:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessVariables(v)
		return nil
	case processdefinition.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case processdefinition.FieldIsLatest:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLatest(v)
		return nil
	case processdefinition.FieldDeploymentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentID(v)
		return nil
	case processdefinition.FieldDeploymentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentName(v)
		return nil
	case processdefinition.FieldDeployedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployedAt(v)
		return nil
	case processdefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case processdefinition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case processdefinition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessDefinitionMutation) AddedFields() []string {
	var fields []string
	if m.adddeployment_id != nil {
		fields = append(fields, processdefinition.FieldDeploymentID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, processdefinition.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processdefinition.FieldDeploymentID:
		return m.AddedDeploymentID()
	case processdefinition.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processdefinition.FieldDeploymentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeploymentID(v)
		return nil
	case processdefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(processdefinition.FieldDescription) {
		fields = append(fields, processdefinition.FieldDescription)
	}
	if m.FieldCleared(processdefinition.FieldProcessVariables) {
		fields = append(fields, processdefinition.FieldProcessVariables)
	}
	if m.FieldCleared(processdefinition.FieldDeploymentName) {
		fields = append(fields, processdefinition.FieldDeploymentName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessDefinitionMutation) ClearField(name string) error {
	switch name {
	case processdefinition.FieldDescription:
		m.ClearDescription()
		return nil
	case processdefinition.FieldProcessVariables:
		m.ClearProcessVariables()
		return nil
	case processdefinition.FieldDeploymentName:
		m.ClearDeploymentName()
		return nil
	}
	return fmt.Errorf("unknown ProcessDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessDefinitionMutation) ResetField(name string) error {
	switch name {
	case processdefinition.FieldKey:
		m.ResetKey()
		return nil
	case processdefinition.FieldName:
		m.ResetName()
		return nil
	case processdefinition.FieldDescription:
		m.ResetDescription()
		return nil
	case processdefinition.FieldVersion:
		m.ResetVersion()
		return nil
	case processdefinition.FieldCategory:
		m.ResetCategory()
		return nil
	case processdefinition.FieldBpmnXML:
		m.ResetBpmnXML()
		return nil
	case processdefinition.FieldProcessVariables:
		m.ResetProcessVariables()
		return nil
	case processdefinition.FieldIsActive:
		m.ResetIsActive()
		return nil
	case processdefinition.FieldIsLatest:
		m.ResetIsLatest()
		return nil
	case processdefinition.FieldDeploymentID:
		m.ResetDeploymentID()
		return nil
	case processdefinition.FieldDeploymentName:
		m.ResetDeploymentName()
		return nil
	case processdefinition.FieldDeployedAt:
		m.ResetDeployedAt()
		return nil
	case processdefinition.FieldTenantID:
		m.ResetTenantID()
		return nil
	case processdefinition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case processdefinition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessDefinitionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessDefinitionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessDefinitionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessDefinitionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessDefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessDefinitionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessDefinition edge %s", name)
}

// ProcessDeploymentMutation represents an operation that mutates the ProcessDeployment nodes in the graph.
type ProcessDeploymentMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	deployment_id       *string
	deployment_name     *string
	deployment_source   *string
	deployment_time     *time.Time
	deployed_by         *string
	deployment_comment  *string
	is_active           *bool
	deployment_category *string
	deployment_metadata *map[string]interface{}
	tenant_id           *int
	addtenant_id        *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*ProcessDeployment, error)
	predicates          []predicate.ProcessDeployment
}

var _ ent.Mutation = (*ProcessDeploymentMutation)(nil)

// processdeploymentOption allows management of the mutation configuration using functional options.
type processdeploymentOption func(*ProcessDeploymentMutation)

// newProcessDeploymentMutation creates new mutation for the ProcessDeployment entity.
func newProcessDeploymentMutation(c config, op Op, opts ...processdeploymentOption) *ProcessDeploymentMutation {
	m := &ProcessDeploymentMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessDeployment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessDeploymentID sets the ID field of the mutation.
func withProcessDeploymentID(id int) processdeploymentOption {
	return func(m *ProcessDeploymentMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessDeployment
		)
		m.oldValue = func(ctx context.Context) (*ProcessDeployment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessDeployment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessDeployment sets the old ProcessDeployment of the mutation.
func withProcessDeployment(node *ProcessDeployment) processdeploymentOption {
	return func(m *ProcessDeploymentMutation) {
		m.oldValue = func(context.Context) (*ProcessDeployment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessDeploymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessDeploymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessDeploymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessDeploymentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessDeployment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeploymentID sets the "deployment_id" field.
func (m *ProcessDeploymentMutation) SetDeploymentID(s string) {
	m.deployment_id = &s
}

// DeploymentID returns the value of the "deployment_id" field in the mutation.
func (m *ProcessDeploymentMutation) DeploymentID() (r string, exists bool) {
	v := m.deployment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentID returns the old "deployment_id" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeploymentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentID: %w", err)
	}
	return oldValue.DeploymentID, nil
}

// ResetDeploymentID resets all changes to the "deployment_id" field.
func (m *ProcessDeploymentMutation) ResetDeploymentID() {
	m.deployment_id = nil
}

// SetDeploymentName sets the "deployment_name" field.
func (m *ProcessDeploymentMutation) SetDeploymentName(s string) {
	m.deployment_name = &s
}

// DeploymentName returns the value of the "deployment_name" field in the mutation.
func (m *ProcessDeploymentMutation) DeploymentName() (r string, exists bool) {
	v := m.deployment_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentName returns the old "deployment_name" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeploymentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentName: %w", err)
	}
	return oldValue.DeploymentName, nil
}

// ResetDeploymentName resets all changes to the "deployment_name" field.
func (m *ProcessDeploymentMutation) ResetDeploymentName() {
	m.deployment_name = nil
}

// SetDeploymentSource sets the "deployment_source" field.
func (m *ProcessDeploymentMutation) SetDeploymentSource(s string) {
	m.deployment_source = &s
}

// DeploymentSource returns the value of the "deployment_source" field in the mutation.
func (m *ProcessDeploymentMutation) DeploymentSource() (r string, exists bool) {
	v := m.deployment_source
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentSource returns the old "deployment_source" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeploymentSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentSource: %w", err)
	}
	return oldValue.DeploymentSource, nil
}

// ClearDeploymentSource clears the value of the "deployment_source" field.
func (m *ProcessDeploymentMutation) ClearDeploymentSource() {
	m.deployment_source = nil
	m.clearedFields[processdeployment.FieldDeploymentSource] = struct{}{}
}

// DeploymentSourceCleared returns if the "deployment_source" field was cleared in this mutation.
func (m *ProcessDeploymentMutation) DeploymentSourceCleared() bool {
	_, ok := m.clearedFields[processdeployment.FieldDeploymentSource]
	return ok
}

// ResetDeploymentSource resets all changes to the "deployment_source" field.
func (m *ProcessDeploymentMutation) ResetDeploymentSource() {
	m.deployment_source = nil
	delete(m.clearedFields, processdeployment.FieldDeploymentSource)
}

// SetDeploymentTime sets the "deployment_time" field.
func (m *ProcessDeploymentMutation) SetDeploymentTime(t time.Time) {
	m.deployment_time = &t
}

// DeploymentTime returns the value of the "deployment_time" field in the mutation.
func (m *ProcessDeploymentMutation) DeploymentTime() (r time.Time, exists bool) {
	v := m.deployment_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentTime returns the old "deployment_time" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeploymentTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentTime: %w", err)
	}
	return oldValue.DeploymentTime, nil
}

// ResetDeploymentTime resets all changes to the "deployment_time" field.
func (m *ProcessDeploymentMutation) ResetDeploymentTime() {
	m.deployment_time = nil
}

// SetDeployedBy sets the "deployed_by" field.
func (m *ProcessDeploymentMutation) SetDeployedBy(s string) {
	m.deployed_by = &s
}

// DeployedBy returns the value of the "deployed_by" field in the mutation.
func (m *ProcessDeploymentMutation) DeployedBy() (r string, exists bool) {
	v := m.deployed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployedBy returns the old "deployed_by" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeployedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployedBy: %w", err)
	}
	return oldValue.DeployedBy, nil
}

// ClearDeployedBy clears the value of the "deployed_by" field.
func (m *ProcessDeploymentMutation) ClearDeployedBy() {
	m.deployed_by = nil
	m.clearedFields[processdeployment.FieldDeployedBy] = struct{}{}
}

// DeployedByCleared returns if the "deployed_by" field was cleared in this mutation.
func (m *ProcessDeploymentMutation) DeployedByCleared() bool {
	_, ok := m.clearedFields[processdeployment.FieldDeployedBy]
	return ok
}

// ResetDeployedBy resets all changes to the "deployed_by" field.
func (m *ProcessDeploymentMutation) ResetDeployedBy() {
	m.deployed_by = nil
	delete(m.clearedFields, processdeployment.FieldDeployedBy)
}

// SetDeploymentComment sets the "deployment_comment" field.
func (m *ProcessDeploymentMutation) SetDeploymentComment(s string) {
	m.deployment_comment = &s
}

// DeploymentComment returns the value of the "deployment_comment" field in the mutation.
func (m *ProcessDeploymentMutation) DeploymentComment() (r string, exists bool) {
	v := m.deployment_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentComment returns the old "deployment_comment" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeploymentComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentComment: %w", err)
	}
	return oldValue.DeploymentComment, nil
}

// ClearDeploymentComment clears the value of the "deployment_comment" field.
func (m *ProcessDeploymentMutation) ClearDeploymentComment() {
	m.deployment_comment = nil
	m.clearedFields[processdeployment.FieldDeploymentComment] = struct{}{}
}

// DeploymentCommentCleared returns if the "deployment_comment" field was cleared in this mutation.
func (m *ProcessDeploymentMutation) DeploymentCommentCleared() bool {
	_, ok := m.clearedFields[processdeployment.FieldDeploymentComment]
	return ok
}

// ResetDeploymentComment resets all changes to the "deployment_comment" field.
func (m *ProcessDeploymentMutation) ResetDeploymentComment() {
	m.deployment_comment = nil
	delete(m.clearedFields, processdeployment.FieldDeploymentComment)
}

// SetIsActive sets the "is_active" field.
func (m *ProcessDeploymentMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ProcessDeploymentMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ProcessDeploymentMutation) ResetIsActive() {
	m.is_active = nil
}

// SetDeploymentCategory sets the "deployment_category" field.
func (m *ProcessDeploymentMutation) SetDeploymentCategory(s string) {
	m.deployment_category = &s
}

// DeploymentCategory returns the value of the "deployment_category" field in the mutation.
func (m *ProcessDeploymentMutation) DeploymentCategory() (r string, exists bool) {
	v := m.deployment_category
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentCategory returns the old "deployment_category" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeploymentCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentCategory: %w", err)
	}
	return oldValue.DeploymentCategory, nil
}

// ResetDeploymentCategory resets all changes to the "deployment_category" field.
func (m *ProcessDeploymentMutation) ResetDeploymentCategory() {
	m.deployment_category = nil
}

// SetDeploymentMetadata sets the "deployment_metadata" field.
func (m *ProcessDeploymentMutation) SetDeploymentMetadata(value map[string]interface{}) {
	m.deployment_metadata = &value
}

// DeploymentMetadata returns the value of the "deployment_metadata" field in the mutation.
func (m *ProcessDeploymentMutation) DeploymentMetadata() (r map[string]interface{}, exists bool) {
	v := m.deployment_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentMetadata returns the old "deployment_metadata" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldDeploymentMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentMetadata: %w", err)
	}
	return oldValue.DeploymentMetadata, nil
}

// ClearDeploymentMetadata clears the value of the "deployment_metadata" field.
func (m *ProcessDeploymentMutation) ClearDeploymentMetadata() {
	m.deployment_metadata = nil
	m.clearedFields[processdeployment.FieldDeploymentMetadata] = struct{}{}
}

// DeploymentMetadataCleared returns if the "deployment_metadata" field was cleared in this mutation.
func (m *ProcessDeploymentMutation) DeploymentMetadataCleared() bool {
	_, ok := m.clearedFields[processdeployment.FieldDeploymentMetadata]
	return ok
}

// ResetDeploymentMetadata resets all changes to the "deployment_metadata" field.
func (m *ProcessDeploymentMutation) ResetDeploymentMetadata() {
	m.deployment_metadata = nil
	delete(m.clearedFields, processdeployment.FieldDeploymentMetadata)
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcessDeploymentMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcessDeploymentMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProcessDeploymentMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProcessDeploymentMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcessDeploymentMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessDeploymentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessDeploymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessDeploymentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessDeploymentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessDeploymentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcessDeployment entity.
// If the ProcessDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDeploymentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessDeploymentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProcessDeploymentMutation builder.
func (m *ProcessDeploymentMutation) Where(ps ...predicate.ProcessDeployment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcessDeploymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcessDeploymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcessDeployment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcessDeploymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcessDeploymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcessDeployment).
func (m *ProcessDeploymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessDeploymentMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.deployment_id != nil {
		fields = append(fields, processdeployment.FieldDeploymentID)
	}
	if m.deployment_name != nil {
		fields = append(fields, processdeployment.FieldDeploymentName)
	}
	if m.deployment_source != nil {
		fields = append(fields, processdeployment.FieldDeploymentSource)
	}
	if m.deployment_time != nil {
		fields = append(fields, processdeployment.FieldDeploymentTime)
	}
	if m.deployed_by != nil {
		fields = append(fields, processdeployment.FieldDeployedBy)
	}
	if m.deployment_comment != nil {
		fields = append(fields, processdeployment.FieldDeploymentComment)
	}
	if m.is_active != nil {
		fields = append(fields, processdeployment.FieldIsActive)
	}
	if m.deployment_category != nil {
		fields = append(fields, processdeployment.FieldDeploymentCategory)
	}
	if m.deployment_metadata != nil {
		fields = append(fields, processdeployment.FieldDeploymentMetadata)
	}
	if m.tenant_id != nil {
		fields = append(fields, processdeployment.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, processdeployment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, processdeployment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessDeploymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processdeployment.FieldDeploymentID:
		return m.DeploymentID()
	case processdeployment.FieldDeploymentName:
		return m.DeploymentName()
	case processdeployment.FieldDeploymentSource:
		return m.DeploymentSource()
	case processdeployment.FieldDeploymentTime:
		return m.DeploymentTime()
	case processdeployment.FieldDeployedBy:
		return m.DeployedBy()
	case processdeployment.FieldDeploymentComment:
		return m.DeploymentComment()
	case processdeployment.FieldIsActive:
		return m.IsActive()
	case processdeployment.FieldDeploymentCategory:
		return m.DeploymentCategory()
	case processdeployment.FieldDeploymentMetadata:
		return m.DeploymentMetadata()
	case processdeployment.FieldTenantID:
		return m.TenantID()
	case processdeployment.FieldCreatedAt:
		return m.CreatedAt()
	case processdeployment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessDeploymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processdeployment.FieldDeploymentID:
		return m.OldDeploymentID(ctx)
	case processdeployment.FieldDeploymentName:
		return m.OldDeploymentName(ctx)
	case processdeployment.FieldDeploymentSource:
		return m.OldDeploymentSource(ctx)
	case processdeployment.FieldDeploymentTime:
		return m.OldDeploymentTime(ctx)
	case processdeployment.FieldDeployedBy:
		return m.OldDeployedBy(ctx)
	case processdeployment.FieldDeploymentComment:
		return m.OldDeploymentComment(ctx)
	case processdeployment.FieldIsActive:
		return m.OldIsActive(ctx)
	case processdeployment.FieldDeploymentCategory:
		return m.OldDeploymentCategory(ctx)
	case processdeployment.FieldDeploymentMetadata:
		return m.OldDeploymentMetadata(ctx)
	case processdeployment.FieldTenantID:
		return m.OldTenantID(ctx)
	case processdeployment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case processdeployment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessDeployment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessDeploymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processdeployment.FieldDeploymentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentID(v)
		return nil
	case processdeployment.FieldDeploymentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentName(v)
		return nil
	case processdeployment.FieldDeploymentSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentSource(v)
		return nil
	case processdeployment.FieldDeploymentTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentTime(v)
		return nil
	case processdeployment.FieldDeployedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployedBy(v)
		return nil
	case processdeployment.FieldDeploymentComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentComment(v)
		return nil
	case processdeployment.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case processdeployment.FieldDeploymentCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentCategory(v)
		return nil
	case processdeployment.FieldDeploymentMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentMetadata(v)
		return nil
	case processdeployment.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case processdeployment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case processdeployment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessDeployment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessDeploymentMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, processdeployment.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessDeploymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processdeployment.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessDeploymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processdeployment.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessDeployment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessDeploymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(processdeployment.FieldDeploymentSource) {
		fields = append(fields, processdeployment.FieldDeploymentSource)
	}
	if m.FieldCleared(processdeployment.FieldDeployedBy) {
		fields = append(fields, processdeployment.FieldDeployedBy)
	}
	if m.FieldCleared(processdeployment.FieldDeploymentComment) {
		fields = append(fields, processdeployment.FieldDeploymentComment)
	}
	if m.FieldCleared(processdeployment.FieldDeploymentMetadata) {
		fields = append(fields, processdeployment.FieldDeploymentMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessDeploymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessDeploymentMutation) ClearField(name string) error {
	switch name {
	case processdeployment.FieldDeploymentSource:
		m.ClearDeploymentSource()
		return nil
	case processdeployment.FieldDeployedBy:
		m.ClearDeployedBy()
		return nil
	case processdeployment.FieldDeploymentComment:
		m.ClearDeploymentComment()
		return nil
	case processdeployment.FieldDeploymentMetadata:
		m.ClearDeploymentMetadata()
		return nil
	}
	return fmt.Errorf("unknown ProcessDeployment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessDeploymentMutation) ResetField(name string) error {
	switch name {
	case processdeployment.FieldDeploymentID:
		m.ResetDeploymentID()
		return nil
	case processdeployment.FieldDeploymentName:
		m.ResetDeploymentName()
		return nil
	case processdeployment.FieldDeploymentSource:
		m.ResetDeploymentSource()
		return nil
	case processdeployment.FieldDeploymentTime:
		m.ResetDeploymentTime()
		return nil
	case processdeployment.FieldDeployedBy:
		m.ResetDeployedBy()
		return nil
	case processdeployment.FieldDeploymentComment:
		m.ResetDeploymentComment()
		return nil
	case processdeployment.FieldIsActive:
		m.ResetIsActive()
		return nil
	case processdeployment.FieldDeploymentCategory:
		m.ResetDeploymentCategory()
		return nil
	case processdeployment.FieldDeploymentMetadata:
		m.ResetDeploymentMetadata()
		return nil
	case processdeployment.FieldTenantID:
		m.ResetTenantID()
		return nil
	case processdeployment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case processdeployment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessDeployment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessDeploymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessDeploymentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessDeploymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessDeploymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessDeploymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessDeploymentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessDeploymentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessDeployment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessDeploymentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessDeployment edge %s", name)
}

// ProcessExecutionHistoryMutation represents an operation that mutates the ProcessExecutionHistory nodes in the graph.
type ProcessExecutionHistoryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	history_id             *string
	process_instance_id    *string
	process_definition_key *string
	activity_id            *string
	activity_name          *string
	activity_type          *string
	event_type             *string
	event_detail           *string
	variables              *map[string]interface{}
	user_id                *string
	user_name              *string
	timestamp              *time.Time
	comment                *string
	error_message          *string
	error_code             *string
	tenant_id              *int
	addtenant_id           *int
	created_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ProcessExecutionHistory, error)
	predicates             []predicate.ProcessExecutionHistory
}

var _ ent.Mutation = (*ProcessExecutionHistoryMutation)(nil)

// processexecutionhistoryOption allows management of the mutation configuration using functional options.
type processexecutionhistoryOption func(*ProcessExecutionHistoryMutation)

// newProcessExecutionHistoryMutation creates new mutation for the ProcessExecutionHistory entity.
func newProcessExecutionHistoryMutation(c config, op Op, opts ...processexecutionhistoryOption) *ProcessExecutionHistoryMutation {
	m := &ProcessExecutionHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessExecutionHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessExecutionHistoryID sets the ID field of the mutation.
func withProcessExecutionHistoryID(id int) processexecutionhistoryOption {
	return func(m *ProcessExecutionHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessExecutionHistory
		)
		m.oldValue = func(ctx context.Context) (*ProcessExecutionHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessExecutionHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessExecutionHistory sets the old ProcessExecutionHistory of the mutation.
func withProcessExecutionHistory(node *ProcessExecutionHistory) processexecutionhistoryOption {
	return func(m *ProcessExecutionHistoryMutation) {
		m.oldValue = func(context.Context) (*ProcessExecutionHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessExecutionHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessExecutionHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessExecutionHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessExecutionHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessExecutionHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryID sets the "history_id" field.
func (m *ProcessExecutionHistoryMutation) SetHistoryID(s string) {
	m.history_id = &s
}

// HistoryID returns the value of the "history_id" field in the mutation.
func (m *ProcessExecutionHistoryMutation) HistoryID() (r string, exists bool) {
	v := m.history_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryID returns the old "history_id" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldHistoryID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryID: %w", err)
	}
	return oldValue.HistoryID, nil
}

// ResetHistoryID resets all changes to the "history_id" field.
func (m *ProcessExecutionHistoryMutation) ResetHistoryID() {
	m.history_id = nil
}

// SetProcessInstanceID sets the "process_instance_id" field.
func (m *ProcessExecutionHistoryMutation) SetProcessInstanceID(s string) {
	m.process_instance_id = &s
}

// ProcessInstanceID returns the value of the "process_instance_id" field in the mutation.
func (m *ProcessExecutionHistoryMutation) ProcessInstanceID() (r string, exists bool) {
	v := m.process_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessInstanceID returns the old "process_instance_id" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldProcessInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessInstanceID: %w", err)
	}
	return oldValue.ProcessInstanceID, nil
}

// ResetProcessInstanceID resets all changes to the "process_instance_id" field.
func (m *ProcessExecutionHistoryMutation) ResetProcessInstanceID() {
	m.process_instance_id = nil
}

// SetProcessDefinitionKey sets the "process_definition_key" field.
func (m *ProcessExecutionHistoryMutation) SetProcessDefinitionKey(s string) {
	m.process_definition_key = &s
}

// ProcessDefinitionKey returns the value of the "process_definition_key" field in the mutation.
func (m *ProcessExecutionHistoryMutation) ProcessDefinitionKey() (r string, exists bool) {
	v := m.process_definition_key
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessDefinitionKey returns the old "process_definition_key" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldProcessDefinitionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessDefinitionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessDefinitionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessDefinitionKey: %w", err)
	}
	return oldValue.ProcessDefinitionKey, nil
}

// ResetProcessDefinitionKey resets all changes to the "process_definition_key" field.
func (m *ProcessExecutionHistoryMutation) ResetProcessDefinitionKey() {
	m.process_definition_key = nil
}

// SetActivityID sets the "activity_id" field.
func (m *ProcessExecutionHistoryMutation) SetActivityID(s string) {
	m.activity_id = &s
}

// ActivityID returns the value of the "activity_id" field in the mutation.
func (m *ProcessExecutionHistoryMutation) ActivityID() (r string, exists bool) {
	v := m.activity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityID returns the old "activity_id" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldActivityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityID: %w", err)
	}
	return oldValue.ActivityID, nil
}

// ClearActivityID clears the value of the "activity_id" field.
func (m *ProcessExecutionHistoryMutation) ClearActivityID() {
	m.activity_id = nil
	m.clearedFields[processexecutionhistory.FieldActivityID] = struct{}{}
}

// ActivityIDCleared returns if the "activity_id" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) ActivityIDCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldActivityID]
	return ok
}

// ResetActivityID resets all changes to the "activity_id" field.
func (m *ProcessExecutionHistoryMutation) ResetActivityID() {
	m.activity_id = nil
	delete(m.clearedFields, processexecutionhistory.FieldActivityID)
}

// SetActivityName sets the "activity_name" field.
func (m *ProcessExecutionHistoryMutation) SetActivityName(s string) {
	m.activity_name = &s
}

// ActivityName returns the value of the "activity_name" field in the mutation.
func (m *ProcessExecutionHistoryMutation) ActivityName() (r string, exists bool) {
	v := m.activity_name
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityName returns the old "activity_name" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldActivityName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityName: %w", err)
	}
	return oldValue.ActivityName, nil
}

// ClearActivityName clears the value of the "activity_name" field.
func (m *ProcessExecutionHistoryMutation) ClearActivityName() {
	m.activity_name = nil
	m.clearedFields[processexecutionhistory.FieldActivityName] = struct{}{}
}

// ActivityNameCleared returns if the "activity_name" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) ActivityNameCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldActivityName]
	return ok
}

// ResetActivityName resets all changes to the "activity_name" field.
func (m *ProcessExecutionHistoryMutation) ResetActivityName() {
	m.activity_name = nil
	delete(m.clearedFields, processexecutionhistory.FieldActivityName)
}

// SetActivityType sets the "activity_type" field.
func (m *ProcessExecutionHistoryMutation) SetActivityType(s string) {
	m.activity_type = &s
}

// ActivityType returns the value of the "activity_type" field in the mutation.
func (m *ProcessExecutionHistoryMutation) ActivityType() (r string, exists bool) {
	v := m.activity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityType returns the old "activity_type" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldActivityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityType: %w", err)
	}
	return oldValue.ActivityType, nil
}

// ResetActivityType resets all changes to the "activity_type" field.
func (m *ProcessExecutionHistoryMutation) ResetActivityType() {
	m.activity_type = nil
}

// SetEventType sets the "event_type" field.
func (m *ProcessExecutionHistoryMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *ProcessExecutionHistoryMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *ProcessExecutionHistoryMutation) ResetEventType() {
	m.event_type = nil
}

// SetEventDetail sets the "event_detail" field.
func (m *ProcessExecutionHistoryMutation) SetEventDetail(s string) {
	m.event_detail = &s
}

// EventDetail returns the value of the "event_detail" field in the mutation.
func (m *ProcessExecutionHistoryMutation) EventDetail() (r string, exists bool) {
	v := m.event_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldEventDetail returns the old "event_detail" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldEventDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventDetail: %w", err)
	}
	return oldValue.EventDetail, nil
}

// ClearEventDetail clears the value of the "event_detail" field.
func (m *ProcessExecutionHistoryMutation) ClearEventDetail() {
	m.event_detail = nil
	m.clearedFields[processexecutionhistory.FieldEventDetail] = struct{}{}
}

// EventDetailCleared returns if the "event_detail" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) EventDetailCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldEventDetail]
	return ok
}

// ResetEventDetail resets all changes to the "event_detail" field.
func (m *ProcessExecutionHistoryMutation) ResetEventDetail() {
	m.event_detail = nil
	delete(m.clearedFields, processexecutionhistory.FieldEventDetail)
}

// SetVariables sets the "variables" field.
func (m *ProcessExecutionHistoryMutation) SetVariables(value map[string]interface{}) {
	m.variables = &value
}

// Variables returns the value of the "variables" field in the mutation.
func (m *ProcessExecutionHistoryMutation) Variables() (r map[string]interface{}, exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old "variables" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldVariables(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// ClearVariables clears the value of the "variables" field.
func (m *ProcessExecutionHistoryMutation) ClearVariables() {
	m.variables = nil
	m.clearedFields[processexecutionhistory.FieldVariables] = struct{}{}
}

// VariablesCleared returns if the "variables" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) VariablesCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldVariables]
	return ok
}

// ResetVariables resets all changes to the "variables" field.
func (m *ProcessExecutionHistoryMutation) ResetVariables() {
	m.variables = nil
	delete(m.clearedFields, processexecutionhistory.FieldVariables)
}

// SetUserID sets the "user_id" field.
func (m *ProcessExecutionHistoryMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProcessExecutionHistoryMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ProcessExecutionHistoryMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[processexecutionhistory.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProcessExecutionHistoryMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, processexecutionhistory.FieldUserID)
}

// SetUserName sets the "user_name" field.
func (m *ProcessExecutionHistoryMutation) SetUserName(s string) {
	m.user_name = &s
}

// UserName returns the value of the "user_name" field in the mutation.
func (m *ProcessExecutionHistoryMutation) UserName() (r string, exists bool) {
	v := m.user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "user_name" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "user_name" field.
func (m *ProcessExecutionHistoryMutation) ClearUserName() {
	m.user_name = nil
	m.clearedFields[processexecutionhistory.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "user_name" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "user_name" field.
func (m *ProcessExecutionHistoryMutation) ResetUserName() {
	m.user_name = nil
	delete(m.clearedFields, processexecutionhistory.FieldUserName)
}

// SetTimestamp sets the "timestamp" field.
func (m *ProcessExecutionHistoryMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *ProcessExecutionHistoryMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *ProcessExecutionHistoryMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetComment sets the "comment" field.
func (m *ProcessExecutionHistoryMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *ProcessExecutionHistoryMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *ProcessExecutionHistoryMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[processexecutionhistory.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) CommentCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *ProcessExecutionHistoryMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, processexecutionhistory.FieldComment)
}

// SetErrorMessage sets the "error_message" field.
func (m *ProcessExecutionHistoryMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ProcessExecutionHistoryMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ProcessExecutionHistoryMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[processexecutionhistory.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ProcessExecutionHistoryMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, processexecutionhistory.FieldErrorMessage)
}

// SetErrorCode sets the "error_code" field.
func (m *ProcessExecutionHistoryMutation) SetErrorCode(s string) {
	m.error_code = &s
}

// ErrorCode returns the value of the "error_code" field in the mutation.
func (m *ProcessExecutionHistoryMutation) ErrorCode() (r string, exists bool) {
	v := m.error_code
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCode returns the old "error_code" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldErrorCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCode: %w", err)
	}
	return oldValue.ErrorCode, nil
}

// ClearErrorCode clears the value of the "error_code" field.
func (m *ProcessExecutionHistoryMutation) ClearErrorCode() {
	m.error_code = nil
	m.clearedFields[processexecutionhistory.FieldErrorCode] = struct{}{}
}

// ErrorCodeCleared returns if the "error_code" field was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) ErrorCodeCleared() bool {
	_, ok := m.clearedFields[processexecutionhistory.FieldErrorCode]
	return ok
}

// ResetErrorCode resets all changes to the "error_code" field.
func (m *ProcessExecutionHistoryMutation) ResetErrorCode() {
	m.error_code = nil
	delete(m.clearedFields, processexecutionhistory.FieldErrorCode)
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcessExecutionHistoryMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcessExecutionHistoryMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProcessExecutionHistoryMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProcessExecutionHistoryMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcessExecutionHistoryMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessExecutionHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessExecutionHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessExecutionHistory entity.
// If the ProcessExecutionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessExecutionHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessExecutionHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the ProcessExecutionHistoryMutation builder.
func (m *ProcessExecutionHistoryMutation) Where(ps ...predicate.ProcessExecutionHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcessExecutionHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcessExecutionHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcessExecutionHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcessExecutionHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcessExecutionHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcessExecutionHistory).
func (m *ProcessExecutionHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessExecutionHistoryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.history_id != nil {
		fields = append(fields, processexecutionhistory.FieldHistoryID)
	}
	if m.process_instance_id != nil {
		fields = append(fields, processexecutionhistory.FieldProcessInstanceID)
	}
	if m.process_definition_key != nil {
		fields = append(fields, processexecutionhistory.FieldProcessDefinitionKey)
	}
	if m.activity_id != nil {
		fields = append(fields, processexecutionhistory.FieldActivityID)
	}
	if m.activity_name != nil {
		fields = append(fields, processexecutionhistory.FieldActivityName)
	}
	if m.activity_type != nil {
		fields = append(fields, processexecutionhistory.FieldActivityType)
	}
	if m.event_type != nil {
		fields = append(fields, processexecutionhistory.FieldEventType)
	}
	if m.event_detail != nil {
		fields = append(fields, processexecutionhistory.FieldEventDetail)
	}
	if m.variables != nil {
		fields = append(fields, processexecutionhistory.FieldVariables)
	}
	if m.user_id != nil {
		fields = append(fields, processexecutionhistory.FieldUserID)
	}
	if m.user_name != nil {
		fields = append(fields, processexecutionhistory.FieldUserName)
	}
	if m.timestamp != nil {
		fields = append(fields, processexecutionhistory.FieldTimestamp)
	}
	if m.comment != nil {
		fields = append(fields, processexecutionhistory.FieldComment)
	}
	if m.error_message != nil {
		fields = append(fields, processexecutionhistory.FieldErrorMessage)
	}
	if m.error_code != nil {
		fields = append(fields, processexecutionhistory.FieldErrorCode)
	}
	if m.tenant_id != nil {
		fields = append(fields, processexecutionhistory.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, processexecutionhistory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessExecutionHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processexecutionhistory.FieldHistoryID:
		return m.HistoryID()
	case processexecutionhistory.FieldProcessInstanceID:
		return m.ProcessInstanceID()
	case processexecutionhistory.FieldProcessDefinitionKey:
		return m.ProcessDefinitionKey()
	case processexecutionhistory.FieldActivityID:
		return m.ActivityID()
	case processexecutionhistory.FieldActivityName:
		return m.ActivityName()
	case processexecutionhistory.FieldActivityType:
		return m.ActivityType()
	case processexecutionhistory.FieldEventType:
		return m.EventType()
	case processexecutionhistory.FieldEventDetail:
		return m.EventDetail()
	case processexecutionhistory.FieldVariables:
		return m.Variables()
	case processexecutionhistory.FieldUserID:
		return m.UserID()
	case processexecutionhistory.FieldUserName:
		return m.UserName()
	case processexecutionhistory.FieldTimestamp:
		return m.Timestamp()
	case processexecutionhistory.FieldComment:
		return m.Comment()
	case processexecutionhistory.FieldErrorMessage:
		return m.ErrorMessage()
	case processexecutionhistory.FieldErrorCode:
		return m.ErrorCode()
	case processexecutionhistory.FieldTenantID:
		return m.TenantID()
	case processexecutionhistory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessExecutionHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processexecutionhistory.FieldHistoryID:
		return m.OldHistoryID(ctx)
	case processexecutionhistory.FieldProcessInstanceID:
		return m.OldProcessInstanceID(ctx)
	case processexecutionhistory.FieldProcessDefinitionKey:
		return m.OldProcessDefinitionKey(ctx)
	case processexecutionhistory.FieldActivityID:
		return m.OldActivityID(ctx)
	case processexecutionhistory.FieldActivityName:
		return m.OldActivityName(ctx)
	case processexecutionhistory.FieldActivityType:
		return m.OldActivityType(ctx)
	case processexecutionhistory.FieldEventType:
		return m.OldEventType(ctx)
	case processexecutionhistory.FieldEventDetail:
		return m.OldEventDetail(ctx)
	case processexecutionhistory.FieldVariables:
		return m.OldVariables(ctx)
	case processexecutionhistory.FieldUserID:
		return m.OldUserID(ctx)
	case processexecutionhistory.FieldUserName:
		return m.OldUserName(ctx)
	case processexecutionhistory.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case processexecutionhistory.FieldComment:
		return m.OldComment(ctx)
	case processexecutionhistory.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case processexecutionhistory.FieldErrorCode:
		return m.OldErrorCode(ctx)
	case processexecutionhistory.FieldTenantID:
		return m.OldTenantID(ctx)
	case processexecutionhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessExecutionHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessExecutionHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processexecutionhistory.FieldHistoryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryID(v)
		return nil
	case processexecutionhistory.FieldProcessInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessInstanceID(v)
		return nil
	case processexecutionhistory.FieldProcessDefinitionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessDefinitionKey(v)
		return nil
	case processexecutionhistory.FieldActivityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityID(v)
		return nil
	case processexecutionhistory.FieldActivityName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityName(v)
		return nil
	case processexecutionhistory.FieldActivityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityType(v)
		return nil
	case processexecutionhistory.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case processexecutionhistory.FieldEventDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventDetail(v)
		return nil
	case processexecutionhistory.FieldVariables:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case processexecutionhistory.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case processexecutionhistory.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case processexecutionhistory.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case processexecutionhistory.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case processexecutionhistory.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case processexecutionhistory.FieldErrorCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCode(v)
		return nil
	case processexecutionhistory.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case processexecutionhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessExecutionHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessExecutionHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, processexecutionhistory.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessExecutionHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processexecutionhistory.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessExecutionHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processexecutionhistory.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessExecutionHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessExecutionHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(processexecutionhistory.FieldActivityID) {
		fields = append(fields, processexecutionhistory.FieldActivityID)
	}
	if m.FieldCleared(processexecutionhistory.FieldActivityName) {
		fields = append(fields, processexecutionhistory.FieldActivityName)
	}
	if m.FieldCleared(processexecutionhistory.FieldEventDetail) {
		fields = append(fields, processexecutionhistory.FieldEventDetail)
	}
	if m.FieldCleared(processexecutionhistory.FieldVariables) {
		fields = append(fields, processexecutionhistory.FieldVariables)
	}
	if m.FieldCleared(processexecutionhistory.FieldUserID) {
		fields = append(fields, processexecutionhistory.FieldUserID)
	}
	if m.FieldCleared(processexecutionhistory.FieldUserName) {
		fields = append(fields, processexecutionhistory.FieldUserName)
	}
	if m.FieldCleared(processexecutionhistory.FieldComment) {
		fields = append(fields, processexecutionhistory.FieldComment)
	}
	if m.FieldCleared(processexecutionhistory.FieldErrorMessage) {
		fields = append(fields, processexecutionhistory.FieldErrorMessage)
	}
	if m.FieldCleared(processexecutionhistory.FieldErrorCode) {
		fields = append(fields, processexecutionhistory.FieldErrorCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessExecutionHistoryMutation) ClearField(name string) error {
	switch name {
	case processexecutionhistory.FieldActivityID:
		m.ClearActivityID()
		return nil
	case processexecutionhistory.FieldActivityName:
		m.ClearActivityName()
		return nil
	case processexecutionhistory.FieldEventDetail:
		m.ClearEventDetail()
		return nil
	case processexecutionhistory.FieldVariables:
		m.ClearVariables()
		return nil
	case processexecutionhistory.FieldUserID:
		m.ClearUserID()
		return nil
	case processexecutionhistory.FieldUserName:
		m.ClearUserName()
		return nil
	case processexecutionhistory.FieldComment:
		m.ClearComment()
		return nil
	case processexecutionhistory.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case processexecutionhistory.FieldErrorCode:
		m.ClearErrorCode()
		return nil
	}
	return fmt.Errorf("unknown ProcessExecutionHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessExecutionHistoryMutation) ResetField(name string) error {
	switch name {
	case processexecutionhistory.FieldHistoryID:
		m.ResetHistoryID()
		return nil
	case processexecutionhistory.FieldProcessInstanceID:
		m.ResetProcessInstanceID()
		return nil
	case processexecutionhistory.FieldProcessDefinitionKey:
		m.ResetProcessDefinitionKey()
		return nil
	case processexecutionhistory.FieldActivityID:
		m.ResetActivityID()
		return nil
	case processexecutionhistory.FieldActivityName:
		m.ResetActivityName()
		return nil
	case processexecutionhistory.FieldActivityType:
		m.ResetActivityType()
		return nil
	case processexecutionhistory.FieldEventType:
		m.ResetEventType()
		return nil
	case processexecutionhistory.FieldEventDetail:
		m.ResetEventDetail()
		return nil
	case processexecutionhistory.FieldVariables:
		m.ResetVariables()
		return nil
	case processexecutionhistory.FieldUserID:
		m.ResetUserID()
		return nil
	case processexecutionhistory.FieldUserName:
		m.ResetUserName()
		return nil
	case processexecutionhistory.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case processexecutionhistory.FieldComment:
		m.ResetComment()
		return nil
	case processexecutionhistory.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case processexecutionhistory.FieldErrorCode:
		m.ResetErrorCode()
		return nil
	case processexecutionhistory.FieldTenantID:
		m.ResetTenantID()
		return nil
	case processexecutionhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessExecutionHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessExecutionHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessExecutionHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessExecutionHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessExecutionHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessExecutionHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessExecutionHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessExecutionHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessExecutionHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessExecutionHistory edge %s", name)
}

// ProcessInstanceMutation represents an operation that mutates the ProcessInstance nodes in the graph.
type ProcessInstanceMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	process_instance_id        *string
	business_key               *string
	process_definition_key     *string
	process_definition_id      *string
	status                     *string
	current_activity_id        *string
	current_activity_name      *string
	variables                  *map[string]interface{}
	start_time                 *time.Time
	end_time                   *time.Time
	suspended_time             *time.Time
	suspended_reason           *string
	tenant_id                  *int
	addtenant_id               *int
	initiator                  *string
	parent_process_instance_id *string
	root_process_instance_id   *string
	created_at                 *time.Time
	updated_at                 *time.Time
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*ProcessInstance, error)
	predicates                 []predicate.ProcessInstance
}

var _ ent.Mutation = (*ProcessInstanceMutation)(nil)

// processinstanceOption allows management of the mutation configuration using functional options.
type processinstanceOption func(*ProcessInstanceMutation)

// newProcessInstanceMutation creates new mutation for the ProcessInstance entity.
func newProcessInstanceMutation(c config, op Op, opts ...processinstanceOption) *ProcessInstanceMutation {
	m := &ProcessInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessInstanceID sets the ID field of the mutation.
func withProcessInstanceID(id int) processinstanceOption {
	return func(m *ProcessInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessInstance
		)
		m.oldValue = func(ctx context.Context) (*ProcessInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessInstance sets the old ProcessInstance of the mutation.
func withProcessInstance(node *ProcessInstance) processinstanceOption {
	return func(m *ProcessInstanceMutation) {
		m.oldValue = func(context.Context) (*ProcessInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessInstanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessInstanceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProcessInstanceID sets the "process_instance_id" field.
func (m *ProcessInstanceMutation) SetProcessInstanceID(s string) {
	m.process_instance_id = &s
}

// ProcessInstanceID returns the value of the "process_instance_id" field in the mutation.
func (m *ProcessInstanceMutation) ProcessInstanceID() (r string, exists bool) {
	v := m.process_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessInstanceID returns the old "process_instance_id" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldProcessInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessInstanceID: %w", err)
	}
	return oldValue.ProcessInstanceID, nil
}

// ResetProcessInstanceID resets all changes to the "process_instance_id" field.
func (m *ProcessInstanceMutation) ResetProcessInstanceID() {
	m.process_instance_id = nil
}

// SetBusinessKey sets the "business_key" field.
func (m *ProcessInstanceMutation) SetBusinessKey(s string) {
	m.business_key = &s
}

// BusinessKey returns the value of the "business_key" field in the mutation.
func (m *ProcessInstanceMutation) BusinessKey() (r string, exists bool) {
	v := m.business_key
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessKey returns the old "business_key" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldBusinessKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessKey: %w", err)
	}
	return oldValue.BusinessKey, nil
}

// ClearBusinessKey clears the value of the "business_key" field.
func (m *ProcessInstanceMutation) ClearBusinessKey() {
	m.business_key = nil
	m.clearedFields[processinstance.FieldBusinessKey] = struct{}{}
}

// BusinessKeyCleared returns if the "business_key" field was cleared in this mutation.
func (m *ProcessInstanceMutation) BusinessKeyCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldBusinessKey]
	return ok
}

// ResetBusinessKey resets all changes to the "business_key" field.
func (m *ProcessInstanceMutation) ResetBusinessKey() {
	m.business_key = nil
	delete(m.clearedFields, processinstance.FieldBusinessKey)
}

// SetProcessDefinitionKey sets the "process_definition_key" field.
func (m *ProcessInstanceMutation) SetProcessDefinitionKey(s string) {
	m.process_definition_key = &s
}

// ProcessDefinitionKey returns the value of the "process_definition_key" field in the mutation.
func (m *ProcessInstanceMutation) ProcessDefinitionKey() (r string, exists bool) {
	v := m.process_definition_key
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessDefinitionKey returns the old "process_definition_key" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldProcessDefinitionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessDefinitionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessDefinitionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessDefinitionKey: %w", err)
	}
	return oldValue.ProcessDefinitionKey, nil
}

// ResetProcessDefinitionKey resets all changes to the "process_definition_key" field.
func (m *ProcessInstanceMutation) ResetProcessDefinitionKey() {
	m.process_definition_key = nil
}

// SetProcessDefinitionID sets the "process_definition_id" field.
func (m *ProcessInstanceMutation) SetProcessDefinitionID(s string) {
	m.process_definition_id = &s
}

// ProcessDefinitionID returns the value of the "process_definition_id" field in the mutation.
func (m *ProcessInstanceMutation) ProcessDefinitionID() (r string, exists bool) {
	v := m.process_definition_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessDefinitionID returns the old "process_definition_id" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldProcessDefinitionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessDefinitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessDefinitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessDefinitionID: %w", err)
	}
	return oldValue.ProcessDefinitionID, nil
}

// ResetProcessDefinitionID resets all changes to the "process_definition_id" field.
func (m *ProcessInstanceMutation) ResetProcessDefinitionID() {
	m.process_definition_id = nil
}

// SetStatus sets the "status" field.
func (m *ProcessInstanceMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProcessInstanceMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProcessInstanceMutation) ResetStatus() {
	m.status = nil
}

// SetCurrentActivityID sets the "current_activity_id" field.
func (m *ProcessInstanceMutation) SetCurrentActivityID(s string) {
	m.current_activity_id = &s
}

// CurrentActivityID returns the value of the "current_activity_id" field in the mutation.
func (m *ProcessInstanceMutation) CurrentActivityID() (r string, exists bool) {
	v := m.current_activity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentActivityID returns the old "current_activity_id" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldCurrentActivityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentActivityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentActivityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentActivityID: %w", err)
	}
	return oldValue.CurrentActivityID, nil
}

// ClearCurrentActivityID clears the value of the "current_activity_id" field.
func (m *ProcessInstanceMutation) ClearCurrentActivityID() {
	m.current_activity_id = nil
	m.clearedFields[processinstance.FieldCurrentActivityID] = struct{}{}
}

// CurrentActivityIDCleared returns if the "current_activity_id" field was cleared in this mutation.
func (m *ProcessInstanceMutation) CurrentActivityIDCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldCurrentActivityID]
	return ok
}

// ResetCurrentActivityID resets all changes to the "current_activity_id" field.
func (m *ProcessInstanceMutation) ResetCurrentActivityID() {
	m.current_activity_id = nil
	delete(m.clearedFields, processinstance.FieldCurrentActivityID)
}

// SetCurrentActivityName sets the "current_activity_name" field.
func (m *ProcessInstanceMutation) SetCurrentActivityName(s string) {
	m.current_activity_name = &s
}

// CurrentActivityName returns the value of the "current_activity_name" field in the mutation.
func (m *ProcessInstanceMutation) CurrentActivityName() (r string, exists bool) {
	v := m.current_activity_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentActivityName returns the old "current_activity_name" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldCurrentActivityName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentActivityName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentActivityName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentActivityName: %w", err)
	}
	return oldValue.CurrentActivityName, nil
}

// ClearCurrentActivityName clears the value of the "current_activity_name" field.
func (m *ProcessInstanceMutation) ClearCurrentActivityName() {
	m.current_activity_name = nil
	m.clearedFields[processinstance.FieldCurrentActivityName] = struct{}{}
}

// CurrentActivityNameCleared returns if the "current_activity_name" field was cleared in this mutation.
func (m *ProcessInstanceMutation) CurrentActivityNameCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldCurrentActivityName]
	return ok
}

// ResetCurrentActivityName resets all changes to the "current_activity_name" field.
func (m *ProcessInstanceMutation) ResetCurrentActivityName() {
	m.current_activity_name = nil
	delete(m.clearedFields, processinstance.FieldCurrentActivityName)
}

// SetVariables sets the "variables" field.
func (m *ProcessInstanceMutation) SetVariables(value map[string]interface{}) {
	m.variables = &value
}

// Variables returns the value of the "variables" field in the mutation.
func (m *ProcessInstanceMutation) Variables() (r map[string]interface{}, exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old "variables" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldVariables(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// ClearVariables clears the value of the "variables" field.
func (m *ProcessInstanceMutation) ClearVariables() {
	m.variables = nil
	m.clearedFields[processinstance.FieldVariables] = struct{}{}
}

// VariablesCleared returns if the "variables" field was cleared in this mutation.
func (m *ProcessInstanceMutation) VariablesCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldVariables]
	return ok
}

// ResetVariables resets all changes to the "variables" field.
func (m *ProcessInstanceMutation) ResetVariables() {
	m.variables = nil
	delete(m.clearedFields, processinstance.FieldVariables)
}

// SetStartTime sets the "start_time" field.
func (m *ProcessInstanceMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ProcessInstanceMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ProcessInstanceMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *ProcessInstanceMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ProcessInstanceMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *ProcessInstanceMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[processinstance.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *ProcessInstanceMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ProcessInstanceMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, processinstance.FieldEndTime)
}

// SetSuspendedTime sets the "suspended_time" field.
func (m *ProcessInstanceMutation) SetSuspendedTime(t time.Time) {
	m.suspended_time = &t
}

// SuspendedTime returns the value of the "suspended_time" field in the mutation.
func (m *ProcessInstanceMutation) SuspendedTime() (r time.Time, exists bool) {
	v := m.suspended_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspendedTime returns the old "suspended_time" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldSuspendedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspendedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspendedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspendedTime: %w", err)
	}
	return oldValue.SuspendedTime, nil
}

// ClearSuspendedTime clears the value of the "suspended_time" field.
func (m *ProcessInstanceMutation) ClearSuspendedTime() {
	m.suspended_time = nil
	m.clearedFields[processinstance.FieldSuspendedTime] = struct{}{}
}

// SuspendedTimeCleared returns if the "suspended_time" field was cleared in this mutation.
func (m *ProcessInstanceMutation) SuspendedTimeCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldSuspendedTime]
	return ok
}

// ResetSuspendedTime resets all changes to the "suspended_time" field.
func (m *ProcessInstanceMutation) ResetSuspendedTime() {
	m.suspended_time = nil
	delete(m.clearedFields, processinstance.FieldSuspendedTime)
}

// SetSuspendedReason sets the "suspended_reason" field.
func (m *ProcessInstanceMutation) SetSuspendedReason(s string) {
	m.suspended_reason = &s
}

// SuspendedReason returns the value of the "suspended_reason" field in the mutation.
func (m *ProcessInstanceMutation) SuspendedReason() (r string, exists bool) {
	v := m.suspended_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspendedReason returns the old "suspended_reason" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldSuspendedReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspendedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspendedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspendedReason: %w", err)
	}
	return oldValue.SuspendedReason, nil
}

// ClearSuspendedReason clears the value of the "suspended_reason" field.
func (m *ProcessInstanceMutation) ClearSuspendedReason() {
	m.suspended_reason = nil
	m.clearedFields[processinstance.FieldSuspendedReason] = struct{}{}
}

// SuspendedReasonCleared returns if the "suspended_reason" field was cleared in this mutation.
func (m *ProcessInstanceMutation) SuspendedReasonCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldSuspendedReason]
	return ok
}

// ResetSuspendedReason resets all changes to the "suspended_reason" field.
func (m *ProcessInstanceMutation) ResetSuspendedReason() {
	m.suspended_reason = nil
	delete(m.clearedFields, processinstance.FieldSuspendedReason)
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcessInstanceMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcessInstanceMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProcessInstanceMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProcessInstanceMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcessInstanceMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetInitiator sets the "initiator" field.
func (m *ProcessInstanceMutation) SetInitiator(s string) {
	m.initiator = &s
}

// Initiator returns the value of the "initiator" field in the mutation.
func (m *ProcessInstanceMutation) Initiator() (r string, exists bool) {
	v := m.initiator
	if v == nil {
		return
	}
	return *v, true
}

// OldInitiator returns the old "initiator" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldInitiator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitiator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitiator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitiator: %w", err)
	}
	return oldValue.Initiator, nil
}

// ClearInitiator clears the value of the "initiator" field.
func (m *ProcessInstanceMutation) ClearInitiator() {
	m.initiator = nil
	m.clearedFields[processinstance.FieldInitiator] = struct{}{}
}

// InitiatorCleared returns if the "initiator" field was cleared in this mutation.
func (m *ProcessInstanceMutation) InitiatorCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldInitiator]
	return ok
}

// ResetInitiator resets all changes to the "initiator" field.
func (m *ProcessInstanceMutation) ResetInitiator() {
	m.initiator = nil
	delete(m.clearedFields, processinstance.FieldInitiator)
}

// SetParentProcessInstanceID sets the "parent_process_instance_id" field.
func (m *ProcessInstanceMutation) SetParentProcessInstanceID(s string) {
	m.parent_process_instance_id = &s
}

// ParentProcessInstanceID returns the value of the "parent_process_instance_id" field in the mutation.
func (m *ProcessInstanceMutation) ParentProcessInstanceID() (r string, exists bool) {
	v := m.parent_process_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentProcessInstanceID returns the old "parent_process_instance_id" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldParentProcessInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentProcessInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentProcessInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentProcessInstanceID: %w", err)
	}
	return oldValue.ParentProcessInstanceID, nil
}

// ClearParentProcessInstanceID clears the value of the "parent_process_instance_id" field.
func (m *ProcessInstanceMutation) ClearParentProcessInstanceID() {
	m.parent_process_instance_id = nil
	m.clearedFields[processinstance.FieldParentProcessInstanceID] = struct{}{}
}

// ParentProcessInstanceIDCleared returns if the "parent_process_instance_id" field was cleared in this mutation.
func (m *ProcessInstanceMutation) ParentProcessInstanceIDCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldParentProcessInstanceID]
	return ok
}

// ResetParentProcessInstanceID resets all changes to the "parent_process_instance_id" field.
func (m *ProcessInstanceMutation) ResetParentProcessInstanceID() {
	m.parent_process_instance_id = nil
	delete(m.clearedFields, processinstance.FieldParentProcessInstanceID)
}

// SetRootProcessInstanceID sets the "root_process_instance_id" field.
func (m *ProcessInstanceMutation) SetRootProcessInstanceID(s string) {
	m.root_process_instance_id = &s
}

// RootProcessInstanceID returns the value of the "root_process_instance_id" field in the mutation.
func (m *ProcessInstanceMutation) RootProcessInstanceID() (r string, exists bool) {
	v := m.root_process_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRootProcessInstanceID returns the old "root_process_instance_id" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldRootProcessInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootProcessInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootProcessInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootProcessInstanceID: %w", err)
	}
	return oldValue.RootProcessInstanceID, nil
}

// ClearRootProcessInstanceID clears the value of the "root_process_instance_id" field.
func (m *ProcessInstanceMutation) ClearRootProcessInstanceID() {
	m.root_process_instance_id = nil
	m.clearedFields[processinstance.FieldRootProcessInstanceID] = struct{}{}
}

// RootProcessInstanceIDCleared returns if the "root_process_instance_id" field was cleared in this mutation.
func (m *ProcessInstanceMutation) RootProcessInstanceIDCleared() bool {
	_, ok := m.clearedFields[processinstance.FieldRootProcessInstanceID]
	return ok
}

// ResetRootProcessInstanceID resets all changes to the "root_process_instance_id" field.
func (m *ProcessInstanceMutation) ResetRootProcessInstanceID() {
	m.root_process_instance_id = nil
	delete(m.clearedFields, processinstance.FieldRootProcessInstanceID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessInstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessInstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessInstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessInstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcessInstance entity.
// If the ProcessInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessInstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessInstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProcessInstanceMutation builder.
func (m *ProcessInstanceMutation) Where(ps ...predicate.ProcessInstance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcessInstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcessInstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcessInstance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcessInstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcessInstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcessInstance).
func (m *ProcessInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessInstanceMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.process_instance_id != nil {
		fields = append(fields, processinstance.FieldProcessInstanceID)
	}
	if m.business_key != nil {
		fields = append(fields, processinstance.FieldBusinessKey)
	}
	if m.process_definition_key != nil {
		fields = append(fields, processinstance.FieldProcessDefinitionKey)
	}
	if m.process_definition_id != nil {
		fields = append(fields, processinstance.FieldProcessDefinitionID)
	}
	if m.status != nil {
		fields = append(fields, processinstance.FieldStatus)
	}
	if m.current_activity_id != nil {
		fields = append(fields, processinstance.FieldCurrentActivityID)
	}
	if m.current_activity_name != nil {
		fields = append(fields, processinstance.FieldCurrentActivityName)
	}
	if m.variables != nil {
		fields = append(fields, processinstance.FieldVariables)
	}
	if m.start_time != nil {
		fields = append(fields, processinstance.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, processinstance.FieldEndTime)
	}
	if m.suspended_time != nil {
		fields = append(fields, processinstance.FieldSuspendedTime)
	}
	if m.suspended_reason != nil {
		fields = append(fields, processinstance.FieldSuspendedReason)
	}
	if m.tenant_id != nil {
		fields = append(fields, processinstance.FieldTenantID)
	}
	if m.initiator != nil {
		fields = append(fields, processinstance.FieldInitiator)
	}
	if m.parent_process_instance_id != nil {
		fields = append(fields, processinstance.FieldParentProcessInstanceID)
	}
	if m.root_process_instance_id != nil {
		fields = append(fields, processinstance.FieldRootProcessInstanceID)
	}
	if m.created_at != nil {
		fields = append(fields, processinstance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, processinstance.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processinstance.FieldProcessInstanceID:
		return m.ProcessInstanceID()
	case processinstance.FieldBusinessKey:
		return m.BusinessKey()
	case processinstance.FieldProcessDefinitionKey:
		return m.ProcessDefinitionKey()
	case processinstance.FieldProcessDefinitionID:
		return m.ProcessDefinitionID()
	case processinstance.FieldStatus:
		return m.Status()
	case processinstance.FieldCurrentActivityID:
		return m.CurrentActivityID()
	case processinstance.FieldCurrentActivityName:
		return m.CurrentActivityName()
	case processinstance.FieldVariables:
		return m.Variables()
	case processinstance.FieldStartTime:
		return m.StartTime()
	case processinstance.FieldEndTime:
		return m.EndTime()
	case processinstance.FieldSuspendedTime:
		return m.SuspendedTime()
	case processinstance.FieldSuspendedReason:
		return m.SuspendedReason()
	case processinstance.FieldTenantID:
		return m.TenantID()
	case processinstance.FieldInitiator:
		return m.Initiator()
	case processinstance.FieldParentProcessInstanceID:
		return m.ParentProcessInstanceID()
	case processinstance.FieldRootProcessInstanceID:
		return m.RootProcessInstanceID()
	case processinstance.FieldCreatedAt:
		return m.CreatedAt()
	case processinstance.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processinstance.FieldProcessInstanceID:
		return m.OldProcessInstanceID(ctx)
	case processinstance.FieldBusinessKey:
		return m.OldBusinessKey(ctx)
	case processinstance.FieldProcessDefinitionKey:
		return m.OldProcessDefinitionKey(ctx)
	case processinstance.FieldProcessDefinitionID:
		return m.OldProcessDefinitionID(ctx)
	case processinstance.FieldStatus:
		return m.OldStatus(ctx)
	case processinstance.FieldCurrentActivityID:
		return m.OldCurrentActivityID(ctx)
	case processinstance.FieldCurrentActivityName:
		return m.OldCurrentActivityName(ctx)
	case processinstance.FieldVariables:
		return m.OldVariables(ctx)
	case processinstance.FieldStartTime:
		return m.OldStartTime(ctx)
	case processinstance.FieldEndTime:
		return m.OldEndTime(ctx)
	case processinstance.FieldSuspendedTime:
		return m.OldSuspendedTime(ctx)
	case processinstance.FieldSuspendedReason:
		return m.OldSuspendedReason(ctx)
	case processinstance.FieldTenantID:
		return m.OldTenantID(ctx)
	case processinstance.FieldInitiator:
		return m.OldInitiator(ctx)
	case processinstance.FieldParentProcessInstanceID:
		return m.OldParentProcessInstanceID(ctx)
	case processinstance.FieldRootProcessInstanceID:
		return m.OldRootProcessInstanceID(ctx)
	case processinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case processinstance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processinstance.FieldProcessInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessInstanceID(v)
		return nil
	case processinstance.FieldBusinessKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessKey(v)
		return nil
	case processinstance.FieldProcessDefinitionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessDefinitionKey(v)
		return nil
	case processinstance.FieldProcessDefinitionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessDefinitionID(v)
		return nil
	case processinstance.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case processinstance.FieldCurrentActivityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentActivityID(v)
		return nil
	case processinstance.FieldCurrentActivityName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentActivityName(v)
		return nil
	case processinstance.FieldVariables:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case processinstance.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case processinstance.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case processinstance.FieldSuspendedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspendedTime(v)
		return nil
	case processinstance.FieldSuspendedReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspendedReason(v)
		return nil
	case processinstance.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case processinstance.FieldInitiator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitiator(v)
		return nil
	case processinstance.FieldParentProcessInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentProcessInstanceID(v)
		return nil
	case processinstance.FieldRootProcessInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootProcessInstanceID(v)
		return nil
	case processinstance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case processinstance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessInstanceMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, processinstance.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processinstance.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processinstance.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(processinstance.FieldBusinessKey) {
		fields = append(fields, processinstance.FieldBusinessKey)
	}
	if m.FieldCleared(processinstance.FieldCurrentActivityID) {
		fields = append(fields, processinstance.FieldCurrentActivityID)
	}
	if m.FieldCleared(processinstance.FieldCurrentActivityName) {
		fields = append(fields, processinstance.FieldCurrentActivityName)
	}
	if m.FieldCleared(processinstance.FieldVariables) {
		fields = append(fields, processinstance.FieldVariables)
	}
	if m.FieldCleared(processinstance.FieldEndTime) {
		fields = append(fields, processinstance.FieldEndTime)
	}
	if m.FieldCleared(processinstance.FieldSuspendedTime) {
		fields = append(fields, processinstance.FieldSuspendedTime)
	}
	if m.FieldCleared(processinstance.FieldSuspendedReason) {
		fields = append(fields, processinstance.FieldSuspendedReason)
	}
	if m.FieldCleared(processinstance.FieldInitiator) {
		fields = append(fields, processinstance.FieldInitiator)
	}
	if m.FieldCleared(processinstance.FieldParentProcessInstanceID) {
		fields = append(fields, processinstance.FieldParentProcessInstanceID)
	}
	if m.FieldCleared(processinstance.FieldRootProcessInstanceID) {
		fields = append(fields, processinstance.FieldRootProcessInstanceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessInstanceMutation) ClearField(name string) error {
	switch name {
	case processinstance.FieldBusinessKey:
		m.ClearBusinessKey()
		return nil
	case processinstance.FieldCurrentActivityID:
		m.ClearCurrentActivityID()
		return nil
	case processinstance.FieldCurrentActivityName:
		m.ClearCurrentActivityName()
		return nil
	case processinstance.FieldVariables:
		m.ClearVariables()
		return nil
	case processinstance.FieldEndTime:
		m.ClearEndTime()
		return nil
	case processinstance.FieldSuspendedTime:
		m.ClearSuspendedTime()
		return nil
	case processinstance.FieldSuspendedReason:
		m.ClearSuspendedReason()
		return nil
	case processinstance.FieldInitiator:
		m.ClearInitiator()
		return nil
	case processinstance.FieldParentProcessInstanceID:
		m.ClearParentProcessInstanceID()
		return nil
	case processinstance.FieldRootProcessInstanceID:
		m.ClearRootProcessInstanceID()
		return nil
	}
	return fmt.Errorf("unknown ProcessInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessInstanceMutation) ResetField(name string) error {
	switch name {
	case processinstance.FieldProcessInstanceID:
		m.ResetProcessInstanceID()
		return nil
	case processinstance.FieldBusinessKey:
		m.ResetBusinessKey()
		return nil
	case processinstance.FieldProcessDefinitionKey:
		m.ResetProcessDefinitionKey()
		return nil
	case processinstance.FieldProcessDefinitionID:
		m.ResetProcessDefinitionID()
		return nil
	case processinstance.FieldStatus:
		m.ResetStatus()
		return nil
	case processinstance.FieldCurrentActivityID:
		m.ResetCurrentActivityID()
		return nil
	case processinstance.FieldCurrentActivityName:
		m.ResetCurrentActivityName()
		return nil
	case processinstance.FieldVariables:
		m.ResetVariables()
		return nil
	case processinstance.FieldStartTime:
		m.ResetStartTime()
		return nil
	case processinstance.FieldEndTime:
		m.ResetEndTime()
		return nil
	case processinstance.FieldSuspendedTime:
		m.ResetSuspendedTime()
		return nil
	case processinstance.FieldSuspendedReason:
		m.ResetSuspendedReason()
		return nil
	case processinstance.FieldTenantID:
		m.ResetTenantID()
		return nil
	case processinstance.FieldInitiator:
		m.ResetInitiator()
		return nil
	case processinstance.FieldParentProcessInstanceID:
		m.ResetParentProcessInstanceID()
		return nil
	case processinstance.FieldRootProcessInstanceID:
		m.ResetRootProcessInstanceID()
		return nil
	case processinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case processinstance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessInstanceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessInstanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessInstanceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessInstanceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessInstanceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessInstance edge %s", name)
}

// ProcessTaskMutation represents an operation that mutates the ProcessTask nodes in the graph.
type ProcessTaskMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	task_id                *string
	process_instance_id    *string
	process_definition_key *string
	task_definition_key    *string
	task_name              *string
	task_type              *string
	assignee               *string
	candidate_users        *string
	candidate_groups       *string
	status                 *string
	priority               *string
	due_date               *time.Time
	created_time           *time.Time
	assigned_time          *time.Time
	started_time           *time.Time
	completed_time         *time.Time
	form_key               *string
	task_variables         *map[string]interface{}
	description            *string
	parent_task_id         *string
	root_task_id           *string
	tenant_id              *int
	addtenant_id           *int
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ProcessTask, error)
	predicates             []predicate.ProcessTask
}

var _ ent.Mutation = (*ProcessTaskMutation)(nil)

// processtaskOption allows management of the mutation configuration using functional options.
type processtaskOption func(*ProcessTaskMutation)

// newProcessTaskMutation creates new mutation for the ProcessTask entity.
func newProcessTaskMutation(c config, op Op, opts ...processtaskOption) *ProcessTaskMutation {
	m := &ProcessTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessTaskID sets the ID field of the mutation.
func withProcessTaskID(id int) processtaskOption {
	return func(m *ProcessTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessTask
		)
		m.oldValue = func(ctx context.Context) (*ProcessTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessTask sets the old ProcessTask of the mutation.
func withProcessTask(node *ProcessTask) processtaskOption {
	return func(m *ProcessTaskMutation) {
		m.oldValue = func(context.Context) (*ProcessTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessTaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessTaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *ProcessTaskMutation) SetTaskID(s string) {
	m.task_id = &s
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *ProcessTaskMutation) TaskID() (r string, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *ProcessTaskMutation) ResetTaskID() {
	m.task_id = nil
}

// SetProcessInstanceID sets the "process_instance_id" field.
func (m *ProcessTaskMutation) SetProcessInstanceID(s string) {
	m.process_instance_id = &s
}

// ProcessInstanceID returns the value of the "process_instance_id" field in the mutation.
func (m *ProcessTaskMutation) ProcessInstanceID() (r string, exists bool) {
	v := m.process_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessInstanceID returns the old "process_instance_id" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldProcessInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessInstanceID: %w", err)
	}
	return oldValue.ProcessInstanceID, nil
}

// ResetProcessInstanceID resets all changes to the "process_instance_id" field.
func (m *ProcessTaskMutation) ResetProcessInstanceID() {
	m.process_instance_id = nil
}

// SetProcessDefinitionKey sets the "process_definition_key" field.
func (m *ProcessTaskMutation) SetProcessDefinitionKey(s string) {
	m.process_definition_key = &s
}

// ProcessDefinitionKey returns the value of the "process_definition_key" field in the mutation.
func (m *ProcessTaskMutation) ProcessDefinitionKey() (r string, exists bool) {
	v := m.process_definition_key
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessDefinitionKey returns the old "process_definition_key" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldProcessDefinitionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessDefinitionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessDefinitionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessDefinitionKey: %w", err)
	}
	return oldValue.ProcessDefinitionKey, nil
}

// ResetProcessDefinitionKey resets all changes to the "process_definition_key" field.
func (m *ProcessTaskMutation) ResetProcessDefinitionKey() {
	m.process_definition_key = nil
}

// SetTaskDefinitionKey sets the "task_definition_key" field.
func (m *ProcessTaskMutation) SetTaskDefinitionKey(s string) {
	m.task_definition_key = &s
}

// TaskDefinitionKey returns the value of the "task_definition_key" field in the mutation.
func (m *ProcessTaskMutation) TaskDefinitionKey() (r string, exists bool) {
	v := m.task_definition_key
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskDefinitionKey returns the old "task_definition_key" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldTaskDefinitionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskDefinitionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskDefinitionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskDefinitionKey: %w", err)
	}
	return oldValue.TaskDefinitionKey, nil
}

// ResetTaskDefinitionKey resets all changes to the "task_definition_key" field.
func (m *ProcessTaskMutation) ResetTaskDefinitionKey() {
	m.task_definition_key = nil
}

// SetTaskName sets the "task_name" field.
func (m *ProcessTaskMutation) SetTaskName(s string) {
	m.task_name = &s
}

// TaskName returns the value of the "task_name" field in the mutation.
func (m *ProcessTaskMutation) TaskName() (r string, exists bool) {
	v := m.task_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskName returns the old "task_name" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldTaskName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskName: %w", err)
	}
	return oldValue.TaskName, nil
}

// ResetTaskName resets all changes to the "task_name" field.
func (m *ProcessTaskMutation) ResetTaskName() {
	m.task_name = nil
}

// SetTaskType sets the "task_type" field.
func (m *ProcessTaskMutation) SetTaskType(s string) {
	m.task_type = &s
}

// TaskType returns the value of the "task_type" field in the mutation.
func (m *ProcessTaskMutation) TaskType() (r string, exists bool) {
	v := m.task_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskType returns the old "task_type" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldTaskType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskType: %w", err)
	}
	return oldValue.TaskType, nil
}

// ResetTaskType resets all changes to the "task_type" field.
func (m *ProcessTaskMutation) ResetTaskType() {
	m.task_type = nil
}

// SetAssignee sets the "assignee" field.
func (m *ProcessTaskMutation) SetAssignee(s string) {
	m.assignee = &s
}

// Assignee returns the value of the "assignee" field in the mutation.
func (m *ProcessTaskMutation) Assignee() (r string, exists bool) {
	v := m.assignee
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignee returns the old "assignee" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldAssignee(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignee: %w", err)
	}
	return oldValue.Assignee, nil
}

// ClearAssignee clears the value of the "assignee" field.
func (m *ProcessTaskMutation) ClearAssignee() {
	m.assignee = nil
	m.clearedFields[processtask.FieldAssignee] = struct{}{}
}

// AssigneeCleared returns if the "assignee" field was cleared in this mutation.
func (m *ProcessTaskMutation) AssigneeCleared() bool {
	_, ok := m.clearedFields[processtask.FieldAssignee]
	return ok
}

// ResetAssignee resets all changes to the "assignee" field.
func (m *ProcessTaskMutation) ResetAssignee() {
	m.assignee = nil
	delete(m.clearedFields, processtask.FieldAssignee)
}

// SetCandidateUsers sets the "candidate_users" field.
func (m *ProcessTaskMutation) SetCandidateUsers(s string) {
	m.candidate_users = &s
}

// CandidateUsers returns the value of the "candidate_users" field in the mutation.
func (m *ProcessTaskMutation) CandidateUsers() (r string, exists bool) {
	v := m.candidate_users
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateUsers returns the old "candidate_users" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldCandidateUsers(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateUsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateUsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateUsers: %w", err)
	}
	return oldValue.CandidateUsers, nil
}

// ClearCandidateUsers clears the value of the "candidate_users" field.
func (m *ProcessTaskMutation) ClearCandidateUsers() {
	m.candidate_users = nil
	m.clearedFields[processtask.FieldCandidateUsers] = struct{}{}
}

// CandidateUsersCleared returns if the "candidate_users" field was cleared in this mutation.
func (m *ProcessTaskMutation) CandidateUsersCleared() bool {
	_, ok := m.clearedFields[processtask.FieldCandidateUsers]
	return ok
}

// ResetCandidateUsers resets all changes to the "candidate_users" field.
func (m *ProcessTaskMutation) ResetCandidateUsers() {
	m.candidate_users = nil
	delete(m.clearedFields, processtask.FieldCandidateUsers)
}

// SetCandidateGroups sets the "candidate_groups" field.
func (m *ProcessTaskMutation) SetCandidateGroups(s string) {
	m.candidate_groups = &s
}

// CandidateGroups returns the value of the "candidate_groups" field in the mutation.
func (m *ProcessTaskMutation) CandidateGroups() (r string, exists bool) {
	v := m.candidate_groups
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateGroups returns the old "candidate_groups" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldCandidateGroups(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateGroups: %w", err)
	}
	return oldValue.CandidateGroups, nil
}

// ClearCandidateGroups clears the value of the "candidate_groups" field.
func (m *ProcessTaskMutation) ClearCandidateGroups() {
	m.candidate_groups = nil
	m.clearedFields[processtask.FieldCandidateGroups] = struct{}{}
}

// CandidateGroupsCleared returns if the "candidate_groups" field was cleared in this mutation.
func (m *ProcessTaskMutation) CandidateGroupsCleared() bool {
	_, ok := m.clearedFields[processtask.FieldCandidateGroups]
	return ok
}

// ResetCandidateGroups resets all changes to the "candidate_groups" field.
func (m *ProcessTaskMutation) ResetCandidateGroups() {
	m.candidate_groups = nil
	delete(m.clearedFields, processtask.FieldCandidateGroups)
}

// SetStatus sets the "status" field.
func (m *ProcessTaskMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProcessTaskMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProcessTaskMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *ProcessTaskMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ProcessTaskMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *ProcessTaskMutation) ResetPriority() {
	m.priority = nil
}

// SetDueDate sets the "due_date" field.
func (m *ProcessTaskMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *ProcessTaskMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of the "due_date" field.
func (m *ProcessTaskMutation) ClearDueDate() {
	m.due_date = nil
	m.clearedFields[processtask.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "due_date" field was cleared in this mutation.
func (m *ProcessTaskMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[processtask.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *ProcessTaskMutation) ResetDueDate() {
	m.due_date = nil
	delete(m.clearedFields, processtask.FieldDueDate)
}

// SetCreatedTime sets the "created_time" field.
func (m *ProcessTaskMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *ProcessTaskMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *ProcessTaskMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetAssignedTime sets the "assigned_time" field.
func (m *ProcessTaskMutation) SetAssignedTime(t time.Time) {
	m.assigned_time = &t
}

// AssignedTime returns the value of the "assigned_time" field in the mutation.
func (m *ProcessTaskMutation) AssignedTime() (r time.Time, exists bool) {
	v := m.assigned_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedTime returns the old "assigned_time" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldAssignedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedTime: %w", err)
	}
	return oldValue.AssignedTime, nil
}

// ClearAssignedTime clears the value of the "assigned_time" field.
func (m *ProcessTaskMutation) ClearAssignedTime() {
	m.assigned_time = nil
	m.clearedFields[processtask.FieldAssignedTime] = struct{}{}
}

// AssignedTimeCleared returns if the "assigned_time" field was cleared in this mutation.
func (m *ProcessTaskMutation) AssignedTimeCleared() bool {
	_, ok := m.clearedFields[processtask.FieldAssignedTime]
	return ok
}

// ResetAssignedTime resets all changes to the "assigned_time" field.
func (m *ProcessTaskMutation) ResetAssignedTime() {
	m.assigned_time = nil
	delete(m.clearedFields, processtask.FieldAssignedTime)
}

// SetStartedTime sets the "started_time" field.
func (m *ProcessTaskMutation) SetStartedTime(t time.Time) {
	m.started_time = &t
}

// StartedTime returns the value of the "started_time" field in the mutation.
func (m *ProcessTaskMutation) StartedTime() (r time.Time, exists bool) {
	v := m.started_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedTime returns the old "started_time" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldStartedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedTime: %w", err)
	}
	return oldValue.StartedTime, nil
}

// ClearStartedTime clears the value of the "started_time" field.
func (m *ProcessTaskMutation) ClearStartedTime() {
	m.started_time = nil
	m.clearedFields[processtask.FieldStartedTime] = struct{}{}
}

// StartedTimeCleared returns if the "started_time" field was cleared in this mutation.
func (m *ProcessTaskMutation) StartedTimeCleared() bool {
	_, ok := m.clearedFields[processtask.FieldStartedTime]
	return ok
}

// ResetStartedTime resets all changes to the "started_time" field.
func (m *ProcessTaskMutation) ResetStartedTime() {
	m.started_time = nil
	delete(m.clearedFields, processtask.FieldStartedTime)
}

// SetCompletedTime sets the "completed_time" field.
func (m *ProcessTaskMutation) SetCompletedTime(t time.Time) {
	m.completed_time = &t
}

// CompletedTime returns the value of the "completed_time" field in the mutation.
func (m *ProcessTaskMutation) CompletedTime() (r time.Time, exists bool) {
	v := m.completed_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedTime returns the old "completed_time" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldCompletedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedTime: %w", err)
	}
	return oldValue.CompletedTime, nil
}

// ClearCompletedTime clears the value of the "completed_time" field.
func (m *ProcessTaskMutation) ClearCompletedTime() {
	m.completed_time = nil
	m.clearedFields[processtask.FieldCompletedTime] = struct{}{}
}

// CompletedTimeCleared returns if the "completed_time" field was cleared in this mutation.
func (m *ProcessTaskMutation) CompletedTimeCleared() bool {
	_, ok := m.clearedFields[processtask.FieldCompletedTime]
	return ok
}

// ResetCompletedTime resets all changes to the "completed_time" field.
func (m *ProcessTaskMutation) ResetCompletedTime() {
	m.completed_time = nil
	delete(m.clearedFields, processtask.FieldCompletedTime)
}

// SetFormKey sets the "form_key" field.
func (m *ProcessTaskMutation) SetFormKey(s string) {
	m.form_key = &s
}

// FormKey returns the value of the "form_key" field in the mutation.
func (m *ProcessTaskMutation) FormKey() (r string, exists bool) {
	v := m.form_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFormKey returns the old "form_key" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldFormKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormKey: %w", err)
	}
	return oldValue.FormKey, nil
}

// ClearFormKey clears the value of the "form_key" field.
func (m *ProcessTaskMutation) ClearFormKey() {
	m.form_key = nil
	m.clearedFields[processtask.FieldFormKey] = struct{}{}
}

// FormKeyCleared returns if the "form_key" field was cleared in this mutation.
func (m *ProcessTaskMutation) FormKeyCleared() bool {
	_, ok := m.clearedFields[processtask.FieldFormKey]
	return ok
}

// ResetFormKey resets all changes to the "form_key" field.
func (m *ProcessTaskMutation) ResetFormKey() {
	m.form_key = nil
	delete(m.clearedFields, processtask.FieldFormKey)
}

// SetTaskVariables sets the "task_variables" field.
func (m *ProcessTaskMutation) SetTaskVariables(value map[string]interface{}) {
	m.task_variables = &value
}

// TaskVariables returns the value of the "task_variables" field in the mutation.
func (m *ProcessTaskMutation) TaskVariables() (r map[string]interface{}, exists bool) {
	v := m.task_variables
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskVariables returns the old "task_variables" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldTaskVariables(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskVariables: %w", err)
	}
	return oldValue.TaskVariables, nil
}

// ClearTaskVariables clears the value of the "task_variables" field.
func (m *ProcessTaskMutation) ClearTaskVariables() {
	m.task_variables = nil
	m.clearedFields[processtask.FieldTaskVariables] = struct{}{}
}

// TaskVariablesCleared returns if the "task_variables" field was cleared in this mutation.
func (m *ProcessTaskMutation) TaskVariablesCleared() bool {
	_, ok := m.clearedFields[processtask.FieldTaskVariables]
	return ok
}

// ResetTaskVariables resets all changes to the "task_variables" field.
func (m *ProcessTaskMutation) ResetTaskVariables() {
	m.task_variables = nil
	delete(m.clearedFields, processtask.FieldTaskVariables)
}

// SetDescription sets the "description" field.
func (m *ProcessTaskMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProcessTaskMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProcessTaskMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[processtask.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProcessTaskMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[processtask.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProcessTaskMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, processtask.FieldDescription)
}

// SetParentTaskID sets the "parent_task_id" field.
func (m *ProcessTaskMutation) SetParentTaskID(s string) {
	m.parent_task_id = &s
}

// ParentTaskID returns the value of the "parent_task_id" field in the mutation.
func (m *ProcessTaskMutation) ParentTaskID() (r string, exists bool) {
	v := m.parent_task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentTaskID returns the old "parent_task_id" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldParentTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentTaskID: %w", err)
	}
	return oldValue.ParentTaskID, nil
}

// ClearParentTaskID clears the value of the "parent_task_id" field.
func (m *ProcessTaskMutation) ClearParentTaskID() {
	m.parent_task_id = nil
	m.clearedFields[processtask.FieldParentTaskID] = struct{}{}
}

// ParentTaskIDCleared returns if the "parent_task_id" field was cleared in this mutation.
func (m *ProcessTaskMutation) ParentTaskIDCleared() bool {
	_, ok := m.clearedFields[processtask.FieldParentTaskID]
	return ok
}

// ResetParentTaskID resets all changes to the "parent_task_id" field.
func (m *ProcessTaskMutation) ResetParentTaskID() {
	m.parent_task_id = nil
	delete(m.clearedFields, processtask.FieldParentTaskID)
}

// SetRootTaskID sets the "root_task_id" field.
func (m *ProcessTaskMutation) SetRootTaskID(s string) {
	m.root_task_id = &s
}

// RootTaskID returns the value of the "root_task_id" field in the mutation.
func (m *ProcessTaskMutation) RootTaskID() (r string, exists bool) {
	v := m.root_task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRootTaskID returns the old "root_task_id" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldRootTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootTaskID: %w", err)
	}
	return oldValue.RootTaskID, nil
}

// ClearRootTaskID clears the value of the "root_task_id" field.
func (m *ProcessTaskMutation) ClearRootTaskID() {
	m.root_task_id = nil
	m.clearedFields[processtask.FieldRootTaskID] = struct{}{}
}

// RootTaskIDCleared returns if the "root_task_id" field was cleared in this mutation.
func (m *ProcessTaskMutation) RootTaskIDCleared() bool {
	_, ok := m.clearedFields[processtask.FieldRootTaskID]
	return ok
}

// ResetRootTaskID resets all changes to the "root_task_id" field.
func (m *ProcessTaskMutation) ResetRootTaskID() {
	m.root_task_id = nil
	delete(m.clearedFields, processtask.FieldRootTaskID)
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcessTaskMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcessTaskMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProcessTaskMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProcessTaskMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcessTaskMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcessTask entity.
// If the ProcessTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProcessTaskMutation builder.
func (m *ProcessTaskMutation) Where(ps ...predicate.ProcessTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcessTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcessTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcessTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcessTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcessTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcessTask).
func (m *ProcessTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessTaskMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.task_id != nil {
		fields = append(fields, processtask.FieldTaskID)
	}
	if m.process_instance_id != nil {
		fields = append(fields, processtask.FieldProcessInstanceID)
	}
	if m.process_definition_key != nil {
		fields = append(fields, processtask.FieldProcessDefinitionKey)
	}
	if m.task_definition_key != nil {
		fields = append(fields, processtask.FieldTaskDefinitionKey)
	}
	if m.task_name != nil {
		fields = append(fields, processtask.FieldTaskName)
	}
	if m.task_type != nil {
		fields = append(fields, processtask.FieldTaskType)
	}
	if m.assignee != nil {
		fields = append(fields, processtask.FieldAssignee)
	}
	if m.candidate_users != nil {
		fields = append(fields, processtask.FieldCandidateUsers)
	}
	if m.candidate_groups != nil {
		fields = append(fields, processtask.FieldCandidateGroups)
	}
	if m.status != nil {
		fields = append(fields, processtask.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, processtask.FieldPriority)
	}
	if m.due_date != nil {
		fields = append(fields, processtask.FieldDueDate)
	}
	if m.created_time != nil {
		fields = append(fields, processtask.FieldCreatedTime)
	}
	if m.assigned_time != nil {
		fields = append(fields, processtask.FieldAssignedTime)
	}
	if m.started_time != nil {
		fields = append(fields, processtask.FieldStartedTime)
	}
	if m.completed_time != nil {
		fields = append(fields, processtask.FieldCompletedTime)
	}
	if m.form_key != nil {
		fields = append(fields, processtask.FieldFormKey)
	}
	if m.task_variables != nil {
		fields = append(fields, processtask.FieldTaskVariables)
	}
	if m.description != nil {
		fields = append(fields, processtask.FieldDescription)
	}
	if m.parent_task_id != nil {
		fields = append(fields, processtask.FieldParentTaskID)
	}
	if m.root_task_id != nil {
		fields = append(fields, processtask.FieldRootTaskID)
	}
	if m.tenant_id != nil {
		fields = append(fields, processtask.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, processtask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, processtask.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processtask.FieldTaskID:
		return m.TaskID()
	case processtask.FieldProcessInstanceID:
		return m.ProcessInstanceID()
	case processtask.FieldProcessDefinitionKey:
		return m.ProcessDefinitionKey()
	case processtask.FieldTaskDefinitionKey:
		return m.TaskDefinitionKey()
	case processtask.FieldTaskName:
		return m.TaskName()
	case processtask.FieldTaskType:
		return m.TaskType()
	case processtask.FieldAssignee:
		return m.Assignee()
	case processtask.FieldCandidateUsers:
		return m.CandidateUsers()
	case processtask.FieldCandidateGroups:
		return m.CandidateGroups()
	case processtask.FieldStatus:
		return m.Status()
	case processtask.FieldPriority:
		return m.Priority()
	case processtask.FieldDueDate:
		return m.DueDate()
	case processtask.FieldCreatedTime:
		return m.CreatedTime()
	case processtask.FieldAssignedTime:
		return m.AssignedTime()
	case processtask.FieldStartedTime:
		return m.StartedTime()
	case processtask.FieldCompletedTime:
		return m.CompletedTime()
	case processtask.FieldFormKey:
		return m.FormKey()
	case processtask.FieldTaskVariables:
		return m.TaskVariables()
	case processtask.FieldDescription:
		return m.Description()
	case processtask.FieldParentTaskID:
		return m.ParentTaskID()
	case processtask.FieldRootTaskID:
		return m.RootTaskID()
	case processtask.FieldTenantID:
		return m.TenantID()
	case processtask.FieldCreatedAt:
		return m.CreatedAt()
	case processtask.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processtask.FieldTaskID:
		return m.OldTaskID(ctx)
	case processtask.FieldProcessInstanceID:
		return m.OldProcessInstanceID(ctx)
	case processtask.FieldProcessDefinitionKey:
		return m.OldProcessDefinitionKey(ctx)
	case processtask.FieldTaskDefinitionKey:
		return m.OldTaskDefinitionKey(ctx)
	case processtask.FieldTaskName:
		return m.OldTaskName(ctx)
	case processtask.FieldTaskType:
		return m.OldTaskType(ctx)
	case processtask.FieldAssignee:
		return m.OldAssignee(ctx)
	case processtask.FieldCandidateUsers:
		return m.OldCandidateUsers(ctx)
	case processtask.FieldCandidateGroups:
		return m.OldCandidateGroups(ctx)
	case processtask.FieldStatus:
		return m.OldStatus(ctx)
	case processtask.FieldPriority:
		return m.OldPriority(ctx)
	case processtask.FieldDueDate:
		return m.OldDueDate(ctx)
	case processtask.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case processtask.FieldAssignedTime:
		return m.OldAssignedTime(ctx)
	case processtask.FieldStartedTime:
		return m.OldStartedTime(ctx)
	case processtask.FieldCompletedTime:
		return m.OldCompletedTime(ctx)
	case processtask.FieldFormKey:
		return m.OldFormKey(ctx)
	case processtask.FieldTaskVariables:
		return m.OldTaskVariables(ctx)
	case processtask.FieldDescription:
		return m.OldDescription(ctx)
	case processtask.FieldParentTaskID:
		return m.OldParentTaskID(ctx)
	case processtask.FieldRootTaskID:
		return m.OldRootTaskID(ctx)
	case processtask.FieldTenantID:
		return m.OldTenantID(ctx)
	case processtask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case processtask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processtask.FieldTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case processtask.FieldProcessInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessInstanceID(v)
		return nil
	case processtask.FieldProcessDefinitionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessDefinitionKey(v)
		return nil
	case processtask.FieldTaskDefinitionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskDefinitionKey(v)
		return nil
	case processtask.FieldTaskName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskName(v)
		return nil
	case processtask.FieldTaskType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskType(v)
		return nil
	case processtask.FieldAssignee:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignee(v)
		return nil
	case processtask.FieldCandidateUsers:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateUsers(v)
		return nil
	case processtask.FieldCandidateGroups:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateGroups(v)
		return nil
	case processtask.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case processtask.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case processtask.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case processtask.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case processtask.FieldAssignedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedTime(v)
		return nil
	case processtask.FieldStartedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedTime(v)
		return nil
	case processtask.FieldCompletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedTime(v)
		return nil
	case processtask.FieldFormKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormKey(v)
		return nil
	case processtask.FieldTaskVariables:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskVariables(v)
		return nil
	case processtask.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case processtask.FieldParentTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentTaskID(v)
		return nil
	case processtask.FieldRootTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootTaskID(v)
		return nil
	case processtask.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case processtask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case processtask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessTaskMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, processtask.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processtask.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processtask.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(processtask.FieldAssignee) {
		fields = append(fields, processtask.FieldAssignee)
	}
	if m.FieldCleared(processtask.FieldCandidateUsers) {
		fields = append(fields, processtask.FieldCandidateUsers)
	}
	if m.FieldCleared(processtask.FieldCandidateGroups) {
		fields = append(fields, processtask.FieldCandidateGroups)
	}
	if m.FieldCleared(processtask.FieldDueDate) {
		fields = append(fields, processtask.FieldDueDate)
	}
	if m.FieldCleared(processtask.FieldAssignedTime) {
		fields = append(fields, processtask.FieldAssignedTime)
	}
	if m.FieldCleared(processtask.FieldStartedTime) {
		fields = append(fields, processtask.FieldStartedTime)
	}
	if m.FieldCleared(processtask.FieldCompletedTime) {
		fields = append(fields, processtask.FieldCompletedTime)
	}
	if m.FieldCleared(processtask.FieldFormKey) {
		fields = append(fields, processtask.FieldFormKey)
	}
	if m.FieldCleared(processtask.FieldTaskVariables) {
		fields = append(fields, processtask.FieldTaskVariables)
	}
	if m.FieldCleared(processtask.FieldDescription) {
		fields = append(fields, processtask.FieldDescription)
	}
	if m.FieldCleared(processtask.FieldParentTaskID) {
		fields = append(fields, processtask.FieldParentTaskID)
	}
	if m.FieldCleared(processtask.FieldRootTaskID) {
		fields = append(fields, processtask.FieldRootTaskID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessTaskMutation) ClearField(name string) error {
	switch name {
	case processtask.FieldAssignee:
		m.ClearAssignee()
		return nil
	case processtask.FieldCandidateUsers:
		m.ClearCandidateUsers()
		return nil
	case processtask.FieldCandidateGroups:
		m.ClearCandidateGroups()
		return nil
	case processtask.FieldDueDate:
		m.ClearDueDate()
		return nil
	case processtask.FieldAssignedTime:
		m.ClearAssignedTime()
		return nil
	case processtask.FieldStartedTime:
		m.ClearStartedTime()
		return nil
	case processtask.FieldCompletedTime:
		m.ClearCompletedTime()
		return nil
	case processtask.FieldFormKey:
		m.ClearFormKey()
		return nil
	case processtask.FieldTaskVariables:
		m.ClearTaskVariables()
		return nil
	case processtask.FieldDescription:
		m.ClearDescription()
		return nil
	case processtask.FieldParentTaskID:
		m.ClearParentTaskID()
		return nil
	case processtask.FieldRootTaskID:
		m.ClearRootTaskID()
		return nil
	}
	return fmt.Errorf("unknown ProcessTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessTaskMutation) ResetField(name string) error {
	switch name {
	case processtask.FieldTaskID:
		m.ResetTaskID()
		return nil
	case processtask.FieldProcessInstanceID:
		m.ResetProcessInstanceID()
		return nil
	case processtask.FieldProcessDefinitionKey:
		m.ResetProcessDefinitionKey()
		return nil
	case processtask.FieldTaskDefinitionKey:
		m.ResetTaskDefinitionKey()
		return nil
	case processtask.FieldTaskName:
		m.ResetTaskName()
		return nil
	case processtask.FieldTaskType:
		m.ResetTaskType()
		return nil
	case processtask.FieldAssignee:
		m.ResetAssignee()
		return nil
	case processtask.FieldCandidateUsers:
		m.ResetCandidateUsers()
		return nil
	case processtask.FieldCandidateGroups:
		m.ResetCandidateGroups()
		return nil
	case processtask.FieldStatus:
		m.ResetStatus()
		return nil
	case processtask.FieldPriority:
		m.ResetPriority()
		return nil
	case processtask.FieldDueDate:
		m.ResetDueDate()
		return nil
	case processtask.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case processtask.FieldAssignedTime:
		m.ResetAssignedTime()
		return nil
	case processtask.FieldStartedTime:
		m.ResetStartedTime()
		return nil
	case processtask.FieldCompletedTime:
		m.ResetCompletedTime()
		return nil
	case processtask.FieldFormKey:
		m.ResetFormKey()
		return nil
	case processtask.FieldTaskVariables:
		m.ResetTaskVariables()
		return nil
	case processtask.FieldDescription:
		m.ResetDescription()
		return nil
	case processtask.FieldParentTaskID:
		m.ResetParentTaskID()
		return nil
	case processtask.FieldRootTaskID:
		m.ResetRootTaskID()
		return nil
	case processtask.FieldTenantID:
		m.ResetTenantID()
		return nil
	case processtask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case processtask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessTaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessTaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessTaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessTaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessTask edge %s", name)
}

// ProcessVariableMutation represents an operation that mutates the ProcessVariable nodes in the graph.
type ProcessVariableMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	variable_id          *string
	process_instance_id  *string
	task_id              *string
	variable_name        *string
	variable_type        *string
	variable_value       *string
	scope                *string
	is_transient         *bool
	serialization_format *string
	tenant_id            *int
	addtenant_id         *int
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*ProcessVariable, error)
	predicates           []predicate.ProcessVariable
}

var _ ent.Mutation = (*ProcessVariableMutation)(nil)

// processvariableOption allows management of the mutation configuration using functional options.
type processvariableOption func(*ProcessVariableMutation)

// newProcessVariableMutation creates new mutation for the ProcessVariable entity.
func newProcessVariableMutation(c config, op Op, opts ...processvariableOption) *ProcessVariableMutation {
	m := &ProcessVariableMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessVariable,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessVariableID sets the ID field of the mutation.
func withProcessVariableID(id int) processvariableOption {
	return func(m *ProcessVariableMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessVariable
		)
		m.oldValue = func(ctx context.Context) (*ProcessVariable, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessVariable.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessVariable sets the old ProcessVariable of the mutation.
func withProcessVariable(node *ProcessVariable) processvariableOption {
	return func(m *ProcessVariableMutation) {
		m.oldValue = func(context.Context) (*ProcessVariable, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessVariableMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessVariableMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessVariableMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessVariableMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessVariable.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVariableID sets the "variable_id" field.
func (m *ProcessVariableMutation) SetVariableID(s string) {
	m.variable_id = &s
}

// VariableID returns the value of the "variable_id" field in the mutation.
func (m *ProcessVariableMutation) VariableID() (r string, exists bool) {
	v := m.variable_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVariableID returns the old "variable_id" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldVariableID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariableID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariableID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariableID: %w", err)
	}
	return oldValue.VariableID, nil
}

// ResetVariableID resets all changes to the "variable_id" field.
func (m *ProcessVariableMutation) ResetVariableID() {
	m.variable_id = nil
}

// SetProcessInstanceID sets the "process_instance_id" field.
func (m *ProcessVariableMutation) SetProcessInstanceID(s string) {
	m.process_instance_id = &s
}

// ProcessInstanceID returns the value of the "process_instance_id" field in the mutation.
func (m *ProcessVariableMutation) ProcessInstanceID() (r string, exists bool) {
	v := m.process_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessInstanceID returns the old "process_instance_id" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldProcessInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessInstanceID: %w", err)
	}
	return oldValue.ProcessInstanceID, nil
}

// ResetProcessInstanceID resets all changes to the "process_instance_id" field.
func (m *ProcessVariableMutation) ResetProcessInstanceID() {
	m.process_instance_id = nil
}

// SetTaskID sets the "task_id" field.
func (m *ProcessVariableMutation) SetTaskID(s string) {
	m.task_id = &s
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *ProcessVariableMutation) TaskID() (r string, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ClearTaskID clears the value of the "task_id" field.
func (m *ProcessVariableMutation) ClearTaskID() {
	m.task_id = nil
	m.clearedFields[processvariable.FieldTaskID] = struct{}{}
}

// TaskIDCleared returns if the "task_id" field was cleared in this mutation.
func (m *ProcessVariableMutation) TaskIDCleared() bool {
	_, ok := m.clearedFields[processvariable.FieldTaskID]
	return ok
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *ProcessVariableMutation) ResetTaskID() {
	m.task_id = nil
	delete(m.clearedFields, processvariable.FieldTaskID)
}

// SetVariableName sets the "variable_name" field.
func (m *ProcessVariableMutation) SetVariableName(s string) {
	m.variable_name = &s
}

// VariableName returns the value of the "variable_name" field in the mutation.
func (m *ProcessVariableMutation) VariableName() (r string, exists bool) {
	v := m.variable_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVariableName returns the old "variable_name" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldVariableName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariableName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariableName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariableName: %w", err)
	}
	return oldValue.VariableName, nil
}

// ResetVariableName resets all changes to the "variable_name" field.
func (m *ProcessVariableMutation) ResetVariableName() {
	m.variable_name = nil
}

// SetVariableType sets the "variable_type" field.
func (m *ProcessVariableMutation) SetVariableType(s string) {
	m.variable_type = &s
}

// VariableType returns the value of the "variable_type" field in the mutation.
func (m *ProcessVariableMutation) VariableType() (r string, exists bool) {
	v := m.variable_type
	if v == nil {
		return
	}
	return *v, true
}

// OldVariableType returns the old "variable_type" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldVariableType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariableType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariableType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariableType: %w", err)
	}
	return oldValue.VariableType, nil
}

// ResetVariableType resets all changes to the "variable_type" field.
func (m *ProcessVariableMutation) ResetVariableType() {
	m.variable_type = nil
}

// SetVariableValue sets the "variable_value" field.
func (m *ProcessVariableMutation) SetVariableValue(s string) {
	m.variable_value = &s
}

// VariableValue returns the value of the "variable_value" field in the mutation.
func (m *ProcessVariableMutation) VariableValue() (r string, exists bool) {
	v := m.variable_value
	if v == nil {
		return
	}
	return *v, true
}

// OldVariableValue returns the old "variable_value" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldVariableValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariableValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariableValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariableValue: %w", err)
	}
	return oldValue.VariableValue, nil
}

// ClearVariableValue clears the value of the "variable_value" field.
func (m *ProcessVariableMutation) ClearVariableValue() {
	m.variable_value = nil
	m.clearedFields[processvariable.FieldVariableValue] = struct{}{}
}

// VariableValueCleared returns if the "variable_value" field was cleared in this mutation.
func (m *ProcessVariableMutation) VariableValueCleared() bool {
	_, ok := m.clearedFields[processvariable.FieldVariableValue]
	return ok
}

// ResetVariableValue resets all changes to the "variable_value" field.
func (m *ProcessVariableMutation) ResetVariableValue() {
	m.variable_value = nil
	delete(m.clearedFields, processvariable.FieldVariableValue)
}

// SetScope sets the "scope" field.
func (m *ProcessVariableMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *ProcessVariableMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *ProcessVariableMutation) ResetScope() {
	m.scope = nil
}

// SetIsTransient sets the "is_transient" field.
func (m *ProcessVariableMutation) SetIsTransient(b bool) {
	m.is_transient = &b
}

// IsTransient returns the value of the "is_transient" field in the mutation.
func (m *ProcessVariableMutation) IsTransient() (r bool, exists bool) {
	v := m.is_transient
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTransient returns the old "is_transient" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldIsTransient(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTransient is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTransient requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTransient: %w", err)
	}
	return oldValue.IsTransient, nil
}

// ResetIsTransient resets all changes to the "is_transient" field.
func (m *ProcessVariableMutation) ResetIsTransient() {
	m.is_transient = nil
}

// SetSerializationFormat sets the "serialization_format" field.
func (m *ProcessVariableMutation) SetSerializationFormat(s string) {
	m.serialization_format = &s
}

// SerializationFormat returns the value of the "serialization_format" field in the mutation.
func (m *ProcessVariableMutation) SerializationFormat() (r string, exists bool) {
	v := m.serialization_format
	if v == nil {
		return
	}
	return *v, true
}

// OldSerializationFormat returns the old "serialization_format" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldSerializationFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerializationFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerializationFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerializationFormat: %w", err)
	}
	return oldValue.SerializationFormat, nil
}

// ResetSerializationFormat resets all changes to the "serialization_format" field.
func (m *ProcessVariableMutation) ResetSerializationFormat() {
	m.serialization_format = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcessVariableMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcessVariableMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProcessVariableMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProcessVariableMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcessVariableMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessVariableMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessVariableMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessVariableMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessVariableMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessVariableMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcessVariable entity.
// If the ProcessVariable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessVariableMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessVariableMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProcessVariableMutation builder.
func (m *ProcessVariableMutation) Where(ps ...predicate.ProcessVariable) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcessVariableMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcessVariableMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcessVariable, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcessVariableMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcessVariableMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcessVariable).
func (m *ProcessVariableMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessVariableMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.variable_id != nil {
		fields = append(fields, processvariable.FieldVariableID)
	}
	if m.process_instance_id != nil {
		fields = append(fields, processvariable.FieldProcessInstanceID)
	}
	if m.task_id != nil {
		fields = append(fields, processvariable.FieldTaskID)
	}
	if m.variable_name != nil {
		fields = append(fields, processvariable.FieldVariableName)
	}
	if m.variable_type != nil {
		fields = append(fields, processvariable.FieldVariableType)
	}
	if m.variable_value != nil {
		fields = append(fields, processvariable.FieldVariableValue)
	}
	if m.scope != nil {
		fields = append(fields, processvariable.FieldScope)
	}
	if m.is_transient != nil {
		fields = append(fields, processvariable.FieldIsTransient)
	}
	if m.serialization_format != nil {
		fields = append(fields, processvariable.FieldSerializationFormat)
	}
	if m.tenant_id != nil {
		fields = append(fields, processvariable.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, processvariable.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, processvariable.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessVariableMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processvariable.FieldVariableID:
		return m.VariableID()
	case processvariable.FieldProcessInstanceID:
		return m.ProcessInstanceID()
	case processvariable.FieldTaskID:
		return m.TaskID()
	case processvariable.FieldVariableName:
		return m.VariableName()
	case processvariable.FieldVariableType:
		return m.VariableType()
	case processvariable.FieldVariableValue:
		return m.VariableValue()
	case processvariable.FieldScope:
		return m.Scope()
	case processvariable.FieldIsTransient:
		return m.IsTransient()
	case processvariable.FieldSerializationFormat:
		return m.SerializationFormat()
	case processvariable.FieldTenantID:
		return m.TenantID()
	case processvariable.FieldCreatedAt:
		return m.CreatedAt()
	case processvariable.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessVariableMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processvariable.FieldVariableID:
		return m.OldVariableID(ctx)
	case processvariable.FieldProcessInstanceID:
		return m.OldProcessInstanceID(ctx)
	case processvariable.FieldTaskID:
		return m.OldTaskID(ctx)
	case processvariable.FieldVariableName:
		return m.OldVariableName(ctx)
	case processvariable.FieldVariableType:
		return m.OldVariableType(ctx)
	case processvariable.FieldVariableValue:
		return m.OldVariableValue(ctx)
	case processvariable.FieldScope:
		return m.OldScope(ctx)
	case processvariable.FieldIsTransient:
		return m.OldIsTransient(ctx)
	case processvariable.FieldSerializationFormat:
		return m.OldSerializationFormat(ctx)
	case processvariable.FieldTenantID:
		return m.OldTenantID(ctx)
	case processvariable.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case processvariable.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessVariable field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessVariableMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processvariable.FieldVariableID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariableID(v)
		return nil
	case processvariable.FieldProcessInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessInstanceID(v)
		return nil
	case processvariable.FieldTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case processvariable.FieldVariableName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariableName(v)
		return nil
	case processvariable.FieldVariableType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariableType(v)
		return nil
	case processvariable.FieldVariableValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariableValue(v)
		return nil
	case processvariable.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case processvariable.FieldIsTransient:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTransient(v)
		return nil
	case processvariable.FieldSerializationFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerializationFormat(v)
		return nil
	case processvariable.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case processvariable.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case processvariable.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessVariable field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessVariableMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, processvariable.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessVariableMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processvariable.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessVariableMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processvariable.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessVariable numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessVariableMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(processvariable.FieldTaskID) {
		fields = append(fields, processvariable.FieldTaskID)
	}
	if m.FieldCleared(processvariable.FieldVariableValue) {
		fields = append(fields, processvariable.FieldVariableValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessVariableMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessVariableMutation) ClearField(name string) error {
	switch name {
	case processvariable.FieldTaskID:
		m.ClearTaskID()
		return nil
	case processvariable.FieldVariableValue:
		m.ClearVariableValue()
		return nil
	}
	return fmt.Errorf("unknown ProcessVariable nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessVariableMutation) ResetField(name string) error {
	switch name {
	case processvariable.FieldVariableID:
		m.ResetVariableID()
		return nil
	case processvariable.FieldProcessInstanceID:
		m.ResetProcessInstanceID()
		return nil
	case processvariable.FieldTaskID:
		m.ResetTaskID()
		return nil
	case processvariable.FieldVariableName:
		m.ResetVariableName()
		return nil
	case processvariable.FieldVariableType:
		m.ResetVariableType()
		return nil
	case processvariable.FieldVariableValue:
		m.ResetVariableValue()
		return nil
	case processvariable.FieldScope:
		m.ResetScope()
		return nil
	case processvariable.FieldIsTransient:
		m.ResetIsTransient()
		return nil
	case processvariable.FieldSerializationFormat:
		m.ResetSerializationFormat()
		return nil
	case processvariable.FieldTenantID:
		m.ResetTenantID()
		return nil
	case processvariable.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case processvariable.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessVariable field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessVariableMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessVariableMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessVariableMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessVariableMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessVariableMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessVariableMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessVariableMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessVariable unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessVariableMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessVariable edge %s", name)
}

// PromptTemplateMutation represents an operation that mutates the PromptTemplate nodes in the graph.
type PromptTemplateMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	version       *string
	template      *string
	description   *string
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PromptTemplate, error)
	predicates    []predicate.PromptTemplate
}

var _ ent.Mutation = (*PromptTemplateMutation)(nil)

// prompttemplateOption allows management of the mutation configuration using functional options.
type prompttemplateOption func(*PromptTemplateMutation)

// newPromptTemplateMutation creates new mutation for the PromptTemplate entity.
func newPromptTemplateMutation(c config, op Op, opts ...prompttemplateOption) *PromptTemplateMutation {
	m := &PromptTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypePromptTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromptTemplateID sets the ID field of the mutation.
func withPromptTemplateID(id int) prompttemplateOption {
	return func(m *PromptTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *PromptTemplate
		)
		m.oldValue = func(ctx context.Context) (*PromptTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromptTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromptTemplate sets the old PromptTemplate of the mutation.
func withPromptTemplate(node *PromptTemplate) prompttemplateOption {
	return func(m *PromptTemplateMutation) {
		m.oldValue = func(context.Context) (*PromptTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromptTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromptTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromptTemplateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromptTemplateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromptTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromptTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromptTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromptTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromptTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromptTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromptTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PromptTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PromptTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PromptTemplateMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *PromptTemplateMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PromptTemplateMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PromptTemplateMutation) ResetVersion() {
	m.version = nil
}

// SetTemplate sets the "template" field.
func (m *PromptTemplateMutation) SetTemplate(s string) {
	m.template = &s
}

// Template returns the value of the "template" field in the mutation.
func (m *PromptTemplateMutation) Template() (r string, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old "template" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ResetTemplate resets all changes to the "template" field.
func (m *PromptTemplateMutation) ResetTemplate() {
	m.template = nil
}

// SetDescription sets the "description" field.
func (m *PromptTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PromptTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PromptTemplateMutation) ResetDescription() {
	m.description = nil
}

// SetMetadata sets the "metadata" field.
func (m *PromptTemplateMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PromptTemplateMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the PromptTemplate entity.
// If the PromptTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptTemplateMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PromptTemplateMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[prompttemplate.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PromptTemplateMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[prompttemplate.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PromptTemplateMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, prompttemplate.FieldMetadata)
}

// Where appends a list predicates to the PromptTemplateMutation builder.
func (m *PromptTemplateMutation) Where(ps ...predicate.PromptTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromptTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromptTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromptTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromptTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromptTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromptTemplate).
func (m *PromptTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromptTemplateMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, prompttemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, prompttemplate.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, prompttemplate.FieldName)
	}
	if m.version != nil {
		fields = append(fields, prompttemplate.FieldVersion)
	}
	if m.template != nil {
		fields = append(fields, prompttemplate.FieldTemplate)
	}
	if m.description != nil {
		fields = append(fields, prompttemplate.FieldDescription)
	}
	if m.metadata != nil {
		fields = append(fields, prompttemplate.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromptTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prompttemplate.FieldCreatedAt:
		return m.CreatedAt()
	case prompttemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	case prompttemplate.FieldName:
		return m.Name()
	case prompttemplate.FieldVersion:
		return m.Version()
	case prompttemplate.FieldTemplate:
		return m.Template()
	case prompttemplate.FieldDescription:
		return m.Description()
	case prompttemplate.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromptTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prompttemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case prompttemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case prompttemplate.FieldName:
		return m.OldName(ctx)
	case prompttemplate.FieldVersion:
		return m.OldVersion(ctx)
	case prompttemplate.FieldTemplate:
		return m.OldTemplate(ctx)
	case prompttemplate.FieldDescription:
		return m.OldDescription(ctx)
	case prompttemplate.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown PromptTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prompttemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case prompttemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case prompttemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case prompttemplate.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case prompttemplate.FieldTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	case prompttemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case prompttemplate.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown PromptTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromptTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromptTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PromptTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromptTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(prompttemplate.FieldMetadata) {
		fields = append(fields, prompttemplate.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromptTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromptTemplateMutation) ClearField(name string) error {
	switch name {
	case prompttemplate.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown PromptTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromptTemplateMutation) ResetField(name string) error {
	switch name {
	case prompttemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case prompttemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case prompttemplate.FieldName:
		m.ResetName()
		return nil
	case prompttemplate.FieldVersion:
		m.ResetVersion()
		return nil
	case prompttemplate.FieldTemplate:
		m.ResetTemplate()
		return nil
	case prompttemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case prompttemplate.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown PromptTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromptTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromptTemplateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromptTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromptTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromptTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromptTemplateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromptTemplateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PromptTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromptTemplateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PromptTemplate edge %s", name)
}

// SLADefinitionMutation represents an operation that mutates the SLADefinition nodes in the graph.
type SLADefinitionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	tenant_id     *int
	addtenant_id  *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SLADefinition, error)
	predicates    []predicate.SLADefinition
}

var _ ent.Mutation = (*SLADefinitionMutation)(nil)

// sladefinitionOption allows management of the mutation configuration using functional options.
type sladefinitionOption func(*SLADefinitionMutation)

// newSLADefinitionMutation creates new mutation for the SLADefinition entity.
func newSLADefinitionMutation(c config, op Op, opts ...sladefinitionOption) *SLADefinitionMutation {
	m := &SLADefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeSLADefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSLADefinitionID sets the ID field of the mutation.
func withSLADefinitionID(id int) sladefinitionOption {
	return func(m *SLADefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *SLADefinition
		)
		m.oldValue = func(ctx context.Context) (*SLADefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SLADefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSLADefinition sets the old SLADefinition of the mutation.
func withSLADefinition(node *SLADefinition) sladefinitionOption {
	return func(m *SLADefinitionMutation) {
		m.oldValue = func(context.Context) (*SLADefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SLADefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SLADefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SLADefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SLADefinitionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SLADefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SLADefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SLADefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SLADefinitionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SLADefinitionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SLADefinitionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SLADefinitionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[sladefinition.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SLADefinitionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[sladefinition.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SLADefinitionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, sladefinition.FieldDescription)
}

// SetTenantID sets the "tenant_id" field.
func (m *SLADefinitionMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SLADefinitionMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *SLADefinitionMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *SLADefinitionMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SLADefinitionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SLADefinitionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SLADefinitionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SLADefinitionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SLADefinitionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SLADefinitionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SLADefinition entity.
// If the SLADefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLADefinitionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SLADefinitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the SLADefinitionMutation builder.
func (m *SLADefinitionMutation) Where(ps ...predicate.SLADefinition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SLADefinitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SLADefinitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SLADefinition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SLADefinitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SLADefinitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SLADefinition).
func (m *SLADefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SLADefinitionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, sladefinition.FieldName)
	}
	if m.description != nil {
		fields = append(fields, sladefinition.FieldDescription)
	}
	if m.tenant_id != nil {
		fields = append(fields, sladefinition.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, sladefinition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sladefinition.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SLADefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sladefinition.FieldName:
		return m.Name()
	case sladefinition.FieldDescription:
		return m.Description()
	case sladefinition.FieldTenantID:
		return m.TenantID()
	case sladefinition.FieldCreatedAt:
		return m.CreatedAt()
	case sladefinition.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SLADefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sladefinition.FieldName:
		return m.OldName(ctx)
	case sladefinition.FieldDescription:
		return m.OldDescription(ctx)
	case sladefinition.FieldTenantID:
		return m.OldTenantID(ctx)
	case sladefinition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sladefinition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SLADefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLADefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sladefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sladefinition.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case sladefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case sladefinition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sladefinition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SLADefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SLADefinitionMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, sladefinition.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SLADefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sladefinition.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLADefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sladefinition.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown SLADefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SLADefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sladefinition.FieldDescription) {
		fields = append(fields, sladefinition.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SLADefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SLADefinitionMutation) ClearField(name string) error {
	switch name {
	case sladefinition.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SLADefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SLADefinitionMutation) ResetField(name string) error {
	switch name {
	case sladefinition.FieldName:
		m.ResetName()
		return nil
	case sladefinition.FieldDescription:
		m.ResetDescription()
		return nil
	case sladefinition.FieldTenantID:
		m.ResetTenantID()
		return nil
	case sladefinition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sladefinition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SLADefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SLADefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SLADefinitionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SLADefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SLADefinitionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SLADefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SLADefinitionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SLADefinitionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SLADefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SLADefinitionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SLADefinition edge %s", name)
}

// SLAViolationMutation represents an operation that mutates the SLAViolation nodes in the graph.
type SLAViolationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	sla_definition_id    *int
	addsla_definition_id *int
	ticket_id            *int
	addticket_id         *int
	violation_type       *string
	violation_time       *time.Time
	description          *string
	tenant_id            *int
	addtenant_id         *int
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*SLAViolation, error)
	predicates           []predicate.SLAViolation
}

var _ ent.Mutation = (*SLAViolationMutation)(nil)

// slaviolationOption allows management of the mutation configuration using functional options.
type slaviolationOption func(*SLAViolationMutation)

// newSLAViolationMutation creates new mutation for the SLAViolation entity.
func newSLAViolationMutation(c config, op Op, opts ...slaviolationOption) *SLAViolationMutation {
	m := &SLAViolationMutation{
		config:        c,
		op:            op,
		typ:           TypeSLAViolation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSLAViolationID sets the ID field of the mutation.
func withSLAViolationID(id int) slaviolationOption {
	return func(m *SLAViolationMutation) {
		var (
			err   error
			once  sync.Once
			value *SLAViolation
		)
		m.oldValue = func(ctx context.Context) (*SLAViolation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SLAViolation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSLAViolation sets the old SLAViolation of the mutation.
func withSLAViolation(node *SLAViolation) slaviolationOption {
	return func(m *SLAViolationMutation) {
		m.oldValue = func(context.Context) (*SLAViolation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SLAViolationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SLAViolationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SLAViolationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SLAViolationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SLAViolation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSLADefinitionID sets the "sla_definition_id" field.
func (m *SLAViolationMutation) SetSLADefinitionID(i int) {
	m.sla_definition_id = &i
	m.addsla_definition_id = nil
}

// SLADefinitionID returns the value of the "sla_definition_id" field in the mutation.
func (m *SLAViolationMutation) SLADefinitionID() (r int, exists bool) {
	v := m.sla_definition_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSLADefinitionID returns the old "sla_definition_id" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldSLADefinitionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSLADefinitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSLADefinitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSLADefinitionID: %w", err)
	}
	return oldValue.SLADefinitionID, nil
}

// AddSLADefinitionID adds i to the "sla_definition_id" field.
func (m *SLAViolationMutation) AddSLADefinitionID(i int) {
	if m.addsla_definition_id != nil {
		*m.addsla_definition_id += i
	} else {
		m.addsla_definition_id = &i
	}
}

// AddedSLADefinitionID returns the value that was added to the "sla_definition_id" field in this mutation.
func (m *SLAViolationMutation) AddedSLADefinitionID() (r int, exists bool) {
	v := m.addsla_definition_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSLADefinitionID resets all changes to the "sla_definition_id" field.
func (m *SLAViolationMutation) ResetSLADefinitionID() {
	m.sla_definition_id = nil
	m.addsla_definition_id = nil
}

// SetTicketID sets the "ticket_id" field.
func (m *SLAViolationMutation) SetTicketID(i int) {
	m.ticket_id = &i
	m.addticket_id = nil
}

// TicketID returns the value of the "ticket_id" field in the mutation.
func (m *SLAViolationMutation) TicketID() (r int, exists bool) {
	v := m.ticket_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketID returns the old "ticket_id" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldTicketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketID: %w", err)
	}
	return oldValue.TicketID, nil
}

// AddTicketID adds i to the "ticket_id" field.
func (m *SLAViolationMutation) AddTicketID(i int) {
	if m.addticket_id != nil {
		*m.addticket_id += i
	} else {
		m.addticket_id = &i
	}
}

// AddedTicketID returns the value that was added to the "ticket_id" field in this mutation.
func (m *SLAViolationMutation) AddedTicketID() (r int, exists bool) {
	v := m.addticket_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTicketID resets all changes to the "ticket_id" field.
func (m *SLAViolationMutation) ResetTicketID() {
	m.ticket_id = nil
	m.addticket_id = nil
}

// SetViolationType sets the "violation_type" field.
func (m *SLAViolationMutation) SetViolationType(s string) {
	m.violation_type = &s
}

// ViolationType returns the value of the "violation_type" field in the mutation.
func (m *SLAViolationMutation) ViolationType() (r string, exists bool) {
	v := m.violation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldViolationType returns the old "violation_type" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldViolationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViolationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViolationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViolationType: %w", err)
	}
	return oldValue.ViolationType, nil
}

// ResetViolationType resets all changes to the "violation_type" field.
func (m *SLAViolationMutation) ResetViolationType() {
	m.violation_type = nil
}

// SetViolationTime sets the "violation_time" field.
func (m *SLAViolationMutation) SetViolationTime(t time.Time) {
	m.violation_time = &t
}

// ViolationTime returns the value of the "violation_time" field in the mutation.
func (m *SLAViolationMutation) ViolationTime() (r time.Time, exists bool) {
	v := m.violation_time
	if v == nil {
		return
	}
	return *v, true
}

// OldViolationTime returns the old "violation_time" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldViolationTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViolationTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViolationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViolationTime: %w", err)
	}
	return oldValue.ViolationTime, nil
}

// ResetViolationTime resets all changes to the "violation_time" field.
func (m *SLAViolationMutation) ResetViolationTime() {
	m.violation_time = nil
}

// SetDescription sets the "description" field.
func (m *SLAViolationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SLAViolationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SLAViolationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[slaviolation.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SLAViolationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[slaviolation.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SLAViolationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, slaviolation.FieldDescription)
}

// SetTenantID sets the "tenant_id" field.
func (m *SLAViolationMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SLAViolationMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *SLAViolationMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *SLAViolationMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SLAViolationMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SLAViolationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SLAViolationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SLAViolationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SLAViolationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SLAViolationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SLAViolation entity.
// If the SLAViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLAViolationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SLAViolationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the SLAViolationMutation builder.
func (m *SLAViolationMutation) Where(ps ...predicate.SLAViolation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SLAViolationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SLAViolationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SLAViolation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SLAViolationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SLAViolationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SLAViolation).
func (m *SLAViolationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SLAViolationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.sla_definition_id != nil {
		fields = append(fields, slaviolation.FieldSLADefinitionID)
	}
	if m.ticket_id != nil {
		fields = append(fields, slaviolation.FieldTicketID)
	}
	if m.violation_type != nil {
		fields = append(fields, slaviolation.FieldViolationType)
	}
	if m.violation_time != nil {
		fields = append(fields, slaviolation.FieldViolationTime)
	}
	if m.description != nil {
		fields = append(fields, slaviolation.FieldDescription)
	}
	if m.tenant_id != nil {
		fields = append(fields, slaviolation.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, slaviolation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, slaviolation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SLAViolationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		return m.SLADefinitionID()
	case slaviolation.FieldTicketID:
		return m.TicketID()
	case slaviolation.FieldViolationType:
		return m.ViolationType()
	case slaviolation.FieldViolationTime:
		return m.ViolationTime()
	case slaviolation.FieldDescription:
		return m.Description()
	case slaviolation.FieldTenantID:
		return m.TenantID()
	case slaviolation.FieldCreatedAt:
		return m.CreatedAt()
	case slaviolation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SLAViolationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		return m.OldSLADefinitionID(ctx)
	case slaviolation.FieldTicketID:
		return m.OldTicketID(ctx)
	case slaviolation.FieldViolationType:
		return m.OldViolationType(ctx)
	case slaviolation.FieldViolationTime:
		return m.OldViolationTime(ctx)
	case slaviolation.FieldDescription:
		return m.OldDescription(ctx)
	case slaviolation.FieldTenantID:
		return m.OldTenantID(ctx)
	case slaviolation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case slaviolation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SLAViolation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLAViolationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSLADefinitionID(v)
		return nil
	case slaviolation.FieldTicketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketID(v)
		return nil
	case slaviolation.FieldViolationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViolationType(v)
		return nil
	case slaviolation.FieldViolationTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViolationTime(v)
		return nil
	case slaviolation.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case slaviolation.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case slaviolation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case slaviolation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SLAViolation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SLAViolationMutation) AddedFields() []string {
	var fields []string
	if m.addsla_definition_id != nil {
		fields = append(fields, slaviolation.FieldSLADefinitionID)
	}
	if m.addticket_id != nil {
		fields = append(fields, slaviolation.FieldTicketID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, slaviolation.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SLAViolationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		return m.AddedSLADefinitionID()
	case slaviolation.FieldTicketID:
		return m.AddedTicketID()
	case slaviolation.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLAViolationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSLADefinitionID(v)
		return nil
	case slaviolation.FieldTicketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTicketID(v)
		return nil
	case slaviolation.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown SLAViolation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SLAViolationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(slaviolation.FieldDescription) {
		fields = append(fields, slaviolation.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SLAViolationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SLAViolationMutation) ClearField(name string) error {
	switch name {
	case slaviolation.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SLAViolation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SLAViolationMutation) ResetField(name string) error {
	switch name {
	case slaviolation.FieldSLADefinitionID:
		m.ResetSLADefinitionID()
		return nil
	case slaviolation.FieldTicketID:
		m.ResetTicketID()
		return nil
	case slaviolation.FieldViolationType:
		m.ResetViolationType()
		return nil
	case slaviolation.FieldViolationTime:
		m.ResetViolationTime()
		return nil
	case slaviolation.FieldDescription:
		m.ResetDescription()
		return nil
	case slaviolation.FieldTenantID:
		m.ResetTenantID()
		return nil
	case slaviolation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case slaviolation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SLAViolation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SLAViolationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SLAViolationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SLAViolationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SLAViolationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SLAViolationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SLAViolationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SLAViolationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SLAViolation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SLAViolationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SLAViolation edge %s", name)
}

// ServiceCatalogMutation represents an operation that mutates the ServiceCatalog nodes in the graph.
type ServiceCatalogMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	description      *string
	category         *string
	price            *float64
	addprice         *float64
	delivery_time    *int
	adddelivery_time *int
	status           *string
	tenant_id        *int
	addtenant_id     *int
	is_active        *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*ServiceCatalog, error)
	predicates       []predicate.ServiceCatalog
}

var _ ent.Mutation = (*ServiceCatalogMutation)(nil)

// servicecatalogOption allows management of the mutation configuration using functional options.
type servicecatalogOption func(*ServiceCatalogMutation)

// newServiceCatalogMutation creates new mutation for the ServiceCatalog entity.
func newServiceCatalogMutation(c config, op Op, opts ...servicecatalogOption) *ServiceCatalogMutation {
	m := &ServiceCatalogMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceCatalog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceCatalogID sets the ID field of the mutation.
func withServiceCatalogID(id int) servicecatalogOption {
	return func(m *ServiceCatalogMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceCatalog
		)
		m.oldValue = func(ctx context.Context) (*ServiceCatalog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceCatalog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceCatalog sets the old ServiceCatalog of the mutation.
func withServiceCatalog(node *ServiceCatalog) servicecatalogOption {
	return func(m *ServiceCatalogMutation) {
		m.oldValue = func(context.Context) (*ServiceCatalog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceCatalogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceCatalogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceCatalogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceCatalogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceCatalog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ServiceCatalogMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceCatalogMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceCatalogMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ServiceCatalogMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServiceCatalogMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ServiceCatalogMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[servicecatalog.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ServiceCatalogMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[servicecatalog.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ServiceCatalogMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, servicecatalog.FieldDescription)
}

// SetCategory sets the "category" field.
func (m *ServiceCatalogMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ServiceCatalogMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ServiceCatalogMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[servicecatalog.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ServiceCatalogMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[servicecatalog.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ServiceCatalogMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, servicecatalog.FieldCategory)
}

// SetPrice sets the "price" field.
func (m *ServiceCatalogMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ServiceCatalogMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ServiceCatalogMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ServiceCatalogMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *ServiceCatalogMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[servicecatalog.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *ServiceCatalogMutation) PriceCleared() bool {
	_, ok := m.clearedFields[servicecatalog.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *ServiceCatalogMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, servicecatalog.FieldPrice)
}

// SetDeliveryTime sets the "delivery_time" field.
func (m *ServiceCatalogMutation) SetDeliveryTime(i int) {
	m.delivery_time = &i
	m.adddelivery_time = nil
}

// DeliveryTime returns the value of the "delivery_time" field in the mutation.
func (m *ServiceCatalogMutation) DeliveryTime() (r int, exists bool) {
	v := m.delivery_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryTime returns the old "delivery_time" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldDeliveryTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryTime: %w", err)
	}
	return oldValue.DeliveryTime, nil
}

// AddDeliveryTime adds i to the "delivery_time" field.
func (m *ServiceCatalogMutation) AddDeliveryTime(i int) {
	if m.adddelivery_time != nil {
		*m.adddelivery_time += i
	} else {
		m.adddelivery_time = &i
	}
}

// AddedDeliveryTime returns the value that was added to the "delivery_time" field in this mutation.
func (m *ServiceCatalogMutation) AddedDeliveryTime() (r int, exists bool) {
	v := m.adddelivery_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeliveryTime clears the value of the "delivery_time" field.
func (m *ServiceCatalogMutation) ClearDeliveryTime() {
	m.delivery_time = nil
	m.adddelivery_time = nil
	m.clearedFields[servicecatalog.FieldDeliveryTime] = struct{}{}
}

// DeliveryTimeCleared returns if the "delivery_time" field was cleared in this mutation.
func (m *ServiceCatalogMutation) DeliveryTimeCleared() bool {
	_, ok := m.clearedFields[servicecatalog.FieldDeliveryTime]
	return ok
}

// ResetDeliveryTime resets all changes to the "delivery_time" field.
func (m *ServiceCatalogMutation) ResetDeliveryTime() {
	m.delivery_time = nil
	m.adddelivery_time = nil
	delete(m.clearedFields, servicecatalog.FieldDeliveryTime)
}

// SetStatus sets the "status" field.
func (m *ServiceCatalogMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceCatalogMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceCatalogMutation) ResetStatus() {
	m.status = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ServiceCatalogMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ServiceCatalogMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ServiceCatalogMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ServiceCatalogMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ServiceCatalogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetIsActive sets the "is_active" field.
func (m *ServiceCatalogMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ServiceCatalogMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ServiceCatalogMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceCatalogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceCatalogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceCatalogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServiceCatalogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServiceCatalogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServiceCatalog entity.
// If the ServiceCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceCatalogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServiceCatalogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ServiceCatalogMutation builder.
func (m *ServiceCatalogMutation) Where(ps ...predicate.ServiceCatalog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceCatalogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceCatalogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceCatalog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceCatalogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceCatalogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceCatalog).
func (m *ServiceCatalogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceCatalogMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, servicecatalog.FieldName)
	}
	if m.description != nil {
		fields = append(fields, servicecatalog.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, servicecatalog.FieldCategory)
	}
	if m.price != nil {
		fields = append(fields, servicecatalog.FieldPrice)
	}
	if m.delivery_time != nil {
		fields = append(fields, servicecatalog.FieldDeliveryTime)
	}
	if m.status != nil {
		fields = append(fields, servicecatalog.FieldStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, servicecatalog.FieldTenantID)
	}
	if m.is_active != nil {
		fields = append(fields, servicecatalog.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, servicecatalog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servicecatalog.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceCatalogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicecatalog.FieldName:
		return m.Name()
	case servicecatalog.FieldDescription:
		return m.Description()
	case servicecatalog.FieldCategory:
		return m.Category()
	case servicecatalog.FieldPrice:
		return m.Price()
	case servicecatalog.FieldDeliveryTime:
		return m.DeliveryTime()
	case servicecatalog.FieldStatus:
		return m.Status()
	case servicecatalog.FieldTenantID:
		return m.TenantID()
	case servicecatalog.FieldIsActive:
		return m.IsActive()
	case servicecatalog.FieldCreatedAt:
		return m.CreatedAt()
	case servicecatalog.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceCatalogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicecatalog.FieldName:
		return m.OldName(ctx)
	case servicecatalog.FieldDescription:
		return m.OldDescription(ctx)
	case servicecatalog.FieldCategory:
		return m.OldCategory(ctx)
	case servicecatalog.FieldPrice:
		return m.OldPrice(ctx)
	case servicecatalog.FieldDeliveryTime:
		return m.OldDeliveryTime(ctx)
	case servicecatalog.FieldStatus:
		return m.OldStatus(ctx)
	case servicecatalog.FieldTenantID:
		return m.OldTenantID(ctx)
	case servicecatalog.FieldIsActive:
		return m.OldIsActive(ctx)
	case servicecatalog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servicecatalog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceCatalog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceCatalogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicecatalog.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case servicecatalog.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case servicecatalog.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case servicecatalog.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case servicecatalog.FieldDeliveryTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryTime(v)
		return nil
	case servicecatalog.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case servicecatalog.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case servicecatalog.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case servicecatalog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servicecatalog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceCatalog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceCatalogMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, servicecatalog.FieldPrice)
	}
	if m.adddelivery_time != nil {
		fields = append(fields, servicecatalog.FieldDeliveryTime)
	}
	if m.addtenant_id != nil {
		fields = append(fields, servicecatalog.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceCatalogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servicecatalog.FieldPrice:
		return m.AddedPrice()
	case servicecatalog.FieldDeliveryTime:
		return m.AddedDeliveryTime()
	case servicecatalog.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceCatalogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servicecatalog.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case servicecatalog.FieldDeliveryTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveryTime(v)
		return nil
	case servicecatalog.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceCatalog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceCatalogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicecatalog.FieldDescription) {
		fields = append(fields, servicecatalog.FieldDescription)
	}
	if m.FieldCleared(servicecatalog.FieldCategory) {
		fields = append(fields, servicecatalog.FieldCategory)
	}
	if m.FieldCleared(servicecatalog.FieldPrice) {
		fields = append(fields, servicecatalog.FieldPrice)
	}
	if m.FieldCleared(servicecatalog.FieldDeliveryTime) {
		fields = append(fields, servicecatalog.FieldDeliveryTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceCatalogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceCatalogMutation) ClearField(name string) error {
	switch name {
	case servicecatalog.FieldDescription:
		m.ClearDescription()
		return nil
	case servicecatalog.FieldCategory:
		m.ClearCategory()
		return nil
	case servicecatalog.FieldPrice:
		m.ClearPrice()
		return nil
	case servicecatalog.FieldDeliveryTime:
		m.ClearDeliveryTime()
		return nil
	}
	return fmt.Errorf("unknown ServiceCatalog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceCatalogMutation) ResetField(name string) error {
	switch name {
	case servicecatalog.FieldName:
		m.ResetName()
		return nil
	case servicecatalog.FieldDescription:
		m.ResetDescription()
		return nil
	case servicecatalog.FieldCategory:
		m.ResetCategory()
		return nil
	case servicecatalog.FieldPrice:
		m.ResetPrice()
		return nil
	case servicecatalog.FieldDeliveryTime:
		m.ResetDeliveryTime()
		return nil
	case servicecatalog.FieldStatus:
		m.ResetStatus()
		return nil
	case servicecatalog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case servicecatalog.FieldIsActive:
		m.ResetIsActive()
		return nil
	case servicecatalog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servicecatalog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ServiceCatalog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceCatalogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceCatalogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceCatalogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceCatalogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceCatalogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceCatalogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceCatalogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ServiceCatalog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceCatalogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ServiceCatalog edge %s", name)
}

// ServiceRequestMutation represents an operation that mutates the ServiceRequest nodes in the graph.
type ServiceRequestMutation struct {
	config
	op              Op
	typ             string
	id              *int
	catalog_id      *int
	addcatalog_id   *int
	requester_id    *int
	addrequester_id *int
	status          *string
	reason          *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*ServiceRequest, error)
	predicates      []predicate.ServiceRequest
}

var _ ent.Mutation = (*ServiceRequestMutation)(nil)

// servicerequestOption allows management of the mutation configuration using functional options.
type servicerequestOption func(*ServiceRequestMutation)

// newServiceRequestMutation creates new mutation for the ServiceRequest entity.
func newServiceRequestMutation(c config, op Op, opts ...servicerequestOption) *ServiceRequestMutation {
	m := &ServiceRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceRequestID sets the ID field of the mutation.
func withServiceRequestID(id int) servicerequestOption {
	return func(m *ServiceRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceRequest
		)
		m.oldValue = func(ctx context.Context) (*ServiceRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceRequest sets the old ServiceRequest of the mutation.
func withServiceRequest(node *ServiceRequest) servicerequestOption {
	return func(m *ServiceRequestMutation) {
		m.oldValue = func(context.Context) (*ServiceRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceRequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceRequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCatalogID sets the "catalog_id" field.
func (m *ServiceRequestMutation) SetCatalogID(i int) {
	m.catalog_id = &i
	m.addcatalog_id = nil
}

// CatalogID returns the value of the "catalog_id" field in the mutation.
func (m *ServiceRequestMutation) CatalogID() (r int, exists bool) {
	v := m.catalog_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCatalogID returns the old "catalog_id" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldCatalogID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCatalogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCatalogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCatalogID: %w", err)
	}
	return oldValue.CatalogID, nil
}

// AddCatalogID adds i to the "catalog_id" field.
func (m *ServiceRequestMutation) AddCatalogID(i int) {
	if m.addcatalog_id != nil {
		*m.addcatalog_id += i
	} else {
		m.addcatalog_id = &i
	}
}

// AddedCatalogID returns the value that was added to the "catalog_id" field in this mutation.
func (m *ServiceRequestMutation) AddedCatalogID() (r int, exists bool) {
	v := m.addcatalog_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCatalogID resets all changes to the "catalog_id" field.
func (m *ServiceRequestMutation) ResetCatalogID() {
	m.catalog_id = nil
	m.addcatalog_id = nil
}

// SetRequesterID sets the "requester_id" field.
func (m *ServiceRequestMutation) SetRequesterID(i int) {
	m.requester_id = &i
	m.addrequester_id = nil
}

// RequesterID returns the value of the "requester_id" field in the mutation.
func (m *ServiceRequestMutation) RequesterID() (r int, exists bool) {
	v := m.requester_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequesterID returns the old "requester_id" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldRequesterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequesterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequesterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequesterID: %w", err)
	}
	return oldValue.RequesterID, nil
}

// AddRequesterID adds i to the "requester_id" field.
func (m *ServiceRequestMutation) AddRequesterID(i int) {
	if m.addrequester_id != nil {
		*m.addrequester_id += i
	} else {
		m.addrequester_id = &i
	}
}

// AddedRequesterID returns the value that was added to the "requester_id" field in this mutation.
func (m *ServiceRequestMutation) AddedRequesterID() (r int, exists bool) {
	v := m.addrequester_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequesterID resets all changes to the "requester_id" field.
func (m *ServiceRequestMutation) ResetRequesterID() {
	m.requester_id = nil
	m.addrequester_id = nil
}

// SetStatus sets the "status" field.
func (m *ServiceRequestMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceRequestMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceRequestMutation) ResetStatus() {
	m.status = nil
}

// SetReason sets the "reason" field.
func (m *ServiceRequestMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *ServiceRequestMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *ServiceRequestMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[servicerequest.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *ServiceRequestMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[servicerequest.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *ServiceRequestMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, servicerequest.FieldReason)
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServiceRequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServiceRequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServiceRequest entity.
// If the ServiceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServiceRequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ServiceRequestMutation builder.
func (m *ServiceRequestMutation) Where(ps ...predicate.ServiceRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceRequest).
func (m *ServiceRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceRequestMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.catalog_id != nil {
		fields = append(fields, servicerequest.FieldCatalogID)
	}
	if m.requester_id != nil {
		fields = append(fields, servicerequest.FieldRequesterID)
	}
	if m.status != nil {
		fields = append(fields, servicerequest.FieldStatus)
	}
	if m.reason != nil {
		fields = append(fields, servicerequest.FieldReason)
	}
	if m.created_at != nil {
		fields = append(fields, servicerequest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servicerequest.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicerequest.FieldCatalogID:
		return m.CatalogID()
	case servicerequest.FieldRequesterID:
		return m.RequesterID()
	case servicerequest.FieldStatus:
		return m.Status()
	case servicerequest.FieldReason:
		return m.Reason()
	case servicerequest.FieldCreatedAt:
		return m.CreatedAt()
	case servicerequest.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicerequest.FieldCatalogID:
		return m.OldCatalogID(ctx)
	case servicerequest.FieldRequesterID:
		return m.OldRequesterID(ctx)
	case servicerequest.FieldStatus:
		return m.OldStatus(ctx)
	case servicerequest.FieldReason:
		return m.OldReason(ctx)
	case servicerequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servicerequest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicerequest.FieldCatalogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCatalogID(v)
		return nil
	case servicerequest.FieldRequesterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequesterID(v)
		return nil
	case servicerequest.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case servicerequest.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case servicerequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servicerequest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceRequestMutation) AddedFields() []string {
	var fields []string
	if m.addcatalog_id != nil {
		fields = append(fields, servicerequest.FieldCatalogID)
	}
	if m.addrequester_id != nil {
		fields = append(fields, servicerequest.FieldRequesterID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceRequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servicerequest.FieldCatalogID:
		return m.AddedCatalogID()
	case servicerequest.FieldRequesterID:
		return m.AddedRequesterID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servicerequest.FieldCatalogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCatalogID(v)
		return nil
	case servicerequest.FieldRequesterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequesterID(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicerequest.FieldReason) {
		fields = append(fields, servicerequest.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceRequestMutation) ClearField(name string) error {
	switch name {
	case servicerequest.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown ServiceRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceRequestMutation) ResetField(name string) error {
	switch name {
	case servicerequest.FieldCatalogID:
		m.ResetCatalogID()
		return nil
	case servicerequest.FieldRequesterID:
		m.ResetRequesterID()
		return nil
	case servicerequest.FieldStatus:
		m.ResetStatus()
		return nil
	case servicerequest.FieldReason:
		m.ResetReason()
		return nil
	case servicerequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servicerequest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ServiceRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceRequestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceRequestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceRequestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ServiceRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceRequestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ServiceRequest edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	code          *string
	domain        *string
	_type         *string
	status        *string
	expires_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tenant, error)
	predicates    []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id int) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *TenantMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TenantMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TenantMutation) ResetCode() {
	m.code = nil
}

// SetDomain sets the "domain" field.
func (m *TenantMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *TenantMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *TenantMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[tenant.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *TenantMutation) DomainCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *TenantMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, tenant.FieldDomain)
}

// SetType sets the "type" field.
func (m *TenantMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TenantMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TenantMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *TenantMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TenantMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TenantMutation) ResetStatus() {
	m.status = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *TenantMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *TenantMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *TenantMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[tenant.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *TenantMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *TenantMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, tenant.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	if m.code != nil {
		fields = append(fields, tenant.FieldCode)
	}
	if m.domain != nil {
		fields = append(fields, tenant.FieldDomain)
	}
	if m._type != nil {
		fields = append(fields, tenant.FieldType)
	}
	if m.status != nil {
		fields = append(fields, tenant.FieldStatus)
	}
	if m.expires_at != nil {
		fields = append(fields, tenant.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenant.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldName:
		return m.Name()
	case tenant.FieldCode:
		return m.Code()
	case tenant.FieldDomain:
		return m.Domain()
	case tenant.FieldType:
		return m.GetType()
	case tenant.FieldStatus:
		return m.Status()
	case tenant.FieldExpiresAt:
		return m.ExpiresAt()
	case tenant.FieldCreatedAt:
		return m.CreatedAt()
	case tenant.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldName:
		return m.OldName(ctx)
	case tenant.FieldCode:
		return m.OldCode(ctx)
	case tenant.FieldDomain:
		return m.OldDomain(ctx)
	case tenant.FieldType:
		return m.OldType(ctx)
	case tenant.FieldStatus:
		return m.OldStatus(ctx)
	case tenant.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case tenant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tenant.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case tenant.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case tenant.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case tenant.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tenant.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case tenant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenant.FieldDomain) {
		fields = append(fields, tenant.FieldDomain)
	}
	if m.FieldCleared(tenant.FieldExpiresAt) {
		fields = append(fields, tenant.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	switch name {
	case tenant.FieldDomain:
		m.ClearDomain()
		return nil
	case tenant.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldName:
		m.ResetName()
		return nil
	case tenant.FieldCode:
		m.ResetCode()
		return nil
	case tenant.FieldDomain:
		m.ResetDomain()
		return nil
	case tenant.FieldType:
		m.ResetType()
		return nil
	case tenant.FieldStatus:
		m.ResetStatus()
		return nil
	case tenant.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case tenant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// TicketMutation represents an operation that mutates the Ticket nodes in the graph.
type TicketMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	title                     *string
	description               *string
	status                    *string
	priority                  *string
	ticket_number             *string
	requester_id              *int
	addrequester_id           *int
	assignee_id               *int
	addassignee_id            *int
	tenant_id                 *int
	addtenant_id              *int
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	template                  *int
	clearedtemplate           bool
	category                  *int
	clearedcategory           bool
	tags                      map[int]struct{}
	removedtags               map[int]struct{}
	clearedtags               bool
	related_tickets           map[int]struct{}
	removedrelated_tickets    map[int]struct{}
	clearedrelated_tickets    bool
	parent_ticket             *int
	clearedparent_ticket      bool
	workflow_instances        map[int]struct{}
	removedworkflow_instances map[int]struct{}
	clearedworkflow_instances bool
	done                      bool
	oldValue                  func(context.Context) (*Ticket, error)
	predicates                []predicate.Ticket
}

var _ ent.Mutation = (*TicketMutation)(nil)

// ticketOption allows management of the mutation configuration using functional options.
type ticketOption func(*TicketMutation)

// newTicketMutation creates new mutation for the Ticket entity.
func newTicketMutation(c config, op Op, opts ...ticketOption) *TicketMutation {
	m := &TicketMutation{
		config:        c,
		op:            op,
		typ:           TypeTicket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketID sets the ID field of the mutation.
func withTicketID(id int) ticketOption {
	return func(m *TicketMutation) {
		var (
			err   error
			once  sync.Once
			value *Ticket
		)
		m.oldValue = func(ctx context.Context) (*Ticket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ticket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicket sets the old Ticket of the mutation.
func withTicket(node *Ticket) ticketOption {
	return func(m *TicketMutation) {
		m.oldValue = func(context.Context) (*Ticket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ticket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *TicketMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TicketMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TicketMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TicketMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TicketMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TicketMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ticket.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TicketMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ticket.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TicketMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ticket.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *TicketMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TicketMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TicketMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *TicketMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TicketMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *TicketMutation) ResetPriority() {
	m.priority = nil
}

// SetTicketNumber sets the "ticket_number" field.
func (m *TicketMutation) SetTicketNumber(s string) {
	m.ticket_number = &s
}

// TicketNumber returns the value of the "ticket_number" field in the mutation.
func (m *TicketMutation) TicketNumber() (r string, exists bool) {
	v := m.ticket_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketNumber returns the old "ticket_number" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldTicketNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketNumber: %w", err)
	}
	return oldValue.TicketNumber, nil
}

// ResetTicketNumber resets all changes to the "ticket_number" field.
func (m *TicketMutation) ResetTicketNumber() {
	m.ticket_number = nil
}

// SetRequesterID sets the "requester_id" field.
func (m *TicketMutation) SetRequesterID(i int) {
	m.requester_id = &i
	m.addrequester_id = nil
}

// RequesterID returns the value of the "requester_id" field in the mutation.
func (m *TicketMutation) RequesterID() (r int, exists bool) {
	v := m.requester_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequesterID returns the old "requester_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldRequesterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequesterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequesterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequesterID: %w", err)
	}
	return oldValue.RequesterID, nil
}

// AddRequesterID adds i to the "requester_id" field.
func (m *TicketMutation) AddRequesterID(i int) {
	if m.addrequester_id != nil {
		*m.addrequester_id += i
	} else {
		m.addrequester_id = &i
	}
}

// AddedRequesterID returns the value that was added to the "requester_id" field in this mutation.
func (m *TicketMutation) AddedRequesterID() (r int, exists bool) {
	v := m.addrequester_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequesterID resets all changes to the "requester_id" field.
func (m *TicketMutation) ResetRequesterID() {
	m.requester_id = nil
	m.addrequester_id = nil
}

// SetAssigneeID sets the "assignee_id" field.
func (m *TicketMutation) SetAssigneeID(i int) {
	m.assignee_id = &i
	m.addassignee_id = nil
}

// AssigneeID returns the value of the "assignee_id" field in the mutation.
func (m *TicketMutation) AssigneeID() (r int, exists bool) {
	v := m.assignee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeID returns the old "assignee_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldAssigneeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeID: %w", err)
	}
	return oldValue.AssigneeID, nil
}

// AddAssigneeID adds i to the "assignee_id" field.
func (m *TicketMutation) AddAssigneeID(i int) {
	if m.addassignee_id != nil {
		*m.addassignee_id += i
	} else {
		m.addassignee_id = &i
	}
}

// AddedAssigneeID returns the value that was added to the "assignee_id" field in this mutation.
func (m *TicketMutation) AddedAssigneeID() (r int, exists bool) {
	v := m.addassignee_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssigneeID clears the value of the "assignee_id" field.
func (m *TicketMutation) ClearAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	m.clearedFields[ticket.FieldAssigneeID] = struct{}{}
}

// AssigneeIDCleared returns if the "assignee_id" field was cleared in this mutation.
func (m *TicketMutation) AssigneeIDCleared() bool {
	_, ok := m.clearedFields[ticket.FieldAssigneeID]
	return ok
}

// ResetAssigneeID resets all changes to the "assignee_id" field.
func (m *TicketMutation) ResetAssigneeID() {
	m.assignee_id = nil
	m.addassignee_id = nil
	delete(m.clearedFields, ticket.FieldAssigneeID)
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TicketMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TicketMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetTemplateID sets the "template_id" field.
func (m *TicketMutation) SetTemplateID(i int) {
	m.template = &i
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *TicketMutation) TemplateID() (r int, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldTemplateID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ClearTemplateID clears the value of the "template_id" field.
func (m *TicketMutation) ClearTemplateID() {
	m.template = nil
	m.clearedFields[ticket.FieldTemplateID] = struct{}{}
}

// TemplateIDCleared returns if the "template_id" field was cleared in this mutation.
func (m *TicketMutation) TemplateIDCleared() bool {
	_, ok := m.clearedFields[ticket.FieldTemplateID]
	return ok
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *TicketMutation) ResetTemplateID() {
	m.template = nil
	delete(m.clearedFields, ticket.FieldTemplateID)
}

// SetCategoryID sets the "category_id" field.
func (m *TicketMutation) SetCategoryID(i int) {
	m.category = &i
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *TicketMutation) CategoryID() (r int, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *TicketMutation) ClearCategoryID() {
	m.category = nil
	m.clearedFields[ticket.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *TicketMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[ticket.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *TicketMutation) ResetCategoryID() {
	m.category = nil
	delete(m.clearedFields, ticket.FieldCategoryID)
}

// SetParentTicketID sets the "parent_ticket_id" field.
func (m *TicketMutation) SetParentTicketID(i int) {
	m.parent_ticket = &i
}

// ParentTicketID returns the value of the "parent_ticket_id" field in the mutation.
func (m *TicketMutation) ParentTicketID() (r int, exists bool) {
	v := m.parent_ticket
	if v == nil {
		return
	}
	return *v, true
}

// OldParentTicketID returns the old "parent_ticket_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldParentTicketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentTicketID: %w", err)
	}
	return oldValue.ParentTicketID, nil
}

// ClearParentTicketID clears the value of the "parent_ticket_id" field.
func (m *TicketMutation) ClearParentTicketID() {
	m.parent_ticket = nil
	m.clearedFields[ticket.FieldParentTicketID] = struct{}{}
}

// ParentTicketIDCleared returns if the "parent_ticket_id" field was cleared in this mutation.
func (m *TicketMutation) ParentTicketIDCleared() bool {
	_, ok := m.clearedFields[ticket.FieldParentTicketID]
	return ok
}

// ResetParentTicketID resets all changes to the "parent_ticket_id" field.
func (m *TicketMutation) ResetParentTicketID() {
	m.parent_ticket = nil
	delete(m.clearedFields, ticket.FieldParentTicketID)
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTemplate clears the "template" edge to the TicketTemplate entity.
func (m *TicketMutation) ClearTemplate() {
	m.clearedtemplate = true
	m.clearedFields[ticket.FieldTemplateID] = struct{}{}
}

// TemplateCleared reports if the "template" edge to the TicketTemplate entity was cleared.
func (m *TicketMutation) TemplateCleared() bool {
	return m.TemplateIDCleared() || m.clearedtemplate
}

// TemplateIDs returns the "template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) TemplateIDs() (ids []int) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate resets all changes to the "template" edge.
func (m *TicketMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// ClearCategory clears the "category" edge to the TicketCategory entity.
func (m *TicketMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[ticket.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the TicketCategory entity was cleared.
func (m *TicketMutation) CategoryCleared() bool {
	return m.CategoryIDCleared() || m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *TicketMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// AddTagIDs adds the "tags" edge to the TicketTag entity by ids.
func (m *TicketMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the TicketTag entity.
func (m *TicketMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the TicketTag entity was cleared.
func (m *TicketMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the TicketTag entity by IDs.
func (m *TicketMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the TicketTag entity.
func (m *TicketMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *TicketMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *TicketMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddRelatedTicketIDs adds the "related_tickets" edge to the Ticket entity by ids.
func (m *TicketMutation) AddRelatedTicketIDs(ids ...int) {
	if m.related_tickets == nil {
		m.related_tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.related_tickets[ids[i]] = struct{}{}
	}
}

// ClearRelatedTickets clears the "related_tickets" edge to the Ticket entity.
func (m *TicketMutation) ClearRelatedTickets() {
	m.clearedrelated_tickets = true
}

// RelatedTicketsCleared reports if the "related_tickets" edge to the Ticket entity was cleared.
func (m *TicketMutation) RelatedTicketsCleared() bool {
	return m.clearedrelated_tickets
}

// RemoveRelatedTicketIDs removes the "related_tickets" edge to the Ticket entity by IDs.
func (m *TicketMutation) RemoveRelatedTicketIDs(ids ...int) {
	if m.removedrelated_tickets == nil {
		m.removedrelated_tickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.related_tickets, ids[i])
		m.removedrelated_tickets[ids[i]] = struct{}{}
	}
}

// RemovedRelatedTickets returns the removed IDs of the "related_tickets" edge to the Ticket entity.
func (m *TicketMutation) RemovedRelatedTicketsIDs() (ids []int) {
	for id := range m.removedrelated_tickets {
		ids = append(ids, id)
	}
	return
}

// RelatedTicketsIDs returns the "related_tickets" edge IDs in the mutation.
func (m *TicketMutation) RelatedTicketsIDs() (ids []int) {
	for id := range m.related_tickets {
		ids = append(ids, id)
	}
	return
}

// ResetRelatedTickets resets all changes to the "related_tickets" edge.
func (m *TicketMutation) ResetRelatedTickets() {
	m.related_tickets = nil
	m.clearedrelated_tickets = false
	m.removedrelated_tickets = nil
}

// ClearParentTicket clears the "parent_ticket" edge to the Ticket entity.
func (m *TicketMutation) ClearParentTicket() {
	m.clearedparent_ticket = true
	m.clearedFields[ticket.FieldParentTicketID] = struct{}{}
}

// ParentTicketCleared reports if the "parent_ticket" edge to the Ticket entity was cleared.
func (m *TicketMutation) ParentTicketCleared() bool {
	return m.ParentTicketIDCleared() || m.clearedparent_ticket
}

// ParentTicketIDs returns the "parent_ticket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentTicketID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) ParentTicketIDs() (ids []int) {
	if id := m.parent_ticket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentTicket resets all changes to the "parent_ticket" edge.
func (m *TicketMutation) ResetParentTicket() {
	m.parent_ticket = nil
	m.clearedparent_ticket = false
}

// AddWorkflowInstanceIDs adds the "workflow_instances" edge to the WorkflowInstance entity by ids.
func (m *TicketMutation) AddWorkflowInstanceIDs(ids ...int) {
	if m.workflow_instances == nil {
		m.workflow_instances = make(map[int]struct{})
	}
	for i := range ids {
		m.workflow_instances[ids[i]] = struct{}{}
	}
}

// ClearWorkflowInstances clears the "workflow_instances" edge to the WorkflowInstance entity.
func (m *TicketMutation) ClearWorkflowInstances() {
	m.clearedworkflow_instances = true
}

// WorkflowInstancesCleared reports if the "workflow_instances" edge to the WorkflowInstance entity was cleared.
func (m *TicketMutation) WorkflowInstancesCleared() bool {
	return m.clearedworkflow_instances
}

// RemoveWorkflowInstanceIDs removes the "workflow_instances" edge to the WorkflowInstance entity by IDs.
func (m *TicketMutation) RemoveWorkflowInstanceIDs(ids ...int) {
	if m.removedworkflow_instances == nil {
		m.removedworkflow_instances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workflow_instances, ids[i])
		m.removedworkflow_instances[ids[i]] = struct{}{}
	}
}

// RemovedWorkflowInstances returns the removed IDs of the "workflow_instances" edge to the WorkflowInstance entity.
func (m *TicketMutation) RemovedWorkflowInstancesIDs() (ids []int) {
	for id := range m.removedworkflow_instances {
		ids = append(ids, id)
	}
	return
}

// WorkflowInstancesIDs returns the "workflow_instances" edge IDs in the mutation.
func (m *TicketMutation) WorkflowInstancesIDs() (ids []int) {
	for id := range m.workflow_instances {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflowInstances resets all changes to the "workflow_instances" edge.
func (m *TicketMutation) ResetWorkflowInstances() {
	m.workflow_instances = nil
	m.clearedworkflow_instances = false
	m.removedworkflow_instances = nil
}

// Where appends a list predicates to the TicketMutation builder.
func (m *TicketMutation) Where(ps ...predicate.Ticket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ticket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ticket).
func (m *TicketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.title != nil {
		fields = append(fields, ticket.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, ticket.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, ticket.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, ticket.FieldPriority)
	}
	if m.ticket_number != nil {
		fields = append(fields, ticket.FieldTicketNumber)
	}
	if m.requester_id != nil {
		fields = append(fields, ticket.FieldRequesterID)
	}
	if m.assignee_id != nil {
		fields = append(fields, ticket.FieldAssigneeID)
	}
	if m.tenant_id != nil {
		fields = append(fields, ticket.FieldTenantID)
	}
	if m.template != nil {
		fields = append(fields, ticket.FieldTemplateID)
	}
	if m.category != nil {
		fields = append(fields, ticket.FieldCategoryID)
	}
	if m.parent_ticket != nil {
		fields = append(fields, ticket.FieldParentTicketID)
	}
	if m.created_at != nil {
		fields = append(fields, ticket.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ticket.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldTitle:
		return m.Title()
	case ticket.FieldDescription:
		return m.Description()
	case ticket.FieldStatus:
		return m.Status()
	case ticket.FieldPriority:
		return m.Priority()
	case ticket.FieldTicketNumber:
		return m.TicketNumber()
	case ticket.FieldRequesterID:
		return m.RequesterID()
	case ticket.FieldAssigneeID:
		return m.AssigneeID()
	case ticket.FieldTenantID:
		return m.TenantID()
	case ticket.FieldTemplateID:
		return m.TemplateID()
	case ticket.FieldCategoryID:
		return m.CategoryID()
	case ticket.FieldParentTicketID:
		return m.ParentTicketID()
	case ticket.FieldCreatedAt:
		return m.CreatedAt()
	case ticket.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticket.FieldTitle:
		return m.OldTitle(ctx)
	case ticket.FieldDescription:
		return m.OldDescription(ctx)
	case ticket.FieldStatus:
		return m.OldStatus(ctx)
	case ticket.FieldPriority:
		return m.OldPriority(ctx)
	case ticket.FieldTicketNumber:
		return m.OldTicketNumber(ctx)
	case ticket.FieldRequesterID:
		return m.OldRequesterID(ctx)
	case ticket.FieldAssigneeID:
		return m.OldAssigneeID(ctx)
	case ticket.FieldTenantID:
		return m.OldTenantID(ctx)
	case ticket.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case ticket.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case ticket.FieldParentTicketID:
		return m.OldParentTicketID(ctx)
	case ticket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ticket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case ticket.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ticket.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ticket.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case ticket.FieldTicketNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketNumber(v)
		return nil
	case ticket.FieldRequesterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequesterID(v)
		return nil
	case ticket.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeID(v)
		return nil
	case ticket.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ticket.FieldTemplateID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case ticket.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case ticket.FieldParentTicketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentTicketID(v)
		return nil
	case ticket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketMutation) AddedFields() []string {
	var fields []string
	if m.addrequester_id != nil {
		fields = append(fields, ticket.FieldRequesterID)
	}
	if m.addassignee_id != nil {
		fields = append(fields, ticket.FieldAssigneeID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, ticket.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldRequesterID:
		return m.AddedRequesterID()
	case ticket.FieldAssigneeID:
		return m.AddedAssigneeID()
	case ticket.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldRequesterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequesterID(v)
		return nil
	case ticket.FieldAssigneeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssigneeID(v)
		return nil
	case ticket.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticket.FieldDescription) {
		fields = append(fields, ticket.FieldDescription)
	}
	if m.FieldCleared(ticket.FieldAssigneeID) {
		fields = append(fields, ticket.FieldAssigneeID)
	}
	if m.FieldCleared(ticket.FieldTemplateID) {
		fields = append(fields, ticket.FieldTemplateID)
	}
	if m.FieldCleared(ticket.FieldCategoryID) {
		fields = append(fields, ticket.FieldCategoryID)
	}
	if m.FieldCleared(ticket.FieldParentTicketID) {
		fields = append(fields, ticket.FieldParentTicketID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketMutation) ClearField(name string) error {
	switch name {
	case ticket.FieldDescription:
		m.ClearDescription()
		return nil
	case ticket.FieldAssigneeID:
		m.ClearAssigneeID()
		return nil
	case ticket.FieldTemplateID:
		m.ClearTemplateID()
		return nil
	case ticket.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case ticket.FieldParentTicketID:
		m.ClearParentTicketID()
		return nil
	}
	return fmt.Errorf("unknown Ticket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketMutation) ResetField(name string) error {
	switch name {
	case ticket.FieldTitle:
		m.ResetTitle()
		return nil
	case ticket.FieldDescription:
		m.ResetDescription()
		return nil
	case ticket.FieldStatus:
		m.ResetStatus()
		return nil
	case ticket.FieldPriority:
		m.ResetPriority()
		return nil
	case ticket.FieldTicketNumber:
		m.ResetTicketNumber()
		return nil
	case ticket.FieldRequesterID:
		m.ResetRequesterID()
		return nil
	case ticket.FieldAssigneeID:
		m.ResetAssigneeID()
		return nil
	case ticket.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ticket.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case ticket.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case ticket.FieldParentTicketID:
		m.ResetParentTicketID()
		return nil
	case ticket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.template != nil {
		edges = append(edges, ticket.EdgeTemplate)
	}
	if m.category != nil {
		edges = append(edges, ticket.EdgeCategory)
	}
	if m.tags != nil {
		edges = append(edges, ticket.EdgeTags)
	}
	if m.related_tickets != nil {
		edges = append(edges, ticket.EdgeRelatedTickets)
	}
	if m.parent_ticket != nil {
		edges = append(edges, ticket.EdgeParentTicket)
	}
	if m.workflow_instances != nil {
		edges = append(edges, ticket.EdgeWorkflowInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticket.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeRelatedTickets:
		ids := make([]ent.Value, 0, len(m.related_tickets))
		for id := range m.related_tickets {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeParentTicket:
		if id := m.parent_ticket; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeWorkflowInstances:
		ids := make([]ent.Value, 0, len(m.workflow_instances))
		for id := range m.workflow_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedtags != nil {
		edges = append(edges, ticket.EdgeTags)
	}
	if m.removedrelated_tickets != nil {
		edges = append(edges, ticket.EdgeRelatedTickets)
	}
	if m.removedworkflow_instances != nil {
		edges = append(edges, ticket.EdgeWorkflowInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ticket.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeRelatedTickets:
		ids := make([]ent.Value, 0, len(m.removedrelated_tickets))
		for id := range m.removedrelated_tickets {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeWorkflowInstances:
		ids := make([]ent.Value, 0, len(m.removedworkflow_instances))
		for id := range m.removedworkflow_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedtemplate {
		edges = append(edges, ticket.EdgeTemplate)
	}
	if m.clearedcategory {
		edges = append(edges, ticket.EdgeCategory)
	}
	if m.clearedtags {
		edges = append(edges, ticket.EdgeTags)
	}
	if m.clearedrelated_tickets {
		edges = append(edges, ticket.EdgeRelatedTickets)
	}
	if m.clearedparent_ticket {
		edges = append(edges, ticket.EdgeParentTicket)
	}
	if m.clearedworkflow_instances {
		edges = append(edges, ticket.EdgeWorkflowInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketMutation) EdgeCleared(name string) bool {
	switch name {
	case ticket.EdgeTemplate:
		return m.clearedtemplate
	case ticket.EdgeCategory:
		return m.clearedcategory
	case ticket.EdgeTags:
		return m.clearedtags
	case ticket.EdgeRelatedTickets:
		return m.clearedrelated_tickets
	case ticket.EdgeParentTicket:
		return m.clearedparent_ticket
	case ticket.EdgeWorkflowInstances:
		return m.clearedworkflow_instances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketMutation) ClearEdge(name string) error {
	switch name {
	case ticket.EdgeTemplate:
		m.ClearTemplate()
		return nil
	case ticket.EdgeCategory:
		m.ClearCategory()
		return nil
	case ticket.EdgeParentTicket:
		m.ClearParentTicket()
		return nil
	}
	return fmt.Errorf("unknown Ticket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketMutation) ResetEdge(name string) error {
	switch name {
	case ticket.EdgeTemplate:
		m.ResetTemplate()
		return nil
	case ticket.EdgeCategory:
		m.ResetCategory()
		return nil
	case ticket.EdgeTags:
		m.ResetTags()
		return nil
	case ticket.EdgeRelatedTickets:
		m.ResetRelatedTickets()
		return nil
	case ticket.EdgeParentTicket:
		m.ResetParentTicket()
		return nil
	case ticket.EdgeWorkflowInstances:
		m.ResetWorkflowInstances()
		return nil
	}
	return fmt.Errorf("unknown Ticket edge %s", name)
}

// TicketCategoryMutation represents an operation that mutates the TicketCategory nodes in the graph.
type TicketCategoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	description     *string
	code            *string
	level           *int
	addlevel        *int
	sort_order      *int
	addsort_order   *int
	is_active       *bool
	tenant_id       *int
	addtenant_id    *int
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	tickets         map[int]struct{}
	removedtickets  map[int]struct{}
	clearedtickets  bool
	children        map[int]struct{}
	removedchildren map[int]struct{}
	clearedchildren bool
	parent          *int
	clearedparent   bool
	done            bool
	oldValue        func(context.Context) (*TicketCategory, error)
	predicates      []predicate.TicketCategory
}

var _ ent.Mutation = (*TicketCategoryMutation)(nil)

// ticketcategoryOption allows management of the mutation configuration using functional options.
type ticketcategoryOption func(*TicketCategoryMutation)

// newTicketCategoryMutation creates new mutation for the TicketCategory entity.
func newTicketCategoryMutation(c config, op Op, opts ...ticketcategoryOption) *TicketCategoryMutation {
	m := &TicketCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTicketCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketCategoryID sets the ID field of the mutation.
func withTicketCategoryID(id int) ticketcategoryOption {
	return func(m *TicketCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TicketCategory
		)
		m.oldValue = func(ctx context.Context) (*TicketCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TicketCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicketCategory sets the old TicketCategory of the mutation.
func withTicketCategory(node *TicketCategory) ticketcategoryOption {
	return func(m *TicketCategoryMutation) {
		m.oldValue = func(context.Context) (*TicketCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TicketCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TicketCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TicketCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TicketCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TicketCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TicketCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TicketCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ticketcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TicketCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ticketcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TicketCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ticketcategory.FieldDescription)
}

// SetCode sets the "code" field.
func (m *TicketCategoryMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TicketCategoryMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TicketCategoryMutation) ResetCode() {
	m.code = nil
}

// SetParentID sets the "parent_id" field.
func (m *TicketCategoryMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *TicketCategoryMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *TicketCategoryMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[ticketcategory.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *TicketCategoryMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[ticketcategory.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *TicketCategoryMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, ticketcategory.FieldParentID)
}

// SetLevel sets the "level" field.
func (m *TicketCategoryMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *TicketCategoryMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *TicketCategoryMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *TicketCategoryMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *TicketCategoryMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *TicketCategoryMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *TicketCategoryMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *TicketCategoryMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *TicketCategoryMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *TicketCategoryMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetIsActive sets the "is_active" field.
func (m *TicketCategoryMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *TicketCategoryMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *TicketCategoryMutation) ResetIsActive() {
	m.is_active = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketCategoryMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketCategoryMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TicketCategoryMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TicketCategoryMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketCategoryMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TicketCategory entity.
// If the TicketCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by ids.
func (m *TicketCategoryMutation) AddTicketIDs(ids ...int) {
	if m.tickets == nil {
		m.tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.tickets[ids[i]] = struct{}{}
	}
}

// ClearTickets clears the "tickets" edge to the Ticket entity.
func (m *TicketCategoryMutation) ClearTickets() {
	m.clearedtickets = true
}

// TicketsCleared reports if the "tickets" edge to the Ticket entity was cleared.
func (m *TicketCategoryMutation) TicketsCleared() bool {
	return m.clearedtickets
}

// RemoveTicketIDs removes the "tickets" edge to the Ticket entity by IDs.
func (m *TicketCategoryMutation) RemoveTicketIDs(ids ...int) {
	if m.removedtickets == nil {
		m.removedtickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tickets, ids[i])
		m.removedtickets[ids[i]] = struct{}{}
	}
}

// RemovedTickets returns the removed IDs of the "tickets" edge to the Ticket entity.
func (m *TicketCategoryMutation) RemovedTicketsIDs() (ids []int) {
	for id := range m.removedtickets {
		ids = append(ids, id)
	}
	return
}

// TicketsIDs returns the "tickets" edge IDs in the mutation.
func (m *TicketCategoryMutation) TicketsIDs() (ids []int) {
	for id := range m.tickets {
		ids = append(ids, id)
	}
	return
}

// ResetTickets resets all changes to the "tickets" edge.
func (m *TicketCategoryMutation) ResetTickets() {
	m.tickets = nil
	m.clearedtickets = false
	m.removedtickets = nil
}

// AddChildIDs adds the "children" edge to the TicketCategory entity by ids.
func (m *TicketCategoryMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the TicketCategory entity.
func (m *TicketCategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the TicketCategory entity was cleared.
func (m *TicketCategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the TicketCategory entity by IDs.
func (m *TicketCategoryMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the TicketCategory entity.
func (m *TicketCategoryMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TicketCategoryMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *TicketCategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// ClearParent clears the "parent" edge to the TicketCategory entity.
func (m *TicketCategoryMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[ticketcategory.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the TicketCategory entity was cleared.
func (m *TicketCategoryMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TicketCategoryMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *TicketCategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the TicketCategoryMutation builder.
func (m *TicketCategoryMutation) Where(ps ...predicate.TicketCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TicketCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TicketCategory).
func (m *TicketCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketCategoryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, ticketcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, ticketcategory.FieldDescription)
	}
	if m.code != nil {
		fields = append(fields, ticketcategory.FieldCode)
	}
	if m.parent != nil {
		fields = append(fields, ticketcategory.FieldParentID)
	}
	if m.level != nil {
		fields = append(fields, ticketcategory.FieldLevel)
	}
	if m.sort_order != nil {
		fields = append(fields, ticketcategory.FieldSortOrder)
	}
	if m.is_active != nil {
		fields = append(fields, ticketcategory.FieldIsActive)
	}
	if m.tenant_id != nil {
		fields = append(fields, ticketcategory.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, ticketcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ticketcategory.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticketcategory.FieldName:
		return m.Name()
	case ticketcategory.FieldDescription:
		return m.Description()
	case ticketcategory.FieldCode:
		return m.Code()
	case ticketcategory.FieldParentID:
		return m.ParentID()
	case ticketcategory.FieldLevel:
		return m.Level()
	case ticketcategory.FieldSortOrder:
		return m.SortOrder()
	case ticketcategory.FieldIsActive:
		return m.IsActive()
	case ticketcategory.FieldTenantID:
		return m.TenantID()
	case ticketcategory.FieldCreatedAt:
		return m.CreatedAt()
	case ticketcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticketcategory.FieldName:
		return m.OldName(ctx)
	case ticketcategory.FieldDescription:
		return m.OldDescription(ctx)
	case ticketcategory.FieldCode:
		return m.OldCode(ctx)
	case ticketcategory.FieldParentID:
		return m.OldParentID(ctx)
	case ticketcategory.FieldLevel:
		return m.OldLevel(ctx)
	case ticketcategory.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case ticketcategory.FieldIsActive:
		return m.OldIsActive(ctx)
	case ticketcategory.FieldTenantID:
		return m.OldTenantID(ctx)
	case ticketcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticketcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TicketCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticketcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ticketcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ticketcategory.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case ticketcategory.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case ticketcategory.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case ticketcategory.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case ticketcategory.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case ticketcategory.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ticketcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticketcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TicketCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, ticketcategory.FieldLevel)
	}
	if m.addsort_order != nil {
		fields = append(fields, ticketcategory.FieldSortOrder)
	}
	if m.addtenant_id != nil {
		fields = append(fields, ticketcategory.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ticketcategory.FieldLevel:
		return m.AddedLevel()
	case ticketcategory.FieldSortOrder:
		return m.AddedSortOrder()
	case ticketcategory.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ticketcategory.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case ticketcategory.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	case ticketcategory.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown TicketCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticketcategory.FieldDescription) {
		fields = append(fields, ticketcategory.FieldDescription)
	}
	if m.FieldCleared(ticketcategory.FieldParentID) {
		fields = append(fields, ticketcategory.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketCategoryMutation) ClearField(name string) error {
	switch name {
	case ticketcategory.FieldDescription:
		m.ClearDescription()
		return nil
	case ticketcategory.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown TicketCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketCategoryMutation) ResetField(name string) error {
	switch name {
	case ticketcategory.FieldName:
		m.ResetName()
		return nil
	case ticketcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case ticketcategory.FieldCode:
		m.ResetCode()
		return nil
	case ticketcategory.FieldParentID:
		m.ResetParentID()
		return nil
	case ticketcategory.FieldLevel:
		m.ResetLevel()
		return nil
	case ticketcategory.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case ticketcategory.FieldIsActive:
		m.ResetIsActive()
		return nil
	case ticketcategory.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ticketcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticketcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tickets != nil {
		edges = append(edges, ticketcategory.EdgeTickets)
	}
	if m.children != nil {
		edges = append(edges, ticketcategory.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, ticketcategory.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticketcategory.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.tickets))
		for id := range m.tickets {
			ids = append(ids, id)
		}
		return ids
	case ticketcategory.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case ticketcategory.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtickets != nil {
		edges = append(edges, ticketcategory.EdgeTickets)
	}
	if m.removedchildren != nil {
		edges = append(edges, ticketcategory.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ticketcategory.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.removedtickets))
		for id := range m.removedtickets {
			ids = append(ids, id)
		}
		return ids
	case ticketcategory.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtickets {
		edges = append(edges, ticketcategory.EdgeTickets)
	}
	if m.clearedchildren {
		edges = append(edges, ticketcategory.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, ticketcategory.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case ticketcategory.EdgeTickets:
		return m.clearedtickets
	case ticketcategory.EdgeChildren:
		return m.clearedchildren
	case ticketcategory.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketCategoryMutation) ClearEdge(name string) error {
	switch name {
	case ticketcategory.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown TicketCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketCategoryMutation) ResetEdge(name string) error {
	switch name {
	case ticketcategory.EdgeTickets:
		m.ResetTickets()
		return nil
	case ticketcategory.EdgeChildren:
		m.ResetChildren()
		return nil
	case ticketcategory.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown TicketCategory edge %s", name)
}

// TicketTagMutation represents an operation that mutates the TicketTag nodes in the graph.
type TicketTagMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	color          *string
	description    *string
	is_active      *bool
	tenant_id      *int
	addtenant_id   *int
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	tickets        map[int]struct{}
	removedtickets map[int]struct{}
	clearedtickets bool
	done           bool
	oldValue       func(context.Context) (*TicketTag, error)
	predicates     []predicate.TicketTag
}

var _ ent.Mutation = (*TicketTagMutation)(nil)

// tickettagOption allows management of the mutation configuration using functional options.
type tickettagOption func(*TicketTagMutation)

// newTicketTagMutation creates new mutation for the TicketTag entity.
func newTicketTagMutation(c config, op Op, opts ...tickettagOption) *TicketTagMutation {
	m := &TicketTagMutation{
		config:        c,
		op:            op,
		typ:           TypeTicketTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketTagID sets the ID field of the mutation.
func withTicketTagID(id int) tickettagOption {
	return func(m *TicketTagMutation) {
		var (
			err   error
			once  sync.Once
			value *TicketTag
		)
		m.oldValue = func(ctx context.Context) (*TicketTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TicketTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicketTag sets the old TicketTag of the mutation.
func withTicketTag(node *TicketTag) tickettagOption {
	return func(m *TicketTagMutation) {
		m.oldValue = func(context.Context) (*TicketTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketTagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketTagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TicketTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TicketTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TicketTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TicketTag entity.
// If the TicketTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TicketTagMutation) ResetName() {
	m.name = nil
}

// SetColor sets the "color" field.
func (m *TicketTagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *TicketTagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the TicketTag entity.
// If the TicketTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *TicketTagMutation) ResetColor() {
	m.color = nil
}

// SetDescription sets the "description" field.
func (m *TicketTagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TicketTagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TicketTag entity.
// If the TicketTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TicketTagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tickettag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TicketTagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tickettag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TicketTagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tickettag.FieldDescription)
}

// SetIsActive sets the "is_active" field.
func (m *TicketTagMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *TicketTagMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the TicketTag entity.
// If the TicketTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTagMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *TicketTagMutation) ResetIsActive() {
	m.is_active = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketTagMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketTagMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TicketTag entity.
// If the TicketTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTagMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TicketTagMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TicketTagMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketTagMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TicketTag entity.
// If the TicketTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TicketTag entity.
// If the TicketTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by ids.
func (m *TicketTagMutation) AddTicketIDs(ids ...int) {
	if m.tickets == nil {
		m.tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.tickets[ids[i]] = struct{}{}
	}
}

// ClearTickets clears the "tickets" edge to the Ticket entity.
func (m *TicketTagMutation) ClearTickets() {
	m.clearedtickets = true
}

// TicketsCleared reports if the "tickets" edge to the Ticket entity was cleared.
func (m *TicketTagMutation) TicketsCleared() bool {
	return m.clearedtickets
}

// RemoveTicketIDs removes the "tickets" edge to the Ticket entity by IDs.
func (m *TicketTagMutation) RemoveTicketIDs(ids ...int) {
	if m.removedtickets == nil {
		m.removedtickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tickets, ids[i])
		m.removedtickets[ids[i]] = struct{}{}
	}
}

// RemovedTickets returns the removed IDs of the "tickets" edge to the Ticket entity.
func (m *TicketTagMutation) RemovedTicketsIDs() (ids []int) {
	for id := range m.removedtickets {
		ids = append(ids, id)
	}
	return
}

// TicketsIDs returns the "tickets" edge IDs in the mutation.
func (m *TicketTagMutation) TicketsIDs() (ids []int) {
	for id := range m.tickets {
		ids = append(ids, id)
	}
	return
}

// ResetTickets resets all changes to the "tickets" edge.
func (m *TicketTagMutation) ResetTickets() {
	m.tickets = nil
	m.clearedtickets = false
	m.removedtickets = nil
}

// Where appends a list predicates to the TicketTagMutation builder.
func (m *TicketTagMutation) Where(ps ...predicate.TicketTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TicketTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TicketTag).
func (m *TicketTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketTagMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, tickettag.FieldName)
	}
	if m.color != nil {
		fields = append(fields, tickettag.FieldColor)
	}
	if m.description != nil {
		fields = append(fields, tickettag.FieldDescription)
	}
	if m.is_active != nil {
		fields = append(fields, tickettag.FieldIsActive)
	}
	if m.tenant_id != nil {
		fields = append(fields, tickettag.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, tickettag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tickettag.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tickettag.FieldName:
		return m.Name()
	case tickettag.FieldColor:
		return m.Color()
	case tickettag.FieldDescription:
		return m.Description()
	case tickettag.FieldIsActive:
		return m.IsActive()
	case tickettag.FieldTenantID:
		return m.TenantID()
	case tickettag.FieldCreatedAt:
		return m.CreatedAt()
	case tickettag.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tickettag.FieldName:
		return m.OldName(ctx)
	case tickettag.FieldColor:
		return m.OldColor(ctx)
	case tickettag.FieldDescription:
		return m.OldDescription(ctx)
	case tickettag.FieldIsActive:
		return m.OldIsActive(ctx)
	case tickettag.FieldTenantID:
		return m.OldTenantID(ctx)
	case tickettag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tickettag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TicketTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tickettag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tickettag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case tickettag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tickettag.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case tickettag.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case tickettag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tickettag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TicketTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketTagMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, tickettag.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tickettag.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tickettag.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown TicketTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tickettag.FieldDescription) {
		fields = append(fields, tickettag.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketTagMutation) ClearField(name string) error {
	switch name {
	case tickettag.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown TicketTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketTagMutation) ResetField(name string) error {
	switch name {
	case tickettag.FieldName:
		m.ResetName()
		return nil
	case tickettag.FieldColor:
		m.ResetColor()
		return nil
	case tickettag.FieldDescription:
		m.ResetDescription()
		return nil
	case tickettag.FieldIsActive:
		m.ResetIsActive()
		return nil
	case tickettag.FieldTenantID:
		m.ResetTenantID()
		return nil
	case tickettag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tickettag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tickets != nil {
		edges = append(edges, tickettag.EdgeTickets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tickettag.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.tickets))
		for id := range m.tickets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtickets != nil {
		edges = append(edges, tickettag.EdgeTickets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tickettag.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.removedtickets))
		for id := range m.removedtickets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtickets {
		edges = append(edges, tickettag.EdgeTickets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketTagMutation) EdgeCleared(name string) bool {
	switch name {
	case tickettag.EdgeTickets:
		return m.clearedtickets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TicketTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketTagMutation) ResetEdge(name string) error {
	switch name {
	case tickettag.EdgeTickets:
		m.ResetTickets()
		return nil
	}
	return fmt.Errorf("unknown TicketTag edge %s", name)
}

// TicketTemplateMutation represents an operation that mutates the TicketTemplate nodes in the graph.
type TicketTemplateMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	description          *string
	category             *string
	priority             *string
	form_fields          *[]uint8
	appendform_fields    []uint8
	workflow_steps       *[]uint8
	appendworkflow_steps []uint8
	is_active            *bool
	tenant_id            *int
	addtenant_id         *int
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	tickets              map[int]struct{}
	removedtickets       map[int]struct{}
	clearedtickets       bool
	done                 bool
	oldValue             func(context.Context) (*TicketTemplate, error)
	predicates           []predicate.TicketTemplate
}

var _ ent.Mutation = (*TicketTemplateMutation)(nil)

// tickettemplateOption allows management of the mutation configuration using functional options.
type tickettemplateOption func(*TicketTemplateMutation)

// newTicketTemplateMutation creates new mutation for the TicketTemplate entity.
func newTicketTemplateMutation(c config, op Op, opts ...tickettemplateOption) *TicketTemplateMutation {
	m := &TicketTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeTicketTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketTemplateID sets the ID field of the mutation.
func withTicketTemplateID(id int) tickettemplateOption {
	return func(m *TicketTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *TicketTemplate
		)
		m.oldValue = func(ctx context.Context) (*TicketTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TicketTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicketTemplate sets the old TicketTemplate of the mutation.
func withTicketTemplate(node *TicketTemplate) tickettemplateOption {
	return func(m *TicketTemplateMutation) {
		m.oldValue = func(context.Context) (*TicketTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketTemplateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketTemplateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TicketTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TicketTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TicketTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TicketTemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TicketTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TicketTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TicketTemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tickettemplate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TicketTemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tickettemplate.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TicketTemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tickettemplate.FieldDescription)
}

// SetCategory sets the "category" field.
func (m *TicketTemplateMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *TicketTemplateMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *TicketTemplateMutation) ResetCategory() {
	m.category = nil
}

// SetPriority sets the "priority" field.
func (m *TicketTemplateMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TicketTemplateMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *TicketTemplateMutation) ResetPriority() {
	m.priority = nil
}

// SetFormFields sets the "form_fields" field.
func (m *TicketTemplateMutation) SetFormFields(u []uint8) {
	m.form_fields = &u
	m.appendform_fields = nil
}

// FormFields returns the value of the "form_fields" field in the mutation.
func (m *TicketTemplateMutation) FormFields() (r []uint8, exists bool) {
	v := m.form_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldFormFields returns the old "form_fields" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldFormFields(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormFields: %w", err)
	}
	return oldValue.FormFields, nil
}

// AppendFormFields adds u to the "form_fields" field.
func (m *TicketTemplateMutation) AppendFormFields(u []uint8) {
	m.appendform_fields = append(m.appendform_fields, u...)
}

// AppendedFormFields returns the list of values that were appended to the "form_fields" field in this mutation.
func (m *TicketTemplateMutation) AppendedFormFields() ([]uint8, bool) {
	if len(m.appendform_fields) == 0 {
		return nil, false
	}
	return m.appendform_fields, true
}

// ClearFormFields clears the value of the "form_fields" field.
func (m *TicketTemplateMutation) ClearFormFields() {
	m.form_fields = nil
	m.appendform_fields = nil
	m.clearedFields[tickettemplate.FieldFormFields] = struct{}{}
}

// FormFieldsCleared returns if the "form_fields" field was cleared in this mutation.
func (m *TicketTemplateMutation) FormFieldsCleared() bool {
	_, ok := m.clearedFields[tickettemplate.FieldFormFields]
	return ok
}

// ResetFormFields resets all changes to the "form_fields" field.
func (m *TicketTemplateMutation) ResetFormFields() {
	m.form_fields = nil
	m.appendform_fields = nil
	delete(m.clearedFields, tickettemplate.FieldFormFields)
}

// SetWorkflowSteps sets the "workflow_steps" field.
func (m *TicketTemplateMutation) SetWorkflowSteps(u []uint8) {
	m.workflow_steps = &u
	m.appendworkflow_steps = nil
}

// WorkflowSteps returns the value of the "workflow_steps" field in the mutation.
func (m *TicketTemplateMutation) WorkflowSteps() (r []uint8, exists bool) {
	v := m.workflow_steps
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowSteps returns the old "workflow_steps" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldWorkflowSteps(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowSteps: %w", err)
	}
	return oldValue.WorkflowSteps, nil
}

// AppendWorkflowSteps adds u to the "workflow_steps" field.
func (m *TicketTemplateMutation) AppendWorkflowSteps(u []uint8) {
	m.appendworkflow_steps = append(m.appendworkflow_steps, u...)
}

// AppendedWorkflowSteps returns the list of values that were appended to the "workflow_steps" field in this mutation.
func (m *TicketTemplateMutation) AppendedWorkflowSteps() ([]uint8, bool) {
	if len(m.appendworkflow_steps) == 0 {
		return nil, false
	}
	return m.appendworkflow_steps, true
}

// ClearWorkflowSteps clears the value of the "workflow_steps" field.
func (m *TicketTemplateMutation) ClearWorkflowSteps() {
	m.workflow_steps = nil
	m.appendworkflow_steps = nil
	m.clearedFields[tickettemplate.FieldWorkflowSteps] = struct{}{}
}

// WorkflowStepsCleared returns if the "workflow_steps" field was cleared in this mutation.
func (m *TicketTemplateMutation) WorkflowStepsCleared() bool {
	_, ok := m.clearedFields[tickettemplate.FieldWorkflowSteps]
	return ok
}

// ResetWorkflowSteps resets all changes to the "workflow_steps" field.
func (m *TicketTemplateMutation) ResetWorkflowSteps() {
	m.workflow_steps = nil
	m.appendworkflow_steps = nil
	delete(m.clearedFields, tickettemplate.FieldWorkflowSteps)
}

// SetIsActive sets the "is_active" field.
func (m *TicketTemplateMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *TicketTemplateMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *TicketTemplateMutation) ResetIsActive() {
	m.is_active = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketTemplateMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketTemplateMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TicketTemplateMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TicketTemplateMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketTemplateMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TicketTemplate entity.
// If the TicketTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by ids.
func (m *TicketTemplateMutation) AddTicketIDs(ids ...int) {
	if m.tickets == nil {
		m.tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.tickets[ids[i]] = struct{}{}
	}
}

// ClearTickets clears the "tickets" edge to the Ticket entity.
func (m *TicketTemplateMutation) ClearTickets() {
	m.clearedtickets = true
}

// TicketsCleared reports if the "tickets" edge to the Ticket entity was cleared.
func (m *TicketTemplateMutation) TicketsCleared() bool {
	return m.clearedtickets
}

// RemoveTicketIDs removes the "tickets" edge to the Ticket entity by IDs.
func (m *TicketTemplateMutation) RemoveTicketIDs(ids ...int) {
	if m.removedtickets == nil {
		m.removedtickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tickets, ids[i])
		m.removedtickets[ids[i]] = struct{}{}
	}
}

// RemovedTickets returns the removed IDs of the "tickets" edge to the Ticket entity.
func (m *TicketTemplateMutation) RemovedTicketsIDs() (ids []int) {
	for id := range m.removedtickets {
		ids = append(ids, id)
	}
	return
}

// TicketsIDs returns the "tickets" edge IDs in the mutation.
func (m *TicketTemplateMutation) TicketsIDs() (ids []int) {
	for id := range m.tickets {
		ids = append(ids, id)
	}
	return
}

// ResetTickets resets all changes to the "tickets" edge.
func (m *TicketTemplateMutation) ResetTickets() {
	m.tickets = nil
	m.clearedtickets = false
	m.removedtickets = nil
}

// Where appends a list predicates to the TicketTemplateMutation builder.
func (m *TicketTemplateMutation) Where(ps ...predicate.TicketTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TicketTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TicketTemplate).
func (m *TicketTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketTemplateMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, tickettemplate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tickettemplate.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, tickettemplate.FieldCategory)
	}
	if m.priority != nil {
		fields = append(fields, tickettemplate.FieldPriority)
	}
	if m.form_fields != nil {
		fields = append(fields, tickettemplate.FieldFormFields)
	}
	if m.workflow_steps != nil {
		fields = append(fields, tickettemplate.FieldWorkflowSteps)
	}
	if m.is_active != nil {
		fields = append(fields, tickettemplate.FieldIsActive)
	}
	if m.tenant_id != nil {
		fields = append(fields, tickettemplate.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, tickettemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tickettemplate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tickettemplate.FieldName:
		return m.Name()
	case tickettemplate.FieldDescription:
		return m.Description()
	case tickettemplate.FieldCategory:
		return m.Category()
	case tickettemplate.FieldPriority:
		return m.Priority()
	case tickettemplate.FieldFormFields:
		return m.FormFields()
	case tickettemplate.FieldWorkflowSteps:
		return m.WorkflowSteps()
	case tickettemplate.FieldIsActive:
		return m.IsActive()
	case tickettemplate.FieldTenantID:
		return m.TenantID()
	case tickettemplate.FieldCreatedAt:
		return m.CreatedAt()
	case tickettemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tickettemplate.FieldName:
		return m.OldName(ctx)
	case tickettemplate.FieldDescription:
		return m.OldDescription(ctx)
	case tickettemplate.FieldCategory:
		return m.OldCategory(ctx)
	case tickettemplate.FieldPriority:
		return m.OldPriority(ctx)
	case tickettemplate.FieldFormFields:
		return m.OldFormFields(ctx)
	case tickettemplate.FieldWorkflowSteps:
		return m.OldWorkflowSteps(ctx)
	case tickettemplate.FieldIsActive:
		return m.OldIsActive(ctx)
	case tickettemplate.FieldTenantID:
		return m.OldTenantID(ctx)
	case tickettemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tickettemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TicketTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tickettemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tickettemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tickettemplate.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case tickettemplate.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case tickettemplate.FieldFormFields:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormFields(v)
		return nil
	case tickettemplate.FieldWorkflowSteps:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowSteps(v)
		return nil
	case tickettemplate.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case tickettemplate.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case tickettemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tickettemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TicketTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketTemplateMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, tickettemplate.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tickettemplate.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tickettemplate.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown TicketTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tickettemplate.FieldDescription) {
		fields = append(fields, tickettemplate.FieldDescription)
	}
	if m.FieldCleared(tickettemplate.FieldFormFields) {
		fields = append(fields, tickettemplate.FieldFormFields)
	}
	if m.FieldCleared(tickettemplate.FieldWorkflowSteps) {
		fields = append(fields, tickettemplate.FieldWorkflowSteps)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketTemplateMutation) ClearField(name string) error {
	switch name {
	case tickettemplate.FieldDescription:
		m.ClearDescription()
		return nil
	case tickettemplate.FieldFormFields:
		m.ClearFormFields()
		return nil
	case tickettemplate.FieldWorkflowSteps:
		m.ClearWorkflowSteps()
		return nil
	}
	return fmt.Errorf("unknown TicketTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketTemplateMutation) ResetField(name string) error {
	switch name {
	case tickettemplate.FieldName:
		m.ResetName()
		return nil
	case tickettemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case tickettemplate.FieldCategory:
		m.ResetCategory()
		return nil
	case tickettemplate.FieldPriority:
		m.ResetPriority()
		return nil
	case tickettemplate.FieldFormFields:
		m.ResetFormFields()
		return nil
	case tickettemplate.FieldWorkflowSteps:
		m.ResetWorkflowSteps()
		return nil
	case tickettemplate.FieldIsActive:
		m.ResetIsActive()
		return nil
	case tickettemplate.FieldTenantID:
		m.ResetTenantID()
		return nil
	case tickettemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tickettemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tickets != nil {
		edges = append(edges, tickettemplate.EdgeTickets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tickettemplate.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.tickets))
		for id := range m.tickets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtickets != nil {
		edges = append(edges, tickettemplate.EdgeTickets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tickettemplate.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.removedtickets))
		for id := range m.removedtickets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtickets {
		edges = append(edges, tickettemplate.EdgeTickets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case tickettemplate.EdgeTickets:
		return m.clearedtickets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketTemplateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TicketTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketTemplateMutation) ResetEdge(name string) error {
	switch name {
	case tickettemplate.EdgeTickets:
		m.ResetTickets()
		return nil
	}
	return fmt.Errorf("unknown TicketTemplate edge %s", name)
}

// ToolInvocationMutation represents an operation that mutates the ToolInvocation nodes in the graph.
type ToolInvocationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	tool_name           *string
	arguments           *string
	result              *string
	status              *string
	request_id          *string
	needs_approval      *bool
	approval_state      *string
	approval_reason     *string
	approved_by         *int
	addapproved_by      *int
	approved_at         *time.Time
	dry_run             *bool
	error               *string
	clearedFields       map[string]struct{}
	conversation        *int
	clearedconversation bool
	done                bool
	oldValue            func(context.Context) (*ToolInvocation, error)
	predicates          []predicate.ToolInvocation
}

var _ ent.Mutation = (*ToolInvocationMutation)(nil)

// toolinvocationOption allows management of the mutation configuration using functional options.
type toolinvocationOption func(*ToolInvocationMutation)

// newToolInvocationMutation creates new mutation for the ToolInvocation entity.
func newToolInvocationMutation(c config, op Op, opts ...toolinvocationOption) *ToolInvocationMutation {
	m := &ToolInvocationMutation{
		config:        c,
		op:            op,
		typ:           TypeToolInvocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolInvocationID sets the ID field of the mutation.
func withToolInvocationID(id int) toolinvocationOption {
	return func(m *ToolInvocationMutation) {
		var (
			err   error
			once  sync.Once
			value *ToolInvocation
		)
		m.oldValue = func(ctx context.Context) (*ToolInvocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ToolInvocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToolInvocation sets the old ToolInvocation of the mutation.
func withToolInvocation(node *ToolInvocation) toolinvocationOption {
	return func(m *ToolInvocationMutation) {
		m.oldValue = func(context.Context) (*ToolInvocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolInvocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolInvocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToolInvocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToolInvocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ToolInvocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ToolInvocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ToolInvocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ToolInvocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetConversationID sets the "conversation_id" field.
func (m *ToolInvocationMutation) SetConversationID(i int) {
	m.conversation = &i
}

// ConversationID returns the value of the "conversation_id" field in the mutation.
func (m *ToolInvocationMutation) ConversationID() (r int, exists bool) {
	v := m.conversation
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationID returns the old "conversation_id" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldConversationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationID: %w", err)
	}
	return oldValue.ConversationID, nil
}

// ResetConversationID resets all changes to the "conversation_id" field.
func (m *ToolInvocationMutation) ResetConversationID() {
	m.conversation = nil
}

// SetToolName sets the "tool_name" field.
func (m *ToolInvocationMutation) SetToolName(s string) {
	m.tool_name = &s
}

// ToolName returns the value of the "tool_name" field in the mutation.
func (m *ToolInvocationMutation) ToolName() (r string, exists bool) {
	v := m.tool_name
	if v == nil {
		return
	}
	return *v, true
}

// OldToolName returns the old "tool_name" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldToolName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToolName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToolName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolName: %w", err)
	}
	return oldValue.ToolName, nil
}

// ResetToolName resets all changes to the "tool_name" field.
func (m *ToolInvocationMutation) ResetToolName() {
	m.tool_name = nil
}

// SetArguments sets the "arguments" field.
func (m *ToolInvocationMutation) SetArguments(s string) {
	m.arguments = &s
}

// Arguments returns the value of the "arguments" field in the mutation.
func (m *ToolInvocationMutation) Arguments() (r string, exists bool) {
	v := m.arguments
	if v == nil {
		return
	}
	return *v, true
}

// OldArguments returns the old "arguments" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldArguments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArguments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArguments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArguments: %w", err)
	}
	return oldValue.Arguments, nil
}

// ResetArguments resets all changes to the "arguments" field.
func (m *ToolInvocationMutation) ResetArguments() {
	m.arguments = nil
}

// SetResult sets the "result" field.
func (m *ToolInvocationMutation) SetResult(s string) {
	m.result = &s
}

// Result returns the value of the "result" field in the mutation.
func (m *ToolInvocationMutation) Result() (r string, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldResult(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ClearResult clears the value of the "result" field.
func (m *ToolInvocationMutation) ClearResult() {
	m.result = nil
	m.clearedFields[toolinvocation.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *ToolInvocationMutation) ResultCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *ToolInvocationMutation) ResetResult() {
	m.result = nil
	delete(m.clearedFields, toolinvocation.FieldResult)
}

// SetStatus sets the "status" field.
func (m *ToolInvocationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ToolInvocationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ToolInvocationMutation) ResetStatus() {
	m.status = nil
}

// SetRequestID sets the "request_id" field.
func (m *ToolInvocationMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *ToolInvocationMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *ToolInvocationMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[toolinvocation.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *ToolInvocationMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *ToolInvocationMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, toolinvocation.FieldRequestID)
}

// SetNeedsApproval sets the "needs_approval" field.
func (m *ToolInvocationMutation) SetNeedsApproval(b bool) {
	m.needs_approval = &b
}

// NeedsApproval returns the value of the "needs_approval" field in the mutation.
func (m *ToolInvocationMutation) NeedsApproval() (r bool, exists bool) {
	v := m.needs_approval
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedsApproval returns the old "needs_approval" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldNeedsApproval(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNeedsApproval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNeedsApproval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedsApproval: %w", err)
	}
	return oldValue.NeedsApproval, nil
}

// ResetNeedsApproval resets all changes to the "needs_approval" field.
func (m *ToolInvocationMutation) ResetNeedsApproval() {
	m.needs_approval = nil
}

// SetApprovalState sets the "approval_state" field.
func (m *ToolInvocationMutation) SetApprovalState(s string) {
	m.approval_state = &s
}

// ApprovalState returns the value of the "approval_state" field in the mutation.
func (m *ToolInvocationMutation) ApprovalState() (r string, exists bool) {
	v := m.approval_state
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalState returns the old "approval_state" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldApprovalState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalState: %w", err)
	}
	return oldValue.ApprovalState, nil
}

// ResetApprovalState resets all changes to the "approval_state" field.
func (m *ToolInvocationMutation) ResetApprovalState() {
	m.approval_state = nil
}

// SetApprovalReason sets the "approval_reason" field.
func (m *ToolInvocationMutation) SetApprovalReason(s string) {
	m.approval_reason = &s
}

// ApprovalReason returns the value of the "approval_reason" field in the mutation.
func (m *ToolInvocationMutation) ApprovalReason() (r string, exists bool) {
	v := m.approval_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalReason returns the old "approval_reason" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldApprovalReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalReason: %w", err)
	}
	return oldValue.ApprovalReason, nil
}

// ResetApprovalReason resets all changes to the "approval_reason" field.
func (m *ToolInvocationMutation) ResetApprovalReason() {
	m.approval_reason = nil
}

// SetApprovedBy sets the "approved_by" field.
func (m *ToolInvocationMutation) SetApprovedBy(i int) {
	m.approved_by = &i
	m.addapproved_by = nil
}

// ApprovedBy returns the value of the "approved_by" field in the mutation.
func (m *ToolInvocationMutation) ApprovedBy() (r int, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedBy returns the old "approved_by" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldApprovedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedBy: %w", err)
	}
	return oldValue.ApprovedBy, nil
}

// AddApprovedBy adds i to the "approved_by" field.
func (m *ToolInvocationMutation) AddApprovedBy(i int) {
	if m.addapproved_by != nil {
		*m.addapproved_by += i
	} else {
		m.addapproved_by = &i
	}
}

// AddedApprovedBy returns the value that was added to the "approved_by" field in this mutation.
func (m *ToolInvocationMutation) AddedApprovedBy() (r int, exists bool) {
	v := m.addapproved_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearApprovedBy clears the value of the "approved_by" field.
func (m *ToolInvocationMutation) ClearApprovedBy() {
	m.approved_by = nil
	m.addapproved_by = nil
	m.clearedFields[toolinvocation.FieldApprovedBy] = struct{}{}
}

// ApprovedByCleared returns if the "approved_by" field was cleared in this mutation.
func (m *ToolInvocationMutation) ApprovedByCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldApprovedBy]
	return ok
}

// ResetApprovedBy resets all changes to the "approved_by" field.
func (m *ToolInvocationMutation) ResetApprovedBy() {
	m.approved_by = nil
	m.addapproved_by = nil
	delete(m.clearedFields, toolinvocation.FieldApprovedBy)
}

// SetApprovedAt sets the "approved_at" field.
func (m *ToolInvocationMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *ToolInvocationMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldApprovedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *ToolInvocationMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[toolinvocation.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *ToolInvocationMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *ToolInvocationMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, toolinvocation.FieldApprovedAt)
}

// SetDryRun sets the "dry_run" field.
func (m *ToolInvocationMutation) SetDryRun(b bool) {
	m.dry_run = &b
}

// DryRun returns the value of the "dry_run" field in the mutation.
func (m *ToolInvocationMutation) DryRun() (r bool, exists bool) {
	v := m.dry_run
	if v == nil {
		return
	}
	return *v, true
}

// OldDryRun returns the old "dry_run" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldDryRun(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDryRun is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDryRun requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDryRun: %w", err)
	}
	return oldValue.DryRun, nil
}

// ResetDryRun resets all changes to the "dry_run" field.
func (m *ToolInvocationMutation) ResetDryRun() {
	m.dry_run = nil
}

// SetError sets the "error" field.
func (m *ToolInvocationMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *ToolInvocationMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldError(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *ToolInvocationMutation) ClearError() {
	m.error = nil
	m.clearedFields[toolinvocation.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *ToolInvocationMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *ToolInvocationMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, toolinvocation.FieldError)
}

// ClearConversation clears the "conversation" edge to the Conversation entity.
func (m *ToolInvocationMutation) ClearConversation() {
	m.clearedconversation = true
	m.clearedFields[toolinvocation.FieldConversationID] = struct{}{}
}

// ConversationCleared reports if the "conversation" edge to the Conversation entity was cleared.
func (m *ToolInvocationMutation) ConversationCleared() bool {
	return m.clearedconversation
}

// ConversationIDs returns the "conversation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConversationID instead. It exists only for internal usage by the builders.
func (m *ToolInvocationMutation) ConversationIDs() (ids []int) {
	if id := m.conversation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConversation resets all changes to the "conversation" edge.
func (m *ToolInvocationMutation) ResetConversation() {
	m.conversation = nil
	m.clearedconversation = false
}

// Where appends a list predicates to the ToolInvocationMutation builder.
func (m *ToolInvocationMutation) Where(ps ...predicate.ToolInvocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToolInvocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToolInvocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ToolInvocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToolInvocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToolInvocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ToolInvocation).
func (m *ToolInvocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToolInvocationMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, toolinvocation.FieldCreatedAt)
	}
	if m.conversation != nil {
		fields = append(fields, toolinvocation.FieldConversationID)
	}
	if m.tool_name != nil {
		fields = append(fields, toolinvocation.FieldToolName)
	}
	if m.arguments != nil {
		fields = append(fields, toolinvocation.FieldArguments)
	}
	if m.result != nil {
		fields = append(fields, toolinvocation.FieldResult)
	}
	if m.status != nil {
		fields = append(fields, toolinvocation.FieldStatus)
	}
	if m.request_id != nil {
		fields = append(fields, toolinvocation.FieldRequestID)
	}
	if m.needs_approval != nil {
		fields = append(fields, toolinvocation.FieldNeedsApproval)
	}
	if m.approval_state != nil {
		fields = append(fields, toolinvocation.FieldApprovalState)
	}
	if m.approval_reason != nil {
		fields = append(fields, toolinvocation.FieldApprovalReason)
	}
	if m.approved_by != nil {
		fields = append(fields, toolinvocation.FieldApprovedBy)
	}
	if m.approved_at != nil {
		fields = append(fields, toolinvocation.FieldApprovedAt)
	}
	if m.dry_run != nil {
		fields = append(fields, toolinvocation.FieldDryRun)
	}
	if m.error != nil {
		fields = append(fields, toolinvocation.FieldError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToolInvocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case toolinvocation.FieldCreatedAt:
		return m.CreatedAt()
	case toolinvocation.FieldConversationID:
		return m.ConversationID()
	case toolinvocation.FieldToolName:
		return m.ToolName()
	case toolinvocation.FieldArguments:
		return m.Arguments()
	case toolinvocation.FieldResult:
		return m.Result()
	case toolinvocation.FieldStatus:
		return m.Status()
	case toolinvocation.FieldRequestID:
		return m.RequestID()
	case toolinvocation.FieldNeedsApproval:
		return m.NeedsApproval()
	case toolinvocation.FieldApprovalState:
		return m.ApprovalState()
	case toolinvocation.FieldApprovalReason:
		return m.ApprovalReason()
	case toolinvocation.FieldApprovedBy:
		return m.ApprovedBy()
	case toolinvocation.FieldApprovedAt:
		return m.ApprovedAt()
	case toolinvocation.FieldDryRun:
		return m.DryRun()
	case toolinvocation.FieldError:
		return m.Error()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToolInvocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case toolinvocation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case toolinvocation.FieldConversationID:
		return m.OldConversationID(ctx)
	case toolinvocation.FieldToolName:
		return m.OldToolName(ctx)
	case toolinvocation.FieldArguments:
		return m.OldArguments(ctx)
	case toolinvocation.FieldResult:
		return m.OldResult(ctx)
	case toolinvocation.FieldStatus:
		return m.OldStatus(ctx)
	case toolinvocation.FieldRequestID:
		return m.OldRequestID(ctx)
	case toolinvocation.FieldNeedsApproval:
		return m.OldNeedsApproval(ctx)
	case toolinvocation.FieldApprovalState:
		return m.OldApprovalState(ctx)
	case toolinvocation.FieldApprovalReason:
		return m.OldApprovalReason(ctx)
	case toolinvocation.FieldApprovedBy:
		return m.OldApprovedBy(ctx)
	case toolinvocation.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case toolinvocation.FieldDryRun:
		return m.OldDryRun(ctx)
	case toolinvocation.FieldError:
		return m.OldError(ctx)
	}
	return nil, fmt.Errorf("unknown ToolInvocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolInvocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case toolinvocation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case toolinvocation.FieldConversationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationID(v)
		return nil
	case toolinvocation.FieldToolName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolName(v)
		return nil
	case toolinvocation.FieldArguments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArguments(v)
		return nil
	case toolinvocation.FieldResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case toolinvocation.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case toolinvocation.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case toolinvocation.FieldNeedsApproval:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedsApproval(v)
		return nil
	case toolinvocation.FieldApprovalState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalState(v)
		return nil
	case toolinvocation.FieldApprovalReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalReason(v)
		return nil
	case toolinvocation.FieldApprovedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedBy(v)
		return nil
	case toolinvocation.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case toolinvocation.FieldDryRun:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDryRun(v)
		return nil
	case toolinvocation.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToolInvocationMutation) AddedFields() []string {
	var fields []string
	if m.addapproved_by != nil {
		fields = append(fields, toolinvocation.FieldApprovedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToolInvocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case toolinvocation.FieldApprovedBy:
		return m.AddedApprovedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolInvocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case toolinvocation.FieldApprovedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApprovedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToolInvocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(toolinvocation.FieldResult) {
		fields = append(fields, toolinvocation.FieldResult)
	}
	if m.FieldCleared(toolinvocation.FieldRequestID) {
		fields = append(fields, toolinvocation.FieldRequestID)
	}
	if m.FieldCleared(toolinvocation.FieldApprovedBy) {
		fields = append(fields, toolinvocation.FieldApprovedBy)
	}
	if m.FieldCleared(toolinvocation.FieldApprovedAt) {
		fields = append(fields, toolinvocation.FieldApprovedAt)
	}
	if m.FieldCleared(toolinvocation.FieldError) {
		fields = append(fields, toolinvocation.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToolInvocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolInvocationMutation) ClearField(name string) error {
	switch name {
	case toolinvocation.FieldResult:
		m.ClearResult()
		return nil
	case toolinvocation.FieldRequestID:
		m.ClearRequestID()
		return nil
	case toolinvocation.FieldApprovedBy:
		m.ClearApprovedBy()
		return nil
	case toolinvocation.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case toolinvocation.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToolInvocationMutation) ResetField(name string) error {
	switch name {
	case toolinvocation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case toolinvocation.FieldConversationID:
		m.ResetConversationID()
		return nil
	case toolinvocation.FieldToolName:
		m.ResetToolName()
		return nil
	case toolinvocation.FieldArguments:
		m.ResetArguments()
		return nil
	case toolinvocation.FieldResult:
		m.ResetResult()
		return nil
	case toolinvocation.FieldStatus:
		m.ResetStatus()
		return nil
	case toolinvocation.FieldRequestID:
		m.ResetRequestID()
		return nil
	case toolinvocation.FieldNeedsApproval:
		m.ResetNeedsApproval()
		return nil
	case toolinvocation.FieldApprovalState:
		m.ResetApprovalState()
		return nil
	case toolinvocation.FieldApprovalReason:
		m.ResetApprovalReason()
		return nil
	case toolinvocation.FieldApprovedBy:
		m.ResetApprovedBy()
		return nil
	case toolinvocation.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case toolinvocation.FieldDryRun:
		m.ResetDryRun()
		return nil
	case toolinvocation.FieldError:
		m.ResetError()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToolInvocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.conversation != nil {
		edges = append(edges, toolinvocation.EdgeConversation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToolInvocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case toolinvocation.EdgeConversation:
		if id := m.conversation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToolInvocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToolInvocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToolInvocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconversation {
		edges = append(edges, toolinvocation.EdgeConversation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToolInvocationMutation) EdgeCleared(name string) bool {
	switch name {
	case toolinvocation.EdgeConversation:
		return m.clearedconversation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToolInvocationMutation) ClearEdge(name string) error {
	switch name {
	case toolinvocation.EdgeConversation:
		m.ClearConversation()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToolInvocationMutation) ResetEdge(name string) error {
	switch name {
	case toolinvocation.EdgeConversation:
		m.ResetConversation()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	username      *string
	email         *string
	name          *string
	department    *string
	phone         *string
	password_hash *string
	active        *bool
	tenant_id     *int
	addtenant_id  *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetDepartment sets the "department" field.
func (m *UserMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the value of the "department" field in the mutation.
func (m *UserMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old "department" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ClearDepartment clears the value of the "department" field.
func (m *UserMutation) ClearDepartment() {
	m.department = nil
	m.clearedFields[user.FieldDepartment] = struct{}{}
}

// DepartmentCleared returns if the "department" field was cleared in this mutation.
func (m *UserMutation) DepartmentCleared() bool {
	_, ok := m.clearedFields[user.FieldDepartment]
	return ok
}

// ResetDepartment resets all changes to the "department" field.
func (m *UserMutation) ResetDepartment() {
	m.department = nil
	delete(m.clearedFields, user.FieldDepartment)
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *UserMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *UserMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *UserMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.department != nil {
		fields = append(fields, user.FieldDepartment)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	if m.tenant_id != nil {
		fields = append(fields, user.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldDepartment:
		return m.Department()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldActive:
		return m.Active()
	case user.FieldTenantID:
		return m.TenantID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldDepartment:
		return m.OldDepartment(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	case user.FieldTenantID:
		return m.OldTenantID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case user.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, user.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDepartment) {
		fields = append(fields, user.FieldDepartment)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDepartment:
		m.ClearDepartment()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldDepartment:
		m.ResetDepartment()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	case user.FieldTenantID:
		m.ResetTenantID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// WorkflowMutation represents an operation that mutates the Workflow nodes in the graph.
type WorkflowMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	description               *string
	_type                     *string
	definition                *[]uint8
	appenddefinition          []uint8
	version                   *string
	is_active                 *bool
	tenant_id                 *int
	addtenant_id              *int
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	workflow_instances        map[int]struct{}
	removedworkflow_instances map[int]struct{}
	clearedworkflow_instances bool
	done                      bool
	oldValue                  func(context.Context) (*Workflow, error)
	predicates                []predicate.Workflow
}

var _ ent.Mutation = (*WorkflowMutation)(nil)

// workflowOption allows management of the mutation configuration using functional options.
type workflowOption func(*WorkflowMutation)

// newWorkflowMutation creates new mutation for the Workflow entity.
func newWorkflowMutation(c config, op Op, opts ...workflowOption) *WorkflowMutation {
	m := &WorkflowMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowID sets the ID field of the mutation.
func withWorkflowID(id int) workflowOption {
	return func(m *WorkflowMutation) {
		var (
			err   error
			once  sync.Once
			value *Workflow
		)
		m.oldValue = func(ctx context.Context) (*Workflow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workflow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflow sets the old Workflow of the mutation.
func withWorkflow(node *Workflow) workflowOption {
	return func(m *WorkflowMutation) {
		m.oldValue = func(context.Context) (*Workflow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workflow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WorkflowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkflowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkflowMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *WorkflowMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkflowMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkflowMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workflow.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkflowMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workflow.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkflowMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workflow.FieldDescription)
}

// SetType sets the "type" field.
func (m *WorkflowMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *WorkflowMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *WorkflowMutation) ResetType() {
	m._type = nil
}

// SetDefinition sets the "definition" field.
func (m *WorkflowMutation) SetDefinition(u []uint8) {
	m.definition = &u
	m.appenddefinition = nil
}

// Definition returns the value of the "definition" field in the mutation.
func (m *WorkflowMutation) Definition() (r []uint8, exists bool) {
	v := m.definition
	if v == nil {
		return
	}
	return *v, true
}

// OldDefinition returns the old "definition" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldDefinition(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefinition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefinition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefinition: %w", err)
	}
	return oldValue.Definition, nil
}

// AppendDefinition adds u to the "definition" field.
func (m *WorkflowMutation) AppendDefinition(u []uint8) {
	m.appenddefinition = append(m.appenddefinition, u...)
}

// AppendedDefinition returns the list of values that were appended to the "definition" field in this mutation.
func (m *WorkflowMutation) AppendedDefinition() ([]uint8, bool) {
	if len(m.appenddefinition) == 0 {
		return nil, false
	}
	return m.appenddefinition, true
}

// ResetDefinition resets all changes to the "definition" field.
func (m *WorkflowMutation) ResetDefinition() {
	m.definition = nil
	m.appenddefinition = nil
}

// SetVersion sets the "version" field.
func (m *WorkflowMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *WorkflowMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *WorkflowMutation) ResetVersion() {
	m.version = nil
}

// SetIsActive sets the "is_active" field.
func (m *WorkflowMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *WorkflowMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *WorkflowMutation) ResetIsActive() {
	m.is_active = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *WorkflowMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *WorkflowMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *WorkflowMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *WorkflowMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *WorkflowMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddWorkflowInstanceIDs adds the "workflow_instances" edge to the WorkflowInstance entity by ids.
func (m *WorkflowMutation) AddWorkflowInstanceIDs(ids ...int) {
	if m.workflow_instances == nil {
		m.workflow_instances = make(map[int]struct{})
	}
	for i := range ids {
		m.workflow_instances[ids[i]] = struct{}{}
	}
}

// ClearWorkflowInstances clears the "workflow_instances" edge to the WorkflowInstance entity.
func (m *WorkflowMutation) ClearWorkflowInstances() {
	m.clearedworkflow_instances = true
}

// WorkflowInstancesCleared reports if the "workflow_instances" edge to the WorkflowInstance entity was cleared.
func (m *WorkflowMutation) WorkflowInstancesCleared() bool {
	return m.clearedworkflow_instances
}

// RemoveWorkflowInstanceIDs removes the "workflow_instances" edge to the WorkflowInstance entity by IDs.
func (m *WorkflowMutation) RemoveWorkflowInstanceIDs(ids ...int) {
	if m.removedworkflow_instances == nil {
		m.removedworkflow_instances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workflow_instances, ids[i])
		m.removedworkflow_instances[ids[i]] = struct{}{}
	}
}

// RemovedWorkflowInstances returns the removed IDs of the "workflow_instances" edge to the WorkflowInstance entity.
func (m *WorkflowMutation) RemovedWorkflowInstancesIDs() (ids []int) {
	for id := range m.removedworkflow_instances {
		ids = append(ids, id)
	}
	return
}

// WorkflowInstancesIDs returns the "workflow_instances" edge IDs in the mutation.
func (m *WorkflowMutation) WorkflowInstancesIDs() (ids []int) {
	for id := range m.workflow_instances {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflowInstances resets all changes to the "workflow_instances" edge.
func (m *WorkflowMutation) ResetWorkflowInstances() {
	m.workflow_instances = nil
	m.clearedworkflow_instances = false
	m.removedworkflow_instances = nil
}

// Where appends a list predicates to the WorkflowMutation builder.
func (m *WorkflowMutation) Where(ps ...predicate.Workflow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workflow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workflow).
func (m *WorkflowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, workflow.FieldName)
	}
	if m.description != nil {
		fields = append(fields, workflow.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, workflow.FieldType)
	}
	if m.definition != nil {
		fields = append(fields, workflow.FieldDefinition)
	}
	if m.version != nil {
		fields = append(fields, workflow.FieldVersion)
	}
	if m.is_active != nil {
		fields = append(fields, workflow.FieldIsActive)
	}
	if m.tenant_id != nil {
		fields = append(fields, workflow.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, workflow.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflow.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldName:
		return m.Name()
	case workflow.FieldDescription:
		return m.Description()
	case workflow.FieldType:
		return m.GetType()
	case workflow.FieldDefinition:
		return m.Definition()
	case workflow.FieldVersion:
		return m.Version()
	case workflow.FieldIsActive:
		return m.IsActive()
	case workflow.FieldTenantID:
		return m.TenantID()
	case workflow.FieldCreatedAt:
		return m.CreatedAt()
	case workflow.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflow.FieldName:
		return m.OldName(ctx)
	case workflow.FieldDescription:
		return m.OldDescription(ctx)
	case workflow.FieldType:
		return m.OldType(ctx)
	case workflow.FieldDefinition:
		return m.OldDefinition(ctx)
	case workflow.FieldVersion:
		return m.OldVersion(ctx)
	case workflow.FieldIsActive:
		return m.OldIsActive(ctx)
	case workflow.FieldTenantID:
		return m.OldTenantID(ctx)
	case workflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Workflow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workflow.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workflow.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case workflow.FieldDefinition:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefinition(v)
		return nil
	case workflow.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case workflow.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case workflow.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case workflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, workflow.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflow.FieldDescription) {
		fields = append(fields, workflow.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowMutation) ClearField(name string) error {
	switch name {
	case workflow.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Workflow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowMutation) ResetField(name string) error {
	switch name {
	case workflow.FieldName:
		m.ResetName()
		return nil
	case workflow.FieldDescription:
		m.ResetDescription()
		return nil
	case workflow.FieldType:
		m.ResetType()
		return nil
	case workflow.FieldDefinition:
		m.ResetDefinition()
		return nil
	case workflow.FieldVersion:
		m.ResetVersion()
		return nil
	case workflow.FieldIsActive:
		m.ResetIsActive()
		return nil
	case workflow.FieldTenantID:
		m.ResetTenantID()
		return nil
	case workflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflow_instances != nil {
		edges = append(edges, workflow.EdgeWorkflowInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeWorkflowInstances:
		ids := make([]ent.Value, 0, len(m.workflow_instances))
		for id := range m.workflow_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedworkflow_instances != nil {
		edges = append(edges, workflow.EdgeWorkflowInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeWorkflowInstances:
		ids := make([]ent.Value, 0, len(m.removedworkflow_instances))
		for id := range m.removedworkflow_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflow_instances {
		edges = append(edges, workflow.EdgeWorkflowInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowMutation) EdgeCleared(name string) bool {
	switch name {
	case workflow.EdgeWorkflowInstances:
		return m.clearedworkflow_instances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Workflow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowMutation) ResetEdge(name string) error {
	switch name {
	case workflow.EdgeWorkflowInstances:
		m.ResetWorkflowInstances()
		return nil
	}
	return fmt.Errorf("unknown Workflow edge %s", name)
}

// WorkflowInstanceMutation represents an operation that mutates the WorkflowInstance nodes in the graph.
type WorkflowInstanceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	status          *string
	current_step    *string
	context         *[]uint8
	appendcontext   []uint8
	entity_id       *int
	addentity_id    *int
	entity_type     *string
	tenant_id       *int
	addtenant_id    *int
	started_at      *time.Time
	completed_at    *time.Time
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	workflow        *int
	clearedworkflow bool
	done            bool
	oldValue        func(context.Context) (*WorkflowInstance, error)
	predicates      []predicate.WorkflowInstance
}

var _ ent.Mutation = (*WorkflowInstanceMutation)(nil)

// workflowinstanceOption allows management of the mutation configuration using functional options.
type workflowinstanceOption func(*WorkflowInstanceMutation)

// newWorkflowInstanceMutation creates new mutation for the WorkflowInstance entity.
func newWorkflowInstanceMutation(c config, op Op, opts ...workflowinstanceOption) *WorkflowInstanceMutation {
	m := &WorkflowInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowInstanceID sets the ID field of the mutation.
func withWorkflowInstanceID(id int) workflowinstanceOption {
	return func(m *WorkflowInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowInstance
		)
		m.oldValue = func(ctx context.Context) (*WorkflowInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowInstance sets the old WorkflowInstance of the mutation.
func withWorkflowInstance(node *WorkflowInstance) workflowinstanceOption {
	return func(m *WorkflowInstanceMutation) {
		m.oldValue = func(context.Context) (*WorkflowInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowInstanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowInstanceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *WorkflowInstanceMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkflowInstanceMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkflowInstanceMutation) ResetStatus() {
	m.status = nil
}

// SetCurrentStep sets the "current_step" field.
func (m *WorkflowInstanceMutation) SetCurrentStep(s string) {
	m.current_step = &s
}

// CurrentStep returns the value of the "current_step" field in the mutation.
func (m *WorkflowInstanceMutation) CurrentStep() (r string, exists bool) {
	v := m.current_step
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentStep returns the old "current_step" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldCurrentStep(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentStep: %w", err)
	}
	return oldValue.CurrentStep, nil
}

// ClearCurrentStep clears the value of the "current_step" field.
func (m *WorkflowInstanceMutation) ClearCurrentStep() {
	m.current_step = nil
	m.clearedFields[workflowinstance.FieldCurrentStep] = struct{}{}
}

// CurrentStepCleared returns if the "current_step" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) CurrentStepCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldCurrentStep]
	return ok
}

// ResetCurrentStep resets all changes to the "current_step" field.
func (m *WorkflowInstanceMutation) ResetCurrentStep() {
	m.current_step = nil
	delete(m.clearedFields, workflowinstance.FieldCurrentStep)
}

// SetContext sets the "context" field.
func (m *WorkflowInstanceMutation) SetContext(u []uint8) {
	m.context = &u
	m.appendcontext = nil
}

// Context returns the value of the "context" field in the mutation.
func (m *WorkflowInstanceMutation) Context() (r []uint8, exists bool) {
	v := m.context
	if v == nil {
		return
	}
	return *v, true
}

// OldContext returns the old "context" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldContext(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContext: %w", err)
	}
	return oldValue.Context, nil
}

// AppendContext adds u to the "context" field.
func (m *WorkflowInstanceMutation) AppendContext(u []uint8) {
	m.appendcontext = append(m.appendcontext, u...)
}

// AppendedContext returns the list of values that were appended to the "context" field in this mutation.
func (m *WorkflowInstanceMutation) AppendedContext() ([]uint8, bool) {
	if len(m.appendcontext) == 0 {
		return nil, false
	}
	return m.appendcontext, true
}

// ClearContext clears the value of the "context" field.
func (m *WorkflowInstanceMutation) ClearContext() {
	m.context = nil
	m.appendcontext = nil
	m.clearedFields[workflowinstance.FieldContext] = struct{}{}
}

// ContextCleared returns if the "context" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) ContextCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldContext]
	return ok
}

// ResetContext resets all changes to the "context" field.
func (m *WorkflowInstanceMutation) ResetContext() {
	m.context = nil
	m.appendcontext = nil
	delete(m.clearedFields, workflowinstance.FieldContext)
}

// SetWorkflowID sets the "workflow_id" field.
func (m *WorkflowInstanceMutation) SetWorkflowID(i int) {
	m.workflow = &i
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *WorkflowInstanceMutation) WorkflowID() (r int, exists bool) {
	v := m.workflow
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldWorkflowID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *WorkflowInstanceMutation) ResetWorkflowID() {
	m.workflow = nil
}

// SetEntityID sets the "entity_id" field.
func (m *WorkflowInstanceMutation) SetEntityID(i int) {
	m.entity_id = &i
	m.addentity_id = nil
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *WorkflowInstanceMutation) EntityID() (r int, exists bool) {
	v := m.entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldEntityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// AddEntityID adds i to the "entity_id" field.
func (m *WorkflowInstanceMutation) AddEntityID(i int) {
	if m.addentity_id != nil {
		*m.addentity_id += i
	} else {
		m.addentity_id = &i
	}
}

// AddedEntityID returns the value that was added to the "entity_id" field in this mutation.
func (m *WorkflowInstanceMutation) AddedEntityID() (r int, exists bool) {
	v := m.addentity_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *WorkflowInstanceMutation) ResetEntityID() {
	m.entity_id = nil
	m.addentity_id = nil
}

// SetEntityType sets the "entity_type" field.
func (m *WorkflowInstanceMutation) SetEntityType(s string) {
	m.entity_type = &s
}

// EntityType returns the value of the "entity_type" field in the mutation.
func (m *WorkflowInstanceMutation) EntityType() (r string, exists bool) {
	v := m.entity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityType returns the old "entity_type" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldEntityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityType: %w", err)
	}
	return oldValue.EntityType, nil
}

// ResetEntityType resets all changes to the "entity_type" field.
func (m *WorkflowInstanceMutation) ResetEntityType() {
	m.entity_type = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *WorkflowInstanceMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *WorkflowInstanceMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *WorkflowInstanceMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *WorkflowInstanceMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *WorkflowInstanceMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetStartedAt sets the "started_at" field.
func (m *WorkflowInstanceMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *WorkflowInstanceMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *WorkflowInstanceMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *WorkflowInstanceMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *WorkflowInstanceMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *WorkflowInstanceMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[workflowinstance.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *WorkflowInstanceMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, workflowinstance.FieldCompletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowInstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowInstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowInstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowInstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowInstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *WorkflowInstanceMutation) ClearWorkflow() {
	m.clearedworkflow = true
	m.clearedFields[workflowinstance.FieldWorkflowID] = struct{}{}
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *WorkflowInstanceMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *WorkflowInstanceMutation) WorkflowIDs() (ids []int) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *WorkflowInstanceMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// Where appends a list predicates to the WorkflowInstanceMutation builder.
func (m *WorkflowInstanceMutation) Where(ps ...predicate.WorkflowInstance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowInstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowInstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowInstance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowInstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowInstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowInstance).
func (m *WorkflowInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowInstanceMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.status != nil {
		fields = append(fields, workflowinstance.FieldStatus)
	}
	if m.current_step != nil {
		fields = append(fields, workflowinstance.FieldCurrentStep)
	}
	if m.context != nil {
		fields = append(fields, workflowinstance.FieldContext)
	}
	if m.workflow != nil {
		fields = append(fields, workflowinstance.FieldWorkflowID)
	}
	if m.entity_id != nil {
		fields = append(fields, workflowinstance.FieldEntityID)
	}
	if m.entity_type != nil {
		fields = append(fields, workflowinstance.FieldEntityType)
	}
	if m.tenant_id != nil {
		fields = append(fields, workflowinstance.FieldTenantID)
	}
	if m.started_at != nil {
		fields = append(fields, workflowinstance.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, workflowinstance.FieldCompletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, workflowinstance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflowinstance.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowinstance.FieldStatus:
		return m.Status()
	case workflowinstance.FieldCurrentStep:
		return m.CurrentStep()
	case workflowinstance.FieldContext:
		return m.Context()
	case workflowinstance.FieldWorkflowID:
		return m.WorkflowID()
	case workflowinstance.FieldEntityID:
		return m.EntityID()
	case workflowinstance.FieldEntityType:
		return m.EntityType()
	case workflowinstance.FieldTenantID:
		return m.TenantID()
	case workflowinstance.FieldStartedAt:
		return m.StartedAt()
	case workflowinstance.FieldCompletedAt:
		return m.CompletedAt()
	case workflowinstance.FieldCreatedAt:
		return m.CreatedAt()
	case workflowinstance.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowinstance.FieldStatus:
		return m.OldStatus(ctx)
	case workflowinstance.FieldCurrentStep:
		return m.OldCurrentStep(ctx)
	case workflowinstance.FieldContext:
		return m.OldContext(ctx)
	case workflowinstance.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case workflowinstance.FieldEntityID:
		return m.OldEntityID(ctx)
	case workflowinstance.FieldEntityType:
		return m.OldEntityType(ctx)
	case workflowinstance.FieldTenantID:
		return m.OldTenantID(ctx)
	case workflowinstance.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case workflowinstance.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case workflowinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflowinstance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowinstance.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workflowinstance.FieldCurrentStep:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentStep(v)
		return nil
	case workflowinstance.FieldContext:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContext(v)
		return nil
	case workflowinstance.FieldWorkflowID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case workflowinstance.FieldEntityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case workflowinstance.FieldEntityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityType(v)
		return nil
	case workflowinstance.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case workflowinstance.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case workflowinstance.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case workflowinstance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflowinstance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowInstanceMutation) AddedFields() []string {
	var fields []string
	if m.addentity_id != nil {
		fields = append(fields, workflowinstance.FieldEntityID)
	}
	if m.addtenant_id != nil {
		fields = append(fields, workflowinstance.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflowinstance.FieldEntityID:
		return m.AddedEntityID()
	case workflowinstance.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflowinstance.FieldEntityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntityID(v)
		return nil
	case workflowinstance.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowinstance.FieldCurrentStep) {
		fields = append(fields, workflowinstance.FieldCurrentStep)
	}
	if m.FieldCleared(workflowinstance.FieldContext) {
		fields = append(fields, workflowinstance.FieldContext)
	}
	if m.FieldCleared(workflowinstance.FieldCompletedAt) {
		fields = append(fields, workflowinstance.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowInstanceMutation) ClearField(name string) error {
	switch name {
	case workflowinstance.FieldCurrentStep:
		m.ClearCurrentStep()
		return nil
	case workflowinstance.FieldContext:
		m.ClearContext()
		return nil
	case workflowinstance.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowInstanceMutation) ResetField(name string) error {
	switch name {
	case workflowinstance.FieldStatus:
		m.ResetStatus()
		return nil
	case workflowinstance.FieldCurrentStep:
		m.ResetCurrentStep()
		return nil
	case workflowinstance.FieldContext:
		m.ResetContext()
		return nil
	case workflowinstance.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case workflowinstance.FieldEntityID:
		m.ResetEntityID()
		return nil
	case workflowinstance.FieldEntityType:
		m.ResetEntityType()
		return nil
	case workflowinstance.FieldTenantID:
		m.ResetTenantID()
		return nil
	case workflowinstance.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case workflowinstance.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case workflowinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflowinstance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflow != nil {
		edges = append(edges, workflowinstance.EdgeWorkflow)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowinstance.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowInstanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflow {
		edges = append(edges, workflowinstance.EdgeWorkflow)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowinstance.EdgeWorkflow:
		return m.clearedworkflow
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowInstanceMutation) ClearEdge(name string) error {
	switch name {
	case workflowinstance.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowInstanceMutation) ResetEdge(name string) error {
	switch name {
	case workflowinstance.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance edge %s", name)
}
