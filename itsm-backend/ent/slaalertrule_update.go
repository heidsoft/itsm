// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"itsm-backend/ent/predicate"
	"itsm-backend/ent/slaalerthistory"
	"itsm-backend/ent/slaalertrule"
	"itsm-backend/ent/sladefinition"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/dialect/sql/sqljson"
	"entgo.io/ent/schema/field"
)

// SLAAlertRuleUpdate is the builder for updating SLAAlertRule entities.
type SLAAlertRuleUpdate struct {
	config
	hooks    []Hook
	mutation *SLAAlertRuleMutation
}

// Where appends a list predicates to the SLAAlertRuleUpdate builder.
func (saru *SLAAlertRuleUpdate) Where(ps ...predicate.SLAAlertRule) *SLAAlertRuleUpdate {
	saru.mutation.Where(ps...)
	return saru
}

// SetName sets the "name" field.
func (saru *SLAAlertRuleUpdate) SetName(s string) *SLAAlertRuleUpdate {
	saru.mutation.SetName(s)
	return saru
}

// SetNillableName sets the "name" field if the given value is not nil.
func (saru *SLAAlertRuleUpdate) SetNillableName(s *string) *SLAAlertRuleUpdate {
	if s != nil {
		saru.SetName(*s)
	}
	return saru
}

// SetSLADefinitionID sets the "sla_definition_id" field.
func (saru *SLAAlertRuleUpdate) SetSLADefinitionID(i int) *SLAAlertRuleUpdate {
	saru.mutation.SetSLADefinitionID(i)
	return saru
}

// SetNillableSLADefinitionID sets the "sla_definition_id" field if the given value is not nil.
func (saru *SLAAlertRuleUpdate) SetNillableSLADefinitionID(i *int) *SLAAlertRuleUpdate {
	if i != nil {
		saru.SetSLADefinitionID(*i)
	}
	return saru
}

// SetAlertLevel sets the "alert_level" field.
func (saru *SLAAlertRuleUpdate) SetAlertLevel(s string) *SLAAlertRuleUpdate {
	saru.mutation.SetAlertLevel(s)
	return saru
}

// SetNillableAlertLevel sets the "alert_level" field if the given value is not nil.
func (saru *SLAAlertRuleUpdate) SetNillableAlertLevel(s *string) *SLAAlertRuleUpdate {
	if s != nil {
		saru.SetAlertLevel(*s)
	}
	return saru
}

// SetThresholdPercentage sets the "threshold_percentage" field.
func (saru *SLAAlertRuleUpdate) SetThresholdPercentage(i int) *SLAAlertRuleUpdate {
	saru.mutation.ResetThresholdPercentage()
	saru.mutation.SetThresholdPercentage(i)
	return saru
}

// SetNillableThresholdPercentage sets the "threshold_percentage" field if the given value is not nil.
func (saru *SLAAlertRuleUpdate) SetNillableThresholdPercentage(i *int) *SLAAlertRuleUpdate {
	if i != nil {
		saru.SetThresholdPercentage(*i)
	}
	return saru
}

// AddThresholdPercentage adds i to the "threshold_percentage" field.
func (saru *SLAAlertRuleUpdate) AddThresholdPercentage(i int) *SLAAlertRuleUpdate {
	saru.mutation.AddThresholdPercentage(i)
	return saru
}

// SetNotificationChannels sets the "notification_channels" field.
func (saru *SLAAlertRuleUpdate) SetNotificationChannels(s []string) *SLAAlertRuleUpdate {
	saru.mutation.SetNotificationChannels(s)
	return saru
}

// AppendNotificationChannels appends s to the "notification_channels" field.
func (saru *SLAAlertRuleUpdate) AppendNotificationChannels(s []string) *SLAAlertRuleUpdate {
	saru.mutation.AppendNotificationChannels(s)
	return saru
}

// SetEscalationEnabled sets the "escalation_enabled" field.
func (saru *SLAAlertRuleUpdate) SetEscalationEnabled(b bool) *SLAAlertRuleUpdate {
	saru.mutation.SetEscalationEnabled(b)
	return saru
}

// SetNillableEscalationEnabled sets the "escalation_enabled" field if the given value is not nil.
func (saru *SLAAlertRuleUpdate) SetNillableEscalationEnabled(b *bool) *SLAAlertRuleUpdate {
	if b != nil {
		saru.SetEscalationEnabled(*b)
	}
	return saru
}

// SetEscalationLevels sets the "escalation_levels" field.
func (saru *SLAAlertRuleUpdate) SetEscalationLevels(m []map[string]interface{}) *SLAAlertRuleUpdate {
	saru.mutation.SetEscalationLevels(m)
	return saru
}

// AppendEscalationLevels appends m to the "escalation_levels" field.
func (saru *SLAAlertRuleUpdate) AppendEscalationLevels(m []map[string]interface{}) *SLAAlertRuleUpdate {
	saru.mutation.AppendEscalationLevels(m)
	return saru
}

// ClearEscalationLevels clears the value of the "escalation_levels" field.
func (saru *SLAAlertRuleUpdate) ClearEscalationLevels() *SLAAlertRuleUpdate {
	saru.mutation.ClearEscalationLevels()
	return saru
}

// SetIsActive sets the "is_active" field.
func (saru *SLAAlertRuleUpdate) SetIsActive(b bool) *SLAAlertRuleUpdate {
	saru.mutation.SetIsActive(b)
	return saru
}

// SetNillableIsActive sets the "is_active" field if the given value is not nil.
func (saru *SLAAlertRuleUpdate) SetNillableIsActive(b *bool) *SLAAlertRuleUpdate {
	if b != nil {
		saru.SetIsActive(*b)
	}
	return saru
}

// SetTenantID sets the "tenant_id" field.
func (saru *SLAAlertRuleUpdate) SetTenantID(i int) *SLAAlertRuleUpdate {
	saru.mutation.ResetTenantID()
	saru.mutation.SetTenantID(i)
	return saru
}

// SetNillableTenantID sets the "tenant_id" field if the given value is not nil.
func (saru *SLAAlertRuleUpdate) SetNillableTenantID(i *int) *SLAAlertRuleUpdate {
	if i != nil {
		saru.SetTenantID(*i)
	}
	return saru
}

// AddTenantID adds i to the "tenant_id" field.
func (saru *SLAAlertRuleUpdate) AddTenantID(i int) *SLAAlertRuleUpdate {
	saru.mutation.AddTenantID(i)
	return saru
}

// SetCreatedAt sets the "created_at" field.
func (saru *SLAAlertRuleUpdate) SetCreatedAt(t time.Time) *SLAAlertRuleUpdate {
	saru.mutation.SetCreatedAt(t)
	return saru
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (saru *SLAAlertRuleUpdate) SetNillableCreatedAt(t *time.Time) *SLAAlertRuleUpdate {
	if t != nil {
		saru.SetCreatedAt(*t)
	}
	return saru
}

// SetUpdatedAt sets the "updated_at" field.
func (saru *SLAAlertRuleUpdate) SetUpdatedAt(t time.Time) *SLAAlertRuleUpdate {
	saru.mutation.SetUpdatedAt(t)
	return saru
}

// SetSLADefinition sets the "sla_definition" edge to the SLADefinition entity.
func (saru *SLAAlertRuleUpdate) SetSLADefinition(s *SLADefinition) *SLAAlertRuleUpdate {
	return saru.SetSLADefinitionID(s.ID)
}

// AddAlertHistoryIDs adds the "alert_history" edge to the SLAAlertHistory entity by IDs.
func (saru *SLAAlertRuleUpdate) AddAlertHistoryIDs(ids ...int) *SLAAlertRuleUpdate {
	saru.mutation.AddAlertHistoryIDs(ids...)
	return saru
}

// AddAlertHistory adds the "alert_history" edges to the SLAAlertHistory entity.
func (saru *SLAAlertRuleUpdate) AddAlertHistory(s ...*SLAAlertHistory) *SLAAlertRuleUpdate {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return saru.AddAlertHistoryIDs(ids...)
}

// Mutation returns the SLAAlertRuleMutation object of the builder.
func (saru *SLAAlertRuleUpdate) Mutation() *SLAAlertRuleMutation {
	return saru.mutation
}

// ClearSLADefinition clears the "sla_definition" edge to the SLADefinition entity.
func (saru *SLAAlertRuleUpdate) ClearSLADefinition() *SLAAlertRuleUpdate {
	saru.mutation.ClearSLADefinition()
	return saru
}

// ClearAlertHistory clears all "alert_history" edges to the SLAAlertHistory entity.
func (saru *SLAAlertRuleUpdate) ClearAlertHistory() *SLAAlertRuleUpdate {
	saru.mutation.ClearAlertHistory()
	return saru
}

// RemoveAlertHistoryIDs removes the "alert_history" edge to SLAAlertHistory entities by IDs.
func (saru *SLAAlertRuleUpdate) RemoveAlertHistoryIDs(ids ...int) *SLAAlertRuleUpdate {
	saru.mutation.RemoveAlertHistoryIDs(ids...)
	return saru
}

// RemoveAlertHistory removes "alert_history" edges to SLAAlertHistory entities.
func (saru *SLAAlertRuleUpdate) RemoveAlertHistory(s ...*SLAAlertHistory) *SLAAlertRuleUpdate {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return saru.RemoveAlertHistoryIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (saru *SLAAlertRuleUpdate) Save(ctx context.Context) (int, error) {
	saru.defaults()
	return withHooks(ctx, saru.sqlSave, saru.mutation, saru.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (saru *SLAAlertRuleUpdate) SaveX(ctx context.Context) int {
	affected, err := saru.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (saru *SLAAlertRuleUpdate) Exec(ctx context.Context) error {
	_, err := saru.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (saru *SLAAlertRuleUpdate) ExecX(ctx context.Context) {
	if err := saru.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (saru *SLAAlertRuleUpdate) defaults() {
	if _, ok := saru.mutation.UpdatedAt(); !ok {
		v := slaalertrule.UpdateDefaultUpdatedAt()
		saru.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (saru *SLAAlertRuleUpdate) check() error {
	if v, ok := saru.mutation.Name(); ok {
		if err := slaalertrule.NameValidator(v); err != nil {
			return &ValidationError{Name: "name", err: fmt.Errorf(`ent: validator failed for field "SLAAlertRule.name": %w`, err)}
		}
	}
	if v, ok := saru.mutation.SLADefinitionID(); ok {
		if err := slaalertrule.SLADefinitionIDValidator(v); err != nil {
			return &ValidationError{Name: "sla_definition_id", err: fmt.Errorf(`ent: validator failed for field "SLAAlertRule.sla_definition_id": %w`, err)}
		}
	}
	if v, ok := saru.mutation.ThresholdPercentage(); ok {
		if err := slaalertrule.ThresholdPercentageValidator(v); err != nil {
			return &ValidationError{Name: "threshold_percentage", err: fmt.Errorf(`ent: validator failed for field "SLAAlertRule.threshold_percentage": %w`, err)}
		}
	}
	if v, ok := saru.mutation.TenantID(); ok {
		if err := slaalertrule.TenantIDValidator(v); err != nil {
			return &ValidationError{Name: "tenant_id", err: fmt.Errorf(`ent: validator failed for field "SLAAlertRule.tenant_id": %w`, err)}
		}
	}
	if saru.mutation.SLADefinitionCleared() && len(saru.mutation.SLADefinitionIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "SLAAlertRule.sla_definition"`)
	}
	return nil
}

func (saru *SLAAlertRuleUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := saru.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(slaalertrule.Table, slaalertrule.Columns, sqlgraph.NewFieldSpec(slaalertrule.FieldID, field.TypeInt))
	if ps := saru.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := saru.mutation.Name(); ok {
		_spec.SetField(slaalertrule.FieldName, field.TypeString, value)
	}
	if value, ok := saru.mutation.AlertLevel(); ok {
		_spec.SetField(slaalertrule.FieldAlertLevel, field.TypeString, value)
	}
	if value, ok := saru.mutation.ThresholdPercentage(); ok {
		_spec.SetField(slaalertrule.FieldThresholdPercentage, field.TypeInt, value)
	}
	if value, ok := saru.mutation.AddedThresholdPercentage(); ok {
		_spec.AddField(slaalertrule.FieldThresholdPercentage, field.TypeInt, value)
	}
	if value, ok := saru.mutation.NotificationChannels(); ok {
		_spec.SetField(slaalertrule.FieldNotificationChannels, field.TypeJSON, value)
	}
	if value, ok := saru.mutation.AppendedNotificationChannels(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, slaalertrule.FieldNotificationChannels, value)
		})
	}
	if value, ok := saru.mutation.EscalationEnabled(); ok {
		_spec.SetField(slaalertrule.FieldEscalationEnabled, field.TypeBool, value)
	}
	if value, ok := saru.mutation.EscalationLevels(); ok {
		_spec.SetField(slaalertrule.FieldEscalationLevels, field.TypeJSON, value)
	}
	if value, ok := saru.mutation.AppendedEscalationLevels(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, slaalertrule.FieldEscalationLevels, value)
		})
	}
	if saru.mutation.EscalationLevelsCleared() {
		_spec.ClearField(slaalertrule.FieldEscalationLevels, field.TypeJSON)
	}
	if value, ok := saru.mutation.IsActive(); ok {
		_spec.SetField(slaalertrule.FieldIsActive, field.TypeBool, value)
	}
	if value, ok := saru.mutation.TenantID(); ok {
		_spec.SetField(slaalertrule.FieldTenantID, field.TypeInt, value)
	}
	if value, ok := saru.mutation.AddedTenantID(); ok {
		_spec.AddField(slaalertrule.FieldTenantID, field.TypeInt, value)
	}
	if value, ok := saru.mutation.CreatedAt(); ok {
		_spec.SetField(slaalertrule.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := saru.mutation.UpdatedAt(); ok {
		_spec.SetField(slaalertrule.FieldUpdatedAt, field.TypeTime, value)
	}
	if saru.mutation.SLADefinitionCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   slaalertrule.SLADefinitionTable,
			Columns: []string{slaalertrule.SLADefinitionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sladefinition.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := saru.mutation.SLADefinitionIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   slaalertrule.SLADefinitionTable,
			Columns: []string{slaalertrule.SLADefinitionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sladefinition.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if saru.mutation.AlertHistoryCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   slaalertrule.AlertHistoryTable,
			Columns: []string{slaalertrule.AlertHistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(slaalerthistory.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := saru.mutation.RemovedAlertHistoryIDs(); len(nodes) > 0 && !saru.mutation.AlertHistoryCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   slaalertrule.AlertHistoryTable,
			Columns: []string{slaalertrule.AlertHistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(slaalerthistory.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := saru.mutation.AlertHistoryIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   slaalertrule.AlertHistoryTable,
			Columns: []string{slaalertrule.AlertHistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(slaalerthistory.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, saru.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{slaalertrule.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	saru.mutation.done = true
	return n, nil
}

// SLAAlertRuleUpdateOne is the builder for updating a single SLAAlertRule entity.
type SLAAlertRuleUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *SLAAlertRuleMutation
}

// SetName sets the "name" field.
func (saruo *SLAAlertRuleUpdateOne) SetName(s string) *SLAAlertRuleUpdateOne {
	saruo.mutation.SetName(s)
	return saruo
}

// SetNillableName sets the "name" field if the given value is not nil.
func (saruo *SLAAlertRuleUpdateOne) SetNillableName(s *string) *SLAAlertRuleUpdateOne {
	if s != nil {
		saruo.SetName(*s)
	}
	return saruo
}

// SetSLADefinitionID sets the "sla_definition_id" field.
func (saruo *SLAAlertRuleUpdateOne) SetSLADefinitionID(i int) *SLAAlertRuleUpdateOne {
	saruo.mutation.SetSLADefinitionID(i)
	return saruo
}

// SetNillableSLADefinitionID sets the "sla_definition_id" field if the given value is not nil.
func (saruo *SLAAlertRuleUpdateOne) SetNillableSLADefinitionID(i *int) *SLAAlertRuleUpdateOne {
	if i != nil {
		saruo.SetSLADefinitionID(*i)
	}
	return saruo
}

// SetAlertLevel sets the "alert_level" field.
func (saruo *SLAAlertRuleUpdateOne) SetAlertLevel(s string) *SLAAlertRuleUpdateOne {
	saruo.mutation.SetAlertLevel(s)
	return saruo
}

// SetNillableAlertLevel sets the "alert_level" field if the given value is not nil.
func (saruo *SLAAlertRuleUpdateOne) SetNillableAlertLevel(s *string) *SLAAlertRuleUpdateOne {
	if s != nil {
		saruo.SetAlertLevel(*s)
	}
	return saruo
}

// SetThresholdPercentage sets the "threshold_percentage" field.
func (saruo *SLAAlertRuleUpdateOne) SetThresholdPercentage(i int) *SLAAlertRuleUpdateOne {
	saruo.mutation.ResetThresholdPercentage()
	saruo.mutation.SetThresholdPercentage(i)
	return saruo
}

// SetNillableThresholdPercentage sets the "threshold_percentage" field if the given value is not nil.
func (saruo *SLAAlertRuleUpdateOne) SetNillableThresholdPercentage(i *int) *SLAAlertRuleUpdateOne {
	if i != nil {
		saruo.SetThresholdPercentage(*i)
	}
	return saruo
}

// AddThresholdPercentage adds i to the "threshold_percentage" field.
func (saruo *SLAAlertRuleUpdateOne) AddThresholdPercentage(i int) *SLAAlertRuleUpdateOne {
	saruo.mutation.AddThresholdPercentage(i)
	return saruo
}

// SetNotificationChannels sets the "notification_channels" field.
func (saruo *SLAAlertRuleUpdateOne) SetNotificationChannels(s []string) *SLAAlertRuleUpdateOne {
	saruo.mutation.SetNotificationChannels(s)
	return saruo
}

// AppendNotificationChannels appends s to the "notification_channels" field.
func (saruo *SLAAlertRuleUpdateOne) AppendNotificationChannels(s []string) *SLAAlertRuleUpdateOne {
	saruo.mutation.AppendNotificationChannels(s)
	return saruo
}

// SetEscalationEnabled sets the "escalation_enabled" field.
func (saruo *SLAAlertRuleUpdateOne) SetEscalationEnabled(b bool) *SLAAlertRuleUpdateOne {
	saruo.mutation.SetEscalationEnabled(b)
	return saruo
}

// SetNillableEscalationEnabled sets the "escalation_enabled" field if the given value is not nil.
func (saruo *SLAAlertRuleUpdateOne) SetNillableEscalationEnabled(b *bool) *SLAAlertRuleUpdateOne {
	if b != nil {
		saruo.SetEscalationEnabled(*b)
	}
	return saruo
}

// SetEscalationLevels sets the "escalation_levels" field.
func (saruo *SLAAlertRuleUpdateOne) SetEscalationLevels(m []map[string]interface{}) *SLAAlertRuleUpdateOne {
	saruo.mutation.SetEscalationLevels(m)
	return saruo
}

// AppendEscalationLevels appends m to the "escalation_levels" field.
func (saruo *SLAAlertRuleUpdateOne) AppendEscalationLevels(m []map[string]interface{}) *SLAAlertRuleUpdateOne {
	saruo.mutation.AppendEscalationLevels(m)
	return saruo
}

// ClearEscalationLevels clears the value of the "escalation_levels" field.
func (saruo *SLAAlertRuleUpdateOne) ClearEscalationLevels() *SLAAlertRuleUpdateOne {
	saruo.mutation.ClearEscalationLevels()
	return saruo
}

// SetIsActive sets the "is_active" field.
func (saruo *SLAAlertRuleUpdateOne) SetIsActive(b bool) *SLAAlertRuleUpdateOne {
	saruo.mutation.SetIsActive(b)
	return saruo
}

// SetNillableIsActive sets the "is_active" field if the given value is not nil.
func (saruo *SLAAlertRuleUpdateOne) SetNillableIsActive(b *bool) *SLAAlertRuleUpdateOne {
	if b != nil {
		saruo.SetIsActive(*b)
	}
	return saruo
}

// SetTenantID sets the "tenant_id" field.
func (saruo *SLAAlertRuleUpdateOne) SetTenantID(i int) *SLAAlertRuleUpdateOne {
	saruo.mutation.ResetTenantID()
	saruo.mutation.SetTenantID(i)
	return saruo
}

// SetNillableTenantID sets the "tenant_id" field if the given value is not nil.
func (saruo *SLAAlertRuleUpdateOne) SetNillableTenantID(i *int) *SLAAlertRuleUpdateOne {
	if i != nil {
		saruo.SetTenantID(*i)
	}
	return saruo
}

// AddTenantID adds i to the "tenant_id" field.
func (saruo *SLAAlertRuleUpdateOne) AddTenantID(i int) *SLAAlertRuleUpdateOne {
	saruo.mutation.AddTenantID(i)
	return saruo
}

// SetCreatedAt sets the "created_at" field.
func (saruo *SLAAlertRuleUpdateOne) SetCreatedAt(t time.Time) *SLAAlertRuleUpdateOne {
	saruo.mutation.SetCreatedAt(t)
	return saruo
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (saruo *SLAAlertRuleUpdateOne) SetNillableCreatedAt(t *time.Time) *SLAAlertRuleUpdateOne {
	if t != nil {
		saruo.SetCreatedAt(*t)
	}
	return saruo
}

// SetUpdatedAt sets the "updated_at" field.
func (saruo *SLAAlertRuleUpdateOne) SetUpdatedAt(t time.Time) *SLAAlertRuleUpdateOne {
	saruo.mutation.SetUpdatedAt(t)
	return saruo
}

// SetSLADefinition sets the "sla_definition" edge to the SLADefinition entity.
func (saruo *SLAAlertRuleUpdateOne) SetSLADefinition(s *SLADefinition) *SLAAlertRuleUpdateOne {
	return saruo.SetSLADefinitionID(s.ID)
}

// AddAlertHistoryIDs adds the "alert_history" edge to the SLAAlertHistory entity by IDs.
func (saruo *SLAAlertRuleUpdateOne) AddAlertHistoryIDs(ids ...int) *SLAAlertRuleUpdateOne {
	saruo.mutation.AddAlertHistoryIDs(ids...)
	return saruo
}

// AddAlertHistory adds the "alert_history" edges to the SLAAlertHistory entity.
func (saruo *SLAAlertRuleUpdateOne) AddAlertHistory(s ...*SLAAlertHistory) *SLAAlertRuleUpdateOne {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return saruo.AddAlertHistoryIDs(ids...)
}

// Mutation returns the SLAAlertRuleMutation object of the builder.
func (saruo *SLAAlertRuleUpdateOne) Mutation() *SLAAlertRuleMutation {
	return saruo.mutation
}

// ClearSLADefinition clears the "sla_definition" edge to the SLADefinition entity.
func (saruo *SLAAlertRuleUpdateOne) ClearSLADefinition() *SLAAlertRuleUpdateOne {
	saruo.mutation.ClearSLADefinition()
	return saruo
}

// ClearAlertHistory clears all "alert_history" edges to the SLAAlertHistory entity.
func (saruo *SLAAlertRuleUpdateOne) ClearAlertHistory() *SLAAlertRuleUpdateOne {
	saruo.mutation.ClearAlertHistory()
	return saruo
}

// RemoveAlertHistoryIDs removes the "alert_history" edge to SLAAlertHistory entities by IDs.
func (saruo *SLAAlertRuleUpdateOne) RemoveAlertHistoryIDs(ids ...int) *SLAAlertRuleUpdateOne {
	saruo.mutation.RemoveAlertHistoryIDs(ids...)
	return saruo
}

// RemoveAlertHistory removes "alert_history" edges to SLAAlertHistory entities.
func (saruo *SLAAlertRuleUpdateOne) RemoveAlertHistory(s ...*SLAAlertHistory) *SLAAlertRuleUpdateOne {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return saruo.RemoveAlertHistoryIDs(ids...)
}

// Where appends a list predicates to the SLAAlertRuleUpdate builder.
func (saruo *SLAAlertRuleUpdateOne) Where(ps ...predicate.SLAAlertRule) *SLAAlertRuleUpdateOne {
	saruo.mutation.Where(ps...)
	return saruo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (saruo *SLAAlertRuleUpdateOne) Select(field string, fields ...string) *SLAAlertRuleUpdateOne {
	saruo.fields = append([]string{field}, fields...)
	return saruo
}

// Save executes the query and returns the updated SLAAlertRule entity.
func (saruo *SLAAlertRuleUpdateOne) Save(ctx context.Context) (*SLAAlertRule, error) {
	saruo.defaults()
	return withHooks(ctx, saruo.sqlSave, saruo.mutation, saruo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (saruo *SLAAlertRuleUpdateOne) SaveX(ctx context.Context) *SLAAlertRule {
	node, err := saruo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (saruo *SLAAlertRuleUpdateOne) Exec(ctx context.Context) error {
	_, err := saruo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (saruo *SLAAlertRuleUpdateOne) ExecX(ctx context.Context) {
	if err := saruo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (saruo *SLAAlertRuleUpdateOne) defaults() {
	if _, ok := saruo.mutation.UpdatedAt(); !ok {
		v := slaalertrule.UpdateDefaultUpdatedAt()
		saruo.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (saruo *SLAAlertRuleUpdateOne) check() error {
	if v, ok := saruo.mutation.Name(); ok {
		if err := slaalertrule.NameValidator(v); err != nil {
			return &ValidationError{Name: "name", err: fmt.Errorf(`ent: validator failed for field "SLAAlertRule.name": %w`, err)}
		}
	}
	if v, ok := saruo.mutation.SLADefinitionID(); ok {
		if err := slaalertrule.SLADefinitionIDValidator(v); err != nil {
			return &ValidationError{Name: "sla_definition_id", err: fmt.Errorf(`ent: validator failed for field "SLAAlertRule.sla_definition_id": %w`, err)}
		}
	}
	if v, ok := saruo.mutation.ThresholdPercentage(); ok {
		if err := slaalertrule.ThresholdPercentageValidator(v); err != nil {
			return &ValidationError{Name: "threshold_percentage", err: fmt.Errorf(`ent: validator failed for field "SLAAlertRule.threshold_percentage": %w`, err)}
		}
	}
	if v, ok := saruo.mutation.TenantID(); ok {
		if err := slaalertrule.TenantIDValidator(v); err != nil {
			return &ValidationError{Name: "tenant_id", err: fmt.Errorf(`ent: validator failed for field "SLAAlertRule.tenant_id": %w`, err)}
		}
	}
	if saruo.mutation.SLADefinitionCleared() && len(saruo.mutation.SLADefinitionIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "SLAAlertRule.sla_definition"`)
	}
	return nil
}

func (saruo *SLAAlertRuleUpdateOne) sqlSave(ctx context.Context) (_node *SLAAlertRule, err error) {
	if err := saruo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(slaalertrule.Table, slaalertrule.Columns, sqlgraph.NewFieldSpec(slaalertrule.FieldID, field.TypeInt))
	id, ok := saruo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "SLAAlertRule.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := saruo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, slaalertrule.FieldID)
		for _, f := range fields {
			if !slaalertrule.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != slaalertrule.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := saruo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := saruo.mutation.Name(); ok {
		_spec.SetField(slaalertrule.FieldName, field.TypeString, value)
	}
	if value, ok := saruo.mutation.AlertLevel(); ok {
		_spec.SetField(slaalertrule.FieldAlertLevel, field.TypeString, value)
	}
	if value, ok := saruo.mutation.ThresholdPercentage(); ok {
		_spec.SetField(slaalertrule.FieldThresholdPercentage, field.TypeInt, value)
	}
	if value, ok := saruo.mutation.AddedThresholdPercentage(); ok {
		_spec.AddField(slaalertrule.FieldThresholdPercentage, field.TypeInt, value)
	}
	if value, ok := saruo.mutation.NotificationChannels(); ok {
		_spec.SetField(slaalertrule.FieldNotificationChannels, field.TypeJSON, value)
	}
	if value, ok := saruo.mutation.AppendedNotificationChannels(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, slaalertrule.FieldNotificationChannels, value)
		})
	}
	if value, ok := saruo.mutation.EscalationEnabled(); ok {
		_spec.SetField(slaalertrule.FieldEscalationEnabled, field.TypeBool, value)
	}
	if value, ok := saruo.mutation.EscalationLevels(); ok {
		_spec.SetField(slaalertrule.FieldEscalationLevels, field.TypeJSON, value)
	}
	if value, ok := saruo.mutation.AppendedEscalationLevels(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, slaalertrule.FieldEscalationLevels, value)
		})
	}
	if saruo.mutation.EscalationLevelsCleared() {
		_spec.ClearField(slaalertrule.FieldEscalationLevels, field.TypeJSON)
	}
	if value, ok := saruo.mutation.IsActive(); ok {
		_spec.SetField(slaalertrule.FieldIsActive, field.TypeBool, value)
	}
	if value, ok := saruo.mutation.TenantID(); ok {
		_spec.SetField(slaalertrule.FieldTenantID, field.TypeInt, value)
	}
	if value, ok := saruo.mutation.AddedTenantID(); ok {
		_spec.AddField(slaalertrule.FieldTenantID, field.TypeInt, value)
	}
	if value, ok := saruo.mutation.CreatedAt(); ok {
		_spec.SetField(slaalertrule.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := saruo.mutation.UpdatedAt(); ok {
		_spec.SetField(slaalertrule.FieldUpdatedAt, field.TypeTime, value)
	}
	if saruo.mutation.SLADefinitionCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   slaalertrule.SLADefinitionTable,
			Columns: []string{slaalertrule.SLADefinitionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sladefinition.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := saruo.mutation.SLADefinitionIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   slaalertrule.SLADefinitionTable,
			Columns: []string{slaalertrule.SLADefinitionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sladefinition.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if saruo.mutation.AlertHistoryCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   slaalertrule.AlertHistoryTable,
			Columns: []string{slaalertrule.AlertHistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(slaalerthistory.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := saruo.mutation.RemovedAlertHistoryIDs(); len(nodes) > 0 && !saruo.mutation.AlertHistoryCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   slaalertrule.AlertHistoryTable,
			Columns: []string{slaalertrule.AlertHistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(slaalerthistory.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := saruo.mutation.AlertHistoryIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   slaalertrule.AlertHistoryTable,
			Columns: []string{slaalertrule.AlertHistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(slaalerthistory.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &SLAAlertRule{config: saruo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, saruo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{slaalertrule.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	saruo.mutation.done = true
	return _node, nil
}
