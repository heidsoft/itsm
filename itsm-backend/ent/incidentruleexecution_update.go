// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"itsm-backend/ent/incidentrule"
	"itsm-backend/ent/incidentruleexecution"
	"itsm-backend/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// IncidentRuleExecutionUpdate is the builder for updating IncidentRuleExecution entities.
type IncidentRuleExecutionUpdate struct {
	config
	hooks    []Hook
	mutation *IncidentRuleExecutionMutation
}

// Where appends a list predicates to the IncidentRuleExecutionUpdate builder.
func (ireu *IncidentRuleExecutionUpdate) Where(ps ...predicate.IncidentRuleExecution) *IncidentRuleExecutionUpdate {
	ireu.mutation.Where(ps...)
	return ireu
}

// SetRuleID sets the "rule_id" field.
func (ireu *IncidentRuleExecutionUpdate) SetRuleID(i int) *IncidentRuleExecutionUpdate {
	ireu.mutation.SetRuleID(i)
	return ireu
}

// SetNillableRuleID sets the "rule_id" field if the given value is not nil.
func (ireu *IncidentRuleExecutionUpdate) SetNillableRuleID(i *int) *IncidentRuleExecutionUpdate {
	if i != nil {
		ireu.SetRuleID(*i)
	}
	return ireu
}

// SetIncidentID sets the "incident_id" field.
func (ireu *IncidentRuleExecutionUpdate) SetIncidentID(i int) *IncidentRuleExecutionUpdate {
	ireu.mutation.ResetIncidentID()
	ireu.mutation.SetIncidentID(i)
	return ireu
}

// SetNillableIncidentID sets the "incident_id" field if the given value is not nil.
func (ireu *IncidentRuleExecutionUpdate) SetNillableIncidentID(i *int) *IncidentRuleExecutionUpdate {
	if i != nil {
		ireu.SetIncidentID(*i)
	}
	return ireu
}

// AddIncidentID adds i to the "incident_id" field.
func (ireu *IncidentRuleExecutionUpdate) AddIncidentID(i int) *IncidentRuleExecutionUpdate {
	ireu.mutation.AddIncidentID(i)
	return ireu
}

// ClearIncidentID clears the value of the "incident_id" field.
func (ireu *IncidentRuleExecutionUpdate) ClearIncidentID() *IncidentRuleExecutionUpdate {
	ireu.mutation.ClearIncidentID()
	return ireu
}

// SetStatus sets the "status" field.
func (ireu *IncidentRuleExecutionUpdate) SetStatus(s string) *IncidentRuleExecutionUpdate {
	ireu.mutation.SetStatus(s)
	return ireu
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (ireu *IncidentRuleExecutionUpdate) SetNillableStatus(s *string) *IncidentRuleExecutionUpdate {
	if s != nil {
		ireu.SetStatus(*s)
	}
	return ireu
}

// SetResult sets the "result" field.
func (ireu *IncidentRuleExecutionUpdate) SetResult(s string) *IncidentRuleExecutionUpdate {
	ireu.mutation.SetResult(s)
	return ireu
}

// SetNillableResult sets the "result" field if the given value is not nil.
func (ireu *IncidentRuleExecutionUpdate) SetNillableResult(s *string) *IncidentRuleExecutionUpdate {
	if s != nil {
		ireu.SetResult(*s)
	}
	return ireu
}

// ClearResult clears the value of the "result" field.
func (ireu *IncidentRuleExecutionUpdate) ClearResult() *IncidentRuleExecutionUpdate {
	ireu.mutation.ClearResult()
	return ireu
}

// SetErrorMessage sets the "error_message" field.
func (ireu *IncidentRuleExecutionUpdate) SetErrorMessage(s string) *IncidentRuleExecutionUpdate {
	ireu.mutation.SetErrorMessage(s)
	return ireu
}

// SetNillableErrorMessage sets the "error_message" field if the given value is not nil.
func (ireu *IncidentRuleExecutionUpdate) SetNillableErrorMessage(s *string) *IncidentRuleExecutionUpdate {
	if s != nil {
		ireu.SetErrorMessage(*s)
	}
	return ireu
}

// ClearErrorMessage clears the value of the "error_message" field.
func (ireu *IncidentRuleExecutionUpdate) ClearErrorMessage() *IncidentRuleExecutionUpdate {
	ireu.mutation.ClearErrorMessage()
	return ireu
}

// SetStartedAt sets the "started_at" field.
func (ireu *IncidentRuleExecutionUpdate) SetStartedAt(t time.Time) *IncidentRuleExecutionUpdate {
	ireu.mutation.SetStartedAt(t)
	return ireu
}

// SetNillableStartedAt sets the "started_at" field if the given value is not nil.
func (ireu *IncidentRuleExecutionUpdate) SetNillableStartedAt(t *time.Time) *IncidentRuleExecutionUpdate {
	if t != nil {
		ireu.SetStartedAt(*t)
	}
	return ireu
}

// SetCompletedAt sets the "completed_at" field.
func (ireu *IncidentRuleExecutionUpdate) SetCompletedAt(t time.Time) *IncidentRuleExecutionUpdate {
	ireu.mutation.SetCompletedAt(t)
	return ireu
}

// SetNillableCompletedAt sets the "completed_at" field if the given value is not nil.
func (ireu *IncidentRuleExecutionUpdate) SetNillableCompletedAt(t *time.Time) *IncidentRuleExecutionUpdate {
	if t != nil {
		ireu.SetCompletedAt(*t)
	}
	return ireu
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (ireu *IncidentRuleExecutionUpdate) ClearCompletedAt() *IncidentRuleExecutionUpdate {
	ireu.mutation.ClearCompletedAt()
	return ireu
}

// SetExecutionTimeMs sets the "execution_time_ms" field.
func (ireu *IncidentRuleExecutionUpdate) SetExecutionTimeMs(i int) *IncidentRuleExecutionUpdate {
	ireu.mutation.ResetExecutionTimeMs()
	ireu.mutation.SetExecutionTimeMs(i)
	return ireu
}

// SetNillableExecutionTimeMs sets the "execution_time_ms" field if the given value is not nil.
func (ireu *IncidentRuleExecutionUpdate) SetNillableExecutionTimeMs(i *int) *IncidentRuleExecutionUpdate {
	if i != nil {
		ireu.SetExecutionTimeMs(*i)
	}
	return ireu
}

// AddExecutionTimeMs adds i to the "execution_time_ms" field.
func (ireu *IncidentRuleExecutionUpdate) AddExecutionTimeMs(i int) *IncidentRuleExecutionUpdate {
	ireu.mutation.AddExecutionTimeMs(i)
	return ireu
}

// ClearExecutionTimeMs clears the value of the "execution_time_ms" field.
func (ireu *IncidentRuleExecutionUpdate) ClearExecutionTimeMs() *IncidentRuleExecutionUpdate {
	ireu.mutation.ClearExecutionTimeMs()
	return ireu
}

// SetInputData sets the "input_data" field.
func (ireu *IncidentRuleExecutionUpdate) SetInputData(m map[string]interface{}) *IncidentRuleExecutionUpdate {
	ireu.mutation.SetInputData(m)
	return ireu
}

// ClearInputData clears the value of the "input_data" field.
func (ireu *IncidentRuleExecutionUpdate) ClearInputData() *IncidentRuleExecutionUpdate {
	ireu.mutation.ClearInputData()
	return ireu
}

// SetOutputData sets the "output_data" field.
func (ireu *IncidentRuleExecutionUpdate) SetOutputData(m map[string]interface{}) *IncidentRuleExecutionUpdate {
	ireu.mutation.SetOutputData(m)
	return ireu
}

// ClearOutputData clears the value of the "output_data" field.
func (ireu *IncidentRuleExecutionUpdate) ClearOutputData() *IncidentRuleExecutionUpdate {
	ireu.mutation.ClearOutputData()
	return ireu
}

// SetTenantID sets the "tenant_id" field.
func (ireu *IncidentRuleExecutionUpdate) SetTenantID(i int) *IncidentRuleExecutionUpdate {
	ireu.mutation.ResetTenantID()
	ireu.mutation.SetTenantID(i)
	return ireu
}

// SetNillableTenantID sets the "tenant_id" field if the given value is not nil.
func (ireu *IncidentRuleExecutionUpdate) SetNillableTenantID(i *int) *IncidentRuleExecutionUpdate {
	if i != nil {
		ireu.SetTenantID(*i)
	}
	return ireu
}

// AddTenantID adds i to the "tenant_id" field.
func (ireu *IncidentRuleExecutionUpdate) AddTenantID(i int) *IncidentRuleExecutionUpdate {
	ireu.mutation.AddTenantID(i)
	return ireu
}

// SetCreatedAt sets the "created_at" field.
func (ireu *IncidentRuleExecutionUpdate) SetCreatedAt(t time.Time) *IncidentRuleExecutionUpdate {
	ireu.mutation.SetCreatedAt(t)
	return ireu
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (ireu *IncidentRuleExecutionUpdate) SetNillableCreatedAt(t *time.Time) *IncidentRuleExecutionUpdate {
	if t != nil {
		ireu.SetCreatedAt(*t)
	}
	return ireu
}

// SetUpdatedAt sets the "updated_at" field.
func (ireu *IncidentRuleExecutionUpdate) SetUpdatedAt(t time.Time) *IncidentRuleExecutionUpdate {
	ireu.mutation.SetUpdatedAt(t)
	return ireu
}

// SetRule sets the "rule" edge to the IncidentRule entity.
func (ireu *IncidentRuleExecutionUpdate) SetRule(i *IncidentRule) *IncidentRuleExecutionUpdate {
	return ireu.SetRuleID(i.ID)
}

// Mutation returns the IncidentRuleExecutionMutation object of the builder.
func (ireu *IncidentRuleExecutionUpdate) Mutation() *IncidentRuleExecutionMutation {
	return ireu.mutation
}

// ClearRule clears the "rule" edge to the IncidentRule entity.
func (ireu *IncidentRuleExecutionUpdate) ClearRule() *IncidentRuleExecutionUpdate {
	ireu.mutation.ClearRule()
	return ireu
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (ireu *IncidentRuleExecutionUpdate) Save(ctx context.Context) (int, error) {
	ireu.defaults()
	return withHooks(ctx, ireu.sqlSave, ireu.mutation, ireu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (ireu *IncidentRuleExecutionUpdate) SaveX(ctx context.Context) int {
	affected, err := ireu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (ireu *IncidentRuleExecutionUpdate) Exec(ctx context.Context) error {
	_, err := ireu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ireu *IncidentRuleExecutionUpdate) ExecX(ctx context.Context) {
	if err := ireu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (ireu *IncidentRuleExecutionUpdate) defaults() {
	if _, ok := ireu.mutation.UpdatedAt(); !ok {
		v := incidentruleexecution.UpdateDefaultUpdatedAt()
		ireu.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (ireu *IncidentRuleExecutionUpdate) check() error {
	if v, ok := ireu.mutation.RuleID(); ok {
		if err := incidentruleexecution.RuleIDValidator(v); err != nil {
			return &ValidationError{Name: "rule_id", err: fmt.Errorf(`ent: validator failed for field "IncidentRuleExecution.rule_id": %w`, err)}
		}
	}
	if v, ok := ireu.mutation.TenantID(); ok {
		if err := incidentruleexecution.TenantIDValidator(v); err != nil {
			return &ValidationError{Name: "tenant_id", err: fmt.Errorf(`ent: validator failed for field "IncidentRuleExecution.tenant_id": %w`, err)}
		}
	}
	if ireu.mutation.RuleCleared() && len(ireu.mutation.RuleIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "IncidentRuleExecution.rule"`)
	}
	return nil
}

func (ireu *IncidentRuleExecutionUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := ireu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(incidentruleexecution.Table, incidentruleexecution.Columns, sqlgraph.NewFieldSpec(incidentruleexecution.FieldID, field.TypeInt))
	if ps := ireu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := ireu.mutation.IncidentID(); ok {
		_spec.SetField(incidentruleexecution.FieldIncidentID, field.TypeInt, value)
	}
	if value, ok := ireu.mutation.AddedIncidentID(); ok {
		_spec.AddField(incidentruleexecution.FieldIncidentID, field.TypeInt, value)
	}
	if ireu.mutation.IncidentIDCleared() {
		_spec.ClearField(incidentruleexecution.FieldIncidentID, field.TypeInt)
	}
	if value, ok := ireu.mutation.Status(); ok {
		_spec.SetField(incidentruleexecution.FieldStatus, field.TypeString, value)
	}
	if value, ok := ireu.mutation.Result(); ok {
		_spec.SetField(incidentruleexecution.FieldResult, field.TypeString, value)
	}
	if ireu.mutation.ResultCleared() {
		_spec.ClearField(incidentruleexecution.FieldResult, field.TypeString)
	}
	if value, ok := ireu.mutation.ErrorMessage(); ok {
		_spec.SetField(incidentruleexecution.FieldErrorMessage, field.TypeString, value)
	}
	if ireu.mutation.ErrorMessageCleared() {
		_spec.ClearField(incidentruleexecution.FieldErrorMessage, field.TypeString)
	}
	if value, ok := ireu.mutation.StartedAt(); ok {
		_spec.SetField(incidentruleexecution.FieldStartedAt, field.TypeTime, value)
	}
	if value, ok := ireu.mutation.CompletedAt(); ok {
		_spec.SetField(incidentruleexecution.FieldCompletedAt, field.TypeTime, value)
	}
	if ireu.mutation.CompletedAtCleared() {
		_spec.ClearField(incidentruleexecution.FieldCompletedAt, field.TypeTime)
	}
	if value, ok := ireu.mutation.ExecutionTimeMs(); ok {
		_spec.SetField(incidentruleexecution.FieldExecutionTimeMs, field.TypeInt, value)
	}
	if value, ok := ireu.mutation.AddedExecutionTimeMs(); ok {
		_spec.AddField(incidentruleexecution.FieldExecutionTimeMs, field.TypeInt, value)
	}
	if ireu.mutation.ExecutionTimeMsCleared() {
		_spec.ClearField(incidentruleexecution.FieldExecutionTimeMs, field.TypeInt)
	}
	if value, ok := ireu.mutation.InputData(); ok {
		_spec.SetField(incidentruleexecution.FieldInputData, field.TypeJSON, value)
	}
	if ireu.mutation.InputDataCleared() {
		_spec.ClearField(incidentruleexecution.FieldInputData, field.TypeJSON)
	}
	if value, ok := ireu.mutation.OutputData(); ok {
		_spec.SetField(incidentruleexecution.FieldOutputData, field.TypeJSON, value)
	}
	if ireu.mutation.OutputDataCleared() {
		_spec.ClearField(incidentruleexecution.FieldOutputData, field.TypeJSON)
	}
	if value, ok := ireu.mutation.TenantID(); ok {
		_spec.SetField(incidentruleexecution.FieldTenantID, field.TypeInt, value)
	}
	if value, ok := ireu.mutation.AddedTenantID(); ok {
		_spec.AddField(incidentruleexecution.FieldTenantID, field.TypeInt, value)
	}
	if value, ok := ireu.mutation.CreatedAt(); ok {
		_spec.SetField(incidentruleexecution.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := ireu.mutation.UpdatedAt(); ok {
		_spec.SetField(incidentruleexecution.FieldUpdatedAt, field.TypeTime, value)
	}
	if ireu.mutation.RuleCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   incidentruleexecution.RuleTable,
			Columns: []string{incidentruleexecution.RuleColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentrule.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ireu.mutation.RuleIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   incidentruleexecution.RuleTable,
			Columns: []string{incidentruleexecution.RuleColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentrule.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, ireu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{incidentruleexecution.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	ireu.mutation.done = true
	return n, nil
}

// IncidentRuleExecutionUpdateOne is the builder for updating a single IncidentRuleExecution entity.
type IncidentRuleExecutionUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *IncidentRuleExecutionMutation
}

// SetRuleID sets the "rule_id" field.
func (ireuo *IncidentRuleExecutionUpdateOne) SetRuleID(i int) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.SetRuleID(i)
	return ireuo
}

// SetNillableRuleID sets the "rule_id" field if the given value is not nil.
func (ireuo *IncidentRuleExecutionUpdateOne) SetNillableRuleID(i *int) *IncidentRuleExecutionUpdateOne {
	if i != nil {
		ireuo.SetRuleID(*i)
	}
	return ireuo
}

// SetIncidentID sets the "incident_id" field.
func (ireuo *IncidentRuleExecutionUpdateOne) SetIncidentID(i int) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.ResetIncidentID()
	ireuo.mutation.SetIncidentID(i)
	return ireuo
}

// SetNillableIncidentID sets the "incident_id" field if the given value is not nil.
func (ireuo *IncidentRuleExecutionUpdateOne) SetNillableIncidentID(i *int) *IncidentRuleExecutionUpdateOne {
	if i != nil {
		ireuo.SetIncidentID(*i)
	}
	return ireuo
}

// AddIncidentID adds i to the "incident_id" field.
func (ireuo *IncidentRuleExecutionUpdateOne) AddIncidentID(i int) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.AddIncidentID(i)
	return ireuo
}

// ClearIncidentID clears the value of the "incident_id" field.
func (ireuo *IncidentRuleExecutionUpdateOne) ClearIncidentID() *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.ClearIncidentID()
	return ireuo
}

// SetStatus sets the "status" field.
func (ireuo *IncidentRuleExecutionUpdateOne) SetStatus(s string) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.SetStatus(s)
	return ireuo
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (ireuo *IncidentRuleExecutionUpdateOne) SetNillableStatus(s *string) *IncidentRuleExecutionUpdateOne {
	if s != nil {
		ireuo.SetStatus(*s)
	}
	return ireuo
}

// SetResult sets the "result" field.
func (ireuo *IncidentRuleExecutionUpdateOne) SetResult(s string) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.SetResult(s)
	return ireuo
}

// SetNillableResult sets the "result" field if the given value is not nil.
func (ireuo *IncidentRuleExecutionUpdateOne) SetNillableResult(s *string) *IncidentRuleExecutionUpdateOne {
	if s != nil {
		ireuo.SetResult(*s)
	}
	return ireuo
}

// ClearResult clears the value of the "result" field.
func (ireuo *IncidentRuleExecutionUpdateOne) ClearResult() *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.ClearResult()
	return ireuo
}

// SetErrorMessage sets the "error_message" field.
func (ireuo *IncidentRuleExecutionUpdateOne) SetErrorMessage(s string) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.SetErrorMessage(s)
	return ireuo
}

// SetNillableErrorMessage sets the "error_message" field if the given value is not nil.
func (ireuo *IncidentRuleExecutionUpdateOne) SetNillableErrorMessage(s *string) *IncidentRuleExecutionUpdateOne {
	if s != nil {
		ireuo.SetErrorMessage(*s)
	}
	return ireuo
}

// ClearErrorMessage clears the value of the "error_message" field.
func (ireuo *IncidentRuleExecutionUpdateOne) ClearErrorMessage() *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.ClearErrorMessage()
	return ireuo
}

// SetStartedAt sets the "started_at" field.
func (ireuo *IncidentRuleExecutionUpdateOne) SetStartedAt(t time.Time) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.SetStartedAt(t)
	return ireuo
}

// SetNillableStartedAt sets the "started_at" field if the given value is not nil.
func (ireuo *IncidentRuleExecutionUpdateOne) SetNillableStartedAt(t *time.Time) *IncidentRuleExecutionUpdateOne {
	if t != nil {
		ireuo.SetStartedAt(*t)
	}
	return ireuo
}

// SetCompletedAt sets the "completed_at" field.
func (ireuo *IncidentRuleExecutionUpdateOne) SetCompletedAt(t time.Time) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.SetCompletedAt(t)
	return ireuo
}

// SetNillableCompletedAt sets the "completed_at" field if the given value is not nil.
func (ireuo *IncidentRuleExecutionUpdateOne) SetNillableCompletedAt(t *time.Time) *IncidentRuleExecutionUpdateOne {
	if t != nil {
		ireuo.SetCompletedAt(*t)
	}
	return ireuo
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (ireuo *IncidentRuleExecutionUpdateOne) ClearCompletedAt() *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.ClearCompletedAt()
	return ireuo
}

// SetExecutionTimeMs sets the "execution_time_ms" field.
func (ireuo *IncidentRuleExecutionUpdateOne) SetExecutionTimeMs(i int) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.ResetExecutionTimeMs()
	ireuo.mutation.SetExecutionTimeMs(i)
	return ireuo
}

// SetNillableExecutionTimeMs sets the "execution_time_ms" field if the given value is not nil.
func (ireuo *IncidentRuleExecutionUpdateOne) SetNillableExecutionTimeMs(i *int) *IncidentRuleExecutionUpdateOne {
	if i != nil {
		ireuo.SetExecutionTimeMs(*i)
	}
	return ireuo
}

// AddExecutionTimeMs adds i to the "execution_time_ms" field.
func (ireuo *IncidentRuleExecutionUpdateOne) AddExecutionTimeMs(i int) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.AddExecutionTimeMs(i)
	return ireuo
}

// ClearExecutionTimeMs clears the value of the "execution_time_ms" field.
func (ireuo *IncidentRuleExecutionUpdateOne) ClearExecutionTimeMs() *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.ClearExecutionTimeMs()
	return ireuo
}

// SetInputData sets the "input_data" field.
func (ireuo *IncidentRuleExecutionUpdateOne) SetInputData(m map[string]interface{}) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.SetInputData(m)
	return ireuo
}

// ClearInputData clears the value of the "input_data" field.
func (ireuo *IncidentRuleExecutionUpdateOne) ClearInputData() *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.ClearInputData()
	return ireuo
}

// SetOutputData sets the "output_data" field.
func (ireuo *IncidentRuleExecutionUpdateOne) SetOutputData(m map[string]interface{}) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.SetOutputData(m)
	return ireuo
}

// ClearOutputData clears the value of the "output_data" field.
func (ireuo *IncidentRuleExecutionUpdateOne) ClearOutputData() *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.ClearOutputData()
	return ireuo
}

// SetTenantID sets the "tenant_id" field.
func (ireuo *IncidentRuleExecutionUpdateOne) SetTenantID(i int) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.ResetTenantID()
	ireuo.mutation.SetTenantID(i)
	return ireuo
}

// SetNillableTenantID sets the "tenant_id" field if the given value is not nil.
func (ireuo *IncidentRuleExecutionUpdateOne) SetNillableTenantID(i *int) *IncidentRuleExecutionUpdateOne {
	if i != nil {
		ireuo.SetTenantID(*i)
	}
	return ireuo
}

// AddTenantID adds i to the "tenant_id" field.
func (ireuo *IncidentRuleExecutionUpdateOne) AddTenantID(i int) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.AddTenantID(i)
	return ireuo
}

// SetCreatedAt sets the "created_at" field.
func (ireuo *IncidentRuleExecutionUpdateOne) SetCreatedAt(t time.Time) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.SetCreatedAt(t)
	return ireuo
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (ireuo *IncidentRuleExecutionUpdateOne) SetNillableCreatedAt(t *time.Time) *IncidentRuleExecutionUpdateOne {
	if t != nil {
		ireuo.SetCreatedAt(*t)
	}
	return ireuo
}

// SetUpdatedAt sets the "updated_at" field.
func (ireuo *IncidentRuleExecutionUpdateOne) SetUpdatedAt(t time.Time) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.SetUpdatedAt(t)
	return ireuo
}

// SetRule sets the "rule" edge to the IncidentRule entity.
func (ireuo *IncidentRuleExecutionUpdateOne) SetRule(i *IncidentRule) *IncidentRuleExecutionUpdateOne {
	return ireuo.SetRuleID(i.ID)
}

// Mutation returns the IncidentRuleExecutionMutation object of the builder.
func (ireuo *IncidentRuleExecutionUpdateOne) Mutation() *IncidentRuleExecutionMutation {
	return ireuo.mutation
}

// ClearRule clears the "rule" edge to the IncidentRule entity.
func (ireuo *IncidentRuleExecutionUpdateOne) ClearRule() *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.ClearRule()
	return ireuo
}

// Where appends a list predicates to the IncidentRuleExecutionUpdate builder.
func (ireuo *IncidentRuleExecutionUpdateOne) Where(ps ...predicate.IncidentRuleExecution) *IncidentRuleExecutionUpdateOne {
	ireuo.mutation.Where(ps...)
	return ireuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (ireuo *IncidentRuleExecutionUpdateOne) Select(field string, fields ...string) *IncidentRuleExecutionUpdateOne {
	ireuo.fields = append([]string{field}, fields...)
	return ireuo
}

// Save executes the query and returns the updated IncidentRuleExecution entity.
func (ireuo *IncidentRuleExecutionUpdateOne) Save(ctx context.Context) (*IncidentRuleExecution, error) {
	ireuo.defaults()
	return withHooks(ctx, ireuo.sqlSave, ireuo.mutation, ireuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (ireuo *IncidentRuleExecutionUpdateOne) SaveX(ctx context.Context) *IncidentRuleExecution {
	node, err := ireuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (ireuo *IncidentRuleExecutionUpdateOne) Exec(ctx context.Context) error {
	_, err := ireuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ireuo *IncidentRuleExecutionUpdateOne) ExecX(ctx context.Context) {
	if err := ireuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (ireuo *IncidentRuleExecutionUpdateOne) defaults() {
	if _, ok := ireuo.mutation.UpdatedAt(); !ok {
		v := incidentruleexecution.UpdateDefaultUpdatedAt()
		ireuo.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (ireuo *IncidentRuleExecutionUpdateOne) check() error {
	if v, ok := ireuo.mutation.RuleID(); ok {
		if err := incidentruleexecution.RuleIDValidator(v); err != nil {
			return &ValidationError{Name: "rule_id", err: fmt.Errorf(`ent: validator failed for field "IncidentRuleExecution.rule_id": %w`, err)}
		}
	}
	if v, ok := ireuo.mutation.TenantID(); ok {
		if err := incidentruleexecution.TenantIDValidator(v); err != nil {
			return &ValidationError{Name: "tenant_id", err: fmt.Errorf(`ent: validator failed for field "IncidentRuleExecution.tenant_id": %w`, err)}
		}
	}
	if ireuo.mutation.RuleCleared() && len(ireuo.mutation.RuleIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "IncidentRuleExecution.rule"`)
	}
	return nil
}

func (ireuo *IncidentRuleExecutionUpdateOne) sqlSave(ctx context.Context) (_node *IncidentRuleExecution, err error) {
	if err := ireuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(incidentruleexecution.Table, incidentruleexecution.Columns, sqlgraph.NewFieldSpec(incidentruleexecution.FieldID, field.TypeInt))
	id, ok := ireuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "IncidentRuleExecution.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := ireuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, incidentruleexecution.FieldID)
		for _, f := range fields {
			if !incidentruleexecution.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != incidentruleexecution.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := ireuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := ireuo.mutation.IncidentID(); ok {
		_spec.SetField(incidentruleexecution.FieldIncidentID, field.TypeInt, value)
	}
	if value, ok := ireuo.mutation.AddedIncidentID(); ok {
		_spec.AddField(incidentruleexecution.FieldIncidentID, field.TypeInt, value)
	}
	if ireuo.mutation.IncidentIDCleared() {
		_spec.ClearField(incidentruleexecution.FieldIncidentID, field.TypeInt)
	}
	if value, ok := ireuo.mutation.Status(); ok {
		_spec.SetField(incidentruleexecution.FieldStatus, field.TypeString, value)
	}
	if value, ok := ireuo.mutation.Result(); ok {
		_spec.SetField(incidentruleexecution.FieldResult, field.TypeString, value)
	}
	if ireuo.mutation.ResultCleared() {
		_spec.ClearField(incidentruleexecution.FieldResult, field.TypeString)
	}
	if value, ok := ireuo.mutation.ErrorMessage(); ok {
		_spec.SetField(incidentruleexecution.FieldErrorMessage, field.TypeString, value)
	}
	if ireuo.mutation.ErrorMessageCleared() {
		_spec.ClearField(incidentruleexecution.FieldErrorMessage, field.TypeString)
	}
	if value, ok := ireuo.mutation.StartedAt(); ok {
		_spec.SetField(incidentruleexecution.FieldStartedAt, field.TypeTime, value)
	}
	if value, ok := ireuo.mutation.CompletedAt(); ok {
		_spec.SetField(incidentruleexecution.FieldCompletedAt, field.TypeTime, value)
	}
	if ireuo.mutation.CompletedAtCleared() {
		_spec.ClearField(incidentruleexecution.FieldCompletedAt, field.TypeTime)
	}
	if value, ok := ireuo.mutation.ExecutionTimeMs(); ok {
		_spec.SetField(incidentruleexecution.FieldExecutionTimeMs, field.TypeInt, value)
	}
	if value, ok := ireuo.mutation.AddedExecutionTimeMs(); ok {
		_spec.AddField(incidentruleexecution.FieldExecutionTimeMs, field.TypeInt, value)
	}
	if ireuo.mutation.ExecutionTimeMsCleared() {
		_spec.ClearField(incidentruleexecution.FieldExecutionTimeMs, field.TypeInt)
	}
	if value, ok := ireuo.mutation.InputData(); ok {
		_spec.SetField(incidentruleexecution.FieldInputData, field.TypeJSON, value)
	}
	if ireuo.mutation.InputDataCleared() {
		_spec.ClearField(incidentruleexecution.FieldInputData, field.TypeJSON)
	}
	if value, ok := ireuo.mutation.OutputData(); ok {
		_spec.SetField(incidentruleexecution.FieldOutputData, field.TypeJSON, value)
	}
	if ireuo.mutation.OutputDataCleared() {
		_spec.ClearField(incidentruleexecution.FieldOutputData, field.TypeJSON)
	}
	if value, ok := ireuo.mutation.TenantID(); ok {
		_spec.SetField(incidentruleexecution.FieldTenantID, field.TypeInt, value)
	}
	if value, ok := ireuo.mutation.AddedTenantID(); ok {
		_spec.AddField(incidentruleexecution.FieldTenantID, field.TypeInt, value)
	}
	if value, ok := ireuo.mutation.CreatedAt(); ok {
		_spec.SetField(incidentruleexecution.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := ireuo.mutation.UpdatedAt(); ok {
		_spec.SetField(incidentruleexecution.FieldUpdatedAt, field.TypeTime, value)
	}
	if ireuo.mutation.RuleCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   incidentruleexecution.RuleTable,
			Columns: []string{incidentruleexecution.RuleColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentrule.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ireuo.mutation.RuleIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   incidentruleexecution.RuleTable,
			Columns: []string{incidentruleexecution.RuleColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentrule.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &IncidentRuleExecution{config: ireuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, ireuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{incidentruleexecution.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	ireuo.mutation.done = true
	return _node, nil
}
