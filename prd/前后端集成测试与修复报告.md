# 前后端集成测试与修复报告

## 测试时间
2025-12-07

## 测试目标
- 使用PostgreSQL MCP查看数据库情况
- 结合后端与前端的集成测试完善接口
- 一步一步改进前端与后端功能
- 使功能尽量使用真实接口数据
- 验证端到端流程：通过接口添加，在前端显示

---

## 数据库情况

### 数据库表结构

**tickets表**:
- `id` (bigint, PK)
- `title` (varchar, NOT NULL)
- `description` (text, nullable)
- `status` (varchar, default: 'open')
- `priority` (varchar, default: 'medium')
- `ticket_number` (varchar, UNIQUE, NOT NULL) ⚠️ **必填且唯一**
- `requester_id` (bigint, NOT NULL)
- `assignee_id` (bigint, nullable)
- `tenant_id` (bigint, NOT NULL)
- `created_at`, `updated_at` (timestamp)

**users表**:
- 已有用户：admin (id: 1), user1 (id: 2)

**tenants表**:
- 已有租户：Default Tenant (id: 1, code: 'default')

**当前数据**:
- tickets表：0条记录（空表）

---

## 发现的问题

### 问题1: 后端缺少ticket_number生成逻辑 ✅

**问题描述**:
- 数据库schema要求`ticket_number`是必填且唯一的
- 后端`CreateTicket`方法没有生成`ticket_number`
- 创建工单时会因为缺少`ticket_number`而失败

**修复方案**:
- 在`CreateTicket`方法中添加`generateTicketNumber`方法
- 参考`IncidentService.generateIncidentNumber`的实现
- 生成格式：`TKT-YYYYMM-XXXXXX`（例如：TKT-202512-000001）

**修复文件**:
- `itsm-backend/service/ticket_service.go`

**修复状态**: ✅ **已修复**

---

### 问题2: 前后端接口格式不匹配 ✅

**问题描述**:
- **后端返回格式**: `common.Success(c, ticket)` - 返回完整的`Ticket`对象
- **前端期望格式**: `{ message: string; ticket_id: number }`
- **前端请求格式**: `{ title, description, priority, type, category, subcategory, tags }`
- **后端期望格式**: `{ title, description, priority, category, requester_id, assignee_id }`

**修复方案**:
1. 修改前端`createTicket`返回类型为`Ticket`
2. 修改前端`CreateTicketRequest`接口以匹配后端DTO
3. 修改前端调用代码，转换格式

**修复文件**:
- `itsm-prototype/src/lib/services/ticket-service.ts`
- `itsm-prototype/src/app/(main)/tickets/create/page.tsx`

**修复状态**: ✅ **已修复**

---

## 修复详情

### 后端修复

**1. 添加ticket_number生成方法**

```go
// generateTicketNumber 生成工单编号
func (s *TicketService) generateTicketNumber(ctx context.Context, tenantID int) (string, error) {
	// 获取当前年份和月份
	now := time.Now()
	year := now.Year()
	month := int(now.Month())

	// 查询当月的工单数量
	count, err := s.client.Ticket.Query().
		Where(
			ticket.TenantIDEQ(tenantID),
			ticket.CreatedAtGTE(time.Date(year, time.Month(month), 1, 0, 0, 0, 0, time.UTC)),
			ticket.CreatedAtLT(time.Date(year, time.Month(month+1), 1, 0, 0, 0, 0, time.UTC)),
		).
		Count(ctx)
	if err != nil {
		return "", fmt.Errorf("failed to count tickets: %w", err)
	}

	// 生成工单编号格式: TKT-YYYYMM-XXXXXX
	ticketNumber := fmt.Sprintf("TKT-%04d%02d-%06d", year, month, count+1)
	return ticketNumber, nil
}
```

**2. 在CreateTicket中调用生成方法**

```go
// 生成工单编号
ticketNumber, err := s.generateTicketNumber(ctx, tenantID)
if err != nil {
	s.logger.Errorw("Failed to generate ticket number", "error", err)
	return nil, fmt.Errorf("failed to generate ticket number: %w", err)
}

createBuilder := s.client.Ticket.Create().
	SetTitle(req.Title).
	SetDescription(req.Description).
	SetPriority(req.Priority).
	SetStatus("submitted").
	SetTicketNumber(ticketNumber). // 添加ticket_number
	...
```

---

### 前端修复

**1. 修改createTicket返回类型**

```typescript
// 修改前
async createTicket(data: CreateTicketRequest): Promise<{ message: string; ticket_id: number }> {
  return httpClient.post<{ message: string; ticket_id: number }>(this.baseUrl, data);
}

// 修改后
async createTicket(data: CreateTicketRequest): Promise<Ticket> {
  return httpClient.post<Ticket>(this.baseUrl, data);
}
```

**2. 修改CreateTicketRequest接口**

```typescript
// 修改前
export interface CreateTicketRequest {
  title: string;
  description: string;
  priority: TicketPriority;
  type: TicketType;
  category: string;
  subcategory?: string;
  assignee_id?: number;
  tags?: string[];
  ...
}

// 修改后（匹配后端DTO）
export interface CreateTicketRequest {
  title: string;
  description: string;
  priority: TicketPriority | string;
  category: string;
  assignee_id?: number;
  parent_ticket_id?: number;
  tags?: string[];
  form_fields?: Record<string, unknown>;
  attachments?: string[];
}
```

**3. 修改前端调用代码**

```typescript
// 转换前端格式到后端格式
const response = await ticketService.createTicket({
  title: values.title,
  description: values.description,
  priority: values.priority,
  category: values.category || values.type, // 使用type作为category的fallback
  assignee_id: undefined, // 后端会自动设置
});

message.success(`工单创建成功！工单编号: ${response.ticket_number || response.id}`);
router.push(`/tickets/${response.id}`);
```

---

## 测试计划

### 待测试项

- [ ] **创建工单测试**
  - [ ] 通过前端表单创建工单
  - [ ] 验证后端API调用成功
  - [ ] 验证数据库中有新记录
  - [ ] 验证ticket_number正确生成

- [ ] **工单列表显示测试**
  - [ ] 验证新创建的工单在列表中显示
  - [ ] 验证工单信息正确显示
  - [ ] 验证分页、筛选功能

- [ ] **工单详情测试**
  - [ ] 验证工单详情页面正确显示
  - [ ] 验证所有字段正确显示

---

## 下一步工作

1. **端到端测试**
   - 启动后端服务
   - 启动前端服务
   - 通过浏览器测试创建工单流程
   - 验证数据在数据库中正确保存
   - 验证前端正确显示新创建的工单

2. **完善功能**
   - 添加工单分类（category_id）支持
   - 添加工单模板（template_id）支持
   - 添加标签（tags）支持
   - 添加附件（attachments）支持

3. **错误处理**
   - 添加前端表单验证
   - 添加后端数据验证
   - 添加错误提示

---

**测试开始时间**：2025-12-07  
**测试人员**：AI Assistant  
**测试工具**：PostgreSQL MCP + 代码审查 + 浏览器MCP自动化测试

